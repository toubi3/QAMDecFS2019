
QAMDecFS2019.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000420c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000009c  00802000  0000420c  000042a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000011c9  0080209c  0080209c  0000433c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000433c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000436c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007c8  00000000  00000000  000043ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010926  00000000  00000000  00004b74  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005399  00000000  00000000  0001549a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000568b  00000000  00000000  0001a833  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001954  00000000  00000000  0001fec0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000077f7  00000000  00000000  00021814  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009ad2  00000000  00000000  0002900b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000838  00000000  00000000  00032add  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 22 01 	jmp	0x244	; 0x244 <__ctors_end>
       4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      10:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      14:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      18:	0c 94 ba 01 	jmp	0x374	; 0x374 <__vector_6>
      1c:	0c 94 00 02 	jmp	0x400	; 0x400 <__vector_7>
      20:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      24:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      28:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      2c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      30:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      34:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      38:	0c 94 03 07 	jmp	0xe06	; 0xe06 <__vector_14>
      3c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      40:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      44:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      48:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      4c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      50:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      54:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      58:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      5c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      60:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      64:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      68:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      6c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      70:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      74:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      78:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      7c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      80:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      84:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      88:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      8c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      90:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      94:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      98:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      9c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      ac:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      bc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      cc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      dc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      ec:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      fc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     100:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     104:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     108:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     10c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     110:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     114:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     118:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     11c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     120:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     124:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     128:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     12c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     130:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     134:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     138:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     13c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     140:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     144:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     148:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     14c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     150:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     154:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     158:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     15c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     160:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     164:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     168:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     16c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     170:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     174:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     178:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     17c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     180:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     184:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     188:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     18c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     190:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     194:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     198:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     19c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1ac:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1b0:	0c 94 c6 14 	jmp	0x298c	; 0x298c <__vector_108>
     1b4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1b8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1bc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1cc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1dc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1ec:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1fc:	e5 12       	cpse	r14, r21
     1fe:	e5 12       	cpse	r14, r21
     200:	e5 12       	cpse	r14, r21
     202:	32 13       	cpse	r19, r18
     204:	1a 13       	cpse	r17, r26
     206:	2f 13       	cpse	r18, r31
     208:	e5 12       	cpse	r14, r21
     20a:	e5 12       	cpse	r14, r21
     20c:	32 13       	cpse	r19, r18
     20e:	1a 13       	cpse	r17, r26

00000210 <__trampolines_start>:
     210:	0c 94 f1 1a 	jmp	0x35e2	; 0x35e2 <vPhase_Detection>
     214:	0c 94 c7 13 	jmp	0x278e	; 0x278e <vWrite_Display>
     218:	0c 94 1a 13 	jmp	0x2634	; 0x2634 <prvTimerTask+0x1e2>
     21c:	0c 94 2f 13 	jmp	0x265e	; 0x265e <prvTimerTask+0x20c>
     220:	0c 94 ee 04 	jmp	0x9dc	; 0x9dc <vEventGroupSetBitsCallback>
     224:	0c 94 32 13 	jmp	0x2664	; 0x2664 <prvTimerTask+0x212>
     228:	0c 94 b2 0b 	jmp	0x1764	; 0x1764 <prvIdleTask>
     22c:	0c 94 37 1c 	jmp	0x386e	; 0x386e <vRead_Peaks>
     230:	0c 94 65 16 	jmp	0x2cca	; 0x2cca <vDisplayUpdateTask>
     234:	0c 94 b6 13 	jmp	0x276c	; 0x276c <vLedBlink>
     238:	0c 94 29 12 	jmp	0x2452	; 0x2452 <prvTimerTask>
     23c:	0c 94 46 02 	jmp	0x48c	; 0x48c <vTask_DMAHandler>
     240:	0c 94 e5 12 	jmp	0x25ca	; 0x25ca <prvTimerTask+0x178>

00000244 <__ctors_end>:
     244:	11 24       	eor	r1, r1
     246:	1f be       	out	0x3f, r1	; 63
     248:	cf ef       	ldi	r28, 0xFF	; 255
     24a:	cd bf       	out	0x3d, r28	; 61
     24c:	df e3       	ldi	r29, 0x3F	; 63
     24e:	de bf       	out	0x3e, r29	; 62
     250:	00 e0       	ldi	r16, 0x00	; 0
     252:	0c bf       	out	0x3c, r16	; 60

00000254 <init_mem>:
// !!! Never call this function, it is part of .init-Code
void __attribute__ ((naked, section(".init3"))) init_mem (void);
void init_mem (void)
{
   //  Use inline assembler so it works even with optimization turned off
   __asm volatile (
     254:	e5 e6       	ldi	r30, 0x65	; 101
     256:	f2 e3       	ldi	r31, 0x32	; 50
     258:	8a ea       	ldi	r24, 0xAA	; 170
     25a:	90 e4       	ldi	r25, 0x40	; 64
     25c:	81 93       	st	Z+, r24
     25e:	e0 30       	cpi	r30, 0x00	; 0
     260:	f9 07       	cpc	r31, r25
     262:	e0 f3       	brcs	.-8      	; 0x25c <init_mem+0x8>

00000264 <__do_copy_data>:
     264:	10 e2       	ldi	r17, 0x20	; 32
     266:	a0 e0       	ldi	r26, 0x00	; 0
     268:	b0 e2       	ldi	r27, 0x20	; 32
     26a:	ec e0       	ldi	r30, 0x0C	; 12
     26c:	f2 e4       	ldi	r31, 0x42	; 66
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	0b bf       	out	0x3b, r16	; 59
     272:	02 c0       	rjmp	.+4      	; 0x278 <__do_copy_data+0x14>
     274:	07 90       	elpm	r0, Z+
     276:	0d 92       	st	X+, r0
     278:	ac 39       	cpi	r26, 0x9C	; 156
     27a:	b1 07       	cpc	r27, r17
     27c:	d9 f7       	brne	.-10     	; 0x274 <__do_copy_data+0x10>

0000027e <__do_clear_bss>:
     27e:	22 e3       	ldi	r18, 0x32	; 50
     280:	ac e9       	ldi	r26, 0x9C	; 156
     282:	b0 e2       	ldi	r27, 0x20	; 32
     284:	01 c0       	rjmp	.+2      	; 0x288 <.do_clear_bss_start>

00000286 <.do_clear_bss_loop>:
     286:	1d 92       	st	X+, r1

00000288 <.do_clear_bss_start>:
     288:	a5 36       	cpi	r26, 0x65	; 101
     28a:	b2 07       	cpc	r27, r18
     28c:	e1 f7       	brne	.-8      	; 0x286 <.do_clear_bss_loop>
     28e:	0e 94 1f 14 	call	0x283e	; 0x283e <main>
     292:	0c 94 04 21 	jmp	0x4208	; 0x4208 <_exit>

00000296 <__bad_interrupt>:
     296:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000029a <sys_InitADC>:
void sys_InitADC(void)
{
	
	// Free Running mode: On
	// Conversion mode: Unsigned, 8Bit
	ADCA.CTRLB=(ADCA.CTRLB & (~(ADC_CONMODE_bm | ADC_FREERUN_bm | ADC_RESOLUTION_gm))) | ADC_RESOLUTION_8BIT_gc | ADC_FREERUN_bm;
     29a:	e0 e0       	ldi	r30, 0x00	; 0
     29c:	f2 e0       	ldi	r31, 0x02	; 2
     29e:	81 81       	ldd	r24, Z+1	; 0x01
     2a0:	81 7e       	andi	r24, 0xE1	; 225
     2a2:	8c 60       	ori	r24, 0x0C	; 12
     2a4:	81 83       	std	Z+1, r24	; 0x01
	// Reference 1V and configuration of prescaler to 256
	ADCA.PRESCALER=(ADCA.PRESCALER & (~ADC_PRESCALER_gm)) | ADC_PRESCALER_DIV256_gc; //?????
     2a6:	84 81       	ldd	r24, Z+4	; 0x04
     2a8:	88 7f       	andi	r24, 0xF8	; 248
     2aa:	86 60       	ori	r24, 0x06	; 6
     2ac:	84 83       	std	Z+4, r24	; 0x04
	ADCA.REFCTRL = ADC_REFSEL_INT1V_gc | ADC_TEMPREF_bm;;			//internal 1V
     2ae:	81 e0       	ldi	r24, 0x01	; 1
     2b0:	82 83       	std	Z+2, r24	; 0x02

	// Read and save the ADC offset using channel 0
	ADCA.CH0.CTRL=(ADCA.CH0.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2b2:	80 a1       	ldd	r24, Z+32	; 0x20
     2b4:	80 76       	andi	r24, 0x60	; 96
     2b6:	81 60       	ori	r24, 0x01	; 1
     2b8:	80 a3       	std	Z+32, r24	; 0x20
	ADCA.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN0_gc ;	// PORTB:0
     2ba:	11 a2       	std	Z+33, r1	; 0x21
	
	ADCA.CH1.CTRL=(ADCB.CH1.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2bc:	80 91 68 02 	lds	r24, 0x0268	; 0x800268 <__TEXT_REGION_LENGTH__+0x700268>
     2c0:	80 76       	andi	r24, 0x60	; 96
     2c2:	81 60       	ori	r24, 0x01	; 1
     2c4:	80 a7       	std	Z+40, r24	; 0x28
	ADCA.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc ;	// PORTB:1	
     2c6:	88 e0       	ldi	r24, 0x08	; 8
     2c8:	81 a7       	std	Z+41, r24	; 0x29
	
	ADCA.CH2.CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_INTERNAL_gc;
     2ca:	10 aa       	std	Z+48, r1	; 0x30
	ADCA.CH2.MUXCTRL = ADC_CH_MUXINT_TEMP_gc;  //Temp Mux
     2cc:	11 aa       	std	Z+49, r1	; 0x31
	
	ADCA.EVCTRL = ADC_SWEEP_012_gc;
     2ce:	80 e8       	ldi	r24, 0x80	; 128
     2d0:	83 83       	std	Z+3, r24	; 0x03
	
	// Enable the ADC in order to read the offset
	ADCA.CTRLA|=ADC_ENABLE_bm;
     2d2:	80 81       	ld	r24, Z
     2d4:	81 60       	ori	r24, 0x01	; 1
     2d6:	80 83       	st	Z, r24
     2d8:	08 95       	ret

000002da <vInitDMA>:
}

void vInitDMA()
{
	//ADC8 PB0 Input
	PORTA.DIRCLR = PIN0_bm;
     2da:	e0 e0       	ldi	r30, 0x00	; 0
     2dc:	f6 e0       	ldi	r31, 0x06	; 6
     2de:	81 e0       	ldi	r24, 0x01	; 1
     2e0:	82 83       	std	Z+2, r24	; 0x02
	PORTA.DIRCLR = PIN1_bm;
     2e2:	82 e0       	ldi	r24, 0x02	; 2
     2e4:	82 83       	std	Z+2, r24	; 0x02
	
	sys_InitADC();
     2e6:	0e 94 4d 01 	call	0x29a	; 0x29a <sys_InitADC>

	// set TCC1 to 11024Hz overflow, actually 11019.2838Hz (-0.052% error)
	TCC1.CTRLA = 0; // stop if running
     2ea:	e0 e4       	ldi	r30, 0x40	; 64
     2ec:	f8 e0       	ldi	r31, 0x08	; 8
     2ee:	10 82       	st	Z, r1
	TCC1.CNT = 0;
     2f0:	10 a2       	std	Z+32, r1	; 0x20
     2f2:	11 a2       	std	Z+33, r1	; 0x21
	TCC1.PER = 0x0FFF;
     2f4:	8f ef       	ldi	r24, 0xFF	; 255
     2f6:	9f e0       	ldi	r25, 0x0F	; 15
     2f8:	86 a3       	std	Z+38, r24	; 0x26
     2fa:	97 a3       	std	Z+39, r25	; 0x27

	EVSYS.CH0MUX = EVSYS_CHMUX_TCC1_OVF_gc; // trigger on timer overflow
     2fc:	88 ec       	ldi	r24, 0xC8	; 200
     2fe:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>


	// reset DMA controller
	DMA.CTRL = 0;
     302:	e0 e0       	ldi	r30, 0x00	; 0
     304:	f1 e0       	ldi	r31, 0x01	; 1
     306:	10 82       	st	Z, r1
	DMA.CTRL = DMA_RESET_bm;
     308:	80 e4       	ldi	r24, 0x40	; 64
     30a:	80 83       	st	Z, r24
	while ((DMA.CTRL & DMA_RESET_bm) != 0);
     30c:	80 81       	ld	r24, Z
     30e:	86 fd       	sbrc	r24, 6
     310:	fd cf       	rjmp	.-6      	; 0x30c <vInitDMA+0x32>
	
	DMA.CTRL			= DMA_CH_ENABLE_bm | DMA_DBUFMODE_CH01_gc; // double buffered with channels 0 and 1
     312:	e0 e0       	ldi	r30, 0x00	; 0
     314:	f1 e0       	ldi	r31, 0x01	; 1
     316:	84 e8       	ldi	r24, 0x84	; 132
     318:	80 83       	st	Z, r24
	//Bei Double Buffering wird automatisch aus Channel 0 und 1 ein "Pair" gebildet. 
	//Siehe dazu AVR1304.P8
	
	// channel 0
	// **** TODO: reset dma channels
	DMA.CH0.REPCNT		= 0;
     31a:	16 8a       	std	Z+22, r1	; 0x16
	DMA.CH0.CTRLA		=  DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 1 byte (8 bit word)
     31c:	74 e2       	ldi	r23, 0x24	; 36
     31e:	70 8b       	std	Z+16, r23	; 0x10
	DMA.CH0.CTRLB		= 0x1;
     320:	61 e0       	ldi	r22, 0x01	; 1
     322:	61 8b       	std	Z+17, r22	; 0x11
	DMA.CH0.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     324:	5d e9       	ldi	r21, 0x9D	; 157
     326:	52 8b       	std	Z+18, r21	; 0x12
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH0.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc;	//DMA0 gets synched by TCC1
     328:	46 e4       	ldi	r20, 0x46	; 70
     32a:	43 8b       	std	Z+19, r20	; 0x13
	DMA.CH0.TRFCNT		= 64; // always the number of bytes, even if burst length > 1
     32c:	20 e4       	ldi	r18, 0x40	; 64
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	24 8b       	std	Z+20, r18	; 0x14
     332:	35 8b       	std	Z+21, r19	; 0x15
	DMA.CH0.DESTADDR0	= (( (uint16_t) buffer_a) >> 0) & 0xFF;
     334:	8c e0       	ldi	r24, 0x0C	; 12
     336:	91 e3       	ldi	r25, 0x31	; 49
     338:	84 8f       	std	Z+28, r24	; 0x1c
	DMA.CH0.DESTADDR1	= (( (uint16_t) buffer_a) >> 8) & 0xFF;
     33a:	95 8f       	std	Z+29, r25	; 0x1d
	DMA.CH0.DESTADDR2	= 0;
     33c:	16 8e       	std	Z+30, r1	; 0x1e
	DMA.CH0.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     33e:	9c e6       	ldi	r25, 0x6C	; 108
     340:	90 8f       	std	Z+24, r25	; 0x18
	DMA.CH0.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     342:	82 e0       	ldi	r24, 0x02	; 2
     344:	81 8f       	std	Z+25, r24	; 0x19
	DMA.CH0.SRCADDR2	= 0;
     346:	12 8e       	std	Z+26, r1	; 0x1a

	// channel 1
	DMA.CH1.REPCNT		= 0;
     348:	16 a2       	std	Z+38, r1	; 0x26
	DMA.CH1.CTRLA		= DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 1 byte (8 bit word)
     34a:	70 a3       	std	Z+32, r23	; 0x20
	DMA.CH1.CTRLB		= 0x1;
     34c:	61 a3       	std	Z+33, r22	; 0x21
	DMA.CH1.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     34e:	52 a3       	std	Z+34, r21	; 0x22
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH1.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc; //DMA1 gets synched by TCC1
     350:	43 a3       	std	Z+35, r20	; 0x23
	DMA.CH1.TRFCNT		= 64; // always the number of bytes, even if burst length > 1
     352:	24 a3       	std	Z+36, r18	; 0x24
     354:	35 a3       	std	Z+37, r19	; 0x25
	DMA.CH1.DESTADDR0	= (( (uint16_t) buffer_b) >> 0) & 0xFF;
     356:	2c ec       	ldi	r18, 0xCC	; 204
     358:	30 e3       	ldi	r19, 0x30	; 48
     35a:	24 a7       	std	Z+44, r18	; 0x2c
	DMA.CH1.DESTADDR1	= (( (uint16_t) buffer_b) >> 8) & 0xFF;
     35c:	35 a7       	std	Z+45, r19	; 0x2d
	DMA.CH1.DESTADDR2	= 0;
     35e:	16 a6       	std	Z+46, r1	; 0x2e
	DMA.CH1.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     360:	90 a7       	std	Z+40, r25	; 0x28
	DMA.CH1.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     362:	81 a7       	std	Z+41, r24	; 0x29
	DMA.CH1.SRCADDR2	= 0;
     364:	12 a6       	std	Z+42, r1	; 0x2a

	DMA.CH0.CTRLA		|= DMA_CH_ENABLE_bm;
     366:	80 89       	ldd	r24, Z+16	; 0x10
     368:	80 68       	ori	r24, 0x80	; 128
     36a:	80 8b       	std	Z+16, r24	; 0x10
	TCC1.CTRLA			= TC_CLKSEL_DIV1024_gc; // start timer, and in turn ADC
     36c:	87 e0       	ldi	r24, 0x07	; 7
     36e:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
     372:	08 95       	ret

00000374 <__vector_6>:
// 		DMA.INTFLAGS = DMA_CH0TRNIF_bm;

}

ISR(DMA_CH0_vect)
{
     374:	1f 92       	push	r1
     376:	0f 92       	push	r0
     378:	0f b6       	in	r0, 0x3f	; 63
     37a:	0f 92       	push	r0
     37c:	11 24       	eor	r1, r1
     37e:	0b b6       	in	r0, 0x3b	; 59
     380:	0f 92       	push	r0
     382:	2f 93       	push	r18
     384:	3f 93       	push	r19
     386:	4f 93       	push	r20
     388:	5f 93       	push	r21
     38a:	6f 93       	push	r22
     38c:	7f 93       	push	r23
     38e:	8f 93       	push	r24
     390:	9f 93       	push	r25
     392:	af 93       	push	r26
     394:	bf 93       	push	r27
     396:	ef 93       	push	r30
     398:	ff 93       	push	r31
     39a:	cf 93       	push	r28
     39c:	df 93       	push	r29
     39e:	1f 92       	push	r1
     3a0:	cd b7       	in	r28, 0x3d	; 61
     3a2:	de b7       	in	r29, 0x3e	; 62
	
	//Interrupt quittieren
	DMA.CH0.CTRLB |= 0x10;
     3a4:	e0 e0       	ldi	r30, 0x00	; 0
     3a6:	f1 e0       	ldi	r31, 0x01	; 1
     3a8:	81 89       	ldd	r24, Z+17	; 0x11
     3aa:	80 61       	ori	r24, 0x10	; 16
     3ac:	81 8b       	std	Z+17, r24	; 0x11
	TCC1.INTFLAGS |= 0x01;
     3ae:	e0 e4       	ldi	r30, 0x40	; 64
     3b0:	f8 e0       	ldi	r31, 0x08	; 8
     3b2:	84 85       	ldd	r24, Z+12	; 0x0c
     3b4:	81 60       	ori	r24, 0x01	; 1
     3b6:	84 87       	std	Z+12, r24	; 0x0c
	//PORTF.OUTTGL = 0x01;
		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     3b8:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     3ba:	9e 01       	movw	r18, r28
     3bc:	2f 5f       	subi	r18, 0xFF	; 255
     3be:	3f 4f       	sbci	r19, 0xFF	; 255
     3c0:	41 e0       	ldi	r20, 0x01	; 1
     3c2:	50 e0       	ldi	r21, 0x00	; 0
     3c4:	60 e0       	ldi	r22, 0x00	; 0
     3c6:	70 e0       	ldi	r23, 0x00	; 0
     3c8:	80 91 52 2d 	lds	r24, 0x2D52	; 0x802d52 <xDMAProcessEventGroup>
     3cc:	90 91 53 2d 	lds	r25, 0x2D53	; 0x802d53 <xDMAProcessEventGroup+0x1>
     3d0:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     3d4:	0f 90       	pop	r0
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	ff 91       	pop	r31
     3dc:	ef 91       	pop	r30
     3de:	bf 91       	pop	r27
     3e0:	af 91       	pop	r26
     3e2:	9f 91       	pop	r25
     3e4:	8f 91       	pop	r24
     3e6:	7f 91       	pop	r23
     3e8:	6f 91       	pop	r22
     3ea:	5f 91       	pop	r21
     3ec:	4f 91       	pop	r20
     3ee:	3f 91       	pop	r19
     3f0:	2f 91       	pop	r18
     3f2:	0f 90       	pop	r0
     3f4:	0b be       	out	0x3b, r0	; 59
     3f6:	0f 90       	pop	r0
     3f8:	0f be       	out	0x3f, r0	; 63
     3fa:	0f 90       	pop	r0
     3fc:	1f 90       	pop	r1
     3fe:	18 95       	reti

00000400 <__vector_7>:

ISR(DMA_CH1_vect)
{
     400:	1f 92       	push	r1
     402:	0f 92       	push	r0
     404:	0f b6       	in	r0, 0x3f	; 63
     406:	0f 92       	push	r0
     408:	11 24       	eor	r1, r1
     40a:	0b b6       	in	r0, 0x3b	; 59
     40c:	0f 92       	push	r0
     40e:	2f 93       	push	r18
     410:	3f 93       	push	r19
     412:	4f 93       	push	r20
     414:	5f 93       	push	r21
     416:	6f 93       	push	r22
     418:	7f 93       	push	r23
     41a:	8f 93       	push	r24
     41c:	9f 93       	push	r25
     41e:	af 93       	push	r26
     420:	bf 93       	push	r27
     422:	ef 93       	push	r30
     424:	ff 93       	push	r31
     426:	cf 93       	push	r28
     428:	df 93       	push	r29
     42a:	1f 92       	push	r1
     42c:	cd b7       	in	r28, 0x3d	; 61
     42e:	de b7       	in	r29, 0x3e	; 62
	//Interrupt quittieren
	DMA.CH1.CTRLB |= 0x10;
     430:	e0 e0       	ldi	r30, 0x00	; 0
     432:	f1 e0       	ldi	r31, 0x01	; 1
     434:	81 a1       	ldd	r24, Z+33	; 0x21
     436:	80 61       	ori	r24, 0x10	; 16
     438:	81 a3       	std	Z+33, r24	; 0x21
	TCC1.INTFLAGS |= 0x01;
     43a:	e0 e4       	ldi	r30, 0x40	; 64
     43c:	f8 e0       	ldi	r31, 0x08	; 8
     43e:	84 85       	ldd	r24, Z+12	; 0x0c
     440:	81 60       	ori	r24, 0x01	; 1
     442:	84 87       	std	Z+12, r24	; 0x0c

		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     444:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     446:	9e 01       	movw	r18, r28
     448:	2f 5f       	subi	r18, 0xFF	; 255
     44a:	3f 4f       	sbci	r19, 0xFF	; 255
     44c:	42 e0       	ldi	r20, 0x02	; 2
     44e:	50 e0       	ldi	r21, 0x00	; 0
     450:	60 e0       	ldi	r22, 0x00	; 0
     452:	70 e0       	ldi	r23, 0x00	; 0
     454:	80 91 52 2d 	lds	r24, 0x2D52	; 0x802d52 <xDMAProcessEventGroup>
     458:	90 91 53 2d 	lds	r25, 0x2D53	; 0x802d53 <xDMAProcessEventGroup+0x1>
     45c:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     460:	0f 90       	pop	r0
     462:	df 91       	pop	r29
     464:	cf 91       	pop	r28
     466:	ff 91       	pop	r31
     468:	ef 91       	pop	r30
     46a:	bf 91       	pop	r27
     46c:	af 91       	pop	r26
     46e:	9f 91       	pop	r25
     470:	8f 91       	pop	r24
     472:	7f 91       	pop	r23
     474:	6f 91       	pop	r22
     476:	5f 91       	pop	r21
     478:	4f 91       	pop	r20
     47a:	3f 91       	pop	r19
     47c:	2f 91       	pop	r18
     47e:	0f 90       	pop	r0
     480:	0b be       	out	0x3b, r0	; 59
     482:	0f 90       	pop	r0
     484:	0f be       	out	0x3f, r0	; 63
     486:	0f 90       	pop	r0
     488:	1f 90       	pop	r1
     48a:	18 95       	reti

0000048c <vTask_DMAHandler>:
*/

void vTask_DMAHandler(void *pvParameters) 
{
	/*Do things and Stuff with DMA!*/
	xDMAProcessEventGroup = xEventGroupCreate();
     48c:	0e 94 61 03 	call	0x6c2	; 0x6c2 <xEventGroupCreate>
     490:	80 93 52 2d 	sts	0x2D52, r24	; 0x802d52 <xDMAProcessEventGroup>
     494:	90 93 53 2d 	sts	0x2D53, r25	; 0x802d53 <xDMAProcessEventGroup+0x1>
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,no_signal_counter = 0;
	PORTF.DIRSET = PIN1_bm; /*LED1*/
     498:	e0 ea       	ldi	r30, 0xA0	; 160
     49a:	f6 e0       	ldi	r31, 0x06	; 6
     49c:	82 e0       	ldi	r24, 0x02	; 2
     49e:	81 83       	std	Z+1, r24	; 0x01
	PORTF.DIRSET = PIN2_bm; /*LED2*/
     4a0:	94 e0       	ldi	r25, 0x04	; 4
     4a2:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN0_bm;
     4a4:	e0 e8       	ldi	r30, 0x80	; 128
     4a6:	f6 e0       	ldi	r31, 0x06	; 6
     4a8:	91 e0       	ldi	r25, 0x01	; 1
     4aa:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN1_bm;
     4ac:	81 83       	std	Z+1, r24	; 0x01
{
	/*Do things and Stuff with DMA!*/
	xDMAProcessEventGroup = xEventGroupCreate();
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,no_signal_counter = 0;
     4ae:	81 2c       	mov	r8, r1
     4b0:	91 2c       	mov	r9, r1
				}
			}
			count_buffer_a++;
			
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x02));
     4b2:	0f 2e       	mov	r0, r31
     4b4:	f0 ea       	ldi	r31, 0xA0	; 160
     4b6:	af 2e       	mov	r10, r31
     4b8:	f6 e0       	ldi	r31, 0x06	; 6
     4ba:	bf 2e       	mov	r11, r31
     4bc:	f0 2d       	mov	r31, r0
	PORTE.DIRSET = PIN1_bm;

	
	while(1)
	{
		uxBits = xEventGroupWaitBits(
     4be:	cc 24       	eor	r12, r12
     4c0:	ca 94       	dec	r12
     4c2:	dc 2c       	mov	r13, r12
     4c4:	76 01       	movw	r14, r12
     4c6:	00 e0       	ldi	r16, 0x00	; 0
     4c8:	21 e0       	ldi	r18, 0x01	; 1
     4ca:	43 e0       	ldi	r20, 0x03	; 3
     4cc:	50 e0       	ldi	r21, 0x00	; 0
     4ce:	60 e0       	ldi	r22, 0x00	; 0
     4d0:	70 e0       	ldi	r23, 0x00	; 0
     4d2:	80 91 52 2d 	lds	r24, 0x2D52	; 0x802d52 <xDMAProcessEventGroup>
     4d6:	90 91 53 2d 	lds	r25, 0x2D53	; 0x802d53 <xDMAProcessEventGroup+0x1>
     4da:	0e 94 76 03 	call	0x6ec	; 0x6ec <xEventGroupWaitBits>
		pdTRUE,        /* Bits should be cleared before returning. */
		pdFALSE,       /* Don't wait for both bits, either bit will do. */
		portMAX_DELAY );/* Wait a maximum for either bit to be set. */
			
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
     4de:	60 fd       	sbrc	r22, 0
     4e0:	05 c0       	rjmp	.+10     	; 0x4ec <vTask_DMAHandler+0x60>
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			for (i=0;i<buffer_length;i++)
     4e2:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     4e6:	81 11       	cpse	r24, r1
     4e8:	43 c0       	rjmp	.+134    	; 0x570 <vTask_DMAHandler+0xe4>
     4ea:	73 c0       	rjmp	.+230    	; 0x5d2 <vTask_DMAHandler+0x146>
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
		{
			//Do stuff with BufferA
			//buffer_a ....
			for (i=0;i<buffer_length;i++)//Detect signal 
     4ec:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     4f0:	88 23       	and	r24, r24
     4f2:	89 f1       	breq	.+98     	; 0x556 <vTask_DMAHandler+0xca>
     4f4:	c0 e0       	ldi	r28, 0x00	; 0
     4f6:	d0 e0       	ldi	r29, 0x00	; 0
			{
				if ((xtest_array_length < 135)&(xtest_array_length > 120))		/*after testing variable is buffer_a				// if value is under threshold, it shall stop calculating the signal*/
     4f8:	80 91 50 2e 	lds	r24, 0x2E50	; 0x802e50 <xtest_array_length>
     4fc:	90 91 51 2e 	lds	r25, 0x2E51	; 0x802e51 <xtest_array_length+0x1>
     500:	89 57       	subi	r24, 0x79	; 121
     502:	91 09       	sbc	r25, r1
     504:	0e 97       	sbiw	r24, 0x0e	; 14
     506:	98 f4       	brcc	.+38     	; 0x52e <vTask_DMAHandler+0xa2>
				{
					no_signal_counter++;							// wait 100 counts to make sure that signal has stopped
     508:	8f ef       	ldi	r24, 0xFF	; 255
     50a:	88 1a       	sub	r8, r24
     50c:	98 0a       	sbc	r9, r24
					if (no_signal_counter >=100)					// no signal stop calculating -> set event bits to 0
     50e:	e4 e6       	ldi	r30, 0x64	; 100
     510:	8e 16       	cp	r8, r30
     512:	91 04       	cpc	r9, r1
     514:	cc f0       	brlt	.+50     	; 0x548 <vTask_DMAHandler+0xbc>
					{											// no signal stop calculating -> set event bits to 0
						xResult = xEventGroupClearBits(			// clear event bits
     516:	43 e0       	ldi	r20, 0x03	; 3
     518:	50 e0       	ldi	r21, 0x00	; 0
     51a:	60 e0       	ldi	r22, 0x00	; 0
     51c:	70 e0       	ldi	r23, 0x00	; 0
     51e:	80 91 4e 2e 	lds	r24, 0x2E4E	; 0x802e4e <xSignalProcessEventGroup>
     522:	90 91 4f 2e 	lds	r25, 0x2E4F	; 0x802e4f <xSignalProcessEventGroup+0x1>
     526:	0e 94 3b 04 	call	0x876	; 0x876 <xEventGroupClearBits>
     52a:	16 2f       	mov	r17, r22
     52c:	0d c0       	rjmp	.+26     	; 0x548 <vTask_DMAHandler+0xbc>
											);												
					}
				}
				else
				{
					xResult = xEventGroupSetBits(
     52e:	42 e0       	ldi	r20, 0x02	; 2
     530:	50 e0       	ldi	r21, 0x00	; 0
     532:	60 e0       	ldi	r22, 0x00	; 0
     534:	70 e0       	ldi	r23, 0x00	; 0
     536:	80 91 4e 2e 	lds	r24, 0x2E4E	; 0x802e4e <xSignalProcessEventGroup>
     53a:	90 91 4f 2e 	lds	r25, 0x2E4F	; 0x802e4f <xSignalProcessEventGroup+0x1>
     53e:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <xEventGroupSetBits>
     542:	16 2f       	mov	r17, r22
					);
					if( xResult & Process_Signal_BufferB )		//test if Eventgroup bit is set
					{
						//count_array_a++;
					}
					no_signal_counter = 0;
     544:	81 2c       	mov	r8, r1
     546:	91 2c       	mov	r9, r1
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
		{
			//Do stuff with BufferA
			//buffer_a ....
			for (i=0;i<buffer_length;i++)//Detect signal 
     548:	21 96       	adiw	r28, 0x01	; 1
     54a:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     54e:	90 e0       	ldi	r25, 0x00	; 0
     550:	c8 17       	cp	r28, r24
     552:	d9 07       	cpc	r29, r25
     554:	8c f2       	brlt	.-94     	; 0x4f8 <vTask_DMAHandler+0x6c>
						//count_array_a++;
					}
					no_signal_counter = 0;
				}
			}
			count_buffer_a++;
     556:	80 91 9d 20 	lds	r24, 0x209D	; 0x80209d <count_buffer_a>
     55a:	8f 5f       	subi	r24, 0xFF	; 255
     55c:	80 93 9d 20 	sts	0x209D, r24	; 0x80209d <count_buffer_a>
			
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x02));
     560:	f5 01       	movw	r30, r10
     562:	84 81       	ldd	r24, Z+4	; 0x04
     564:	8d 7f       	andi	r24, 0xFD	; 253
     566:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x04;	
     568:	84 81       	ldd	r24, Z+4	; 0x04
     56a:	84 60       	ori	r24, 0x04	; 4
     56c:	84 83       	std	Z+4, r24	; 0x04
     56e:	3d c0       	rjmp	.+122    	; 0x5ea <vTask_DMAHandler+0x15e>
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			for (i=0;i<buffer_length;i++)
     570:	c0 e0       	ldi	r28, 0x00	; 0
     572:	d0 e0       	ldi	r29, 0x00	; 0
			{				
				if (buffer_b[i] >= 20)
     574:	fe 01       	movw	r30, r28
     576:	e4 53       	subi	r30, 0x34	; 52
     578:	ff 4c       	sbci	r31, 0xCF	; 207
     57a:	80 81       	ld	r24, Z
     57c:	84 31       	cpi	r24, 0x14	; 20
     57e:	58 f0       	brcs	.+22     	; 0x596 <vTask_DMAHandler+0x10a>
				{
				xResult = xEventGroupSetBits(
     580:	41 e0       	ldi	r20, 0x01	; 1
     582:	50 e0       	ldi	r21, 0x00	; 0
     584:	60 e0       	ldi	r22, 0x00	; 0
     586:	70 e0       	ldi	r23, 0x00	; 0
     588:	80 91 4e 2e 	lds	r24, 0x2E4E	; 0x802e4e <xSignalProcessEventGroup>
     58c:	90 91 4f 2e 	lds	r25, 0x2E4F	; 0x802e4f <xSignalProcessEventGroup+0x1>
     590:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <xEventGroupSetBits>
     594:	16 2f       	mov	r17, r22
									xSignalProcessEventGroup,   /* The event group being updated. */
									Process_Signal_BufferA		/* The bits being set. */
									);	
				}
				if(xResult & Process_Signal_BufferA)			//test if Eventgroup bit is set
     596:	10 ff       	sbrs	r17, 0
     598:	03 c0       	rjmp	.+6      	; 0x5a0 <vTask_DMAHandler+0x114>
				{
					{
						//count_array_b++;
					}
					count_buffer_a = 0;
     59a:	10 92 9d 20 	sts	0x209D, r1	; 0x80209d <count_buffer_a>
     59e:	12 c0       	rjmp	.+36     	; 0x5c4 <vTask_DMAHandler+0x138>
				}
				else											// if value is under threshold, it shall stop calculating the signal
				{
					no_signal_counter++;					
     5a0:	ff ef       	ldi	r31, 0xFF	; 255
     5a2:	8f 1a       	sub	r8, r31
     5a4:	9f 0a       	sbc	r9, r31
					if (no_signal_counter >=100)					// wait 100 counts to make sure that signal has stopped
     5a6:	84 e6       	ldi	r24, 0x64	; 100
     5a8:	88 16       	cp	r8, r24
     5aa:	91 04       	cpc	r9, r1
     5ac:	5c f0       	brlt	.+22     	; 0x5c4 <vTask_DMAHandler+0x138>
					{									
						xResult = xEventGroupClearBits(			// clear event bits
     5ae:	43 e0       	ldi	r20, 0x03	; 3
     5b0:	50 e0       	ldi	r21, 0x00	; 0
     5b2:	60 e0       	ldi	r22, 0x00	; 0
     5b4:	70 e0       	ldi	r23, 0x00	; 0
     5b6:	80 91 4e 2e 	lds	r24, 0x2E4E	; 0x802e4e <xSignalProcessEventGroup>
     5ba:	90 91 4f 2e 	lds	r25, 0x2E4F	; 0x802e4f <xSignalProcessEventGroup+0x1>
     5be:	0e 94 3b 04 	call	0x876	; 0x876 <xEventGroupClearBits>
     5c2:	16 2f       	mov	r17, r22
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			for (i=0;i<buffer_length;i++)
     5c4:	21 96       	adiw	r28, 0x01	; 1
     5c6:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     5ca:	90 e0       	ldi	r25, 0x00	; 0
     5cc:	c8 17       	cp	r28, r24
     5ce:	d9 07       	cpc	r29, r25
     5d0:	8c f2       	brlt	.-94     	; 0x574 <vTask_DMAHandler+0xe8>
												Process_Signal_BufferA|Process_Signal_BufferB
												);										// no signal stop calculating -> set event bits to 0
						}
				}
			}
			count_buffer_b++;
     5d2:	80 91 9c 20 	lds	r24, 0x209C	; 0x80209c <__data_end>
     5d6:	8f 5f       	subi	r24, 0xFF	; 255
     5d8:	80 93 9c 20 	sts	0x209C, r24	; 0x80209c <__data_end>
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x04));
     5dc:	f5 01       	movw	r30, r10
     5de:	84 81       	ldd	r24, Z+4	; 0x04
     5e0:	8b 7f       	andi	r24, 0xFB	; 251
     5e2:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x02;
     5e4:	84 81       	ldd	r24, Z+4	; 0x04
     5e6:	82 60       	ori	r24, 0x02	; 2
     5e8:	84 83       	std	Z+4, r24	; 0x04
		}
	vTaskDelay(100 / portTICK_RATE_MS);
     5ea:	64 e6       	ldi	r22, 0x64	; 100
     5ec:	70 e0       	ldi	r23, 0x00	; 0
     5ee:	80 e0       	ldi	r24, 0x00	; 0
     5f0:	90 e0       	ldi	r25, 0x00	; 0
     5f2:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskDelay>
	}
     5f6:	63 cf       	rjmp	.-314    	; 0x4be <vTask_DMAHandler+0x32>

000005f8 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     5f8:	0f 93       	push	r16
     5fa:	cf 93       	push	r28
     5fc:	df 93       	push	r29
     5fe:	1f 92       	push	r1
     600:	cd b7       	in	r28, 0x3d	; 61
     602:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     604:	2f b7       	in	r18, 0x3f	; 63
     606:	29 83       	std	Y+1, r18	; 0x01
     608:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     60a:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     60c:	fc 01       	movw	r30, r24
     60e:	08 ed       	ldi	r16, 0xD8	; 216
     610:	04 bf       	out	0x34, r16	; 52
     612:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     614:	89 81       	ldd	r24, Y+1	; 0x01
     616:	8f bf       	out	0x3f, r24	; 63
#endif
}
     618:	0f 90       	pop	r0
     61a:	df 91       	pop	r29
     61c:	cf 91       	pop	r28
     61e:	0f 91       	pop	r16
     620:	08 95       	ret

00000622 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     622:	61 11       	cpse	r22, r1
     624:	02 c0       	rjmp	.+4      	; 0x62a <CLKSYS_XOSC_Config+0x8>
     626:	90 e0       	ldi	r25, 0x00	; 0
     628:	01 c0       	rjmp	.+2      	; 0x62c <CLKSYS_XOSC_Config+0xa>
     62a:	90 e2       	ldi	r25, 0x20	; 32
     62c:	84 2b       	or	r24, r20
     62e:	89 2b       	or	r24, r25
     630:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
     634:	08 95       	ret

00000636 <CLKSYS_PLL_Config>:
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     636:	6f 71       	andi	r22, 0x1F	; 31
     638:	86 2b       	or	r24, r22
     63a:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
     63e:	08 95       	ret

00000640 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     640:	e0 e5       	ldi	r30, 0x50	; 80
     642:	f0 e0       	ldi	r31, 0x00	; 0
     644:	90 81       	ld	r25, Z
     646:	28 2f       	mov	r18, r24
     648:	20 95       	com	r18
     64a:	92 23       	and	r25, r18
     64c:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     64e:	90 81       	ld	r25, Z
	return clkEnabled;
}
     650:	89 23       	and	r24, r25
     652:	08 95       	ret

00000654 <CLKSYS_Prescalers_Config>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
     654:	68 2b       	or	r22, r24
     656:	81 e4       	ldi	r24, 0x41	; 65
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <CCPWrite>
     65e:	08 95       	ret

00000660 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     660:	0f 93       	push	r16
     662:	1f 93       	push	r17
     664:	cf 93       	push	r28
     666:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     668:	00 e4       	ldi	r16, 0x40	; 64
     66a:	10 e0       	ldi	r17, 0x00	; 0
     66c:	f8 01       	movw	r30, r16
     66e:	60 81       	ld	r22, Z
	CCPWrite( &CLK.CTRL, clkCtrl );
     670:	68 7f       	andi	r22, 0xF8	; 248
     672:	68 2b       	or	r22, r24
     674:	80 e4       	ldi	r24, 0x40	; 64
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     67c:	f8 01       	movw	r30, r16
     67e:	80 81       	ld	r24, Z
	return clkCtrl;
}
     680:	8c 23       	and	r24, r28
     682:	cf 91       	pop	r28
     684:	1f 91       	pop	r17
     686:	0f 91       	pop	r16
     688:	08 95       	ret

0000068a <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
     68a:	fc 01       	movw	r30, r24
     68c:	90 81       	ld	r25, Z
     68e:	90 7f       	andi	r25, 0xF0	; 240
     690:	69 2b       	or	r22, r25
     692:	60 83       	st	Z, r22
     694:	08 95       	ret

00000696 <TC0_ConfigWGM>:
     696:	fc 01       	movw	r30, r24
     698:	91 81       	ldd	r25, Z+1	; 0x01
     69a:	98 7f       	andi	r25, 0xF8	; 248
     69c:	69 2b       	or	r22, r25
     69e:	61 83       	std	Z+1, r22	; 0x01
     6a0:	08 95       	ret

000006a2 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
     6a2:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     6a4:	96 81       	ldd	r25, Z+6	; 0x06
     6a6:	9c 7f       	andi	r25, 0xFC	; 252
     6a8:	69 2b       	or	r22, r25
     6aa:	66 83       	std	Z+6, r22	; 0x06
     6ac:	08 95       	ret

000006ae <software_reset>:
	 // TODO from here:
	 //
	 // - log the occurance of any error in flash mem (inc counter)
	 // - print a message

	 software_reset();
     6ae:	00 00       	nop
     6b0:	88 ed       	ldi	r24, 0xD8	; 216
     6b2:	84 bf       	out	0x34, r24	; 52
     6b4:	81 e0       	ldi	r24, 0x01	; 1
     6b6:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     6ba:	08 95       	ret

000006bc <vApplicationStackOverflowHook>:
     6bc:	0e 94 57 03 	call	0x6ae	; 0x6ae <software_reset>
     6c0:	08 95       	ret

000006c2 <xEventGroupCreate>:
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
}
     6c2:	cf 93       	push	r28
     6c4:	df 93       	push	r29
     6c6:	80 e1       	ldi	r24, 0x10	; 16
     6c8:	90 e0       	ldi	r25, 0x00	; 0
     6ca:	0e 94 fe 04 	call	0x9fc	; 0x9fc <pvPortMalloc>
     6ce:	ec 01       	movw	r28, r24
     6d0:	00 97       	sbiw	r24, 0x00	; 0
     6d2:	41 f0       	breq	.+16     	; 0x6e4 <xEventGroupCreate+0x22>
     6d4:	fc 01       	movw	r30, r24
     6d6:	11 92       	st	Z+, r1
     6d8:	11 92       	st	Z+, r1
     6da:	11 92       	st	Z+, r1
     6dc:	11 92       	st	Z+, r1
     6de:	cf 01       	movw	r24, r30
     6e0:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
     6e4:	ce 01       	movw	r24, r28
     6e6:	df 91       	pop	r29
     6e8:	cf 91       	pop	r28
     6ea:	08 95       	ret

000006ec <xEventGroupWaitBits>:
     6ec:	2f 92       	push	r2
     6ee:	3f 92       	push	r3
     6f0:	4f 92       	push	r4
     6f2:	5f 92       	push	r5
     6f4:	6f 92       	push	r6
     6f6:	7f 92       	push	r7
     6f8:	8f 92       	push	r8
     6fa:	9f 92       	push	r9
     6fc:	af 92       	push	r10
     6fe:	bf 92       	push	r11
     700:	cf 92       	push	r12
     702:	df 92       	push	r13
     704:	ef 92       	push	r14
     706:	ff 92       	push	r15
     708:	0f 93       	push	r16
     70a:	1f 93       	push	r17
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	ec 01       	movw	r28, r24
     712:	4a 01       	movw	r8, r20
     714:	5b 01       	movw	r10, r22
     716:	62 2e       	mov	r6, r18
     718:	70 2e       	mov	r7, r16
     71a:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskSuspendAll>
     71e:	28 80       	ld	r2, Y
     720:	39 80       	ldd	r3, Y+1	; 0x01
     722:	4a 80       	ldd	r4, Y+2	; 0x02
     724:	5b 80       	ldd	r5, Y+3	; 0x03
     726:	01 11       	cpse	r16, r1
     728:	0d c0       	rjmp	.+26     	; 0x744 <xEventGroupWaitBits+0x58>
     72a:	81 e0       	ldi	r24, 0x01	; 1
     72c:	b2 01       	movw	r22, r4
     72e:	a1 01       	movw	r20, r2
     730:	48 21       	and	r20, r8
     732:	59 21       	and	r21, r9
     734:	6a 21       	and	r22, r10
     736:	7b 21       	and	r23, r11
     738:	45 2b       	or	r20, r21
     73a:	46 2b       	or	r20, r22
     73c:	47 2b       	or	r20, r23
     73e:	79 f4       	brne	.+30     	; 0x75e <xEventGroupWaitBits+0x72>
     740:	80 e0       	ldi	r24, 0x00	; 0
     742:	0d c0       	rjmp	.+26     	; 0x75e <xEventGroupWaitBits+0x72>
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	b2 01       	movw	r22, r4
     748:	a1 01       	movw	r20, r2
     74a:	48 21       	and	r20, r8
     74c:	59 21       	and	r21, r9
     74e:	6a 21       	and	r22, r10
     750:	7b 21       	and	r23, r11
     752:	48 15       	cp	r20, r8
     754:	59 05       	cpc	r21, r9
     756:	6a 05       	cpc	r22, r10
     758:	7b 05       	cpc	r23, r11
     75a:	09 f0       	breq	.+2      	; 0x75e <xEventGroupWaitBits+0x72>
     75c:	80 e0       	ldi	r24, 0x00	; 0
     75e:	88 23       	and	r24, r24
     760:	81 f0       	breq	.+32     	; 0x782 <xEventGroupWaitBits+0x96>
     762:	66 20       	and	r6, r6
     764:	09 f4       	brne	.+2      	; 0x768 <xEventGroupWaitBits+0x7c>
     766:	70 c0       	rjmp	.+224    	; 0x848 <xEventGroupWaitBits+0x15c>
     768:	80 94       	com	r8
     76a:	90 94       	com	r9
     76c:	a0 94       	com	r10
     76e:	b0 94       	com	r11
     770:	82 20       	and	r8, r2
     772:	93 20       	and	r9, r3
     774:	a4 20       	and	r10, r4
     776:	b5 20       	and	r11, r5
     778:	88 82       	st	Y, r8
     77a:	99 82       	std	Y+1, r9	; 0x01
     77c:	aa 82       	std	Y+2, r10	; 0x02
     77e:	bb 82       	std	Y+3, r11	; 0x03
     780:	63 c0       	rjmp	.+198    	; 0x848 <xEventGroupWaitBits+0x15c>
     782:	c1 14       	cp	r12, r1
     784:	d1 04       	cpc	r13, r1
     786:	e1 04       	cpc	r14, r1
     788:	f1 04       	cpc	r15, r1
     78a:	09 f4       	brne	.+2      	; 0x78e <xEventGroupWaitBits+0xa2>
     78c:	5d c0       	rjmp	.+186    	; 0x848 <xEventGroupWaitBits+0x15c>
     78e:	66 20       	and	r6, r6
     790:	29 f0       	breq	.+10     	; 0x79c <xEventGroupWaitBits+0xb0>
     792:	40 e0       	ldi	r20, 0x00	; 0
     794:	50 e0       	ldi	r21, 0x00	; 0
     796:	60 e0       	ldi	r22, 0x00	; 0
     798:	71 e0       	ldi	r23, 0x01	; 1
     79a:	03 c0       	rjmp	.+6      	; 0x7a2 <xEventGroupWaitBits+0xb6>
     79c:	40 e0       	ldi	r20, 0x00	; 0
     79e:	50 e0       	ldi	r21, 0x00	; 0
     7a0:	ba 01       	movw	r22, r20
     7a2:	71 10       	cpse	r7, r1
     7a4:	74 60       	ori	r23, 0x04	; 4
     7a6:	48 29       	or	r20, r8
     7a8:	59 29       	or	r21, r9
     7aa:	6a 29       	or	r22, r10
     7ac:	7b 29       	or	r23, r11
     7ae:	97 01       	movw	r18, r14
     7b0:	86 01       	movw	r16, r12
     7b2:	ce 01       	movw	r24, r28
     7b4:	04 96       	adiw	r24, 0x04	; 4
     7b6:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <vTaskPlaceOnUnorderedEventList>
     7ba:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
     7be:	81 11       	cpse	r24, r1
     7c0:	02 c0       	rjmp	.+4      	; 0x7c6 <xEventGroupWaitBits+0xda>
     7c2:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
     7c6:	0e 94 78 10 	call	0x20f0	; 0x20f0 <uxTaskResetEventItemValue>
     7ca:	91 fd       	sbrc	r25, 1
     7cc:	39 c0       	rjmp	.+114    	; 0x840 <xEventGroupWaitBits+0x154>
     7ce:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     7d2:	ff 93       	push	r31
     7d4:	f8 7f       	andi	r31, 0xF8	; 248
     7d6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     7da:	68 81       	ld	r22, Y
     7dc:	79 81       	ldd	r23, Y+1	; 0x01
     7de:	8a 81       	ldd	r24, Y+2	; 0x02
     7e0:	9b 81       	ldd	r25, Y+3	; 0x03
     7e2:	71 10       	cpse	r7, r1
     7e4:	0d c0       	rjmp	.+26     	; 0x800 <xEventGroupWaitBits+0x114>
     7e6:	21 e0       	ldi	r18, 0x01	; 1
     7e8:	75 01       	movw	r14, r10
     7ea:	64 01       	movw	r12, r8
     7ec:	c6 22       	and	r12, r22
     7ee:	d7 22       	and	r13, r23
     7f0:	e8 22       	and	r14, r24
     7f2:	f9 22       	and	r15, r25
     7f4:	cd 28       	or	r12, r13
     7f6:	ce 28       	or	r12, r14
     7f8:	cf 28       	or	r12, r15
     7fa:	79 f4       	brne	.+30     	; 0x81a <xEventGroupWaitBits+0x12e>
     7fc:	20 e0       	ldi	r18, 0x00	; 0
     7fe:	0d c0       	rjmp	.+26     	; 0x81a <xEventGroupWaitBits+0x12e>
     800:	21 e0       	ldi	r18, 0x01	; 1
     802:	75 01       	movw	r14, r10
     804:	64 01       	movw	r12, r8
     806:	c6 22       	and	r12, r22
     808:	d7 22       	and	r13, r23
     80a:	e8 22       	and	r14, r24
     80c:	f9 22       	and	r15, r25
     80e:	c8 14       	cp	r12, r8
     810:	d9 04       	cpc	r13, r9
     812:	ea 04       	cpc	r14, r10
     814:	fb 04       	cpc	r15, r11
     816:	09 f0       	breq	.+2      	; 0x81a <xEventGroupWaitBits+0x12e>
     818:	20 e0       	ldi	r18, 0x00	; 0
     81a:	22 23       	and	r18, r18
     81c:	71 f0       	breq	.+28     	; 0x83a <xEventGroupWaitBits+0x14e>
     81e:	66 20       	and	r6, r6
     820:	61 f0       	breq	.+24     	; 0x83a <xEventGroupWaitBits+0x14e>
     822:	80 94       	com	r8
     824:	90 94       	com	r9
     826:	a0 94       	com	r10
     828:	b0 94       	com	r11
     82a:	86 22       	and	r8, r22
     82c:	97 22       	and	r9, r23
     82e:	a8 22       	and	r10, r24
     830:	b9 22       	and	r11, r25
     832:	88 82       	st	Y, r8
     834:	99 82       	std	Y+1, r9	; 0x01
     836:	aa 82       	std	Y+2, r10	; 0x02
     838:	bb 82       	std	Y+3, r11	; 0x03
     83a:	ff 91       	pop	r31
     83c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     840:	1b 01       	movw	r2, r22
     842:	2c 01       	movw	r4, r24
     844:	55 24       	eor	r5, r5
     846:	02 c0       	rjmp	.+4      	; 0x84c <xEventGroupWaitBits+0x160>
     848:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
     84c:	c2 01       	movw	r24, r4
     84e:	b1 01       	movw	r22, r2
     850:	df 91       	pop	r29
     852:	cf 91       	pop	r28
     854:	1f 91       	pop	r17
     856:	0f 91       	pop	r16
     858:	ff 90       	pop	r15
     85a:	ef 90       	pop	r14
     85c:	df 90       	pop	r13
     85e:	cf 90       	pop	r12
     860:	bf 90       	pop	r11
     862:	af 90       	pop	r10
     864:	9f 90       	pop	r9
     866:	8f 90       	pop	r8
     868:	7f 90       	pop	r7
     86a:	6f 90       	pop	r6
     86c:	5f 90       	pop	r5
     86e:	4f 90       	pop	r4
     870:	3f 90       	pop	r3
     872:	2f 90       	pop	r2
     874:	08 95       	ret

00000876 <xEventGroupClearBits>:
     876:	0f 93       	push	r16
     878:	1f 93       	push	r17
     87a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     87e:	ff 93       	push	r31
     880:	f8 7f       	andi	r31, 0xF8	; 248
     882:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     886:	fc 01       	movw	r30, r24
     888:	00 81       	ld	r16, Z
     88a:	11 81       	ldd	r17, Z+1	; 0x01
     88c:	22 81       	ldd	r18, Z+2	; 0x02
     88e:	33 81       	ldd	r19, Z+3	; 0x03
     890:	40 95       	com	r20
     892:	50 95       	com	r21
     894:	60 95       	com	r22
     896:	70 95       	com	r23
     898:	40 23       	and	r20, r16
     89a:	51 23       	and	r21, r17
     89c:	62 23       	and	r22, r18
     89e:	73 23       	and	r23, r19
     8a0:	40 83       	st	Z, r20
     8a2:	51 83       	std	Z+1, r21	; 0x01
     8a4:	62 83       	std	Z+2, r22	; 0x02
     8a6:	73 83       	std	Z+3, r23	; 0x03
     8a8:	ff 91       	pop	r31
     8aa:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     8ae:	c9 01       	movw	r24, r18
     8b0:	b8 01       	movw	r22, r16
     8b2:	1f 91       	pop	r17
     8b4:	0f 91       	pop	r16
     8b6:	08 95       	ret

000008b8 <xEventGroupSetBits>:
     8b8:	4f 92       	push	r4
     8ba:	5f 92       	push	r5
     8bc:	6f 92       	push	r6
     8be:	7f 92       	push	r7
     8c0:	af 92       	push	r10
     8c2:	bf 92       	push	r11
     8c4:	cf 92       	push	r12
     8c6:	df 92       	push	r13
     8c8:	ef 92       	push	r14
     8ca:	ff 92       	push	r15
     8cc:	0f 93       	push	r16
     8ce:	1f 93       	push	r17
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	ec 01       	movw	r28, r24
     8d6:	6a 01       	movw	r12, r20
     8d8:	7b 01       	movw	r14, r22
     8da:	8c 01       	movw	r16, r24
     8dc:	09 5f       	subi	r16, 0xF9	; 249
     8de:	1f 4f       	sbci	r17, 0xFF	; 255
     8e0:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskSuspendAll>
     8e4:	eb 85       	ldd	r30, Y+11	; 0x0b
     8e6:	fc 85       	ldd	r31, Y+12	; 0x0c
     8e8:	88 81       	ld	r24, Y
     8ea:	99 81       	ldd	r25, Y+1	; 0x01
     8ec:	aa 81       	ldd	r26, Y+2	; 0x02
     8ee:	bb 81       	ldd	r27, Y+3	; 0x03
     8f0:	c8 2a       	or	r12, r24
     8f2:	d9 2a       	or	r13, r25
     8f4:	ea 2a       	or	r14, r26
     8f6:	fb 2a       	or	r15, r27
     8f8:	c8 82       	st	Y, r12
     8fa:	d9 82       	std	Y+1, r13	; 0x01
     8fc:	ea 82       	std	Y+2, r14	; 0x02
     8fe:	fb 82       	std	Y+3, r15	; 0x03
     900:	0e 17       	cp	r16, r30
     902:	1f 07       	cpc	r17, r31
     904:	09 f4       	brne	.+2      	; 0x908 <xEventGroupSetBits+0x50>
     906:	42 c0       	rjmp	.+132    	; 0x98c <xEventGroupSetBits+0xd4>
     908:	c1 2c       	mov	r12, r1
     90a:	d1 2c       	mov	r13, r1
     90c:	76 01       	movw	r14, r12
     90e:	a4 80       	ldd	r10, Z+4	; 0x04
     910:	b5 80       	ldd	r11, Z+5	; 0x05
     912:	80 81       	ld	r24, Z
     914:	91 81       	ldd	r25, Z+1	; 0x01
     916:	a2 81       	ldd	r26, Z+2	; 0x02
     918:	b3 81       	ldd	r27, Z+3	; 0x03
     91a:	ac 01       	movw	r20, r24
     91c:	bd 01       	movw	r22, r26
     91e:	77 27       	eor	r23, r23
     920:	b2 fd       	sbrc	r27, 2
     922:	0f c0       	rjmp	.+30     	; 0x942 <xEventGroupSetBits+0x8a>
     924:	48 80       	ld	r4, Y
     926:	59 80       	ldd	r5, Y+1	; 0x01
     928:	6a 80       	ldd	r6, Y+2	; 0x02
     92a:	7b 80       	ldd	r7, Y+3	; 0x03
     92c:	44 22       	and	r4, r20
     92e:	55 22       	and	r5, r21
     930:	66 22       	and	r6, r22
     932:	77 22       	and	r7, r23
     934:	21 e0       	ldi	r18, 0x01	; 1
     936:	45 28       	or	r4, r5
     938:	46 28       	or	r4, r6
     93a:	47 28       	or	r4, r7
     93c:	89 f4       	brne	.+34     	; 0x960 <xEventGroupSetBits+0xa8>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	0f c0       	rjmp	.+30     	; 0x960 <xEventGroupSetBits+0xa8>
     942:	48 80       	ld	r4, Y
     944:	59 80       	ldd	r5, Y+1	; 0x01
     946:	6a 80       	ldd	r6, Y+2	; 0x02
     948:	7b 80       	ldd	r7, Y+3	; 0x03
     94a:	44 22       	and	r4, r20
     94c:	55 22       	and	r5, r21
     94e:	66 22       	and	r6, r22
     950:	77 22       	and	r7, r23
     952:	21 e0       	ldi	r18, 0x01	; 1
     954:	44 16       	cp	r4, r20
     956:	55 06       	cpc	r5, r21
     958:	66 06       	cpc	r6, r22
     95a:	77 06       	cpc	r7, r23
     95c:	09 f0       	breq	.+2      	; 0x960 <xEventGroupSetBits+0xa8>
     95e:	20 e0       	ldi	r18, 0x00	; 0
     960:	22 23       	and	r18, r18
     962:	71 f0       	breq	.+28     	; 0x980 <xEventGroupSetBits+0xc8>
     964:	b0 ff       	sbrs	r27, 0
     966:	04 c0       	rjmp	.+8      	; 0x970 <xEventGroupSetBits+0xb8>
     968:	c4 2a       	or	r12, r20
     96a:	d5 2a       	or	r13, r21
     96c:	e6 2a       	or	r14, r22
     96e:	f7 2a       	or	r15, r23
     970:	48 81       	ld	r20, Y
     972:	59 81       	ldd	r21, Y+1	; 0x01
     974:	6a 81       	ldd	r22, Y+2	; 0x02
     976:	7b 81       	ldd	r23, Y+3	; 0x03
     978:	72 60       	ori	r23, 0x02	; 2
     97a:	cf 01       	movw	r24, r30
     97c:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <vTaskRemoveFromUnorderedEventList>
     980:	ea 2d       	mov	r30, r10
     982:	fb 2d       	mov	r31, r11
     984:	0e 17       	cp	r16, r30
     986:	1f 07       	cpc	r17, r31
     988:	11 f6       	brne	.-124    	; 0x90e <xEventGroupSetBits+0x56>
     98a:	03 c0       	rjmp	.+6      	; 0x992 <xEventGroupSetBits+0xda>
     98c:	c1 2c       	mov	r12, r1
     98e:	d1 2c       	mov	r13, r1
     990:	76 01       	movw	r14, r12
     992:	c0 94       	com	r12
     994:	d0 94       	com	r13
     996:	e0 94       	com	r14
     998:	f0 94       	com	r15
     99a:	88 81       	ld	r24, Y
     99c:	99 81       	ldd	r25, Y+1	; 0x01
     99e:	aa 81       	ldd	r26, Y+2	; 0x02
     9a0:	bb 81       	ldd	r27, Y+3	; 0x03
     9a2:	c8 22       	and	r12, r24
     9a4:	d9 22       	and	r13, r25
     9a6:	ea 22       	and	r14, r26
     9a8:	fb 22       	and	r15, r27
     9aa:	c8 82       	st	Y, r12
     9ac:	d9 82       	std	Y+1, r13	; 0x01
     9ae:	ea 82       	std	Y+2, r14	; 0x02
     9b0:	fb 82       	std	Y+3, r15	; 0x03
     9b2:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
     9b6:	68 81       	ld	r22, Y
     9b8:	79 81       	ldd	r23, Y+1	; 0x01
     9ba:	8a 81       	ldd	r24, Y+2	; 0x02
     9bc:	9b 81       	ldd	r25, Y+3	; 0x03
     9be:	df 91       	pop	r29
     9c0:	cf 91       	pop	r28
     9c2:	1f 91       	pop	r17
     9c4:	0f 91       	pop	r16
     9c6:	ff 90       	pop	r15
     9c8:	ef 90       	pop	r14
     9ca:	df 90       	pop	r13
     9cc:	cf 90       	pop	r12
     9ce:	bf 90       	pop	r11
     9d0:	af 90       	pop	r10
     9d2:	7f 90       	pop	r7
     9d4:	6f 90       	pop	r6
     9d6:	5f 90       	pop	r5
     9d8:	4f 90       	pop	r4
     9da:	08 95       	ret

000009dc <vEventGroupSetBitsCallback>:
     9dc:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <xEventGroupSetBits>
     9e0:	08 95       	ret

000009e2 <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
     9e2:	0f 93       	push	r16
     9e4:	1f 93       	push	r17
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
     9e6:	89 01       	movw	r16, r18
     9e8:	9a 01       	movw	r18, r20
     9ea:	ab 01       	movw	r20, r22
     9ec:	bc 01       	movw	r22, r24
     9ee:	8e ee       	ldi	r24, 0xEE	; 238
     9f0:	94 e0       	ldi	r25, 0x04	; 4
     9f2:	0e 94 58 13 	call	0x26b0	; 0x26b0 <xTimerPendFunctionCallFromISR>

		return xReturn;
	}
     9f6:	1f 91       	pop	r17
     9f8:	0f 91       	pop	r16
     9fa:	08 95       	ret

000009fc <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     9fc:	cf 93       	push	r28
     9fe:	df 93       	push	r29
     a00:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     a02:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     a06:	20 91 9e 20 	lds	r18, 0x209E	; 0x80209e <xNextFreeByte>
     a0a:	30 91 9f 20 	lds	r19, 0x209F	; 0x80209f <xNextFreeByte+0x1>
     a0e:	c9 01       	movw	r24, r18
     a10:	8c 0f       	add	r24, r28
     a12:	9d 1f       	adc	r25, r29
     a14:	88 3b       	cpi	r24, 0xB8	; 184
     a16:	4b e0       	ldi	r20, 0x0B	; 11
     a18:	94 07       	cpc	r25, r20
     a1a:	58 f4       	brcc	.+22     	; 0xa32 <pvPortMalloc+0x36>
     a1c:	28 17       	cp	r18, r24
     a1e:	39 07       	cpc	r19, r25
     a20:	58 f4       	brcc	.+22     	; 0xa38 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     a22:	e9 01       	movw	r28, r18
     a24:	c0 56       	subi	r28, 0x60	; 96
     a26:	df 4d       	sbci	r29, 0xDF	; 223
			xNextFreeByte += xWantedSize;			
     a28:	80 93 9e 20 	sts	0x209E, r24	; 0x80209e <xNextFreeByte>
     a2c:	90 93 9f 20 	sts	0x209F, r25	; 0x80209f <xNextFreeByte+0x1>
     a30:	05 c0       	rjmp	.+10     	; 0xa3c <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     a32:	c0 e0       	ldi	r28, 0x00	; 0
     a34:	d0 e0       	ldi	r29, 0x00	; 0
     a36:	02 c0       	rjmp	.+4      	; 0xa3c <pvPortMalloc+0x40>
     a38:	c0 e0       	ldi	r28, 0x00	; 0
     a3a:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     a3c:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     a40:	ce 01       	movw	r24, r28
     a42:	df 91       	pop	r29
     a44:	cf 91       	pop	r28
     a46:	08 95       	ret

00000a48 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     a48:	08 95       	ret

00000a4a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     a4a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a4c:	03 96       	adiw	r24, 0x03	; 3
     a4e:	81 83       	std	Z+1, r24	; 0x01
     a50:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     a52:	4f ef       	ldi	r20, 0xFF	; 255
     a54:	5f ef       	ldi	r21, 0xFF	; 255
     a56:	ba 01       	movw	r22, r20
     a58:	43 83       	std	Z+3, r20	; 0x03
     a5a:	54 83       	std	Z+4, r21	; 0x04
     a5c:	65 83       	std	Z+5, r22	; 0x05
     a5e:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a60:	87 83       	std	Z+7, r24	; 0x07
     a62:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a64:	81 87       	std	Z+9, r24	; 0x09
     a66:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     a68:	10 82       	st	Z, r1
     a6a:	08 95       	ret

00000a6c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     a6c:	fc 01       	movw	r30, r24
     a6e:	12 86       	std	Z+10, r1	; 0x0a
     a70:	13 86       	std	Z+11, r1	; 0x0b
     a72:	08 95       	ret

00000a74 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a74:	cf 93       	push	r28
     a76:	df 93       	push	r29
     a78:	9c 01       	movw	r18, r24
     a7a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     a7c:	dc 01       	movw	r26, r24
     a7e:	11 96       	adiw	r26, 0x01	; 1
     a80:	cd 91       	ld	r28, X+
     a82:	dc 91       	ld	r29, X
     a84:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     a86:	c4 83       	std	Z+4, r28	; 0x04
     a88:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     a8a:	8e 81       	ldd	r24, Y+6	; 0x06
     a8c:	9f 81       	ldd	r25, Y+7	; 0x07
     a8e:	86 83       	std	Z+6, r24	; 0x06
     a90:	97 83       	std	Z+7, r25	; 0x07

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     a92:	8e 81       	ldd	r24, Y+6	; 0x06
     a94:	9f 81       	ldd	r25, Y+7	; 0x07
     a96:	dc 01       	movw	r26, r24
     a98:	14 96       	adiw	r26, 0x04	; 4
     a9a:	6d 93       	st	X+, r22
     a9c:	7c 93       	st	X, r23
     a9e:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxPrevious = pxNewListItem;
     aa0:	6e 83       	std	Y+6, r22	; 0x06
     aa2:	7f 83       	std	Y+7, r23	; 0x07

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     aa4:	22 87       	std	Z+10, r18	; 0x0a
     aa6:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     aa8:	f9 01       	movw	r30, r18
     aaa:	80 81       	ld	r24, Z
     aac:	8f 5f       	subi	r24, 0xFF	; 255
     aae:	80 83       	st	Z, r24
}
     ab0:	df 91       	pop	r29
     ab2:	cf 91       	pop	r28
     ab4:	08 95       	ret

00000ab6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     ab6:	0f 93       	push	r16
     ab8:	1f 93       	push	r17
     aba:	cf 93       	push	r28
     abc:	df 93       	push	r29
     abe:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     ac0:	08 81       	ld	r16, Y
     ac2:	19 81       	ldd	r17, Y+1	; 0x01
     ac4:	2a 81       	ldd	r18, Y+2	; 0x02
     ac6:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     ac8:	0f 3f       	cpi	r16, 0xFF	; 255
     aca:	4f ef       	ldi	r20, 0xFF	; 255
     acc:	14 07       	cpc	r17, r20
     ace:	24 07       	cpc	r18, r20
     ad0:	34 07       	cpc	r19, r20
     ad2:	21 f4       	brne	.+8      	; 0xadc <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     ad4:	fc 01       	movw	r30, r24
     ad6:	a1 85       	ldd	r26, Z+9	; 0x09
     ad8:	b2 85       	ldd	r27, Z+10	; 0x0a
     ada:	11 c0       	rjmp	.+34     	; 0xafe <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     adc:	dc 01       	movw	r26, r24
     ade:	13 96       	adiw	r26, 0x03	; 3
     ae0:	01 c0       	rjmp	.+2      	; 0xae4 <vListInsert+0x2e>
     ae2:	df 01       	movw	r26, r30
     ae4:	14 96       	adiw	r26, 0x04	; 4
     ae6:	ed 91       	ld	r30, X+
     ae8:	fc 91       	ld	r31, X
     aea:	15 97       	sbiw	r26, 0x05	; 5
     aec:	40 81       	ld	r20, Z
     aee:	51 81       	ldd	r21, Z+1	; 0x01
     af0:	62 81       	ldd	r22, Z+2	; 0x02
     af2:	73 81       	ldd	r23, Z+3	; 0x03
     af4:	04 17       	cp	r16, r20
     af6:	15 07       	cpc	r17, r21
     af8:	26 07       	cpc	r18, r22
     afa:	37 07       	cpc	r19, r23
     afc:	90 f7       	brcc	.-28     	; 0xae2 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	ed 91       	ld	r30, X+
     b02:	fc 91       	ld	r31, X
     b04:	15 97       	sbiw	r26, 0x05	; 5
     b06:	ec 83       	std	Y+4, r30	; 0x04
     b08:	fd 83       	std	Y+5, r31	; 0x05
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     b0a:	c6 83       	std	Z+6, r28	; 0x06
     b0c:	d7 83       	std	Z+7, r29	; 0x07
	pxNewListItem->pxPrevious = pxIterator;
     b0e:	ae 83       	std	Y+6, r26	; 0x06
     b10:	bf 83       	std	Y+7, r27	; 0x07
	pxIterator->pxNext = pxNewListItem;
     b12:	14 96       	adiw	r26, 0x04	; 4
     b14:	cd 93       	st	X+, r28
     b16:	dc 93       	st	X, r29
     b18:	15 97       	sbiw	r26, 0x05	; 5

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b1a:	8a 87       	std	Y+10, r24	; 0x0a
     b1c:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     b1e:	fc 01       	movw	r30, r24
     b20:	20 81       	ld	r18, Z
     b22:	2f 5f       	subi	r18, 0xFF	; 255
     b24:	20 83       	st	Z, r18
}
     b26:	df 91       	pop	r29
     b28:	cf 91       	pop	r28
     b2a:	1f 91       	pop	r17
     b2c:	0f 91       	pop	r16
     b2e:	08 95       	ret

00000b30 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     b30:	cf 93       	push	r28
     b32:	df 93       	push	r29
     b34:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     b36:	a2 85       	ldd	r26, Z+10	; 0x0a
     b38:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     b3a:	c4 81       	ldd	r28, Z+4	; 0x04
     b3c:	d5 81       	ldd	r29, Z+5	; 0x05
     b3e:	86 81       	ldd	r24, Z+6	; 0x06
     b40:	97 81       	ldd	r25, Z+7	; 0x07
     b42:	8e 83       	std	Y+6, r24	; 0x06
     b44:	9f 83       	std	Y+7, r25	; 0x07
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     b46:	c6 81       	ldd	r28, Z+6	; 0x06
     b48:	d7 81       	ldd	r29, Z+7	; 0x07
     b4a:	84 81       	ldd	r24, Z+4	; 0x04
     b4c:	95 81       	ldd	r25, Z+5	; 0x05
     b4e:	8c 83       	std	Y+4, r24	; 0x04
     b50:	9d 83       	std	Y+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     b52:	11 96       	adiw	r26, 0x01	; 1
     b54:	8d 91       	ld	r24, X+
     b56:	9c 91       	ld	r25, X
     b58:	12 97       	sbiw	r26, 0x02	; 2
     b5a:	e8 17       	cp	r30, r24
     b5c:	f9 07       	cpc	r31, r25
     b5e:	31 f4       	brne	.+12     	; 0xb6c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     b60:	86 81       	ldd	r24, Z+6	; 0x06
     b62:	97 81       	ldd	r25, Z+7	; 0x07
     b64:	11 96       	adiw	r26, 0x01	; 1
     b66:	8d 93       	st	X+, r24
     b68:	9c 93       	st	X, r25
     b6a:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     b6c:	12 86       	std	Z+10, r1	; 0x0a
     b6e:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     b70:	8c 91       	ld	r24, X
     b72:	81 50       	subi	r24, 0x01	; 1
     b74:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     b76:	8c 91       	ld	r24, X
}
     b78:	df 91       	pop	r29
     b7a:	cf 91       	pop	r28
     b7c:	08 95       	ret

00000b7e <_portSetInterruptMaskFromIsr>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     b7e:	e0 ea       	ldi	r30, 0xA0	; 160
     b80:	f0 e0       	ldi	r31, 0x00	; 0
     b82:	82 81       	ldd	r24, Z+2	; 0x02
     b84:	92 81       	ldd	r25, Z+2	; 0x02
     b86:	98 7f       	andi	r25, 0xF8	; 248
     b88:	92 83       	std	Z+2, r25	; 0x02
     b8a:	08 95       	ret

00000b8c <pxPortInitialiseStack>:
     b8c:	cf 92       	push	r12
     b8e:	df 92       	push	r13
     b90:	ef 92       	push	r14
     b92:	ff 92       	push	r15
     b94:	31 e1       	ldi	r19, 0x11	; 17
     b96:	fc 01       	movw	r30, r24
     b98:	30 83       	st	Z, r19
     b9a:	31 97       	sbiw	r30, 0x01	; 1
     b9c:	22 e2       	ldi	r18, 0x22	; 34
     b9e:	20 83       	st	Z, r18
     ba0:	31 97       	sbiw	r30, 0x01	; 1
     ba2:	a3 e3       	ldi	r26, 0x33	; 51
     ba4:	a0 83       	st	Z, r26
     ba6:	6b 01       	movw	r12, r22
     ba8:	e1 2c       	mov	r14, r1
     baa:	f1 2c       	mov	r15, r1
     bac:	31 97       	sbiw	r30, 0x01	; 1
     bae:	60 83       	st	Z, r22
     bb0:	31 97       	sbiw	r30, 0x01	; 1
     bb2:	d0 82       	st	Z, r13
     bb4:	31 97       	sbiw	r30, 0x01	; 1
     bb6:	e0 82       	st	Z, r14
     bb8:	31 97       	sbiw	r30, 0x01	; 1
     bba:	61 e3       	ldi	r22, 0x31	; 49
     bbc:	60 83       	st	Z, r22
     bbe:	31 97       	sbiw	r30, 0x01	; 1
     bc0:	60 e8       	ldi	r22, 0x80	; 128
     bc2:	60 83       	st	Z, r22
     bc4:	31 97       	sbiw	r30, 0x01	; 1
     bc6:	67 e8       	ldi	r22, 0x87	; 135
     bc8:	60 83       	st	Z, r22
     bca:	31 97       	sbiw	r30, 0x01	; 1
     bcc:	10 82       	st	Z, r1
     bce:	31 97       	sbiw	r30, 0x01	; 1
     bd0:	10 82       	st	Z, r1
     bd2:	31 97       	sbiw	r30, 0x01	; 1
     bd4:	62 e0       	ldi	r22, 0x02	; 2
     bd6:	60 83       	st	Z, r22
     bd8:	31 97       	sbiw	r30, 0x01	; 1
     bda:	63 e0       	ldi	r22, 0x03	; 3
     bdc:	60 83       	st	Z, r22
     bde:	31 97       	sbiw	r30, 0x01	; 1
     be0:	64 e0       	ldi	r22, 0x04	; 4
     be2:	60 83       	st	Z, r22
     be4:	31 97       	sbiw	r30, 0x01	; 1
     be6:	65 e0       	ldi	r22, 0x05	; 5
     be8:	60 83       	st	Z, r22
     bea:	31 97       	sbiw	r30, 0x01	; 1
     bec:	66 e0       	ldi	r22, 0x06	; 6
     bee:	60 83       	st	Z, r22
     bf0:	31 97       	sbiw	r30, 0x01	; 1
     bf2:	67 e0       	ldi	r22, 0x07	; 7
     bf4:	60 83       	st	Z, r22
     bf6:	31 97       	sbiw	r30, 0x01	; 1
     bf8:	68 e0       	ldi	r22, 0x08	; 8
     bfa:	60 83       	st	Z, r22
     bfc:	31 97       	sbiw	r30, 0x01	; 1
     bfe:	69 e0       	ldi	r22, 0x09	; 9
     c00:	60 83       	st	Z, r22
     c02:	31 97       	sbiw	r30, 0x01	; 1
     c04:	60 e1       	ldi	r22, 0x10	; 16
     c06:	60 83       	st	Z, r22
     c08:	31 97       	sbiw	r30, 0x01	; 1
     c0a:	30 83       	st	Z, r19
     c0c:	31 97       	sbiw	r30, 0x01	; 1
     c0e:	32 e1       	ldi	r19, 0x12	; 18
     c10:	30 83       	st	Z, r19
     c12:	31 97       	sbiw	r30, 0x01	; 1
     c14:	33 e1       	ldi	r19, 0x13	; 19
     c16:	30 83       	st	Z, r19
     c18:	31 97       	sbiw	r30, 0x01	; 1
     c1a:	34 e1       	ldi	r19, 0x14	; 20
     c1c:	30 83       	st	Z, r19
     c1e:	31 97       	sbiw	r30, 0x01	; 1
     c20:	35 e1       	ldi	r19, 0x15	; 21
     c22:	30 83       	st	Z, r19
     c24:	31 97       	sbiw	r30, 0x01	; 1
     c26:	36 e1       	ldi	r19, 0x16	; 22
     c28:	30 83       	st	Z, r19
     c2a:	31 97       	sbiw	r30, 0x01	; 1
     c2c:	37 e1       	ldi	r19, 0x17	; 23
     c2e:	30 83       	st	Z, r19
     c30:	31 97       	sbiw	r30, 0x01	; 1
     c32:	38 e1       	ldi	r19, 0x18	; 24
     c34:	30 83       	st	Z, r19
     c36:	31 97       	sbiw	r30, 0x01	; 1
     c38:	39 e1       	ldi	r19, 0x19	; 25
     c3a:	30 83       	st	Z, r19
     c3c:	31 97       	sbiw	r30, 0x01	; 1
     c3e:	30 e2       	ldi	r19, 0x20	; 32
     c40:	30 83       	st	Z, r19
     c42:	31 97       	sbiw	r30, 0x01	; 1
     c44:	31 e2       	ldi	r19, 0x21	; 33
     c46:	30 83       	st	Z, r19
     c48:	31 97       	sbiw	r30, 0x01	; 1
     c4a:	20 83       	st	Z, r18
     c4c:	31 97       	sbiw	r30, 0x01	; 1
     c4e:	23 e2       	ldi	r18, 0x23	; 35
     c50:	20 83       	st	Z, r18
     c52:	6a 01       	movw	r12, r20
     c54:	31 97       	sbiw	r30, 0x01	; 1
     c56:	40 83       	st	Z, r20
     c58:	31 97       	sbiw	r30, 0x01	; 1
     c5a:	d0 82       	st	Z, r13
     c5c:	31 97       	sbiw	r30, 0x01	; 1
     c5e:	26 e2       	ldi	r18, 0x26	; 38
     c60:	20 83       	st	Z, r18
     c62:	31 97       	sbiw	r30, 0x01	; 1
     c64:	27 e2       	ldi	r18, 0x27	; 39
     c66:	20 83       	st	Z, r18
     c68:	31 97       	sbiw	r30, 0x01	; 1
     c6a:	28 e2       	ldi	r18, 0x28	; 40
     c6c:	20 83       	st	Z, r18
     c6e:	31 97       	sbiw	r30, 0x01	; 1
     c70:	29 e2       	ldi	r18, 0x29	; 41
     c72:	20 83       	st	Z, r18
     c74:	31 97       	sbiw	r30, 0x01	; 1
     c76:	20 e3       	ldi	r18, 0x30	; 48
     c78:	20 83       	st	Z, r18
     c7a:	88 97       	sbiw	r24, 0x28	; 40
     c7c:	ff 90       	pop	r15
     c7e:	ef 90       	pop	r14
     c80:	df 90       	pop	r13
     c82:	cf 90       	pop	r12
     c84:	08 95       	ret

00000c86 <xPortStartScheduler>:
     c86:	83 ef       	ldi	r24, 0xF3	; 243
     c88:	91 e0       	ldi	r25, 0x01	; 1
     c8a:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     c8e:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
     c92:	65 e0       	ldi	r22, 0x05	; 5
     c94:	80 e0       	ldi	r24, 0x00	; 0
     c96:	98 e0       	ldi	r25, 0x08	; 8
     c98:	0e 94 45 03 	call	0x68a	; 0x68a <TC0_ConfigClockSource>
     c9c:	61 e0       	ldi	r22, 0x01	; 1
     c9e:	80 e0       	ldi	r24, 0x00	; 0
     ca0:	98 e0       	ldi	r25, 0x08	; 8
     ca2:	0e 94 51 03 	call	0x6a2	; 0x6a2 <TC0_SetOverflowIntLevel>
     ca6:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
     caa:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
     cae:	0d 90       	ld	r0, X+
     cb0:	0d be       	out	0x3d, r0	; 61
     cb2:	0d 90       	ld	r0, X+
     cb4:	0e be       	out	0x3e, r0	; 62
     cb6:	ef 91       	pop	r30
     cb8:	df 91       	pop	r29
     cba:	cf 91       	pop	r28
     cbc:	bf 91       	pop	r27
     cbe:	af 91       	pop	r26
     cc0:	9f 91       	pop	r25
     cc2:	8f 91       	pop	r24
     cc4:	7f 91       	pop	r23
     cc6:	6f 91       	pop	r22
     cc8:	5f 91       	pop	r21
     cca:	4f 91       	pop	r20
     ccc:	3f 91       	pop	r19
     cce:	2f 91       	pop	r18
     cd0:	1f 91       	pop	r17
     cd2:	0f 91       	pop	r16
     cd4:	ff 90       	pop	r15
     cd6:	ef 90       	pop	r14
     cd8:	df 90       	pop	r13
     cda:	cf 90       	pop	r12
     cdc:	bf 90       	pop	r11
     cde:	af 90       	pop	r10
     ce0:	9f 90       	pop	r9
     ce2:	8f 90       	pop	r8
     ce4:	7f 90       	pop	r7
     ce6:	6f 90       	pop	r6
     ce8:	5f 90       	pop	r5
     cea:	4f 90       	pop	r4
     cec:	3f 90       	pop	r3
     cee:	2f 90       	pop	r2
     cf0:	1f 90       	pop	r1
     cf2:	0f 90       	pop	r0
     cf4:	ff 91       	pop	r31
     cf6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     cfa:	ff 91       	pop	r31
     cfc:	ff bf       	out	0x3f, r31	; 63
     cfe:	ff 91       	pop	r31
     d00:	08 95       	ret
     d02:	81 e0       	ldi	r24, 0x01	; 1
     d04:	08 95       	ret

00000d06 <vPortYield>:
// 
//
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     d06:	ff 93       	push	r31
     d08:	ff b7       	in	r31, 0x3f	; 63
     d0a:	ff 93       	push	r31
     d0c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d10:	ff 93       	push	r31
     d12:	f8 7f       	andi	r31, 0xF8	; 248
     d14:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d18:	0f 92       	push	r0
     d1a:	1f 92       	push	r1
     d1c:	11 24       	eor	r1, r1
     d1e:	2f 92       	push	r2
     d20:	3f 92       	push	r3
     d22:	4f 92       	push	r4
     d24:	5f 92       	push	r5
     d26:	6f 92       	push	r6
     d28:	7f 92       	push	r7
     d2a:	8f 92       	push	r8
     d2c:	9f 92       	push	r9
     d2e:	af 92       	push	r10
     d30:	bf 92       	push	r11
     d32:	cf 92       	push	r12
     d34:	df 92       	push	r13
     d36:	ef 92       	push	r14
     d38:	ff 92       	push	r15
     d3a:	0f 93       	push	r16
     d3c:	1f 93       	push	r17
     d3e:	2f 93       	push	r18
     d40:	3f 93       	push	r19
     d42:	4f 93       	push	r20
     d44:	5f 93       	push	r21
     d46:	6f 93       	push	r22
     d48:	7f 93       	push	r23
     d4a:	8f 93       	push	r24
     d4c:	9f 93       	push	r25
     d4e:	af 93       	push	r26
     d50:	bf 93       	push	r27
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
     d56:	ef 93       	push	r30
     d58:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
     d5c:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
     d60:	0d b6       	in	r0, 0x3d	; 61
     d62:	0d 92       	st	X+, r0
     d64:	0e b6       	in	r0, 0x3e	; 62
     d66:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     d68:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     d6c:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
     d70:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
     d74:	0d 90       	ld	r0, X+
     d76:	0d be       	out	0x3d, r0	; 61
     d78:	0d 90       	ld	r0, X+
     d7a:	0e be       	out	0x3e, r0	; 62
     d7c:	ef 91       	pop	r30
     d7e:	df 91       	pop	r29
     d80:	cf 91       	pop	r28
     d82:	bf 91       	pop	r27
     d84:	af 91       	pop	r26
     d86:	9f 91       	pop	r25
     d88:	8f 91       	pop	r24
     d8a:	7f 91       	pop	r23
     d8c:	6f 91       	pop	r22
     d8e:	5f 91       	pop	r21
     d90:	4f 91       	pop	r20
     d92:	3f 91       	pop	r19
     d94:	2f 91       	pop	r18
     d96:	1f 91       	pop	r17
     d98:	0f 91       	pop	r16
     d9a:	ff 90       	pop	r15
     d9c:	ef 90       	pop	r14
     d9e:	df 90       	pop	r13
     da0:	cf 90       	pop	r12
     da2:	bf 90       	pop	r11
     da4:	af 90       	pop	r10
     da6:	9f 90       	pop	r9
     da8:	8f 90       	pop	r8
     daa:	7f 90       	pop	r7
     dac:	6f 90       	pop	r6
     dae:	5f 90       	pop	r5
     db0:	4f 90       	pop	r4
     db2:	3f 90       	pop	r3
     db4:	2f 90       	pop	r2
     db6:	1f 90       	pop	r1
     db8:	0f 90       	pop	r0
     dba:	ff 91       	pop	r31
     dbc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     dc0:	ff 91       	pop	r31
     dc2:	ff bf       	out	0x3f, r31	; 63
     dc4:	ff 91       	pop	r31
	asm volatile ( "ret" );
     dc6:	08 95       	ret

00000dc8 <portTaskSwitchContext>:
	//-----------------------------------------------------------
	//
	// The task switch is deferred until there is no more nesting.
	//
	void portTaskSwitchContext(signed portBASE_TYPE xSwitchRequired)
	{
     dc8:	cf 93       	push	r28
		intTaskSwitchPending |= xSwitchRequired;					
     dca:	90 91 4c 31 	lds	r25, 0x314C	; 0x80314c <intTaskSwitchPending>
     dce:	89 2b       	or	r24, r25
     dd0:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <intTaskSwitchPending>
																
		if(NOT_NESTING() && intTaskSwitchPending)					
     dd4:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     dd8:	91 30       	cpi	r25, 0x01	; 1
     dda:	41 f0       	breq	.+16     	; 0xdec <portTaskSwitchContext+0x24>
     ddc:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     de0:	92 30       	cpi	r25, 0x02	; 2
     de2:	21 f0       	breq	.+8      	; 0xdec <portTaskSwitchContext+0x24>
     de4:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     de8:	94 30       	cpi	r25, 0x04	; 4
     dea:	59 f4       	brne	.+22     	; 0xe02 <portTaskSwitchContext+0x3a>
     dec:	88 23       	and	r24, r24
     dee:	49 f0       	breq	.+18     	; 0xe02 <portTaskSwitchContext+0x3a>
		{															
			register unsigned portBASE_TYPE uxSavedPmicCtrlReg; 				
			extern void vTaskSwitchContext(void);   				
																
			// Critical section used, because vTaskSwitchContext handles FreeRTOS internal data structures.
 			uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR(); 
     df0:	0e 94 bf 05 	call	0xb7e	; 0xb7e <_portSetInterruptMaskFromIsr>
     df4:	c8 2f       	mov	r28, r24
			intTaskSwitchPending = 0;								
     df6:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <intTaskSwitchPending>
			vTaskSwitchContext();                   				
     dfa:	0e 94 95 0e 	call	0x1d2a	; 0x1d2a <vTaskSwitchContext>
			portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedPmicCtrlReg);
     dfe:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		}                                          					
	}
     e02:	cf 91       	pop	r28
     e04:	08 95       	ret

00000e06 <__vector_14>:
	// the context is saved at the start of vPortYieldFromTick().  The tick
	// count is incremented after the context is saved.
	//
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
     e06:	ff 93       	push	r31
     e08:	ff b7       	in	r31, 0x3f	; 63
     e0a:	ff 93       	push	r31
     e0c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e10:	ff 93       	push	r31
     e12:	f8 7f       	andi	r31, 0xF8	; 248
     e14:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e18:	0f 92       	push	r0
     e1a:	1f 92       	push	r1
     e1c:	11 24       	eor	r1, r1
     e1e:	2f 92       	push	r2
     e20:	3f 92       	push	r3
     e22:	4f 92       	push	r4
     e24:	5f 92       	push	r5
     e26:	6f 92       	push	r6
     e28:	7f 92       	push	r7
     e2a:	8f 92       	push	r8
     e2c:	9f 92       	push	r9
     e2e:	af 92       	push	r10
     e30:	bf 92       	push	r11
     e32:	cf 92       	push	r12
     e34:	df 92       	push	r13
     e36:	ef 92       	push	r14
     e38:	ff 92       	push	r15
     e3a:	0f 93       	push	r16
     e3c:	1f 93       	push	r17
     e3e:	2f 93       	push	r18
     e40:	3f 93       	push	r19
     e42:	4f 93       	push	r20
     e44:	5f 93       	push	r21
     e46:	6f 93       	push	r22
     e48:	7f 93       	push	r23
     e4a:	8f 93       	push	r24
     e4c:	9f 93       	push	r25
     e4e:	af 93       	push	r26
     e50:	bf 93       	push	r27
     e52:	cf 93       	push	r28
     e54:	df 93       	push	r29
     e56:	ef 93       	push	r30
     e58:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
     e5c:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
     e60:	0d b6       	in	r0, 0x3d	; 61
     e62:	0d 92       	st	X+, r0
     e64:	0e b6       	in	r0, 0x3e	; 62
     e66:	0d 92       	st	X+, r0
	//
	static void portTaskIncrementTick( void )
	{
		register unsigned portBASE_TYPE uxSavedPmicCtrlReg;

 		uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR();
     e68:	0e 94 bf 05 	call	0xb7e	; 0xb7e <_portSetInterruptMaskFromIsr>
     e6c:	c8 2f       	mov	r28, r24
		xTaskIncrementTick();
     e6e:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <xTaskIncrementTick>
 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedPmicCtrlReg );
     e72:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
		portTaskIncrementTick();
		//always try a task switch, but only if on kernel interrupt level
		portEND_SWITCHING_ISR(pdTRUE); 
     e76:	81 e0       	ldi	r24, 0x01	; 1
     e78:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <portTaskSwitchContext>
     e7c:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
     e80:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
     e84:	0d 90       	ld	r0, X+
     e86:	0d be       	out	0x3d, r0	; 61
     e88:	0d 90       	ld	r0, X+
     e8a:	0e be       	out	0x3e, r0	; 62
     e8c:	ef 91       	pop	r30
     e8e:	df 91       	pop	r29
     e90:	cf 91       	pop	r28
     e92:	bf 91       	pop	r27
     e94:	af 91       	pop	r26
     e96:	9f 91       	pop	r25
     e98:	8f 91       	pop	r24
     e9a:	7f 91       	pop	r23
     e9c:	6f 91       	pop	r22
     e9e:	5f 91       	pop	r21
     ea0:	4f 91       	pop	r20
     ea2:	3f 91       	pop	r19
     ea4:	2f 91       	pop	r18
     ea6:	1f 91       	pop	r17
     ea8:	0f 91       	pop	r16
     eaa:	ff 90       	pop	r15
     eac:	ef 90       	pop	r14
     eae:	df 90       	pop	r13
     eb0:	cf 90       	pop	r12
     eb2:	bf 90       	pop	r11
     eb4:	af 90       	pop	r10
     eb6:	9f 90       	pop	r9
     eb8:	8f 90       	pop	r8
     eba:	7f 90       	pop	r7
     ebc:	6f 90       	pop	r6
     ebe:	5f 90       	pop	r5
     ec0:	4f 90       	pop	r4
     ec2:	3f 90       	pop	r3
     ec4:	2f 90       	pop	r2
     ec6:	1f 90       	pop	r1
     ec8:	0f 90       	pop	r0
     eca:	ff 91       	pop	r31
     ecc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ed0:	ff 91       	pop	r31
     ed2:	ff bf       	out	0x3f, r31	; 63
     ed4:	ff 91       	pop	r31
     ed6:	18 95       	reti

00000ed8 <prvIsQueueEmpty>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
     ed8:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     edc:	ff 93       	push	r31
     ede:	f8 7f       	andi	r31, 0xF8	; 248
     ee0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ee4:	fc 01       	movw	r30, r24
     ee6:	96 8d       	ldd	r25, Z+30	; 0x1e
     ee8:	ff 91       	pop	r31
     eea:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     eee:	81 e0       	ldi	r24, 0x01	; 1
     ef0:	91 11       	cpse	r25, r1
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	08 95       	ret

00000ef6 <prvIsQueueFull>:
     ef6:	dc 01       	movw	r26, r24
     ef8:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     efc:	ff 93       	push	r31
     efe:	f8 7f       	andi	r31, 0xF8	; 248
     f00:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f04:	5e 96       	adiw	r26, 0x1e	; 30
     f06:	9c 91       	ld	r25, X
     f08:	5e 97       	sbiw	r26, 0x1e	; 30
     f0a:	ff 91       	pop	r31
     f0c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f10:	81 e0       	ldi	r24, 0x01	; 1
     f12:	5f 96       	adiw	r26, 0x1f	; 31
     f14:	2c 91       	ld	r18, X
     f16:	29 13       	cpse	r18, r25
     f18:	80 e0       	ldi	r24, 0x00	; 0
     f1a:	08 95       	ret

00000f1c <prvCopyDataToQueue>:
     f1c:	0f 93       	push	r16
     f1e:	1f 93       	push	r17
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
     f24:	ec 01       	movw	r28, r24
     f26:	04 2f       	mov	r16, r20
     f28:	1e 8d       	ldd	r17, Y+30	; 0x1e
     f2a:	48 a1       	ldd	r20, Y+32	; 0x20
     f2c:	44 23       	and	r20, r20
     f2e:	b9 f1       	breq	.+110    	; 0xf9e <prvCopyDataToQueue+0x82>
     f30:	01 11       	cpse	r16, r1
     f32:	16 c0       	rjmp	.+44     	; 0xf60 <prvCopyDataToQueue+0x44>
     f34:	50 e0       	ldi	r21, 0x00	; 0
     f36:	8c 81       	ldd	r24, Y+4	; 0x04
     f38:	9d 81       	ldd	r25, Y+5	; 0x05
     f3a:	0e 94 bf 20 	call	0x417e	; 0x417e <memcpy>
     f3e:	28 a1       	ldd	r18, Y+32	; 0x20
     f40:	8c 81       	ldd	r24, Y+4	; 0x04
     f42:	9d 81       	ldd	r25, Y+5	; 0x05
     f44:	82 0f       	add	r24, r18
     f46:	91 1d       	adc	r25, r1
     f48:	8c 83       	std	Y+4, r24	; 0x04
     f4a:	9d 83       	std	Y+5, r25	; 0x05
     f4c:	2a 81       	ldd	r18, Y+2	; 0x02
     f4e:	3b 81       	ldd	r19, Y+3	; 0x03
     f50:	82 17       	cp	r24, r18
     f52:	93 07       	cpc	r25, r19
     f54:	20 f1       	brcs	.+72     	; 0xf9e <prvCopyDataToQueue+0x82>
     f56:	88 81       	ld	r24, Y
     f58:	99 81       	ldd	r25, Y+1	; 0x01
     f5a:	8c 83       	std	Y+4, r24	; 0x04
     f5c:	9d 83       	std	Y+5, r25	; 0x05
     f5e:	1f c0       	rjmp	.+62     	; 0xf9e <prvCopyDataToQueue+0x82>
     f60:	50 e0       	ldi	r21, 0x00	; 0
     f62:	8e 81       	ldd	r24, Y+6	; 0x06
     f64:	9f 81       	ldd	r25, Y+7	; 0x07
     f66:	0e 94 bf 20 	call	0x417e	; 0x417e <memcpy>
     f6a:	88 a1       	ldd	r24, Y+32	; 0x20
     f6c:	90 e0       	ldi	r25, 0x00	; 0
     f6e:	91 95       	neg	r25
     f70:	81 95       	neg	r24
     f72:	91 09       	sbc	r25, r1
     f74:	2e 81       	ldd	r18, Y+6	; 0x06
     f76:	3f 81       	ldd	r19, Y+7	; 0x07
     f78:	28 0f       	add	r18, r24
     f7a:	39 1f       	adc	r19, r25
     f7c:	2e 83       	std	Y+6, r18	; 0x06
     f7e:	3f 83       	std	Y+7, r19	; 0x07
     f80:	48 81       	ld	r20, Y
     f82:	59 81       	ldd	r21, Y+1	; 0x01
     f84:	24 17       	cp	r18, r20
     f86:	35 07       	cpc	r19, r21
     f88:	30 f4       	brcc	.+12     	; 0xf96 <prvCopyDataToQueue+0x7a>
     f8a:	2a 81       	ldd	r18, Y+2	; 0x02
     f8c:	3b 81       	ldd	r19, Y+3	; 0x03
     f8e:	82 0f       	add	r24, r18
     f90:	93 1f       	adc	r25, r19
     f92:	8e 83       	std	Y+6, r24	; 0x06
     f94:	9f 83       	std	Y+7, r25	; 0x07
     f96:	02 30       	cpi	r16, 0x02	; 2
     f98:	11 f4       	brne	.+4      	; 0xf9e <prvCopyDataToQueue+0x82>
     f9a:	11 11       	cpse	r17, r1
     f9c:	11 50       	subi	r17, 0x01	; 1
     f9e:	1f 5f       	subi	r17, 0xFF	; 255
     fa0:	1e 8f       	std	Y+30, r17	; 0x1e
     fa2:	80 e0       	ldi	r24, 0x00	; 0
     fa4:	df 91       	pop	r29
     fa6:	cf 91       	pop	r28
     fa8:	1f 91       	pop	r17
     faa:	0f 91       	pop	r16
     fac:	08 95       	ret

00000fae <prvCopyDataFromQueue>:
     fae:	fc 01       	movw	r30, r24
     fb0:	40 a1       	ldd	r20, Z+32	; 0x20
     fb2:	44 23       	and	r20, r20
     fb4:	a9 f0       	breq	.+42     	; 0xfe0 <prvCopyDataFromQueue+0x32>
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	26 81       	ldd	r18, Z+6	; 0x06
     fba:	37 81       	ldd	r19, Z+7	; 0x07
     fbc:	24 0f       	add	r18, r20
     fbe:	35 1f       	adc	r19, r21
     fc0:	26 83       	std	Z+6, r18	; 0x06
     fc2:	37 83       	std	Z+7, r19	; 0x07
     fc4:	82 81       	ldd	r24, Z+2	; 0x02
     fc6:	93 81       	ldd	r25, Z+3	; 0x03
     fc8:	28 17       	cp	r18, r24
     fca:	39 07       	cpc	r19, r25
     fcc:	20 f0       	brcs	.+8      	; 0xfd6 <prvCopyDataFromQueue+0x28>
     fce:	80 81       	ld	r24, Z
     fd0:	91 81       	ldd	r25, Z+1	; 0x01
     fd2:	86 83       	std	Z+6, r24	; 0x06
     fd4:	97 83       	std	Z+7, r25	; 0x07
     fd6:	cb 01       	movw	r24, r22
     fd8:	66 81       	ldd	r22, Z+6	; 0x06
     fda:	77 81       	ldd	r23, Z+7	; 0x07
     fdc:	0e 94 bf 20 	call	0x417e	; 0x417e <memcpy>
     fe0:	08 95       	ret

00000fe2 <prvUnlockQueue>:
     fe2:	ef 92       	push	r14
     fe4:	ff 92       	push	r15
     fe6:	0f 93       	push	r16
     fe8:	1f 93       	push	r17
     fea:	cf 93       	push	r28
     fec:	8c 01       	movw	r16, r24
     fee:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ff2:	ff 93       	push	r31
     ff4:	f8 7f       	andi	r31, 0xF8	; 248
     ff6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ffa:	fc 01       	movw	r30, r24
     ffc:	c2 a1       	ldd	r28, Z+34	; 0x22
     ffe:	1c 16       	cp	r1, r28
    1000:	ac f4       	brge	.+42     	; 0x102c <prvUnlockQueue+0x4a>
    1002:	83 89       	ldd	r24, Z+19	; 0x13
    1004:	81 11       	cpse	r24, r1
    1006:	06 c0       	rjmp	.+12     	; 0x1014 <prvUnlockQueue+0x32>
    1008:	11 c0       	rjmp	.+34     	; 0x102c <prvUnlockQueue+0x4a>
    100a:	f8 01       	movw	r30, r16
    100c:	83 89       	ldd	r24, Z+19	; 0x13
    100e:	81 11       	cpse	r24, r1
    1010:	05 c0       	rjmp	.+10     	; 0x101c <prvUnlockQueue+0x3a>
    1012:	0c c0       	rjmp	.+24     	; 0x102c <prvUnlockQueue+0x4a>
    1014:	78 01       	movw	r14, r16
    1016:	f3 e1       	ldi	r31, 0x13	; 19
    1018:	ef 0e       	add	r14, r31
    101a:	f1 1c       	adc	r15, r1
    101c:	c7 01       	movw	r24, r14
    101e:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <xTaskRemoveFromEventList>
    1022:	81 11       	cpse	r24, r1
    1024:	0e 94 66 10 	call	0x20cc	; 0x20cc <vTaskMissedYield>
    1028:	c1 50       	subi	r28, 0x01	; 1
    102a:	79 f7       	brne	.-34     	; 0x100a <prvUnlockQueue+0x28>
    102c:	8f ef       	ldi	r24, 0xFF	; 255
    102e:	f8 01       	movw	r30, r16
    1030:	82 a3       	std	Z+34, r24	; 0x22
    1032:	ff 91       	pop	r31
    1034:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1038:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    103c:	ff 93       	push	r31
    103e:	f8 7f       	andi	r31, 0xF8	; 248
    1040:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1044:	f8 01       	movw	r30, r16
    1046:	c1 a1       	ldd	r28, Z+33	; 0x21
    1048:	1c 16       	cp	r1, r28
    104a:	ac f4       	brge	.+42     	; 0x1076 <prvUnlockQueue+0x94>
    104c:	80 85       	ldd	r24, Z+8	; 0x08
    104e:	81 11       	cpse	r24, r1
    1050:	06 c0       	rjmp	.+12     	; 0x105e <prvUnlockQueue+0x7c>
    1052:	11 c0       	rjmp	.+34     	; 0x1076 <prvUnlockQueue+0x94>
    1054:	f8 01       	movw	r30, r16
    1056:	80 85       	ldd	r24, Z+8	; 0x08
    1058:	81 11       	cpse	r24, r1
    105a:	05 c0       	rjmp	.+10     	; 0x1066 <prvUnlockQueue+0x84>
    105c:	0c c0       	rjmp	.+24     	; 0x1076 <prvUnlockQueue+0x94>
    105e:	78 01       	movw	r14, r16
    1060:	f8 e0       	ldi	r31, 0x08	; 8
    1062:	ef 0e       	add	r14, r31
    1064:	f1 1c       	adc	r15, r1
    1066:	c7 01       	movw	r24, r14
    1068:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <xTaskRemoveFromEventList>
    106c:	81 11       	cpse	r24, r1
    106e:	0e 94 66 10 	call	0x20cc	; 0x20cc <vTaskMissedYield>
    1072:	c1 50       	subi	r28, 0x01	; 1
    1074:	79 f7       	brne	.-34     	; 0x1054 <prvUnlockQueue+0x72>
    1076:	8f ef       	ldi	r24, 0xFF	; 255
    1078:	f8 01       	movw	r30, r16
    107a:	81 a3       	std	Z+33, r24	; 0x21
    107c:	ff 91       	pop	r31
    107e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1082:	cf 91       	pop	r28
    1084:	1f 91       	pop	r17
    1086:	0f 91       	pop	r16
    1088:	ff 90       	pop	r15
    108a:	ef 90       	pop	r14
    108c:	08 95       	ret

0000108e <xQueueGenericReset>:
    108e:	cf 93       	push	r28
    1090:	df 93       	push	r29
    1092:	ec 01       	movw	r28, r24
    1094:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1098:	ff 93       	push	r31
    109a:	f8 7f       	andi	r31, 0xF8	; 248
    109c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10a0:	48 81       	ld	r20, Y
    10a2:	59 81       	ldd	r21, Y+1	; 0x01
    10a4:	28 a1       	ldd	r18, Y+32	; 0x20
    10a6:	30 e0       	ldi	r19, 0x00	; 0
    10a8:	7f 8d       	ldd	r23, Y+31	; 0x1f
    10aa:	72 9f       	mul	r23, r18
    10ac:	c0 01       	movw	r24, r0
    10ae:	73 9f       	mul	r23, r19
    10b0:	90 0d       	add	r25, r0
    10b2:	11 24       	eor	r1, r1
    10b4:	fa 01       	movw	r30, r20
    10b6:	e8 0f       	add	r30, r24
    10b8:	f9 1f       	adc	r31, r25
    10ba:	ea 83       	std	Y+2, r30	; 0x02
    10bc:	fb 83       	std	Y+3, r31	; 0x03
    10be:	1e 8e       	std	Y+30, r1	; 0x1e
    10c0:	4c 83       	std	Y+4, r20	; 0x04
    10c2:	5d 83       	std	Y+5, r21	; 0x05
    10c4:	82 1b       	sub	r24, r18
    10c6:	93 0b       	sbc	r25, r19
    10c8:	84 0f       	add	r24, r20
    10ca:	95 1f       	adc	r25, r21
    10cc:	8e 83       	std	Y+6, r24	; 0x06
    10ce:	9f 83       	std	Y+7, r25	; 0x07
    10d0:	8f ef       	ldi	r24, 0xFF	; 255
    10d2:	89 a3       	std	Y+33, r24	; 0x21
    10d4:	8a a3       	std	Y+34, r24	; 0x22
    10d6:	61 11       	cpse	r22, r1
    10d8:	0c c0       	rjmp	.+24     	; 0x10f2 <xQueueGenericReset+0x64>
    10da:	88 85       	ldd	r24, Y+8	; 0x08
    10dc:	88 23       	and	r24, r24
    10de:	89 f0       	breq	.+34     	; 0x1102 <xQueueGenericReset+0x74>
    10e0:	ce 01       	movw	r24, r28
    10e2:	08 96       	adiw	r24, 0x08	; 8
    10e4:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <xTaskRemoveFromEventList>
    10e8:	88 23       	and	r24, r24
    10ea:	59 f0       	breq	.+22     	; 0x1102 <xQueueGenericReset+0x74>
    10ec:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    10f0:	08 c0       	rjmp	.+16     	; 0x1102 <xQueueGenericReset+0x74>
    10f2:	ce 01       	movw	r24, r28
    10f4:	08 96       	adiw	r24, 0x08	; 8
    10f6:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    10fa:	ce 01       	movw	r24, r28
    10fc:	43 96       	adiw	r24, 0x13	; 19
    10fe:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    1102:	ff 91       	pop	r31
    1104:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1108:	81 e0       	ldi	r24, 0x01	; 1
    110a:	df 91       	pop	r29
    110c:	cf 91       	pop	r28
    110e:	08 95       	ret

00001110 <xQueueGenericCreate>:
    1110:	ff 92       	push	r15
    1112:	0f 93       	push	r16
    1114:	1f 93       	push	r17
    1116:	cf 93       	push	r28
    1118:	df 93       	push	r29
    111a:	08 2f       	mov	r16, r24
    111c:	16 2f       	mov	r17, r22
    111e:	f4 2e       	mov	r15, r20
    1120:	66 23       	and	r22, r22
    1122:	c9 f0       	breq	.+50     	; 0x1156 <xQueueGenericCreate+0x46>
    1124:	86 9f       	mul	r24, r22
    1126:	c0 01       	movw	r24, r0
    1128:	11 24       	eor	r1, r1
    112a:	85 96       	adiw	r24, 0x25	; 37
    112c:	0e 94 fe 04 	call	0x9fc	; 0x9fc <pvPortMalloc>
    1130:	ec 01       	movw	r28, r24
    1132:	00 97       	sbiw	r24, 0x00	; 0
    1134:	49 f4       	brne	.+18     	; 0x1148 <xQueueGenericCreate+0x38>
    1136:	16 c0       	rjmp	.+44     	; 0x1164 <xQueueGenericCreate+0x54>
    1138:	0f 8f       	std	Y+31, r16	; 0x1f
    113a:	18 a3       	std	Y+32, r17	; 0x20
    113c:	61 e0       	ldi	r22, 0x01	; 1
    113e:	ce 01       	movw	r24, r28
    1140:	0e 94 47 08 	call	0x108e	; 0x108e <xQueueGenericReset>
    1144:	fc a2       	std	Y+36, r15	; 0x24
    1146:	0e c0       	rjmp	.+28     	; 0x1164 <xQueueGenericCreate+0x54>
    1148:	85 96       	adiw	r24, 0x25	; 37
    114a:	88 83       	st	Y, r24
    114c:	99 83       	std	Y+1, r25	; 0x01
    114e:	f4 cf       	rjmp	.-24     	; 0x1138 <xQueueGenericCreate+0x28>
    1150:	c8 83       	st	Y, r28
    1152:	d9 83       	std	Y+1, r29	; 0x01
    1154:	f1 cf       	rjmp	.-30     	; 0x1138 <xQueueGenericCreate+0x28>
    1156:	85 e2       	ldi	r24, 0x25	; 37
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	0e 94 fe 04 	call	0x9fc	; 0x9fc <pvPortMalloc>
    115e:	ec 01       	movw	r28, r24
    1160:	89 2b       	or	r24, r25
    1162:	b1 f7       	brne	.-20     	; 0x1150 <xQueueGenericCreate+0x40>
    1164:	ce 01       	movw	r24, r28
    1166:	df 91       	pop	r29
    1168:	cf 91       	pop	r28
    116a:	1f 91       	pop	r17
    116c:	0f 91       	pop	r16
    116e:	ff 90       	pop	r15
    1170:	08 95       	ret

00001172 <xQueueGenericSend>:
    1172:	af 92       	push	r10
    1174:	bf 92       	push	r11
    1176:	cf 92       	push	r12
    1178:	df 92       	push	r13
    117a:	ef 92       	push	r14
    117c:	ff 92       	push	r15
    117e:	0f 93       	push	r16
    1180:	1f 93       	push	r17
    1182:	cf 93       	push	r28
    1184:	df 93       	push	r29
    1186:	cd b7       	in	r28, 0x3d	; 61
    1188:	de b7       	in	r29, 0x3e	; 62
    118a:	29 97       	sbiw	r28, 0x09	; 9
    118c:	cd bf       	out	0x3d, r28	; 61
    118e:	de bf       	out	0x3e, r29	; 62
    1190:	7c 01       	movw	r14, r24
    1192:	5b 01       	movw	r10, r22
    1194:	2e 83       	std	Y+6, r18	; 0x06
    1196:	3f 83       	std	Y+7, r19	; 0x07
    1198:	48 87       	std	Y+8, r20	; 0x08
    119a:	59 87       	std	Y+9, r21	; 0x09
    119c:	10 e0       	ldi	r17, 0x00	; 0
    119e:	6c 01       	movw	r12, r24
    11a0:	88 e0       	ldi	r24, 0x08	; 8
    11a2:	c8 0e       	add	r12, r24
    11a4:	d1 1c       	adc	r13, r1
    11a6:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11aa:	ff 93       	push	r31
    11ac:	f8 7f       	andi	r31, 0xF8	; 248
    11ae:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11b2:	f7 01       	movw	r30, r14
    11b4:	96 8d       	ldd	r25, Z+30	; 0x1e
    11b6:	87 8d       	ldd	r24, Z+31	; 0x1f
    11b8:	98 17       	cp	r25, r24
    11ba:	10 f0       	brcs	.+4      	; 0x11c0 <xQueueGenericSend+0x4e>
    11bc:	02 30       	cpi	r16, 0x02	; 2
    11be:	d1 f4       	brne	.+52     	; 0x11f4 <xQueueGenericSend+0x82>
    11c0:	40 2f       	mov	r20, r16
    11c2:	b5 01       	movw	r22, r10
    11c4:	c7 01       	movw	r24, r14
    11c6:	0e 94 8e 07 	call	0xf1c	; 0xf1c <prvCopyDataToQueue>
    11ca:	f7 01       	movw	r30, r14
    11cc:	93 89       	ldd	r25, Z+19	; 0x13
    11ce:	99 23       	and	r25, r25
    11d0:	49 f0       	breq	.+18     	; 0x11e4 <xQueueGenericSend+0x72>
    11d2:	c7 01       	movw	r24, r14
    11d4:	43 96       	adiw	r24, 0x13	; 19
    11d6:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <xTaskRemoveFromEventList>
    11da:	88 23       	and	r24, r24
    11dc:	31 f0       	breq	.+12     	; 0x11ea <xQueueGenericSend+0x78>
    11de:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    11e2:	03 c0       	rjmp	.+6      	; 0x11ea <xQueueGenericSend+0x78>
    11e4:	81 11       	cpse	r24, r1
    11e6:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    11ea:	ff 91       	pop	r31
    11ec:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11f0:	81 e0       	ldi	r24, 0x01	; 1
    11f2:	57 c0       	rjmp	.+174    	; 0x12a2 <xQueueGenericSend+0x130>
    11f4:	8e 81       	ldd	r24, Y+6	; 0x06
    11f6:	9f 81       	ldd	r25, Y+7	; 0x07
    11f8:	a8 85       	ldd	r26, Y+8	; 0x08
    11fa:	b9 85       	ldd	r27, Y+9	; 0x09
    11fc:	89 2b       	or	r24, r25
    11fe:	8a 2b       	or	r24, r26
    1200:	8b 2b       	or	r24, r27
    1202:	29 f4       	brne	.+10     	; 0x120e <xQueueGenericSend+0x9c>
    1204:	ff 91       	pop	r31
    1206:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    120a:	80 e0       	ldi	r24, 0x00	; 0
    120c:	4a c0       	rjmp	.+148    	; 0x12a2 <xQueueGenericSend+0x130>
    120e:	11 11       	cpse	r17, r1
    1210:	05 c0       	rjmp	.+10     	; 0x121c <xQueueGenericSend+0xaa>
    1212:	ce 01       	movw	r24, r28
    1214:	01 96       	adiw	r24, 0x01	; 1
    1216:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <vTaskInternalSetTimeOutState>
    121a:	11 e0       	ldi	r17, 0x01	; 1
    121c:	ff 91       	pop	r31
    121e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1222:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskSuspendAll>
    1226:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    122a:	ff 93       	push	r31
    122c:	f8 7f       	andi	r31, 0xF8	; 248
    122e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1232:	f7 01       	movw	r30, r14
    1234:	81 a1       	ldd	r24, Z+33	; 0x21
    1236:	8f 3f       	cpi	r24, 0xFF	; 255
    1238:	09 f4       	brne	.+2      	; 0x123c <xQueueGenericSend+0xca>
    123a:	11 a2       	std	Z+33, r1	; 0x21
    123c:	f7 01       	movw	r30, r14
    123e:	82 a1       	ldd	r24, Z+34	; 0x22
    1240:	8f 3f       	cpi	r24, 0xFF	; 255
    1242:	09 f4       	brne	.+2      	; 0x1246 <xQueueGenericSend+0xd4>
    1244:	12 a2       	std	Z+34, r1	; 0x22
    1246:	ff 91       	pop	r31
    1248:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    124c:	be 01       	movw	r22, r28
    124e:	6a 5f       	subi	r22, 0xFA	; 250
    1250:	7f 4f       	sbci	r23, 0xFF	; 255
    1252:	ce 01       	movw	r24, r28
    1254:	01 96       	adiw	r24, 0x01	; 1
    1256:	0e 94 08 10 	call	0x2010	; 0x2010 <xTaskCheckForTimeOut>
    125a:	81 11       	cpse	r24, r1
    125c:	1c c0       	rjmp	.+56     	; 0x1296 <xQueueGenericSend+0x124>
    125e:	c7 01       	movw	r24, r14
    1260:	0e 94 7b 07 	call	0xef6	; 0xef6 <prvIsQueueFull>
    1264:	88 23       	and	r24, r24
    1266:	89 f0       	breq	.+34     	; 0x128a <xQueueGenericSend+0x118>
    1268:	4e 81       	ldd	r20, Y+6	; 0x06
    126a:	5f 81       	ldd	r21, Y+7	; 0x07
    126c:	68 85       	ldd	r22, Y+8	; 0x08
    126e:	79 85       	ldd	r23, Y+9	; 0x09
    1270:	c6 01       	movw	r24, r12
    1272:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vTaskPlaceOnEventList>
    1276:	c7 01       	movw	r24, r14
    1278:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <prvUnlockQueue>
    127c:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    1280:	81 11       	cpse	r24, r1
    1282:	91 cf       	rjmp	.-222    	; 0x11a6 <xQueueGenericSend+0x34>
    1284:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    1288:	8e cf       	rjmp	.-228    	; 0x11a6 <xQueueGenericSend+0x34>
    128a:	c7 01       	movw	r24, r14
    128c:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <prvUnlockQueue>
    1290:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    1294:	88 cf       	rjmp	.-240    	; 0x11a6 <xQueueGenericSend+0x34>
    1296:	c7 01       	movw	r24, r14
    1298:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <prvUnlockQueue>
    129c:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    12a0:	80 e0       	ldi	r24, 0x00	; 0
    12a2:	29 96       	adiw	r28, 0x09	; 9
    12a4:	cd bf       	out	0x3d, r28	; 61
    12a6:	de bf       	out	0x3e, r29	; 62
    12a8:	df 91       	pop	r29
    12aa:	cf 91       	pop	r28
    12ac:	1f 91       	pop	r17
    12ae:	0f 91       	pop	r16
    12b0:	ff 90       	pop	r15
    12b2:	ef 90       	pop	r14
    12b4:	df 90       	pop	r13
    12b6:	cf 90       	pop	r12
    12b8:	bf 90       	pop	r11
    12ba:	af 90       	pop	r10
    12bc:	08 95       	ret

000012be <xQueueGenericSendFromISR>:
    12be:	af 92       	push	r10
    12c0:	bf 92       	push	r11
    12c2:	cf 92       	push	r12
    12c4:	df 92       	push	r13
    12c6:	ff 92       	push	r15
    12c8:	0f 93       	push	r16
    12ca:	1f 93       	push	r17
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	ec 01       	movw	r28, r24
    12d2:	6b 01       	movw	r12, r22
    12d4:	5a 01       	movw	r10, r20
    12d6:	02 2f       	mov	r16, r18
    12d8:	0e 94 bf 05 	call	0xb7e	; 0xb7e <_portSetInterruptMaskFromIsr>
    12dc:	f8 2e       	mov	r15, r24
    12de:	9e 8d       	ldd	r25, Y+30	; 0x1e
    12e0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    12e2:	98 17       	cp	r25, r24
    12e4:	10 f0       	brcs	.+4      	; 0x12ea <xQueueGenericSendFromISR+0x2c>
    12e6:	02 30       	cpi	r16, 0x02	; 2
    12e8:	e1 f4       	brne	.+56     	; 0x1322 <xQueueGenericSendFromISR+0x64>
    12ea:	1a a1       	ldd	r17, Y+34	; 0x22
    12ec:	40 2f       	mov	r20, r16
    12ee:	b6 01       	movw	r22, r12
    12f0:	ce 01       	movw	r24, r28
    12f2:	0e 94 8e 07 	call	0xf1c	; 0xf1c <prvCopyDataToQueue>
    12f6:	1f 3f       	cpi	r17, 0xFF	; 255
    12f8:	81 f4       	brne	.+32     	; 0x131a <xQueueGenericSendFromISR+0x5c>
    12fa:	8b 89       	ldd	r24, Y+19	; 0x13
    12fc:	88 23       	and	r24, r24
    12fe:	99 f0       	breq	.+38     	; 0x1326 <xQueueGenericSendFromISR+0x68>
    1300:	ce 01       	movw	r24, r28
    1302:	43 96       	adiw	r24, 0x13	; 19
    1304:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <xTaskRemoveFromEventList>
    1308:	88 23       	and	r24, r24
    130a:	79 f0       	breq	.+30     	; 0x132a <xQueueGenericSendFromISR+0x6c>
    130c:	a1 14       	cp	r10, r1
    130e:	b1 04       	cpc	r11, r1
    1310:	71 f0       	breq	.+28     	; 0x132e <xQueueGenericSendFromISR+0x70>
    1312:	81 e0       	ldi	r24, 0x01	; 1
    1314:	f5 01       	movw	r30, r10
    1316:	80 83       	st	Z, r24
    1318:	0b c0       	rjmp	.+22     	; 0x1330 <xQueueGenericSendFromISR+0x72>
    131a:	1f 5f       	subi	r17, 0xFF	; 255
    131c:	1a a3       	std	Y+34, r17	; 0x22
    131e:	81 e0       	ldi	r24, 0x01	; 1
    1320:	07 c0       	rjmp	.+14     	; 0x1330 <xQueueGenericSendFromISR+0x72>
    1322:	80 e0       	ldi	r24, 0x00	; 0
    1324:	05 c0       	rjmp	.+10     	; 0x1330 <xQueueGenericSendFromISR+0x72>
    1326:	81 e0       	ldi	r24, 0x01	; 1
    1328:	03 c0       	rjmp	.+6      	; 0x1330 <xQueueGenericSendFromISR+0x72>
    132a:	81 e0       	ldi	r24, 0x01	; 1
    132c:	01 c0       	rjmp	.+2      	; 0x1330 <xQueueGenericSendFromISR+0x72>
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	f0 92 a2 00 	sts	0x00A2, r15	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1334:	df 91       	pop	r29
    1336:	cf 91       	pop	r28
    1338:	1f 91       	pop	r17
    133a:	0f 91       	pop	r16
    133c:	ff 90       	pop	r15
    133e:	df 90       	pop	r13
    1340:	cf 90       	pop	r12
    1342:	bf 90       	pop	r11
    1344:	af 90       	pop	r10
    1346:	08 95       	ret

00001348 <xQueueReceive>:
    1348:	af 92       	push	r10
    134a:	bf 92       	push	r11
    134c:	cf 92       	push	r12
    134e:	df 92       	push	r13
    1350:	ef 92       	push	r14
    1352:	ff 92       	push	r15
    1354:	0f 93       	push	r16
    1356:	1f 93       	push	r17
    1358:	cf 93       	push	r28
    135a:	df 93       	push	r29
    135c:	cd b7       	in	r28, 0x3d	; 61
    135e:	de b7       	in	r29, 0x3e	; 62
    1360:	29 97       	sbiw	r28, 0x09	; 9
    1362:	cd bf       	out	0x3d, r28	; 61
    1364:	de bf       	out	0x3e, r29	; 62
    1366:	8c 01       	movw	r16, r24
    1368:	5b 01       	movw	r10, r22
    136a:	2e 83       	std	Y+6, r18	; 0x06
    136c:	3f 83       	std	Y+7, r19	; 0x07
    136e:	48 87       	std	Y+8, r20	; 0x08
    1370:	59 87       	std	Y+9, r21	; 0x09
    1372:	e1 2c       	mov	r14, r1
    1374:	6c 01       	movw	r12, r24
    1376:	83 e1       	ldi	r24, 0x13	; 19
    1378:	c8 0e       	add	r12, r24
    137a:	d1 1c       	adc	r13, r1
    137c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1380:	ff 93       	push	r31
    1382:	f8 7f       	andi	r31, 0xF8	; 248
    1384:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1388:	f8 01       	movw	r30, r16
    138a:	f6 8c       	ldd	r15, Z+30	; 0x1e
    138c:	ff 20       	and	r15, r15
    138e:	b1 f0       	breq	.+44     	; 0x13bc <xQueueReceive+0x74>
    1390:	b5 01       	movw	r22, r10
    1392:	c8 01       	movw	r24, r16
    1394:	0e 94 d7 07 	call	0xfae	; 0xfae <prvCopyDataFromQueue>
    1398:	fa 94       	dec	r15
    139a:	f8 01       	movw	r30, r16
    139c:	f6 8e       	std	Z+30, r15	; 0x1e
    139e:	80 85       	ldd	r24, Z+8	; 0x08
    13a0:	88 23       	and	r24, r24
    13a2:	39 f0       	breq	.+14     	; 0x13b2 <xQueueReceive+0x6a>
    13a4:	c8 01       	movw	r24, r16
    13a6:	08 96       	adiw	r24, 0x08	; 8
    13a8:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <xTaskRemoveFromEventList>
    13ac:	81 11       	cpse	r24, r1
    13ae:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    13b2:	ff 91       	pop	r31
    13b4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	5e c0       	rjmp	.+188    	; 0x1478 <xQueueReceive+0x130>
    13bc:	8e 81       	ldd	r24, Y+6	; 0x06
    13be:	9f 81       	ldd	r25, Y+7	; 0x07
    13c0:	a8 85       	ldd	r26, Y+8	; 0x08
    13c2:	b9 85       	ldd	r27, Y+9	; 0x09
    13c4:	89 2b       	or	r24, r25
    13c6:	8a 2b       	or	r24, r26
    13c8:	8b 2b       	or	r24, r27
    13ca:	29 f4       	brne	.+10     	; 0x13d6 <xQueueReceive+0x8e>
    13cc:	ff 91       	pop	r31
    13ce:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	51 c0       	rjmp	.+162    	; 0x1478 <xQueueReceive+0x130>
    13d6:	e1 10       	cpse	r14, r1
    13d8:	06 c0       	rjmp	.+12     	; 0x13e6 <xQueueReceive+0x9e>
    13da:	ce 01       	movw	r24, r28
    13dc:	01 96       	adiw	r24, 0x01	; 1
    13de:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <vTaskInternalSetTimeOutState>
    13e2:	ee 24       	eor	r14, r14
    13e4:	e3 94       	inc	r14
    13e6:	ff 91       	pop	r31
    13e8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13ec:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskSuspendAll>
    13f0:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13f4:	ff 93       	push	r31
    13f6:	f8 7f       	andi	r31, 0xF8	; 248
    13f8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13fc:	f8 01       	movw	r30, r16
    13fe:	81 a1       	ldd	r24, Z+33	; 0x21
    1400:	8f 3f       	cpi	r24, 0xFF	; 255
    1402:	09 f4       	brne	.+2      	; 0x1406 <xQueueReceive+0xbe>
    1404:	11 a2       	std	Z+33, r1	; 0x21
    1406:	f8 01       	movw	r30, r16
    1408:	82 a1       	ldd	r24, Z+34	; 0x22
    140a:	8f 3f       	cpi	r24, 0xFF	; 255
    140c:	09 f4       	brne	.+2      	; 0x1410 <xQueueReceive+0xc8>
    140e:	12 a2       	std	Z+34, r1	; 0x22
    1410:	ff 91       	pop	r31
    1412:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1416:	be 01       	movw	r22, r28
    1418:	6a 5f       	subi	r22, 0xFA	; 250
    141a:	7f 4f       	sbci	r23, 0xFF	; 255
    141c:	ce 01       	movw	r24, r28
    141e:	01 96       	adiw	r24, 0x01	; 1
    1420:	0e 94 08 10 	call	0x2010	; 0x2010 <xTaskCheckForTimeOut>
    1424:	81 11       	cpse	r24, r1
    1426:	1c c0       	rjmp	.+56     	; 0x1460 <xQueueReceive+0x118>
    1428:	c8 01       	movw	r24, r16
    142a:	0e 94 6c 07 	call	0xed8	; 0xed8 <prvIsQueueEmpty>
    142e:	88 23       	and	r24, r24
    1430:	89 f0       	breq	.+34     	; 0x1454 <xQueueReceive+0x10c>
    1432:	4e 81       	ldd	r20, Y+6	; 0x06
    1434:	5f 81       	ldd	r21, Y+7	; 0x07
    1436:	68 85       	ldd	r22, Y+8	; 0x08
    1438:	79 85       	ldd	r23, Y+9	; 0x09
    143a:	c6 01       	movw	r24, r12
    143c:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vTaskPlaceOnEventList>
    1440:	c8 01       	movw	r24, r16
    1442:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <prvUnlockQueue>
    1446:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    144a:	81 11       	cpse	r24, r1
    144c:	97 cf       	rjmp	.-210    	; 0x137c <xQueueReceive+0x34>
    144e:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    1452:	94 cf       	rjmp	.-216    	; 0x137c <xQueueReceive+0x34>
    1454:	c8 01       	movw	r24, r16
    1456:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <prvUnlockQueue>
    145a:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    145e:	8e cf       	rjmp	.-228    	; 0x137c <xQueueReceive+0x34>
    1460:	c8 01       	movw	r24, r16
    1462:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <prvUnlockQueue>
    1466:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    146a:	c8 01       	movw	r24, r16
    146c:	0e 94 6c 07 	call	0xed8	; 0xed8 <prvIsQueueEmpty>
    1470:	88 23       	and	r24, r24
    1472:	09 f4       	brne	.+2      	; 0x1476 <xQueueReceive+0x12e>
    1474:	83 cf       	rjmp	.-250    	; 0x137c <xQueueReceive+0x34>
    1476:	80 e0       	ldi	r24, 0x00	; 0
    1478:	29 96       	adiw	r28, 0x09	; 9
    147a:	cd bf       	out	0x3d, r28	; 61
    147c:	de bf       	out	0x3e, r29	; 62
    147e:	df 91       	pop	r29
    1480:	cf 91       	pop	r28
    1482:	1f 91       	pop	r17
    1484:	0f 91       	pop	r16
    1486:	ff 90       	pop	r15
    1488:	ef 90       	pop	r14
    148a:	df 90       	pop	r13
    148c:	cf 90       	pop	r12
    148e:	bf 90       	pop	r11
    1490:	af 90       	pop	r10
    1492:	08 95       	ret

00001494 <xQueueSemaphoreTake>:
    1494:	df 92       	push	r13
    1496:	ef 92       	push	r14
    1498:	ff 92       	push	r15
    149a:	0f 93       	push	r16
    149c:	1f 93       	push	r17
    149e:	cf 93       	push	r28
    14a0:	df 93       	push	r29
    14a2:	cd b7       	in	r28, 0x3d	; 61
    14a4:	de b7       	in	r29, 0x3e	; 62
    14a6:	29 97       	sbiw	r28, 0x09	; 9
    14a8:	cd bf       	out	0x3d, r28	; 61
    14aa:	de bf       	out	0x3e, r29	; 62
    14ac:	8c 01       	movw	r16, r24
    14ae:	4e 83       	std	Y+6, r20	; 0x06
    14b0:	5f 83       	std	Y+7, r21	; 0x07
    14b2:	68 87       	std	Y+8, r22	; 0x08
    14b4:	79 87       	std	Y+9, r23	; 0x09
    14b6:	d1 2c       	mov	r13, r1
    14b8:	7c 01       	movw	r14, r24
    14ba:	83 e1       	ldi	r24, 0x13	; 19
    14bc:	e8 0e       	add	r14, r24
    14be:	f1 1c       	adc	r15, r1
    14c0:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    14c4:	ff 93       	push	r31
    14c6:	f8 7f       	andi	r31, 0xF8	; 248
    14c8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    14cc:	f8 01       	movw	r30, r16
    14ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    14d0:	88 23       	and	r24, r24
    14d2:	89 f0       	breq	.+34     	; 0x14f6 <xQueueSemaphoreTake+0x62>
    14d4:	81 50       	subi	r24, 0x01	; 1
    14d6:	86 8f       	std	Z+30, r24	; 0x1e
    14d8:	80 85       	ldd	r24, Z+8	; 0x08
    14da:	88 23       	and	r24, r24
    14dc:	39 f0       	breq	.+14     	; 0x14ec <xQueueSemaphoreTake+0x58>
    14de:	c8 01       	movw	r24, r16
    14e0:	08 96       	adiw	r24, 0x08	; 8
    14e2:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <xTaskRemoveFromEventList>
    14e6:	81 11       	cpse	r24, r1
    14e8:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    14ec:	ff 91       	pop	r31
    14ee:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    14f2:	81 e0       	ldi	r24, 0x01	; 1
    14f4:	5e c0       	rjmp	.+188    	; 0x15b2 <xQueueSemaphoreTake+0x11e>
    14f6:	8e 81       	ldd	r24, Y+6	; 0x06
    14f8:	9f 81       	ldd	r25, Y+7	; 0x07
    14fa:	a8 85       	ldd	r26, Y+8	; 0x08
    14fc:	b9 85       	ldd	r27, Y+9	; 0x09
    14fe:	89 2b       	or	r24, r25
    1500:	8a 2b       	or	r24, r26
    1502:	8b 2b       	or	r24, r27
    1504:	29 f4       	brne	.+10     	; 0x1510 <xQueueSemaphoreTake+0x7c>
    1506:	ff 91       	pop	r31
    1508:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    150c:	80 e0       	ldi	r24, 0x00	; 0
    150e:	51 c0       	rjmp	.+162    	; 0x15b2 <xQueueSemaphoreTake+0x11e>
    1510:	d1 10       	cpse	r13, r1
    1512:	06 c0       	rjmp	.+12     	; 0x1520 <xQueueSemaphoreTake+0x8c>
    1514:	ce 01       	movw	r24, r28
    1516:	01 96       	adiw	r24, 0x01	; 1
    1518:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <vTaskInternalSetTimeOutState>
    151c:	dd 24       	eor	r13, r13
    151e:	d3 94       	inc	r13
    1520:	ff 91       	pop	r31
    1522:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1526:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskSuspendAll>
    152a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    152e:	ff 93       	push	r31
    1530:	f8 7f       	andi	r31, 0xF8	; 248
    1532:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1536:	f8 01       	movw	r30, r16
    1538:	81 a1       	ldd	r24, Z+33	; 0x21
    153a:	8f 3f       	cpi	r24, 0xFF	; 255
    153c:	09 f4       	brne	.+2      	; 0x1540 <xQueueSemaphoreTake+0xac>
    153e:	11 a2       	std	Z+33, r1	; 0x21
    1540:	f8 01       	movw	r30, r16
    1542:	82 a1       	ldd	r24, Z+34	; 0x22
    1544:	8f 3f       	cpi	r24, 0xFF	; 255
    1546:	09 f4       	brne	.+2      	; 0x154a <xQueueSemaphoreTake+0xb6>
    1548:	12 a2       	std	Z+34, r1	; 0x22
    154a:	ff 91       	pop	r31
    154c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1550:	be 01       	movw	r22, r28
    1552:	6a 5f       	subi	r22, 0xFA	; 250
    1554:	7f 4f       	sbci	r23, 0xFF	; 255
    1556:	ce 01       	movw	r24, r28
    1558:	01 96       	adiw	r24, 0x01	; 1
    155a:	0e 94 08 10 	call	0x2010	; 0x2010 <xTaskCheckForTimeOut>
    155e:	81 11       	cpse	r24, r1
    1560:	1c c0       	rjmp	.+56     	; 0x159a <xQueueSemaphoreTake+0x106>
    1562:	c8 01       	movw	r24, r16
    1564:	0e 94 6c 07 	call	0xed8	; 0xed8 <prvIsQueueEmpty>
    1568:	88 23       	and	r24, r24
    156a:	89 f0       	breq	.+34     	; 0x158e <xQueueSemaphoreTake+0xfa>
    156c:	4e 81       	ldd	r20, Y+6	; 0x06
    156e:	5f 81       	ldd	r21, Y+7	; 0x07
    1570:	68 85       	ldd	r22, Y+8	; 0x08
    1572:	79 85       	ldd	r23, Y+9	; 0x09
    1574:	c7 01       	movw	r24, r14
    1576:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vTaskPlaceOnEventList>
    157a:	c8 01       	movw	r24, r16
    157c:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <prvUnlockQueue>
    1580:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    1584:	81 11       	cpse	r24, r1
    1586:	9c cf       	rjmp	.-200    	; 0x14c0 <xQueueSemaphoreTake+0x2c>
    1588:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    158c:	99 cf       	rjmp	.-206    	; 0x14c0 <xQueueSemaphoreTake+0x2c>
    158e:	c8 01       	movw	r24, r16
    1590:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <prvUnlockQueue>
    1594:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    1598:	93 cf       	rjmp	.-218    	; 0x14c0 <xQueueSemaphoreTake+0x2c>
    159a:	c8 01       	movw	r24, r16
    159c:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <prvUnlockQueue>
    15a0:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    15a4:	c8 01       	movw	r24, r16
    15a6:	0e 94 6c 07 	call	0xed8	; 0xed8 <prvIsQueueEmpty>
    15aa:	88 23       	and	r24, r24
    15ac:	09 f4       	brne	.+2      	; 0x15b0 <xQueueSemaphoreTake+0x11c>
    15ae:	88 cf       	rjmp	.-240    	; 0x14c0 <xQueueSemaphoreTake+0x2c>
    15b0:	80 e0       	ldi	r24, 0x00	; 0
    15b2:	29 96       	adiw	r28, 0x09	; 9
    15b4:	cd bf       	out	0x3d, r28	; 61
    15b6:	de bf       	out	0x3e, r29	; 62
    15b8:	df 91       	pop	r29
    15ba:	cf 91       	pop	r28
    15bc:	1f 91       	pop	r17
    15be:	0f 91       	pop	r16
    15c0:	ff 90       	pop	r15
    15c2:	ef 90       	pop	r14
    15c4:	df 90       	pop	r13
    15c6:	08 95       	ret

000015c8 <uxQueueMessagesWaiting>:
    15c8:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15cc:	ff 93       	push	r31
    15ce:	f8 7f       	andi	r31, 0xF8	; 248
    15d0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15d4:	fc 01       	movw	r30, r24
    15d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    15d8:	ff 91       	pop	r31
    15da:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15de:	08 95       	ret

000015e0 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    15e0:	cf 93       	push	r28
    15e2:	df 93       	push	r29
    15e4:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    15e6:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15ea:	ff 93       	push	r31
    15ec:	f8 7f       	andi	r31, 0xF8	; 248
    15ee:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15f2:	89 a1       	ldd	r24, Y+33	; 0x21
    15f4:	8f 3f       	cpi	r24, 0xFF	; 255
    15f6:	09 f4       	brne	.+2      	; 0x15fa <vQueueWaitForMessageRestricted+0x1a>
    15f8:	19 a2       	std	Y+33, r1	; 0x21
    15fa:	8a a1       	ldd	r24, Y+34	; 0x22
    15fc:	8f 3f       	cpi	r24, 0xFF	; 255
    15fe:	09 f4       	brne	.+2      	; 0x1602 <vQueueWaitForMessageRestricted+0x22>
    1600:	1a a2       	std	Y+34, r1	; 0x22
    1602:	ff 91       	pop	r31
    1604:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1608:	8e 8d       	ldd	r24, Y+30	; 0x1e
    160a:	81 11       	cpse	r24, r1
    160c:	04 c0       	rjmp	.+8      	; 0x1616 <vQueueWaitForMessageRestricted+0x36>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    160e:	ce 01       	movw	r24, r28
    1610:	43 96       	adiw	r24, 0x13	; 19
    1612:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1616:	ce 01       	movw	r24, r28
    1618:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <prvUnlockQueue>
	}
    161c:	df 91       	pop	r29
    161e:	cf 91       	pop	r28
    1620:	08 95       	ret

00001622 <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
    1622:	e0 91 82 2c 	lds	r30, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    1626:	f0 91 83 2c 	lds	r31, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    162a:	80 81       	ld	r24, Z
    162c:	81 11       	cpse	r24, r1
    162e:	0c c0       	rjmp	.+24     	; 0x1648 <prvResetNextTaskUnblockTime+0x26>
    1630:	8f ef       	ldi	r24, 0xFF	; 255
    1632:	9f ef       	ldi	r25, 0xFF	; 255
    1634:	dc 01       	movw	r26, r24
    1636:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <xNextTaskUnblockTime>
    163a:	90 93 5c 2c 	sts	0x2C5C, r25	; 0x802c5c <xNextTaskUnblockTime+0x1>
    163e:	a0 93 5d 2c 	sts	0x2C5D, r26	; 0x802c5d <xNextTaskUnblockTime+0x2>
    1642:	b0 93 5e 2c 	sts	0x2C5E, r27	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1646:	08 95       	ret
    1648:	e0 91 82 2c 	lds	r30, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    164c:	f0 91 83 2c 	lds	r31, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    1650:	07 80       	ldd	r0, Z+7	; 0x07
    1652:	f0 85       	ldd	r31, Z+8	; 0x08
    1654:	e0 2d       	mov	r30, r0
    1656:	00 84       	ldd	r0, Z+8	; 0x08
    1658:	f1 85       	ldd	r31, Z+9	; 0x09
    165a:	e0 2d       	mov	r30, r0
    165c:	82 81       	ldd	r24, Z+2	; 0x02
    165e:	93 81       	ldd	r25, Z+3	; 0x03
    1660:	a4 81       	ldd	r26, Z+4	; 0x04
    1662:	b5 81       	ldd	r27, Z+5	; 0x05
    1664:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <xNextTaskUnblockTime>
    1668:	90 93 5c 2c 	sts	0x2C5C, r25	; 0x802c5c <xNextTaskUnblockTime+0x1>
    166c:	a0 93 5d 2c 	sts	0x2C5D, r26	; 0x802c5d <xNextTaskUnblockTime+0x2>
    1670:	b0 93 5e 2c 	sts	0x2C5E, r27	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1674:	08 95       	ret

00001676 <prvAddCurrentTaskToDelayedList>:
    1676:	8f 92       	push	r8
    1678:	9f 92       	push	r9
    167a:	af 92       	push	r10
    167c:	bf 92       	push	r11
    167e:	cf 92       	push	r12
    1680:	df 92       	push	r13
    1682:	ef 92       	push	r14
    1684:	ff 92       	push	r15
    1686:	cf 93       	push	r28
    1688:	6b 01       	movw	r12, r22
    168a:	7c 01       	movw	r14, r24
    168c:	c4 2f       	mov	r28, r20
    168e:	80 90 65 2c 	lds	r8, 0x2C65	; 0x802c65 <xTickCount>
    1692:	90 90 66 2c 	lds	r9, 0x2C66	; 0x802c66 <xTickCount+0x1>
    1696:	a0 90 67 2c 	lds	r10, 0x2C67	; 0x802c67 <xTickCount+0x2>
    169a:	b0 90 68 2c 	lds	r11, 0x2C68	; 0x802c68 <xTickCount+0x3>
    169e:	80 91 c6 2c 	lds	r24, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    16a2:	90 91 c7 2c 	lds	r25, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    16a6:	02 96       	adiw	r24, 0x02	; 2
    16a8:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    16ac:	8f ef       	ldi	r24, 0xFF	; 255
    16ae:	c8 16       	cp	r12, r24
    16b0:	d8 06       	cpc	r13, r24
    16b2:	e8 06       	cpc	r14, r24
    16b4:	f8 06       	cpc	r15, r24
    16b6:	69 f4       	brne	.+26     	; 0x16d2 <prvAddCurrentTaskToDelayedList+0x5c>
    16b8:	cc 23       	and	r28, r28
    16ba:	59 f0       	breq	.+22     	; 0x16d2 <prvAddCurrentTaskToDelayedList+0x5c>
    16bc:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    16c0:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    16c4:	6e 5f       	subi	r22, 0xFE	; 254
    16c6:	7f 4f       	sbci	r23, 0xFF	; 255
    16c8:	8a e6       	ldi	r24, 0x6A	; 106
    16ca:	9c e2       	ldi	r25, 0x2C	; 44
    16cc:	0e 94 3a 05 	call	0xa74	; 0xa74 <vListInsertEnd>
    16d0:	3f c0       	rjmp	.+126    	; 0x1750 <prvAddCurrentTaskToDelayedList+0xda>
    16d2:	c8 0c       	add	r12, r8
    16d4:	d9 1c       	adc	r13, r9
    16d6:	ea 1c       	adc	r14, r10
    16d8:	fb 1c       	adc	r15, r11
    16da:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    16de:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    16e2:	c2 82       	std	Z+2, r12	; 0x02
    16e4:	d3 82       	std	Z+3, r13	; 0x03
    16e6:	e4 82       	std	Z+4, r14	; 0x04
    16e8:	f5 82       	std	Z+5, r15	; 0x05
    16ea:	c8 14       	cp	r12, r8
    16ec:	d9 04       	cpc	r13, r9
    16ee:	ea 04       	cpc	r14, r10
    16f0:	fb 04       	cpc	r15, r11
    16f2:	68 f4       	brcc	.+26     	; 0x170e <prvAddCurrentTaskToDelayedList+0x98>
    16f4:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    16f8:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    16fc:	80 91 80 2c 	lds	r24, 0x2C80	; 0x802c80 <pxOverflowDelayedTaskList>
    1700:	90 91 81 2c 	lds	r25, 0x2C81	; 0x802c81 <pxOverflowDelayedTaskList+0x1>
    1704:	6e 5f       	subi	r22, 0xFE	; 254
    1706:	7f 4f       	sbci	r23, 0xFF	; 255
    1708:	0e 94 5b 05 	call	0xab6	; 0xab6 <vListInsert>
    170c:	21 c0       	rjmp	.+66     	; 0x1750 <prvAddCurrentTaskToDelayedList+0xda>
    170e:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1712:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1716:	80 91 82 2c 	lds	r24, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    171a:	90 91 83 2c 	lds	r25, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    171e:	6e 5f       	subi	r22, 0xFE	; 254
    1720:	7f 4f       	sbci	r23, 0xFF	; 255
    1722:	0e 94 5b 05 	call	0xab6	; 0xab6 <vListInsert>
    1726:	80 91 5b 2c 	lds	r24, 0x2C5B	; 0x802c5b <xNextTaskUnblockTime>
    172a:	90 91 5c 2c 	lds	r25, 0x2C5C	; 0x802c5c <xNextTaskUnblockTime+0x1>
    172e:	a0 91 5d 2c 	lds	r26, 0x2C5D	; 0x802c5d <xNextTaskUnblockTime+0x2>
    1732:	b0 91 5e 2c 	lds	r27, 0x2C5E	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1736:	c8 16       	cp	r12, r24
    1738:	d9 06       	cpc	r13, r25
    173a:	ea 06       	cpc	r14, r26
    173c:	fb 06       	cpc	r15, r27
    173e:	40 f4       	brcc	.+16     	; 0x1750 <prvAddCurrentTaskToDelayedList+0xda>
    1740:	c0 92 5b 2c 	sts	0x2C5B, r12	; 0x802c5b <xNextTaskUnblockTime>
    1744:	d0 92 5c 2c 	sts	0x2C5C, r13	; 0x802c5c <xNextTaskUnblockTime+0x1>
    1748:	e0 92 5d 2c 	sts	0x2C5D, r14	; 0x802c5d <xNextTaskUnblockTime+0x2>
    174c:	f0 92 5e 2c 	sts	0x2C5E, r15	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1750:	cf 91       	pop	r28
    1752:	ff 90       	pop	r15
    1754:	ef 90       	pop	r14
    1756:	df 90       	pop	r13
    1758:	cf 90       	pop	r12
    175a:	bf 90       	pop	r11
    175c:	af 90       	pop	r10
    175e:	9f 90       	pop	r9
    1760:	8f 90       	pop	r8
    1762:	08 95       	ret

00001764 <prvIdleTask>:
    1764:	ca e9       	ldi	r28, 0x9A	; 154
    1766:	dc e2       	ldi	r29, 0x2C	; 44
    1768:	88 81       	ld	r24, Y
    176a:	82 30       	cpi	r24, 0x02	; 2
    176c:	10 f0       	brcs	.+4      	; 0x1772 <prvIdleTask+0xe>
    176e:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    1772:	0e 94 1e 14 	call	0x283c	; 0x283c <vApplicationIdleHook>
    1776:	f8 cf       	rjmp	.-16     	; 0x1768 <prvIdleTask+0x4>

00001778 <xTaskCreate>:
    1778:	4f 92       	push	r4
    177a:	5f 92       	push	r5
    177c:	6f 92       	push	r6
    177e:	7f 92       	push	r7
    1780:	8f 92       	push	r8
    1782:	9f 92       	push	r9
    1784:	af 92       	push	r10
    1786:	bf 92       	push	r11
    1788:	cf 92       	push	r12
    178a:	df 92       	push	r13
    178c:	ef 92       	push	r14
    178e:	ff 92       	push	r15
    1790:	0f 93       	push	r16
    1792:	cf 93       	push	r28
    1794:	df 93       	push	r29
    1796:	4c 01       	movw	r8, r24
    1798:	6b 01       	movw	r12, r22
    179a:	5a 01       	movw	r10, r20
    179c:	29 01       	movw	r4, r18
    179e:	ca 01       	movw	r24, r20
    17a0:	0e 94 fe 04 	call	0x9fc	; 0x9fc <pvPortMalloc>
    17a4:	3c 01       	movw	r6, r24
    17a6:	89 2b       	or	r24, r25
    17a8:	09 f4       	brne	.+2      	; 0x17ac <xTaskCreate+0x34>
    17aa:	ea c0       	rjmp	.+468    	; 0x1980 <xTaskCreate+0x208>
    17ac:	8c e2       	ldi	r24, 0x2C	; 44
    17ae:	90 e0       	ldi	r25, 0x00	; 0
    17b0:	0e 94 fe 04 	call	0x9fc	; 0x9fc <pvPortMalloc>
    17b4:	ec 01       	movw	r28, r24
    17b6:	89 2b       	or	r24, r25
    17b8:	b1 f0       	breq	.+44     	; 0x17e6 <xTaskCreate+0x6e>
    17ba:	6b 8e       	std	Y+27, r6	; 0x1b
    17bc:	7c 8e       	std	Y+28, r7	; 0x1c
    17be:	a5 01       	movw	r20, r10
    17c0:	65 ea       	ldi	r22, 0xA5	; 165
    17c2:	70 e0       	ldi	r23, 0x00	; 0
    17c4:	c3 01       	movw	r24, r6
    17c6:	0e 94 c8 20 	call	0x4190	; 0x4190 <memset>
    17ca:	21 e0       	ldi	r18, 0x01	; 1
    17cc:	a2 1a       	sub	r10, r18
    17ce:	b1 08       	sbc	r11, r1
    17d0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    17d2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    17d4:	a8 0e       	add	r10, r24
    17d6:	b9 1e       	adc	r11, r25
    17d8:	d6 01       	movw	r26, r12
    17da:	8c 91       	ld	r24, X
    17dc:	8d 8f       	std	Y+29, r24	; 0x1d
    17de:	8c 91       	ld	r24, X
    17e0:	81 11       	cpse	r24, r1
    17e2:	05 c0       	rjmp	.+10     	; 0x17ee <xTaskCreate+0x76>
    17e4:	18 c0       	rjmp	.+48     	; 0x1816 <xTaskCreate+0x9e>
    17e6:	c3 01       	movw	r24, r6
    17e8:	0e 94 24 05 	call	0xa48	; 0xa48 <vPortFree>
    17ec:	c9 c0       	rjmp	.+402    	; 0x1980 <xTaskCreate+0x208>
    17ee:	ae 01       	movw	r20, r28
    17f0:	42 5e       	subi	r20, 0xE2	; 226
    17f2:	5f 4f       	sbci	r21, 0xFF	; 255
    17f4:	f6 01       	movw	r30, r12
    17f6:	31 96       	adiw	r30, 0x01	; 1
    17f8:	b8 e0       	ldi	r27, 0x08	; 8
    17fa:	cb 0e       	add	r12, r27
    17fc:	d1 1c       	adc	r13, r1
    17fe:	cf 01       	movw	r24, r30
    1800:	21 91       	ld	r18, Z+
    1802:	da 01       	movw	r26, r20
    1804:	2d 93       	st	X+, r18
    1806:	ad 01       	movw	r20, r26
    1808:	dc 01       	movw	r26, r24
    180a:	8c 91       	ld	r24, X
    180c:	88 23       	and	r24, r24
    180e:	19 f0       	breq	.+6      	; 0x1816 <xTaskCreate+0x9e>
    1810:	ec 15       	cp	r30, r12
    1812:	fd 05       	cpc	r31, r13
    1814:	a1 f7       	brne	.-24     	; 0x17fe <xTaskCreate+0x86>
    1816:	1c a2       	std	Y+36, r1	; 0x24
    1818:	04 30       	cpi	r16, 0x04	; 4
    181a:	08 f0       	brcs	.+2      	; 0x181e <xTaskCreate+0xa6>
    181c:	03 e0       	ldi	r16, 0x03	; 3
    181e:	0a 8f       	std	Y+26, r16	; 0x1a
    1820:	6e 01       	movw	r12, r28
    1822:	b2 e0       	ldi	r27, 0x02	; 2
    1824:	cb 0e       	add	r12, r27
    1826:	d1 1c       	adc	r13, r1
    1828:	c6 01       	movw	r24, r12
    182a:	0e 94 36 05 	call	0xa6c	; 0xa6c <vListInitialiseItem>
    182e:	ce 01       	movw	r24, r28
    1830:	0e 96       	adiw	r24, 0x0e	; 14
    1832:	0e 94 36 05 	call	0xa6c	; 0xa6c <vListInitialiseItem>
    1836:	ca 87       	std	Y+10, r28	; 0x0a
    1838:	db 87       	std	Y+11, r29	; 0x0b
    183a:	84 e0       	ldi	r24, 0x04	; 4
    183c:	90 e0       	ldi	r25, 0x00	; 0
    183e:	a0 e0       	ldi	r26, 0x00	; 0
    1840:	b0 e0       	ldi	r27, 0x00	; 0
    1842:	80 1b       	sub	r24, r16
    1844:	91 09       	sbc	r25, r1
    1846:	a1 09       	sbc	r26, r1
    1848:	b1 09       	sbc	r27, r1
    184a:	8e 87       	std	Y+14, r24	; 0x0e
    184c:	9f 87       	std	Y+15, r25	; 0x0f
    184e:	a8 8b       	std	Y+16, r26	; 0x10
    1850:	b9 8b       	std	Y+17, r27	; 0x11
    1852:	ce 8b       	std	Y+22, r28	; 0x16
    1854:	df 8b       	std	Y+23, r29	; 0x17
    1856:	1f a2       	std	Y+39, r1	; 0x27
    1858:	18 a6       	std	Y+40, r1	; 0x28
    185a:	19 a6       	std	Y+41, r1	; 0x29
    185c:	1a a6       	std	Y+42, r1	; 0x2a
    185e:	1b a6       	std	Y+43, r1	; 0x2b
    1860:	a2 01       	movw	r20, r4
    1862:	b4 01       	movw	r22, r8
    1864:	c5 01       	movw	r24, r10
    1866:	0e 94 c6 05 	call	0xb8c	; 0xb8c <pxPortInitialiseStack>
    186a:	88 83       	st	Y, r24
    186c:	99 83       	std	Y+1, r25	; 0x01
    186e:	e1 14       	cp	r14, r1
    1870:	f1 04       	cpc	r15, r1
    1872:	19 f0       	breq	.+6      	; 0x187a <xTaskCreate+0x102>
    1874:	f7 01       	movw	r30, r14
    1876:	c0 83       	st	Z, r28
    1878:	d1 83       	std	Z+1, r29	; 0x01
    187a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    187e:	ff 93       	push	r31
    1880:	f8 7f       	andi	r31, 0xF8	; 248
    1882:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1886:	80 91 69 2c 	lds	r24, 0x2C69	; 0x802c69 <uxCurrentNumberOfTasks>
    188a:	8f 5f       	subi	r24, 0xFF	; 255
    188c:	80 93 69 2c 	sts	0x2C69, r24	; 0x802c69 <uxCurrentNumberOfTasks>
    1890:	80 91 c6 2c 	lds	r24, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1894:	90 91 c7 2c 	lds	r25, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1898:	89 2b       	or	r24, r25
    189a:	a9 f5       	brne	.+106    	; 0x1906 <xTaskCreate+0x18e>
    189c:	c0 93 c6 2c 	sts	0x2CC6, r28	; 0x802cc6 <pxCurrentTCB>
    18a0:	d0 93 c7 2c 	sts	0x2CC7, r29	; 0x802cc7 <pxCurrentTCB+0x1>
    18a4:	80 91 69 2c 	lds	r24, 0x2C69	; 0x802c69 <uxCurrentNumberOfTasks>
    18a8:	81 30       	cpi	r24, 0x01	; 1
    18aa:	e9 f5       	brne	.+122    	; 0x1926 <xTaskCreate+0x1ae>
    18ac:	8a e9       	ldi	r24, 0x9A	; 154
    18ae:	9c e2       	ldi	r25, 0x2C	; 44
    18b0:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    18b4:	85 ea       	ldi	r24, 0xA5	; 165
    18b6:	9c e2       	ldi	r25, 0x2C	; 44
    18b8:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    18bc:	80 eb       	ldi	r24, 0xB0	; 176
    18be:	9c e2       	ldi	r25, 0x2C	; 44
    18c0:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    18c4:	8b eb       	ldi	r24, 0xBB	; 187
    18c6:	9c e2       	ldi	r25, 0x2C	; 44
    18c8:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    18cc:	8f e8       	ldi	r24, 0x8F	; 143
    18ce:	9c e2       	ldi	r25, 0x2C	; 44
    18d0:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    18d4:	84 e8       	ldi	r24, 0x84	; 132
    18d6:	9c e2       	ldi	r25, 0x2C	; 44
    18d8:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    18dc:	85 e7       	ldi	r24, 0x75	; 117
    18de:	9c e2       	ldi	r25, 0x2C	; 44
    18e0:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    18e4:	8a e6       	ldi	r24, 0x6A	; 106
    18e6:	9c e2       	ldi	r25, 0x2C	; 44
    18e8:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    18ec:	8f e8       	ldi	r24, 0x8F	; 143
    18ee:	9c e2       	ldi	r25, 0x2C	; 44
    18f0:	80 93 82 2c 	sts	0x2C82, r24	; 0x802c82 <pxDelayedTaskList>
    18f4:	90 93 83 2c 	sts	0x2C83, r25	; 0x802c83 <pxDelayedTaskList+0x1>
    18f8:	84 e8       	ldi	r24, 0x84	; 132
    18fa:	9c e2       	ldi	r25, 0x2C	; 44
    18fc:	80 93 80 2c 	sts	0x2C80, r24	; 0x802c80 <pxOverflowDelayedTaskList>
    1900:	90 93 81 2c 	sts	0x2C81, r25	; 0x802c81 <pxOverflowDelayedTaskList+0x1>
    1904:	10 c0       	rjmp	.+32     	; 0x1926 <xTaskCreate+0x1ae>
    1906:	80 91 63 2c 	lds	r24, 0x2C63	; 0x802c63 <xSchedulerRunning>
    190a:	81 11       	cpse	r24, r1
    190c:	0c c0       	rjmp	.+24     	; 0x1926 <xTaskCreate+0x1ae>
    190e:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1912:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1916:	92 8d       	ldd	r25, Z+26	; 0x1a
    1918:	8a 8d       	ldd	r24, Y+26	; 0x1a
    191a:	89 17       	cp	r24, r25
    191c:	20 f0       	brcs	.+8      	; 0x1926 <xTaskCreate+0x1ae>
    191e:	c0 93 c6 2c 	sts	0x2CC6, r28	; 0x802cc6 <pxCurrentTCB>
    1922:	d0 93 c7 2c 	sts	0x2CC7, r29	; 0x802cc7 <pxCurrentTCB+0x1>
    1926:	80 91 5f 2c 	lds	r24, 0x2C5F	; 0x802c5f <uxTaskNumber>
    192a:	8f 5f       	subi	r24, 0xFF	; 255
    192c:	80 93 5f 2c 	sts	0x2C5F, r24	; 0x802c5f <uxTaskNumber>
    1930:	8d a3       	std	Y+37, r24	; 0x25
    1932:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1934:	90 91 64 2c 	lds	r25, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    1938:	98 17       	cp	r25, r24
    193a:	10 f4       	brcc	.+4      	; 0x1940 <xTaskCreate+0x1c8>
    193c:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    1940:	fb e0       	ldi	r31, 0x0B	; 11
    1942:	8f 9f       	mul	r24, r31
    1944:	c0 01       	movw	r24, r0
    1946:	11 24       	eor	r1, r1
    1948:	b6 01       	movw	r22, r12
    194a:	86 56       	subi	r24, 0x66	; 102
    194c:	93 4d       	sbci	r25, 0xD3	; 211
    194e:	0e 94 3a 05 	call	0xa74	; 0xa74 <vListInsertEnd>
    1952:	ff 91       	pop	r31
    1954:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1958:	80 91 63 2c 	lds	r24, 0x2C63	; 0x802c63 <xSchedulerRunning>
    195c:	88 23       	and	r24, r24
    195e:	61 f0       	breq	.+24     	; 0x1978 <xTaskCreate+0x200>
    1960:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1964:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1968:	92 8d       	ldd	r25, Z+26	; 0x1a
    196a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    196c:	98 17       	cp	r25, r24
    196e:	30 f4       	brcc	.+12     	; 0x197c <xTaskCreate+0x204>
    1970:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	05 c0       	rjmp	.+10     	; 0x1982 <xTaskCreate+0x20a>
    1978:	81 e0       	ldi	r24, 0x01	; 1
    197a:	03 c0       	rjmp	.+6      	; 0x1982 <xTaskCreate+0x20a>
    197c:	81 e0       	ldi	r24, 0x01	; 1
    197e:	01 c0       	rjmp	.+2      	; 0x1982 <xTaskCreate+0x20a>
    1980:	8f ef       	ldi	r24, 0xFF	; 255
    1982:	df 91       	pop	r29
    1984:	cf 91       	pop	r28
    1986:	0f 91       	pop	r16
    1988:	ff 90       	pop	r15
    198a:	ef 90       	pop	r14
    198c:	df 90       	pop	r13
    198e:	cf 90       	pop	r12
    1990:	bf 90       	pop	r11
    1992:	af 90       	pop	r10
    1994:	9f 90       	pop	r9
    1996:	8f 90       	pop	r8
    1998:	7f 90       	pop	r7
    199a:	6f 90       	pop	r6
    199c:	5f 90       	pop	r5
    199e:	4f 90       	pop	r4
    19a0:	08 95       	ret

000019a2 <vTaskStartScheduler>:
    19a2:	ef 92       	push	r14
    19a4:	ff 92       	push	r15
    19a6:	0f 93       	push	r16
    19a8:	0f 2e       	mov	r0, r31
    19aa:	f9 e5       	ldi	r31, 0x59	; 89
    19ac:	ef 2e       	mov	r14, r31
    19ae:	fc e2       	ldi	r31, 0x2C	; 44
    19b0:	ff 2e       	mov	r15, r31
    19b2:	f0 2d       	mov	r31, r0
    19b4:	00 e0       	ldi	r16, 0x00	; 0
    19b6:	20 e0       	ldi	r18, 0x00	; 0
    19b8:	30 e0       	ldi	r19, 0x00	; 0
    19ba:	48 ec       	ldi	r20, 0xC8	; 200
    19bc:	50 e0       	ldi	r21, 0x00	; 0
    19be:	61 e0       	ldi	r22, 0x01	; 1
    19c0:	70 e2       	ldi	r23, 0x20	; 32
    19c2:	82 eb       	ldi	r24, 0xB2	; 178
    19c4:	9b e0       	ldi	r25, 0x0B	; 11
    19c6:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskCreate>
    19ca:	81 30       	cpi	r24, 0x01	; 1
    19cc:	09 f5       	brne	.+66     	; 0x1a10 <vTaskStartScheduler+0x6e>
    19ce:	0e 94 16 11 	call	0x222c	; 0x222c <xTimerCreateTimerTask>
    19d2:	81 30       	cpi	r24, 0x01	; 1
    19d4:	e9 f4       	brne	.+58     	; 0x1a10 <vTaskStartScheduler+0x6e>
    19d6:	e0 ea       	ldi	r30, 0xA0	; 160
    19d8:	f0 e0       	ldi	r31, 0x00	; 0
    19da:	82 81       	ldd	r24, Z+2	; 0x02
    19dc:	88 7f       	andi	r24, 0xF8	; 248
    19de:	82 83       	std	Z+2, r24	; 0x02
    19e0:	8f ef       	ldi	r24, 0xFF	; 255
    19e2:	9f ef       	ldi	r25, 0xFF	; 255
    19e4:	dc 01       	movw	r26, r24
    19e6:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <xNextTaskUnblockTime>
    19ea:	90 93 5c 2c 	sts	0x2C5C, r25	; 0x802c5c <xNextTaskUnblockTime+0x1>
    19ee:	a0 93 5d 2c 	sts	0x2C5D, r26	; 0x802c5d <xNextTaskUnblockTime+0x2>
    19f2:	b0 93 5e 2c 	sts	0x2C5E, r27	; 0x802c5e <xNextTaskUnblockTime+0x3>
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	80 93 63 2c 	sts	0x2C63, r24	; 0x802c63 <xSchedulerRunning>
    19fc:	10 92 65 2c 	sts	0x2C65, r1	; 0x802c65 <xTickCount>
    1a00:	10 92 66 2c 	sts	0x2C66, r1	; 0x802c66 <xTickCount+0x1>
    1a04:	10 92 67 2c 	sts	0x2C67, r1	; 0x802c67 <xTickCount+0x2>
    1a08:	10 92 68 2c 	sts	0x2C68, r1	; 0x802c68 <xTickCount+0x3>
    1a0c:	0e 94 43 06 	call	0xc86	; 0xc86 <xPortStartScheduler>
    1a10:	0f 91       	pop	r16
    1a12:	ff 90       	pop	r15
    1a14:	ef 90       	pop	r14
    1a16:	08 95       	ret

00001a18 <vTaskSuspendAll>:
    1a18:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    1a1c:	8f 5f       	subi	r24, 0xFF	; 255
    1a1e:	80 93 58 2c 	sts	0x2C58, r24	; 0x802c58 <uxSchedulerSuspended>
    1a22:	08 95       	ret

00001a24 <xTaskGetTickCount>:
    1a24:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1a28:	ff 93       	push	r31
    1a2a:	f8 7f       	andi	r31, 0xF8	; 248
    1a2c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1a30:	60 91 65 2c 	lds	r22, 0x2C65	; 0x802c65 <xTickCount>
    1a34:	70 91 66 2c 	lds	r23, 0x2C66	; 0x802c66 <xTickCount+0x1>
    1a38:	80 91 67 2c 	lds	r24, 0x2C67	; 0x802c67 <xTickCount+0x2>
    1a3c:	90 91 68 2c 	lds	r25, 0x2C68	; 0x802c68 <xTickCount+0x3>
    1a40:	ff 91       	pop	r31
    1a42:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1a46:	08 95       	ret

00001a48 <xTaskIncrementTick>:
    1a48:	af 92       	push	r10
    1a4a:	bf 92       	push	r11
    1a4c:	cf 92       	push	r12
    1a4e:	df 92       	push	r13
    1a50:	ef 92       	push	r14
    1a52:	ff 92       	push	r15
    1a54:	0f 93       	push	r16
    1a56:	1f 93       	push	r17
    1a58:	cf 93       	push	r28
    1a5a:	df 93       	push	r29
    1a5c:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    1a60:	81 11       	cpse	r24, r1
    1a62:	ad c0       	rjmp	.+346    	; 0x1bbe <xTaskIncrementTick+0x176>
    1a64:	c0 90 65 2c 	lds	r12, 0x2C65	; 0x802c65 <xTickCount>
    1a68:	d0 90 66 2c 	lds	r13, 0x2C66	; 0x802c66 <xTickCount+0x1>
    1a6c:	e0 90 67 2c 	lds	r14, 0x2C67	; 0x802c67 <xTickCount+0x2>
    1a70:	f0 90 68 2c 	lds	r15, 0x2C68	; 0x802c68 <xTickCount+0x3>
    1a74:	8f ef       	ldi	r24, 0xFF	; 255
    1a76:	c8 1a       	sub	r12, r24
    1a78:	d8 0a       	sbc	r13, r24
    1a7a:	e8 0a       	sbc	r14, r24
    1a7c:	f8 0a       	sbc	r15, r24
    1a7e:	c0 92 65 2c 	sts	0x2C65, r12	; 0x802c65 <xTickCount>
    1a82:	d0 92 66 2c 	sts	0x2C66, r13	; 0x802c66 <xTickCount+0x1>
    1a86:	e0 92 67 2c 	sts	0x2C67, r14	; 0x802c67 <xTickCount+0x2>
    1a8a:	f0 92 68 2c 	sts	0x2C68, r15	; 0x802c68 <xTickCount+0x3>
    1a8e:	c1 14       	cp	r12, r1
    1a90:	d1 04       	cpc	r13, r1
    1a92:	e1 04       	cpc	r14, r1
    1a94:	f1 04       	cpc	r15, r1
    1a96:	b9 f4       	brne	.+46     	; 0x1ac6 <xTaskIncrementTick+0x7e>
    1a98:	80 91 82 2c 	lds	r24, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    1a9c:	90 91 83 2c 	lds	r25, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    1aa0:	20 91 80 2c 	lds	r18, 0x2C80	; 0x802c80 <pxOverflowDelayedTaskList>
    1aa4:	30 91 81 2c 	lds	r19, 0x2C81	; 0x802c81 <pxOverflowDelayedTaskList+0x1>
    1aa8:	20 93 82 2c 	sts	0x2C82, r18	; 0x802c82 <pxDelayedTaskList>
    1aac:	30 93 83 2c 	sts	0x2C83, r19	; 0x802c83 <pxDelayedTaskList+0x1>
    1ab0:	80 93 80 2c 	sts	0x2C80, r24	; 0x802c80 <pxOverflowDelayedTaskList>
    1ab4:	90 93 81 2c 	sts	0x2C81, r25	; 0x802c81 <pxOverflowDelayedTaskList+0x1>
    1ab8:	80 91 60 2c 	lds	r24, 0x2C60	; 0x802c60 <xNumOfOverflows>
    1abc:	8f 5f       	subi	r24, 0xFF	; 255
    1abe:	80 93 60 2c 	sts	0x2C60, r24	; 0x802c60 <xNumOfOverflows>
    1ac2:	0e 94 11 0b 	call	0x1622	; 0x1622 <prvResetNextTaskUnblockTime>
    1ac6:	80 91 5b 2c 	lds	r24, 0x2C5B	; 0x802c5b <xNextTaskUnblockTime>
    1aca:	90 91 5c 2c 	lds	r25, 0x2C5C	; 0x802c5c <xNextTaskUnblockTime+0x1>
    1ace:	a0 91 5d 2c 	lds	r26, 0x2C5D	; 0x802c5d <xNextTaskUnblockTime+0x2>
    1ad2:	b0 91 5e 2c 	lds	r27, 0x2C5E	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1ad6:	c8 16       	cp	r12, r24
    1ad8:	d9 06       	cpc	r13, r25
    1ada:	ea 06       	cpc	r14, r26
    1adc:	fb 06       	cpc	r15, r27
    1ade:	10 f4       	brcc	.+4      	; 0x1ae4 <xTaskIncrementTick+0x9c>
    1ae0:	b1 2c       	mov	r11, r1
    1ae2:	5c c0       	rjmp	.+184    	; 0x1b9c <xTaskIncrementTick+0x154>
    1ae4:	b1 2c       	mov	r11, r1
    1ae6:	0f 2e       	mov	r0, r31
    1ae8:	fb e0       	ldi	r31, 0x0B	; 11
    1aea:	af 2e       	mov	r10, r31
    1aec:	f0 2d       	mov	r31, r0
    1aee:	e0 91 82 2c 	lds	r30, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    1af2:	f0 91 83 2c 	lds	r31, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    1af6:	80 81       	ld	r24, Z
    1af8:	81 11       	cpse	r24, r1
    1afa:	0c c0       	rjmp	.+24     	; 0x1b14 <xTaskIncrementTick+0xcc>
    1afc:	8f ef       	ldi	r24, 0xFF	; 255
    1afe:	9f ef       	ldi	r25, 0xFF	; 255
    1b00:	dc 01       	movw	r26, r24
    1b02:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <xNextTaskUnblockTime>
    1b06:	90 93 5c 2c 	sts	0x2C5C, r25	; 0x802c5c <xNextTaskUnblockTime+0x1>
    1b0a:	a0 93 5d 2c 	sts	0x2C5D, r26	; 0x802c5d <xNextTaskUnblockTime+0x2>
    1b0e:	b0 93 5e 2c 	sts	0x2C5E, r27	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1b12:	44 c0       	rjmp	.+136    	; 0x1b9c <xTaskIncrementTick+0x154>
    1b14:	e0 91 82 2c 	lds	r30, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    1b18:	f0 91 83 2c 	lds	r31, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    1b1c:	07 80       	ldd	r0, Z+7	; 0x07
    1b1e:	f0 85       	ldd	r31, Z+8	; 0x08
    1b20:	e0 2d       	mov	r30, r0
    1b22:	c0 85       	ldd	r28, Z+8	; 0x08
    1b24:	d1 85       	ldd	r29, Z+9	; 0x09
    1b26:	8a 81       	ldd	r24, Y+2	; 0x02
    1b28:	9b 81       	ldd	r25, Y+3	; 0x03
    1b2a:	ac 81       	ldd	r26, Y+4	; 0x04
    1b2c:	bd 81       	ldd	r27, Y+5	; 0x05
    1b2e:	c8 16       	cp	r12, r24
    1b30:	d9 06       	cpc	r13, r25
    1b32:	ea 06       	cpc	r14, r26
    1b34:	fb 06       	cpc	r15, r27
    1b36:	48 f4       	brcc	.+18     	; 0x1b4a <xTaskIncrementTick+0x102>
    1b38:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <xNextTaskUnblockTime>
    1b3c:	90 93 5c 2c 	sts	0x2C5C, r25	; 0x802c5c <xNextTaskUnblockTime+0x1>
    1b40:	a0 93 5d 2c 	sts	0x2C5D, r26	; 0x802c5d <xNextTaskUnblockTime+0x2>
    1b44:	b0 93 5e 2c 	sts	0x2C5E, r27	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1b48:	29 c0       	rjmp	.+82     	; 0x1b9c <xTaskIncrementTick+0x154>
    1b4a:	8e 01       	movw	r16, r28
    1b4c:	0e 5f       	subi	r16, 0xFE	; 254
    1b4e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b50:	c8 01       	movw	r24, r16
    1b52:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    1b56:	88 8d       	ldd	r24, Y+24	; 0x18
    1b58:	99 8d       	ldd	r25, Y+25	; 0x19
    1b5a:	89 2b       	or	r24, r25
    1b5c:	21 f0       	breq	.+8      	; 0x1b66 <xTaskIncrementTick+0x11e>
    1b5e:	ce 01       	movw	r24, r28
    1b60:	0e 96       	adiw	r24, 0x0e	; 14
    1b62:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    1b66:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b68:	90 91 64 2c 	lds	r25, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    1b6c:	98 17       	cp	r25, r24
    1b6e:	10 f4       	brcc	.+4      	; 0x1b74 <xTaskIncrementTick+0x12c>
    1b70:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    1b74:	a8 9e       	mul	r10, r24
    1b76:	c0 01       	movw	r24, r0
    1b78:	11 24       	eor	r1, r1
    1b7a:	b8 01       	movw	r22, r16
    1b7c:	86 56       	subi	r24, 0x66	; 102
    1b7e:	93 4d       	sbci	r25, 0xD3	; 211
    1b80:	0e 94 3a 05 	call	0xa74	; 0xa74 <vListInsertEnd>
    1b84:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1b88:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1b8c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b8e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b90:	98 17       	cp	r25, r24
    1b92:	08 f4       	brcc	.+2      	; 0x1b96 <xTaskIncrementTick+0x14e>
    1b94:	ac cf       	rjmp	.-168    	; 0x1aee <xTaskIncrementTick+0xa6>
    1b96:	bb 24       	eor	r11, r11
    1b98:	b3 94       	inc	r11
    1b9a:	a9 cf       	rjmp	.-174    	; 0x1aee <xTaskIncrementTick+0xa6>
    1b9c:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1ba0:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1ba4:	e2 8d       	ldd	r30, Z+26	; 0x1a
    1ba6:	8b e0       	ldi	r24, 0x0B	; 11
    1ba8:	e8 9f       	mul	r30, r24
    1baa:	f0 01       	movw	r30, r0
    1bac:	11 24       	eor	r1, r1
    1bae:	e6 56       	subi	r30, 0x66	; 102
    1bb0:	f3 4d       	sbci	r31, 0xD3	; 211
    1bb2:	80 81       	ld	r24, Z
    1bb4:	82 30       	cpi	r24, 0x02	; 2
    1bb6:	48 f0       	brcs	.+18     	; 0x1bca <xTaskIncrementTick+0x182>
    1bb8:	bb 24       	eor	r11, r11
    1bba:	b3 94       	inc	r11
    1bbc:	06 c0       	rjmp	.+12     	; 0x1bca <xTaskIncrementTick+0x182>
    1bbe:	80 91 62 2c 	lds	r24, 0x2C62	; 0x802c62 <uxPendedTicks>
    1bc2:	8f 5f       	subi	r24, 0xFF	; 255
    1bc4:	80 93 62 2c 	sts	0x2C62, r24	; 0x802c62 <uxPendedTicks>
    1bc8:	b1 2c       	mov	r11, r1
    1bca:	80 91 61 2c 	lds	r24, 0x2C61	; 0x802c61 <xYieldPending>
    1bce:	88 23       	and	r24, r24
    1bd0:	11 f0       	breq	.+4      	; 0x1bd6 <xTaskIncrementTick+0x18e>
    1bd2:	bb 24       	eor	r11, r11
    1bd4:	b3 94       	inc	r11
    1bd6:	8b 2d       	mov	r24, r11
    1bd8:	df 91       	pop	r29
    1bda:	cf 91       	pop	r28
    1bdc:	1f 91       	pop	r17
    1bde:	0f 91       	pop	r16
    1be0:	ff 90       	pop	r15
    1be2:	ef 90       	pop	r14
    1be4:	df 90       	pop	r13
    1be6:	cf 90       	pop	r12
    1be8:	bf 90       	pop	r11
    1bea:	af 90       	pop	r10
    1bec:	08 95       	ret

00001bee <xTaskResumeAll>:
    1bee:	cf 92       	push	r12
    1bf0:	df 92       	push	r13
    1bf2:	ef 92       	push	r14
    1bf4:	ff 92       	push	r15
    1bf6:	0f 93       	push	r16
    1bf8:	1f 93       	push	r17
    1bfa:	cf 93       	push	r28
    1bfc:	df 93       	push	r29
    1bfe:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1c02:	ff 93       	push	r31
    1c04:	f8 7f       	andi	r31, 0xF8	; 248
    1c06:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1c0a:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    1c0e:	81 50       	subi	r24, 0x01	; 1
    1c10:	80 93 58 2c 	sts	0x2C58, r24	; 0x802c58 <uxSchedulerSuspended>
    1c14:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    1c18:	81 11       	cpse	r24, r1
    1c1a:	5c c0       	rjmp	.+184    	; 0x1cd4 <xTaskResumeAll+0xe6>
    1c1c:	80 91 69 2c 	lds	r24, 0x2C69	; 0x802c69 <uxCurrentNumberOfTasks>
    1c20:	81 11       	cpse	r24, r1
    1c22:	2c c0       	rjmp	.+88     	; 0x1c7c <xTaskResumeAll+0x8e>
    1c24:	5a c0       	rjmp	.+180    	; 0x1cda <xTaskResumeAll+0xec>
    1c26:	d7 01       	movw	r26, r14
    1c28:	17 96       	adiw	r26, 0x07	; 7
    1c2a:	ed 91       	ld	r30, X+
    1c2c:	fc 91       	ld	r31, X
    1c2e:	18 97       	sbiw	r26, 0x08	; 8
    1c30:	c0 85       	ldd	r28, Z+8	; 0x08
    1c32:	d1 85       	ldd	r29, Z+9	; 0x09
    1c34:	ce 01       	movw	r24, r28
    1c36:	0e 96       	adiw	r24, 0x0e	; 14
    1c38:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    1c3c:	8e 01       	movw	r16, r28
    1c3e:	0e 5f       	subi	r16, 0xFE	; 254
    1c40:	1f 4f       	sbci	r17, 0xFF	; 255
    1c42:	c8 01       	movw	r24, r16
    1c44:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    1c48:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c4a:	90 91 64 2c 	lds	r25, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    1c4e:	98 17       	cp	r25, r24
    1c50:	10 f4       	brcc	.+4      	; 0x1c56 <xTaskResumeAll+0x68>
    1c52:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    1c56:	d8 9e       	mul	r13, r24
    1c58:	c0 01       	movw	r24, r0
    1c5a:	11 24       	eor	r1, r1
    1c5c:	b8 01       	movw	r22, r16
    1c5e:	86 56       	subi	r24, 0x66	; 102
    1c60:	93 4d       	sbci	r25, 0xD3	; 211
    1c62:	0e 94 3a 05 	call	0xa74	; 0xa74 <vListInsertEnd>
    1c66:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1c6a:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1c6e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c70:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c72:	98 17       	cp	r25, r24
    1c74:	88 f0       	brcs	.+34     	; 0x1c98 <xTaskResumeAll+0xaa>
    1c76:	c0 92 61 2c 	sts	0x2C61, r12	; 0x802c61 <xYieldPending>
    1c7a:	0e c0       	rjmp	.+28     	; 0x1c98 <xTaskResumeAll+0xaa>
    1c7c:	c0 e0       	ldi	r28, 0x00	; 0
    1c7e:	d0 e0       	ldi	r29, 0x00	; 0
    1c80:	0f 2e       	mov	r0, r31
    1c82:	f5 e7       	ldi	r31, 0x75	; 117
    1c84:	ef 2e       	mov	r14, r31
    1c86:	fc e2       	ldi	r31, 0x2C	; 44
    1c88:	ff 2e       	mov	r15, r31
    1c8a:	f0 2d       	mov	r31, r0
    1c8c:	0f 2e       	mov	r0, r31
    1c8e:	fb e0       	ldi	r31, 0x0B	; 11
    1c90:	df 2e       	mov	r13, r31
    1c92:	f0 2d       	mov	r31, r0
    1c94:	cc 24       	eor	r12, r12
    1c96:	c3 94       	inc	r12
    1c98:	f7 01       	movw	r30, r14
    1c9a:	80 81       	ld	r24, Z
    1c9c:	81 11       	cpse	r24, r1
    1c9e:	c3 cf       	rjmp	.-122    	; 0x1c26 <xTaskResumeAll+0x38>
    1ca0:	cd 2b       	or	r28, r29
    1ca2:	11 f0       	breq	.+4      	; 0x1ca8 <xTaskResumeAll+0xba>
    1ca4:	0e 94 11 0b 	call	0x1622	; 0x1622 <prvResetNextTaskUnblockTime>
    1ca8:	c0 91 62 2c 	lds	r28, 0x2C62	; 0x802c62 <uxPendedTicks>
    1cac:	cc 23       	and	r28, r28
    1cae:	51 f0       	breq	.+20     	; 0x1cc4 <xTaskResumeAll+0xd6>
    1cb0:	d1 e0       	ldi	r29, 0x01	; 1
    1cb2:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <xTaskIncrementTick>
    1cb6:	81 11       	cpse	r24, r1
    1cb8:	d0 93 61 2c 	sts	0x2C61, r29	; 0x802c61 <xYieldPending>
    1cbc:	c1 50       	subi	r28, 0x01	; 1
    1cbe:	c9 f7       	brne	.-14     	; 0x1cb2 <xTaskResumeAll+0xc4>
    1cc0:	10 92 62 2c 	sts	0x2C62, r1	; 0x802c62 <uxPendedTicks>
    1cc4:	80 91 61 2c 	lds	r24, 0x2C61	; 0x802c61 <xYieldPending>
    1cc8:	88 23       	and	r24, r24
    1cca:	31 f0       	breq	.+12     	; 0x1cd8 <xTaskResumeAll+0xea>
    1ccc:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    1cd0:	81 e0       	ldi	r24, 0x01	; 1
    1cd2:	03 c0       	rjmp	.+6      	; 0x1cda <xTaskResumeAll+0xec>
    1cd4:	80 e0       	ldi	r24, 0x00	; 0
    1cd6:	01 c0       	rjmp	.+2      	; 0x1cda <xTaskResumeAll+0xec>
    1cd8:	80 e0       	ldi	r24, 0x00	; 0
    1cda:	ff 91       	pop	r31
    1cdc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1ce0:	df 91       	pop	r29
    1ce2:	cf 91       	pop	r28
    1ce4:	1f 91       	pop	r17
    1ce6:	0f 91       	pop	r16
    1ce8:	ff 90       	pop	r15
    1cea:	ef 90       	pop	r14
    1cec:	df 90       	pop	r13
    1cee:	cf 90       	pop	r12
    1cf0:	08 95       	ret

00001cf2 <vTaskDelay>:
    1cf2:	cf 92       	push	r12
    1cf4:	df 92       	push	r13
    1cf6:	ef 92       	push	r14
    1cf8:	ff 92       	push	r15
    1cfa:	6b 01       	movw	r12, r22
    1cfc:	7c 01       	movw	r14, r24
    1cfe:	67 2b       	or	r22, r23
    1d00:	68 2b       	or	r22, r24
    1d02:	69 2b       	or	r22, r25
    1d04:	59 f0       	breq	.+22     	; 0x1d1c <vTaskDelay+0x2a>
    1d06:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskSuspendAll>
    1d0a:	40 e0       	ldi	r20, 0x00	; 0
    1d0c:	c7 01       	movw	r24, r14
    1d0e:	b6 01       	movw	r22, r12
    1d10:	0e 94 3b 0b 	call	0x1676	; 0x1676 <prvAddCurrentTaskToDelayedList>
    1d14:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    1d18:	81 11       	cpse	r24, r1
    1d1a:	02 c0       	rjmp	.+4      	; 0x1d20 <vTaskDelay+0x2e>
    1d1c:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    1d20:	ff 90       	pop	r15
    1d22:	ef 90       	pop	r14
    1d24:	df 90       	pop	r13
    1d26:	cf 90       	pop	r12
    1d28:	08 95       	ret

00001d2a <vTaskSwitchContext>:
    1d2a:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    1d2e:	88 23       	and	r24, r24
    1d30:	21 f0       	breq	.+8      	; 0x1d3a <vTaskSwitchContext+0x10>
    1d32:	81 e0       	ldi	r24, 0x01	; 1
    1d34:	80 93 61 2c 	sts	0x2C61, r24	; 0x802c61 <xYieldPending>
    1d38:	08 95       	ret
    1d3a:	10 92 61 2c 	sts	0x2C61, r1	; 0x802c61 <xYieldPending>
    1d3e:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1d42:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1d46:	03 8c       	ldd	r0, Z+27	; 0x1b
    1d48:	f4 8d       	ldd	r31, Z+28	; 0x1c
    1d4a:	e0 2d       	mov	r30, r0
    1d4c:	80 81       	ld	r24, Z
    1d4e:	91 81       	ldd	r25, Z+1	; 0x01
    1d50:	a2 81       	ldd	r26, Z+2	; 0x02
    1d52:	b3 81       	ldd	r27, Z+3	; 0x03
    1d54:	85 3a       	cpi	r24, 0xA5	; 165
    1d56:	95 4a       	sbci	r25, 0xA5	; 165
    1d58:	a5 4a       	sbci	r26, 0xA5	; 165
    1d5a:	b5 4a       	sbci	r27, 0xA5	; 165
    1d5c:	d9 f4       	brne	.+54     	; 0x1d94 <vTaskSwitchContext+0x6a>
    1d5e:	84 81       	ldd	r24, Z+4	; 0x04
    1d60:	95 81       	ldd	r25, Z+5	; 0x05
    1d62:	a6 81       	ldd	r26, Z+6	; 0x06
    1d64:	b7 81       	ldd	r27, Z+7	; 0x07
    1d66:	85 3a       	cpi	r24, 0xA5	; 165
    1d68:	95 4a       	sbci	r25, 0xA5	; 165
    1d6a:	a5 4a       	sbci	r26, 0xA5	; 165
    1d6c:	b5 4a       	sbci	r27, 0xA5	; 165
    1d6e:	91 f4       	brne	.+36     	; 0x1d94 <vTaskSwitchContext+0x6a>
    1d70:	80 85       	ldd	r24, Z+8	; 0x08
    1d72:	91 85       	ldd	r25, Z+9	; 0x09
    1d74:	a2 85       	ldd	r26, Z+10	; 0x0a
    1d76:	b3 85       	ldd	r27, Z+11	; 0x0b
    1d78:	85 3a       	cpi	r24, 0xA5	; 165
    1d7a:	95 4a       	sbci	r25, 0xA5	; 165
    1d7c:	a5 4a       	sbci	r26, 0xA5	; 165
    1d7e:	b5 4a       	sbci	r27, 0xA5	; 165
    1d80:	49 f4       	brne	.+18     	; 0x1d94 <vTaskSwitchContext+0x6a>
    1d82:	84 85       	ldd	r24, Z+12	; 0x0c
    1d84:	95 85       	ldd	r25, Z+13	; 0x0d
    1d86:	a6 85       	ldd	r26, Z+14	; 0x0e
    1d88:	b7 85       	ldd	r27, Z+15	; 0x0f
    1d8a:	85 3a       	cpi	r24, 0xA5	; 165
    1d8c:	95 4a       	sbci	r25, 0xA5	; 165
    1d8e:	a5 4a       	sbci	r26, 0xA5	; 165
    1d90:	b5 4a       	sbci	r27, 0xA5	; 165
    1d92:	61 f0       	breq	.+24     	; 0x1dac <vTaskSwitchContext+0x82>
    1d94:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1d98:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1d9c:	80 91 c6 2c 	lds	r24, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1da0:	90 91 c7 2c 	lds	r25, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1da4:	63 5e       	subi	r22, 0xE3	; 227
    1da6:	7f 4f       	sbci	r23, 0xFF	; 255
    1da8:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vApplicationStackOverflowHook>
    1dac:	80 91 64 2c 	lds	r24, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    1db0:	28 2f       	mov	r18, r24
    1db2:	30 e0       	ldi	r19, 0x00	; 0
    1db4:	9b e0       	ldi	r25, 0x0B	; 11
    1db6:	89 9f       	mul	r24, r25
    1db8:	f0 01       	movw	r30, r0
    1dba:	11 24       	eor	r1, r1
    1dbc:	e6 56       	subi	r30, 0x66	; 102
    1dbe:	f3 4d       	sbci	r31, 0xD3	; 211
    1dc0:	90 81       	ld	r25, Z
    1dc2:	91 11       	cpse	r25, r1
    1dc4:	0e c0       	rjmp	.+28     	; 0x1de2 <vTaskSwitchContext+0xb8>
    1dc6:	4b e0       	ldi	r20, 0x0B	; 11
    1dc8:	81 50       	subi	r24, 0x01	; 1
    1dca:	28 2f       	mov	r18, r24
    1dcc:	30 e0       	ldi	r19, 0x00	; 0
    1dce:	42 9f       	mul	r20, r18
    1dd0:	f0 01       	movw	r30, r0
    1dd2:	43 9f       	mul	r20, r19
    1dd4:	f0 0d       	add	r31, r0
    1dd6:	11 24       	eor	r1, r1
    1dd8:	e6 56       	subi	r30, 0x66	; 102
    1dda:	f3 4d       	sbci	r31, 0xD3	; 211
    1ddc:	90 81       	ld	r25, Z
    1dde:	99 23       	and	r25, r25
    1de0:	99 f3       	breq	.-26     	; 0x1dc8 <vTaskSwitchContext+0x9e>
    1de2:	9b e0       	ldi	r25, 0x0B	; 11
    1de4:	92 9f       	mul	r25, r18
    1de6:	a0 01       	movw	r20, r0
    1de8:	93 9f       	mul	r25, r19
    1dea:	50 0d       	add	r21, r0
    1dec:	11 24       	eor	r1, r1
    1dee:	da 01       	movw	r26, r20
    1df0:	a6 56       	subi	r26, 0x66	; 102
    1df2:	b3 4d       	sbci	r27, 0xD3	; 211
    1df4:	11 96       	adiw	r26, 0x01	; 1
    1df6:	ed 91       	ld	r30, X+
    1df8:	fc 91       	ld	r31, X
    1dfa:	12 97       	sbiw	r26, 0x02	; 2
    1dfc:	04 80       	ldd	r0, Z+4	; 0x04
    1dfe:	f5 81       	ldd	r31, Z+5	; 0x05
    1e00:	e0 2d       	mov	r30, r0
    1e02:	11 96       	adiw	r26, 0x01	; 1
    1e04:	ed 93       	st	X+, r30
    1e06:	fc 93       	st	X, r31
    1e08:	12 97       	sbiw	r26, 0x02	; 2
    1e0a:	43 56       	subi	r20, 0x63	; 99
    1e0c:	53 4d       	sbci	r21, 0xD3	; 211
    1e0e:	e4 17       	cp	r30, r20
    1e10:	f5 07       	cpc	r31, r21
    1e12:	29 f4       	brne	.+10     	; 0x1e1e <vTaskSwitchContext+0xf4>
    1e14:	44 81       	ldd	r20, Z+4	; 0x04
    1e16:	55 81       	ldd	r21, Z+5	; 0x05
    1e18:	fd 01       	movw	r30, r26
    1e1a:	41 83       	std	Z+1, r20	; 0x01
    1e1c:	52 83       	std	Z+2, r21	; 0x02
    1e1e:	9b e0       	ldi	r25, 0x0B	; 11
    1e20:	92 9f       	mul	r25, r18
    1e22:	f0 01       	movw	r30, r0
    1e24:	93 9f       	mul	r25, r19
    1e26:	f0 0d       	add	r31, r0
    1e28:	11 24       	eor	r1, r1
    1e2a:	e6 56       	subi	r30, 0x66	; 102
    1e2c:	f3 4d       	sbci	r31, 0xD3	; 211
    1e2e:	01 80       	ldd	r0, Z+1	; 0x01
    1e30:	f2 81       	ldd	r31, Z+2	; 0x02
    1e32:	e0 2d       	mov	r30, r0
    1e34:	20 85       	ldd	r18, Z+8	; 0x08
    1e36:	31 85       	ldd	r19, Z+9	; 0x09
    1e38:	20 93 c6 2c 	sts	0x2CC6, r18	; 0x802cc6 <pxCurrentTCB>
    1e3c:	30 93 c7 2c 	sts	0x2CC7, r19	; 0x802cc7 <pxCurrentTCB+0x1>
    1e40:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    1e44:	08 95       	ret

00001e46 <vTaskPlaceOnEventList>:
    1e46:	cf 92       	push	r12
    1e48:	df 92       	push	r13
    1e4a:	ef 92       	push	r14
    1e4c:	ff 92       	push	r15
    1e4e:	6a 01       	movw	r12, r20
    1e50:	7b 01       	movw	r14, r22
    1e52:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1e56:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1e5a:	62 5f       	subi	r22, 0xF2	; 242
    1e5c:	7f 4f       	sbci	r23, 0xFF	; 255
    1e5e:	0e 94 5b 05 	call	0xab6	; 0xab6 <vListInsert>
    1e62:	41 e0       	ldi	r20, 0x01	; 1
    1e64:	c7 01       	movw	r24, r14
    1e66:	b6 01       	movw	r22, r12
    1e68:	0e 94 3b 0b 	call	0x1676	; 0x1676 <prvAddCurrentTaskToDelayedList>
    1e6c:	ff 90       	pop	r15
    1e6e:	ef 90       	pop	r14
    1e70:	df 90       	pop	r13
    1e72:	cf 90       	pop	r12
    1e74:	08 95       	ret

00001e76 <vTaskPlaceOnUnorderedEventList>:
    1e76:	cf 92       	push	r12
    1e78:	df 92       	push	r13
    1e7a:	ef 92       	push	r14
    1e7c:	ff 92       	push	r15
    1e7e:	0f 93       	push	r16
    1e80:	1f 93       	push	r17
    1e82:	68 01       	movw	r12, r16
    1e84:	79 01       	movw	r14, r18
    1e86:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1e8a:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1e8e:	70 68       	ori	r23, 0x80	; 128
    1e90:	46 87       	std	Z+14, r20	; 0x0e
    1e92:	57 87       	std	Z+15, r21	; 0x0f
    1e94:	60 8b       	std	Z+16, r22	; 0x10
    1e96:	71 8b       	std	Z+17, r23	; 0x11
    1e98:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1e9c:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1ea0:	62 5f       	subi	r22, 0xF2	; 242
    1ea2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ea4:	0e 94 3a 05 	call	0xa74	; 0xa74 <vListInsertEnd>
    1ea8:	41 e0       	ldi	r20, 0x01	; 1
    1eaa:	c7 01       	movw	r24, r14
    1eac:	b6 01       	movw	r22, r12
    1eae:	0e 94 3b 0b 	call	0x1676	; 0x1676 <prvAddCurrentTaskToDelayedList>
    1eb2:	1f 91       	pop	r17
    1eb4:	0f 91       	pop	r16
    1eb6:	ff 90       	pop	r15
    1eb8:	ef 90       	pop	r14
    1eba:	df 90       	pop	r13
    1ebc:	cf 90       	pop	r12
    1ebe:	08 95       	ret

00001ec0 <vTaskPlaceOnEventListRestricted>:
    1ec0:	cf 92       	push	r12
    1ec2:	df 92       	push	r13
    1ec4:	ef 92       	push	r14
    1ec6:	ff 92       	push	r15
    1ec8:	cf 93       	push	r28
    1eca:	6a 01       	movw	r12, r20
    1ecc:	7b 01       	movw	r14, r22
    1ece:	c2 2f       	mov	r28, r18
    1ed0:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1ed4:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1ed8:	62 5f       	subi	r22, 0xF2	; 242
    1eda:	7f 4f       	sbci	r23, 0xFF	; 255
    1edc:	0e 94 3a 05 	call	0xa74	; 0xa74 <vListInsertEnd>
    1ee0:	cc 23       	and	r28, r28
    1ee2:	21 f0       	breq	.+8      	; 0x1eec <vTaskPlaceOnEventListRestricted+0x2c>
    1ee4:	cc 24       	eor	r12, r12
    1ee6:	ca 94       	dec	r12
    1ee8:	dc 2c       	mov	r13, r12
    1eea:	76 01       	movw	r14, r12
    1eec:	4c 2f       	mov	r20, r28
    1eee:	c7 01       	movw	r24, r14
    1ef0:	b6 01       	movw	r22, r12
    1ef2:	0e 94 3b 0b 	call	0x1676	; 0x1676 <prvAddCurrentTaskToDelayedList>
    1ef6:	cf 91       	pop	r28
    1ef8:	ff 90       	pop	r15
    1efa:	ef 90       	pop	r14
    1efc:	df 90       	pop	r13
    1efe:	cf 90       	pop	r12
    1f00:	08 95       	ret

00001f02 <xTaskRemoveFromEventList>:
    1f02:	0f 93       	push	r16
    1f04:	1f 93       	push	r17
    1f06:	cf 93       	push	r28
    1f08:	df 93       	push	r29
    1f0a:	dc 01       	movw	r26, r24
    1f0c:	17 96       	adiw	r26, 0x07	; 7
    1f0e:	ed 91       	ld	r30, X+
    1f10:	fc 91       	ld	r31, X
    1f12:	18 97       	sbiw	r26, 0x08	; 8
    1f14:	c0 85       	ldd	r28, Z+8	; 0x08
    1f16:	d1 85       	ldd	r29, Z+9	; 0x09
    1f18:	8e 01       	movw	r16, r28
    1f1a:	02 5f       	subi	r16, 0xF2	; 242
    1f1c:	1f 4f       	sbci	r17, 0xFF	; 255
    1f1e:	c8 01       	movw	r24, r16
    1f20:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    1f24:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    1f28:	81 11       	cpse	r24, r1
    1f2a:	16 c0       	rjmp	.+44     	; 0x1f58 <xTaskRemoveFromEventList+0x56>
    1f2c:	0c 50       	subi	r16, 0x0C	; 12
    1f2e:	11 09       	sbc	r17, r1
    1f30:	c8 01       	movw	r24, r16
    1f32:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    1f36:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f38:	90 91 64 2c 	lds	r25, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    1f3c:	98 17       	cp	r25, r24
    1f3e:	10 f4       	brcc	.+4      	; 0x1f44 <xTaskRemoveFromEventList+0x42>
    1f40:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    1f44:	bb e0       	ldi	r27, 0x0B	; 11
    1f46:	8b 9f       	mul	r24, r27
    1f48:	c0 01       	movw	r24, r0
    1f4a:	11 24       	eor	r1, r1
    1f4c:	b8 01       	movw	r22, r16
    1f4e:	86 56       	subi	r24, 0x66	; 102
    1f50:	93 4d       	sbci	r25, 0xD3	; 211
    1f52:	0e 94 3a 05 	call	0xa74	; 0xa74 <vListInsertEnd>
    1f56:	05 c0       	rjmp	.+10     	; 0x1f62 <xTaskRemoveFromEventList+0x60>
    1f58:	b8 01       	movw	r22, r16
    1f5a:	85 e7       	ldi	r24, 0x75	; 117
    1f5c:	9c e2       	ldi	r25, 0x2C	; 44
    1f5e:	0e 94 3a 05 	call	0xa74	; 0xa74 <vListInsertEnd>
    1f62:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1f66:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1f6a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1f6c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f6e:	89 17       	cp	r24, r25
    1f70:	20 f4       	brcc	.+8      	; 0x1f7a <xTaskRemoveFromEventList+0x78>
    1f72:	81 e0       	ldi	r24, 0x01	; 1
    1f74:	80 93 61 2c 	sts	0x2C61, r24	; 0x802c61 <xYieldPending>
    1f78:	01 c0       	rjmp	.+2      	; 0x1f7c <xTaskRemoveFromEventList+0x7a>
    1f7a:	80 e0       	ldi	r24, 0x00	; 0
    1f7c:	df 91       	pop	r29
    1f7e:	cf 91       	pop	r28
    1f80:	1f 91       	pop	r17
    1f82:	0f 91       	pop	r16
    1f84:	08 95       	ret

00001f86 <vTaskRemoveFromUnorderedEventList>:
    1f86:	0f 93       	push	r16
    1f88:	1f 93       	push	r17
    1f8a:	cf 93       	push	r28
    1f8c:	df 93       	push	r29
    1f8e:	70 68       	ori	r23, 0x80	; 128
    1f90:	fc 01       	movw	r30, r24
    1f92:	40 83       	st	Z, r20
    1f94:	51 83       	std	Z+1, r21	; 0x01
    1f96:	62 83       	std	Z+2, r22	; 0x02
    1f98:	73 83       	std	Z+3, r23	; 0x03
    1f9a:	c0 85       	ldd	r28, Z+8	; 0x08
    1f9c:	d1 85       	ldd	r29, Z+9	; 0x09
    1f9e:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    1fa2:	8e 01       	movw	r16, r28
    1fa4:	0e 5f       	subi	r16, 0xFE	; 254
    1fa6:	1f 4f       	sbci	r17, 0xFF	; 255
    1fa8:	c8 01       	movw	r24, r16
    1faa:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    1fae:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fb0:	90 91 64 2c 	lds	r25, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    1fb4:	98 17       	cp	r25, r24
    1fb6:	10 f4       	brcc	.+4      	; 0x1fbc <vTaskRemoveFromUnorderedEventList+0x36>
    1fb8:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    1fbc:	fb e0       	ldi	r31, 0x0B	; 11
    1fbe:	8f 9f       	mul	r24, r31
    1fc0:	c0 01       	movw	r24, r0
    1fc2:	11 24       	eor	r1, r1
    1fc4:	b8 01       	movw	r22, r16
    1fc6:	86 56       	subi	r24, 0x66	; 102
    1fc8:	93 4d       	sbci	r25, 0xD3	; 211
    1fca:	0e 94 3a 05 	call	0xa74	; 0xa74 <vListInsertEnd>
    1fce:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1fd2:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1fd6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1fd8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fda:	89 17       	cp	r24, r25
    1fdc:	18 f4       	brcc	.+6      	; 0x1fe4 <vTaskRemoveFromUnorderedEventList+0x5e>
    1fde:	81 e0       	ldi	r24, 0x01	; 1
    1fe0:	80 93 61 2c 	sts	0x2C61, r24	; 0x802c61 <xYieldPending>
    1fe4:	df 91       	pop	r29
    1fe6:	cf 91       	pop	r28
    1fe8:	1f 91       	pop	r17
    1fea:	0f 91       	pop	r16
    1fec:	08 95       	ret

00001fee <vTaskInternalSetTimeOutState>:
    1fee:	20 91 60 2c 	lds	r18, 0x2C60	; 0x802c60 <xNumOfOverflows>
    1ff2:	fc 01       	movw	r30, r24
    1ff4:	20 83       	st	Z, r18
    1ff6:	40 91 65 2c 	lds	r20, 0x2C65	; 0x802c65 <xTickCount>
    1ffa:	50 91 66 2c 	lds	r21, 0x2C66	; 0x802c66 <xTickCount+0x1>
    1ffe:	60 91 67 2c 	lds	r22, 0x2C67	; 0x802c67 <xTickCount+0x2>
    2002:	70 91 68 2c 	lds	r23, 0x2C68	; 0x802c68 <xTickCount+0x3>
    2006:	41 83       	std	Z+1, r20	; 0x01
    2008:	52 83       	std	Z+2, r21	; 0x02
    200a:	63 83       	std	Z+3, r22	; 0x03
    200c:	74 83       	std	Z+4, r23	; 0x04
    200e:	08 95       	ret

00002010 <xTaskCheckForTimeOut>:
    2010:	cf 92       	push	r12
    2012:	df 92       	push	r13
    2014:	ef 92       	push	r14
    2016:	ff 92       	push	r15
    2018:	0f 93       	push	r16
    201a:	1f 93       	push	r17
    201c:	cf 93       	push	r28
    201e:	df 93       	push	r29
    2020:	db 01       	movw	r26, r22
    2022:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    2026:	ff 93       	push	r31
    2028:	f8 7f       	andi	r31, 0xF8	; 248
    202a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    202e:	40 91 65 2c 	lds	r20, 0x2C65	; 0x802c65 <xTickCount>
    2032:	50 91 66 2c 	lds	r21, 0x2C66	; 0x802c66 <xTickCount+0x1>
    2036:	60 91 67 2c 	lds	r22, 0x2C67	; 0x802c67 <xTickCount+0x2>
    203a:	70 91 68 2c 	lds	r23, 0x2C68	; 0x802c68 <xTickCount+0x3>
    203e:	0d 91       	ld	r16, X+
    2040:	1d 91       	ld	r17, X+
    2042:	2d 91       	ld	r18, X+
    2044:	3c 91       	ld	r19, X
    2046:	13 97       	sbiw	r26, 0x03	; 3
    2048:	0f 3f       	cpi	r16, 0xFF	; 255
    204a:	cf ef       	ldi	r28, 0xFF	; 255
    204c:	1c 07       	cpc	r17, r28
    204e:	2c 07       	cpc	r18, r28
    2050:	3c 07       	cpc	r19, r28
    2052:	69 f1       	breq	.+90     	; 0x20ae <xTaskCheckForTimeOut+0x9e>
    2054:	fc 01       	movw	r30, r24
    2056:	c1 80       	ldd	r12, Z+1	; 0x01
    2058:	d2 80       	ldd	r13, Z+2	; 0x02
    205a:	e3 80       	ldd	r14, Z+3	; 0x03
    205c:	f4 80       	ldd	r15, Z+4	; 0x04
    205e:	e0 91 60 2c 	lds	r30, 0x2C60	; 0x802c60 <xNumOfOverflows>
    2062:	ec 01       	movw	r28, r24
    2064:	f8 81       	ld	r31, Y
    2066:	fe 17       	cp	r31, r30
    2068:	29 f0       	breq	.+10     	; 0x2074 <xTaskCheckForTimeOut+0x64>
    206a:	4c 15       	cp	r20, r12
    206c:	5d 05       	cpc	r21, r13
    206e:	6e 05       	cpc	r22, r14
    2070:	7f 05       	cpc	r23, r15
    2072:	f8 f4       	brcc	.+62     	; 0x20b2 <xTaskCheckForTimeOut+0xa2>
    2074:	4c 19       	sub	r20, r12
    2076:	5d 09       	sbc	r21, r13
    2078:	6e 09       	sbc	r22, r14
    207a:	7f 09       	sbc	r23, r15
    207c:	40 17       	cp	r20, r16
    207e:	51 07       	cpc	r21, r17
    2080:	62 07       	cpc	r22, r18
    2082:	73 07       	cpc	r23, r19
    2084:	68 f4       	brcc	.+26     	; 0x20a0 <xTaskCheckForTimeOut+0x90>
    2086:	fd 01       	movw	r30, r26
    2088:	04 1b       	sub	r16, r20
    208a:	15 0b       	sbc	r17, r21
    208c:	26 0b       	sbc	r18, r22
    208e:	37 0b       	sbc	r19, r23
    2090:	00 83       	st	Z, r16
    2092:	11 83       	std	Z+1, r17	; 0x01
    2094:	22 83       	std	Z+2, r18	; 0x02
    2096:	33 83       	std	Z+3, r19	; 0x03
    2098:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <vTaskInternalSetTimeOutState>
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	0a c0       	rjmp	.+20     	; 0x20b4 <xTaskCheckForTimeOut+0xa4>
    20a0:	1d 92       	st	X+, r1
    20a2:	1d 92       	st	X+, r1
    20a4:	1d 92       	st	X+, r1
    20a6:	1c 92       	st	X, r1
    20a8:	13 97       	sbiw	r26, 0x03	; 3
    20aa:	81 e0       	ldi	r24, 0x01	; 1
    20ac:	03 c0       	rjmp	.+6      	; 0x20b4 <xTaskCheckForTimeOut+0xa4>
    20ae:	80 e0       	ldi	r24, 0x00	; 0
    20b0:	01 c0       	rjmp	.+2      	; 0x20b4 <xTaskCheckForTimeOut+0xa4>
    20b2:	81 e0       	ldi	r24, 0x01	; 1
    20b4:	ff 91       	pop	r31
    20b6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    20ba:	df 91       	pop	r29
    20bc:	cf 91       	pop	r28
    20be:	1f 91       	pop	r17
    20c0:	0f 91       	pop	r16
    20c2:	ff 90       	pop	r15
    20c4:	ef 90       	pop	r14
    20c6:	df 90       	pop	r13
    20c8:	cf 90       	pop	r12
    20ca:	08 95       	ret

000020cc <vTaskMissedYield>:
    20cc:	81 e0       	ldi	r24, 0x01	; 1
    20ce:	80 93 61 2c 	sts	0x2C61, r24	; 0x802c61 <xYieldPending>
    20d2:	08 95       	ret

000020d4 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    20d4:	80 91 63 2c 	lds	r24, 0x2C63	; 0x802c63 <xSchedulerRunning>
    20d8:	88 23       	and	r24, r24
    20da:	31 f0       	breq	.+12     	; 0x20e8 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    20dc:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    20e0:	88 23       	and	r24, r24
    20e2:	21 f0       	breq	.+8      	; 0x20ec <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    20e4:	80 e0       	ldi	r24, 0x00	; 0
    20e6:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    20e8:	81 e0       	ldi	r24, 0x01	; 1
    20ea:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    20ec:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    20ee:	08 95       	ret

000020f0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    20f0:	cf 92       	push	r12
    20f2:	df 92       	push	r13
    20f4:	ef 92       	push	r14
    20f6:	ff 92       	push	r15
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    20f8:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    20fc:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    2100:	66 85       	ldd	r22, Z+14	; 0x0e
    2102:	77 85       	ldd	r23, Z+15	; 0x0f
    2104:	80 89       	ldd	r24, Z+16	; 0x10
    2106:	91 89       	ldd	r25, Z+17	; 0x11

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2108:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    210c:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    2110:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    2114:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    2118:	5a 96       	adiw	r26, 0x1a	; 26
    211a:	2c 91       	ld	r18, X
    211c:	c1 2c       	mov	r12, r1
    211e:	d1 2c       	mov	r13, r1
    2120:	76 01       	movw	r14, r12
    2122:	68 94       	set
    2124:	c2 f8       	bld	r12, 2
    2126:	c2 1a       	sub	r12, r18
    2128:	d1 08       	sbc	r13, r1
    212a:	e1 08       	sbc	r14, r1
    212c:	f1 08       	sbc	r15, r1
    212e:	c6 86       	std	Z+14, r12	; 0x0e
    2130:	d7 86       	std	Z+15, r13	; 0x0f
    2132:	e0 8a       	std	Z+16, r14	; 0x10
    2134:	f1 8a       	std	Z+17, r15	; 0x11

	return uxReturn;
}
    2136:	ff 90       	pop	r15
    2138:	ef 90       	pop	r14
    213a:	df 90       	pop	r13
    213c:	cf 90       	pop	r12
    213e:	08 95       	ret

00002140 <prvInsertTimerInActiveList>:

	taskENTER_CRITICAL();
	{
		pxTimer->pvTimerID = pvNewID;
	}
	taskEXIT_CRITICAL();
    2140:	cf 92       	push	r12
    2142:	df 92       	push	r13
    2144:	ef 92       	push	r14
    2146:	ff 92       	push	r15
    2148:	0f 93       	push	r16
    214a:	1f 93       	push	r17
    214c:	fc 01       	movw	r30, r24
    214e:	42 83       	std	Z+2, r20	; 0x02
    2150:	53 83       	std	Z+3, r21	; 0x03
    2152:	64 83       	std	Z+4, r22	; 0x04
    2154:	75 83       	std	Z+5, r23	; 0x05
    2156:	82 87       	std	Z+10, r24	; 0x0a
    2158:	93 87       	std	Z+11, r25	; 0x0b
    215a:	04 17       	cp	r16, r20
    215c:	15 07       	cpc	r17, r21
    215e:	26 07       	cpc	r18, r22
    2160:	37 07       	cpc	r19, r23
    2162:	c0 f0       	brcs	.+48     	; 0x2194 <prvInsertTimerInActiveList+0x54>
    2164:	0c 19       	sub	r16, r12
    2166:	1d 09       	sbc	r17, r13
    2168:	2e 09       	sbc	r18, r14
    216a:	3f 09       	sbc	r19, r15
    216c:	86 85       	ldd	r24, Z+14	; 0x0e
    216e:	97 85       	ldd	r25, Z+15	; 0x0f
    2170:	a0 89       	ldd	r26, Z+16	; 0x10
    2172:	b1 89       	ldd	r27, Z+17	; 0x11
    2174:	08 17       	cp	r16, r24
    2176:	19 07       	cpc	r17, r25
    2178:	2a 07       	cpc	r18, r26
    217a:	3b 07       	cpc	r19, r27
    217c:	00 f5       	brcc	.+64     	; 0x21be <prvInsertTimerInActiveList+0x7e>
    217e:	bf 01       	movw	r22, r30
    2180:	6e 5f       	subi	r22, 0xFE	; 254
    2182:	7f 4f       	sbci	r23, 0xFF	; 255
    2184:	80 91 d0 2c 	lds	r24, 0x2CD0	; 0x802cd0 <pxOverflowTimerList>
    2188:	90 91 d1 2c 	lds	r25, 0x2CD1	; 0x802cd1 <pxOverflowTimerList+0x1>
    218c:	0e 94 5b 05 	call	0xab6	; 0xab6 <vListInsert>
    2190:	80 e0       	ldi	r24, 0x00	; 0
    2192:	18 c0       	rjmp	.+48     	; 0x21c4 <prvInsertTimerInActiveList+0x84>
    2194:	0c 15       	cp	r16, r12
    2196:	1d 05       	cpc	r17, r13
    2198:	2e 05       	cpc	r18, r14
    219a:	3f 05       	cpc	r19, r15
    219c:	28 f4       	brcc	.+10     	; 0x21a8 <prvInsertTimerInActiveList+0x68>
    219e:	4c 15       	cp	r20, r12
    21a0:	5d 05       	cpc	r21, r13
    21a2:	6e 05       	cpc	r22, r14
    21a4:	7f 05       	cpc	r23, r15
    21a6:	68 f4       	brcc	.+26     	; 0x21c2 <prvInsertTimerInActiveList+0x82>
    21a8:	bf 01       	movw	r22, r30
    21aa:	6e 5f       	subi	r22, 0xFE	; 254
    21ac:	7f 4f       	sbci	r23, 0xFF	; 255
    21ae:	80 91 d2 2c 	lds	r24, 0x2CD2	; 0x802cd2 <pxCurrentTimerList>
    21b2:	90 91 d3 2c 	lds	r25, 0x2CD3	; 0x802cd3 <pxCurrentTimerList+0x1>
    21b6:	0e 94 5b 05 	call	0xab6	; 0xab6 <vListInsert>
    21ba:	80 e0       	ldi	r24, 0x00	; 0
    21bc:	03 c0       	rjmp	.+6      	; 0x21c4 <prvInsertTimerInActiveList+0x84>
    21be:	81 e0       	ldi	r24, 0x01	; 1
    21c0:	01 c0       	rjmp	.+2      	; 0x21c4 <prvInsertTimerInActiveList+0x84>
    21c2:	81 e0       	ldi	r24, 0x01	; 1
    21c4:	1f 91       	pop	r17
    21c6:	0f 91       	pop	r16
    21c8:	ff 90       	pop	r15
    21ca:	ef 90       	pop	r14
    21cc:	df 90       	pop	r13
    21ce:	cf 90       	pop	r12
    21d0:	08 95       	ret

000021d2 <prvCheckForValidListAndQueue>:
    21d2:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    21d6:	ff 93       	push	r31
    21d8:	f8 7f       	andi	r31, 0xF8	; 248
    21da:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    21de:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    21e2:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    21e6:	89 2b       	or	r24, r25
    21e8:	e9 f4       	brne	.+58     	; 0x2224 <prvCheckForValidListAndQueue+0x52>
    21ea:	8f ed       	ldi	r24, 0xDF	; 223
    21ec:	9c e2       	ldi	r25, 0x2C	; 44
    21ee:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    21f2:	84 ed       	ldi	r24, 0xD4	; 212
    21f4:	9c e2       	ldi	r25, 0x2C	; 44
    21f6:	0e 94 25 05 	call	0xa4a	; 0xa4a <vListInitialise>
    21fa:	8f ed       	ldi	r24, 0xDF	; 223
    21fc:	9c e2       	ldi	r25, 0x2C	; 44
    21fe:	80 93 d2 2c 	sts	0x2CD2, r24	; 0x802cd2 <pxCurrentTimerList>
    2202:	90 93 d3 2c 	sts	0x2CD3, r25	; 0x802cd3 <pxCurrentTimerList+0x1>
    2206:	84 ed       	ldi	r24, 0xD4	; 212
    2208:	9c e2       	ldi	r25, 0x2C	; 44
    220a:	80 93 d0 2c 	sts	0x2CD0, r24	; 0x802cd0 <pxOverflowTimerList>
    220e:	90 93 d1 2c 	sts	0x2CD1, r25	; 0x802cd1 <pxOverflowTimerList+0x1>
    2212:	40 e0       	ldi	r20, 0x00	; 0
    2214:	69 e0       	ldi	r22, 0x09	; 9
    2216:	85 e0       	ldi	r24, 0x05	; 5
    2218:	0e 94 88 08 	call	0x1110	; 0x1110 <xQueueGenericCreate>
    221c:	80 93 ce 2c 	sts	0x2CCE, r24	; 0x802cce <xTimerQueue>
    2220:	90 93 cf 2c 	sts	0x2CCF, r25	; 0x802ccf <xTimerQueue+0x1>
    2224:	ff 91       	pop	r31
    2226:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    222a:	08 95       	ret

0000222c <xTimerCreateTimerTask>:
    222c:	ef 92       	push	r14
    222e:	ff 92       	push	r15
    2230:	0f 93       	push	r16
    2232:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <prvCheckForValidListAndQueue>
    2236:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    223a:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    223e:	89 2b       	or	r24, r25
    2240:	91 f0       	breq	.+36     	; 0x2266 <xTimerCreateTimerTask+0x3a>
    2242:	0f 2e       	mov	r0, r31
    2244:	fc ec       	ldi	r31, 0xCC	; 204
    2246:	ef 2e       	mov	r14, r31
    2248:	fc e2       	ldi	r31, 0x2C	; 44
    224a:	ff 2e       	mov	r15, r31
    224c:	f0 2d       	mov	r31, r0
    224e:	03 e0       	ldi	r16, 0x03	; 3
    2250:	20 e0       	ldi	r18, 0x00	; 0
    2252:	30 e0       	ldi	r19, 0x00	; 0
    2254:	48 ec       	ldi	r20, 0xC8	; 200
    2256:	50 e0       	ldi	r21, 0x00	; 0
    2258:	66 e0       	ldi	r22, 0x06	; 6
    225a:	70 e2       	ldi	r23, 0x20	; 32
    225c:	89 e2       	ldi	r24, 0x29	; 41
    225e:	92 e1       	ldi	r25, 0x12	; 18
    2260:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskCreate>
    2264:	01 c0       	rjmp	.+2      	; 0x2268 <xTimerCreateTimerTask+0x3c>
    2266:	80 e0       	ldi	r24, 0x00	; 0
    2268:	0f 91       	pop	r16
    226a:	ff 90       	pop	r15
    226c:	ef 90       	pop	r14
    226e:	08 95       	ret

00002270 <xTimerGenericCommand>:
    2270:	8f 92       	push	r8
    2272:	9f 92       	push	r9
    2274:	af 92       	push	r10
    2276:	bf 92       	push	r11
    2278:	cf 92       	push	r12
    227a:	df 92       	push	r13
    227c:	ef 92       	push	r14
    227e:	ff 92       	push	r15
    2280:	0f 93       	push	r16
    2282:	1f 93       	push	r17
    2284:	cf 93       	push	r28
    2286:	df 93       	push	r29
    2288:	cd b7       	in	r28, 0x3d	; 61
    228a:	de b7       	in	r29, 0x3e	; 62
    228c:	29 97       	sbiw	r28, 0x09	; 9
    228e:	cd bf       	out	0x3d, r28	; 61
    2290:	de bf       	out	0x3e, r29	; 62
    2292:	e0 91 ce 2c 	lds	r30, 0x2CCE	; 0x802cce <xTimerQueue>
    2296:	f0 91 cf 2c 	lds	r31, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    229a:	30 97       	sbiw	r30, 0x00	; 0
    229c:	89 f1       	breq	.+98     	; 0x2300 <xTimerGenericCommand+0x90>
    229e:	69 83       	std	Y+1, r22	; 0x01
    22a0:	2a 83       	std	Y+2, r18	; 0x02
    22a2:	3b 83       	std	Y+3, r19	; 0x03
    22a4:	4c 83       	std	Y+4, r20	; 0x04
    22a6:	5d 83       	std	Y+5, r21	; 0x05
    22a8:	8e 83       	std	Y+6, r24	; 0x06
    22aa:	9f 83       	std	Y+7, r25	; 0x07
    22ac:	66 30       	cpi	r22, 0x06	; 6
    22ae:	fc f4       	brge	.+62     	; 0x22ee <xTimerGenericCommand+0x7e>
    22b0:	0e 94 6a 10 	call	0x20d4	; 0x20d4 <xTaskGetSchedulerState>
    22b4:	82 30       	cpi	r24, 0x02	; 2
    22b6:	69 f4       	brne	.+26     	; 0x22d2 <xTimerGenericCommand+0x62>
    22b8:	00 e0       	ldi	r16, 0x00	; 0
    22ba:	a7 01       	movw	r20, r14
    22bc:	96 01       	movw	r18, r12
    22be:	be 01       	movw	r22, r28
    22c0:	6f 5f       	subi	r22, 0xFF	; 255
    22c2:	7f 4f       	sbci	r23, 0xFF	; 255
    22c4:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    22c8:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    22cc:	0e 94 b9 08 	call	0x1172	; 0x1172 <xQueueGenericSend>
    22d0:	18 c0       	rjmp	.+48     	; 0x2302 <xTimerGenericCommand+0x92>
    22d2:	00 e0       	ldi	r16, 0x00	; 0
    22d4:	20 e0       	ldi	r18, 0x00	; 0
    22d6:	30 e0       	ldi	r19, 0x00	; 0
    22d8:	a9 01       	movw	r20, r18
    22da:	be 01       	movw	r22, r28
    22dc:	6f 5f       	subi	r22, 0xFF	; 255
    22de:	7f 4f       	sbci	r23, 0xFF	; 255
    22e0:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    22e4:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    22e8:	0e 94 b9 08 	call	0x1172	; 0x1172 <xQueueGenericSend>
    22ec:	0a c0       	rjmp	.+20     	; 0x2302 <xTimerGenericCommand+0x92>
    22ee:	20 e0       	ldi	r18, 0x00	; 0
    22f0:	a8 01       	movw	r20, r16
    22f2:	be 01       	movw	r22, r28
    22f4:	6f 5f       	subi	r22, 0xFF	; 255
    22f6:	7f 4f       	sbci	r23, 0xFF	; 255
    22f8:	cf 01       	movw	r24, r30
    22fa:	0e 94 5f 09 	call	0x12be	; 0x12be <xQueueGenericSendFromISR>
    22fe:	01 c0       	rjmp	.+2      	; 0x2302 <xTimerGenericCommand+0x92>
    2300:	80 e0       	ldi	r24, 0x00	; 0
    2302:	29 96       	adiw	r28, 0x09	; 9
    2304:	cd bf       	out	0x3d, r28	; 61
    2306:	de bf       	out	0x3e, r29	; 62
    2308:	df 91       	pop	r29
    230a:	cf 91       	pop	r28
    230c:	1f 91       	pop	r17
    230e:	0f 91       	pop	r16
    2310:	ff 90       	pop	r15
    2312:	ef 90       	pop	r14
    2314:	df 90       	pop	r13
    2316:	cf 90       	pop	r12
    2318:	bf 90       	pop	r11
    231a:	af 90       	pop	r10
    231c:	9f 90       	pop	r9
    231e:	8f 90       	pop	r8
    2320:	08 95       	ret

00002322 <prvSampleTimeNow>:
    2322:	2f 92       	push	r2
    2324:	3f 92       	push	r3
    2326:	4f 92       	push	r4
    2328:	5f 92       	push	r5
    232a:	6f 92       	push	r6
    232c:	7f 92       	push	r7
    232e:	8f 92       	push	r8
    2330:	9f 92       	push	r9
    2332:	af 92       	push	r10
    2334:	bf 92       	push	r11
    2336:	cf 92       	push	r12
    2338:	df 92       	push	r13
    233a:	ef 92       	push	r14
    233c:	ff 92       	push	r15
    233e:	0f 93       	push	r16
    2340:	1f 93       	push	r17
    2342:	cf 93       	push	r28
    2344:	df 93       	push	r29
    2346:	1c 01       	movw	r2, r24
    2348:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <xTaskGetTickCount>
    234c:	2b 01       	movw	r4, r22
    234e:	3c 01       	movw	r6, r24
    2350:	80 91 c8 2c 	lds	r24, 0x2CC8	; 0x802cc8 <xLastTime.4745>
    2354:	90 91 c9 2c 	lds	r25, 0x2CC9	; 0x802cc9 <xLastTime.4745+0x1>
    2358:	a0 91 ca 2c 	lds	r26, 0x2CCA	; 0x802cca <xLastTime.4745+0x2>
    235c:	b0 91 cb 2c 	lds	r27, 0x2CCB	; 0x802ccb <xLastTime.4745+0x3>
    2360:	48 16       	cp	r4, r24
    2362:	59 06       	cpc	r5, r25
    2364:	6a 06       	cpc	r6, r26
    2366:	7b 06       	cpc	r7, r27
    2368:	08 f0       	brcs	.+2      	; 0x236c <prvSampleTimeNow+0x4a>
    236a:	54 c0       	rjmp	.+168    	; 0x2414 <prvSampleTimeNow+0xf2>
    236c:	3c c0       	rjmp	.+120    	; 0x23e6 <prvSampleTimeNow+0xc4>
    236e:	07 80       	ldd	r0, Z+7	; 0x07
    2370:	f0 85       	ldd	r31, Z+8	; 0x08
    2372:	e0 2d       	mov	r30, r0
    2374:	80 80       	ld	r8, Z
    2376:	91 80       	ldd	r9, Z+1	; 0x01
    2378:	a2 80       	ldd	r10, Z+2	; 0x02
    237a:	b3 80       	ldd	r11, Z+3	; 0x03
    237c:	c0 85       	ldd	r28, Z+8	; 0x08
    237e:	d1 85       	ldd	r29, Z+9	; 0x09
    2380:	8e 01       	movw	r16, r28
    2382:	0e 5f       	subi	r16, 0xFE	; 254
    2384:	1f 4f       	sbci	r17, 0xFF	; 255
    2386:	c8 01       	movw	r24, r16
    2388:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    238c:	ed 89       	ldd	r30, Y+21	; 0x15
    238e:	fe 89       	ldd	r31, Y+22	; 0x16
    2390:	ce 01       	movw	r24, r28
    2392:	19 95       	eicall
    2394:	8a 89       	ldd	r24, Y+18	; 0x12
    2396:	81 30       	cpi	r24, 0x01	; 1
    2398:	31 f5       	brne	.+76     	; 0x23e6 <prvSampleTimeNow+0xc4>
    239a:	8e 85       	ldd	r24, Y+14	; 0x0e
    239c:	9f 85       	ldd	r25, Y+15	; 0x0f
    239e:	a8 89       	ldd	r26, Y+16	; 0x10
    23a0:	b9 89       	ldd	r27, Y+17	; 0x11
    23a2:	88 0d       	add	r24, r8
    23a4:	99 1d       	adc	r25, r9
    23a6:	aa 1d       	adc	r26, r10
    23a8:	bb 1d       	adc	r27, r11
    23aa:	88 16       	cp	r8, r24
    23ac:	99 06       	cpc	r9, r25
    23ae:	aa 06       	cpc	r10, r26
    23b0:	bb 06       	cpc	r11, r27
    23b2:	70 f4       	brcc	.+28     	; 0x23d0 <prvSampleTimeNow+0xae>
    23b4:	8a 83       	std	Y+2, r24	; 0x02
    23b6:	9b 83       	std	Y+3, r25	; 0x03
    23b8:	ac 83       	std	Y+4, r26	; 0x04
    23ba:	bd 83       	std	Y+5, r27	; 0x05
    23bc:	ca 87       	std	Y+10, r28	; 0x0a
    23be:	db 87       	std	Y+11, r29	; 0x0b
    23c0:	b8 01       	movw	r22, r16
    23c2:	80 91 d2 2c 	lds	r24, 0x2CD2	; 0x802cd2 <pxCurrentTimerList>
    23c6:	90 91 d3 2c 	lds	r25, 0x2CD3	; 0x802cd3 <pxCurrentTimerList+0x1>
    23ca:	0e 94 5b 05 	call	0xab6	; 0xab6 <vListInsert>
    23ce:	0b c0       	rjmp	.+22     	; 0x23e6 <prvSampleTimeNow+0xc4>
    23d0:	c1 2c       	mov	r12, r1
    23d2:	d1 2c       	mov	r13, r1
    23d4:	76 01       	movw	r14, r12
    23d6:	00 e0       	ldi	r16, 0x00	; 0
    23d8:	10 e0       	ldi	r17, 0x00	; 0
    23da:	a5 01       	movw	r20, r10
    23dc:	94 01       	movw	r18, r8
    23de:	60 e0       	ldi	r22, 0x00	; 0
    23e0:	ce 01       	movw	r24, r28
    23e2:	0e 94 38 11 	call	0x2270	; 0x2270 <xTimerGenericCommand>
    23e6:	e0 91 d2 2c 	lds	r30, 0x2CD2	; 0x802cd2 <pxCurrentTimerList>
    23ea:	f0 91 d3 2c 	lds	r31, 0x2CD3	; 0x802cd3 <pxCurrentTimerList+0x1>
    23ee:	80 81       	ld	r24, Z
    23f0:	81 11       	cpse	r24, r1
    23f2:	bd cf       	rjmp	.-134    	; 0x236e <prvSampleTimeNow+0x4c>
    23f4:	80 91 d0 2c 	lds	r24, 0x2CD0	; 0x802cd0 <pxOverflowTimerList>
    23f8:	90 91 d1 2c 	lds	r25, 0x2CD1	; 0x802cd1 <pxOverflowTimerList+0x1>
    23fc:	80 93 d2 2c 	sts	0x2CD2, r24	; 0x802cd2 <pxCurrentTimerList>
    2400:	90 93 d3 2c 	sts	0x2CD3, r25	; 0x802cd3 <pxCurrentTimerList+0x1>
    2404:	e0 93 d0 2c 	sts	0x2CD0, r30	; 0x802cd0 <pxOverflowTimerList>
    2408:	f0 93 d1 2c 	sts	0x2CD1, r31	; 0x802cd1 <pxOverflowTimerList+0x1>
    240c:	81 e0       	ldi	r24, 0x01	; 1
    240e:	f1 01       	movw	r30, r2
    2410:	80 83       	st	Z, r24
    2412:	02 c0       	rjmp	.+4      	; 0x2418 <prvSampleTimeNow+0xf6>
    2414:	f1 01       	movw	r30, r2
    2416:	10 82       	st	Z, r1
    2418:	40 92 c8 2c 	sts	0x2CC8, r4	; 0x802cc8 <xLastTime.4745>
    241c:	50 92 c9 2c 	sts	0x2CC9, r5	; 0x802cc9 <xLastTime.4745+0x1>
    2420:	60 92 ca 2c 	sts	0x2CCA, r6	; 0x802cca <xLastTime.4745+0x2>
    2424:	70 92 cb 2c 	sts	0x2CCB, r7	; 0x802ccb <xLastTime.4745+0x3>
    2428:	c3 01       	movw	r24, r6
    242a:	b2 01       	movw	r22, r4
    242c:	df 91       	pop	r29
    242e:	cf 91       	pop	r28
    2430:	1f 91       	pop	r17
    2432:	0f 91       	pop	r16
    2434:	ff 90       	pop	r15
    2436:	ef 90       	pop	r14
    2438:	df 90       	pop	r13
    243a:	cf 90       	pop	r12
    243c:	bf 90       	pop	r11
    243e:	af 90       	pop	r10
    2440:	9f 90       	pop	r9
    2442:	8f 90       	pop	r8
    2444:	7f 90       	pop	r7
    2446:	6f 90       	pop	r6
    2448:	5f 90       	pop	r5
    244a:	4f 90       	pop	r4
    244c:	3f 90       	pop	r3
    244e:	2f 90       	pop	r2
    2450:	08 95       	ret

00002452 <prvTimerTask>:
    2452:	cf 93       	push	r28
    2454:	df 93       	push	r29
    2456:	cd b7       	in	r28, 0x3d	; 61
    2458:	de b7       	in	r29, 0x3e	; 62
    245a:	2e 97       	sbiw	r28, 0x0e	; 14
    245c:	cd bf       	out	0x3d, r28	; 61
    245e:	de bf       	out	0x3e, r29	; 62
    2460:	ce 01       	movw	r24, r28
    2462:	01 96       	adiw	r24, 0x01	; 1
    2464:	1c 01       	movw	r2, r24
    2466:	a8 2e       	mov	r10, r24
    2468:	b3 2c       	mov	r11, r3
    246a:	e0 91 d2 2c 	lds	r30, 0x2CD2	; 0x802cd2 <pxCurrentTimerList>
    246e:	f0 91 d3 2c 	lds	r31, 0x2CD3	; 0x802cd3 <pxCurrentTimerList+0x1>
    2472:	80 81       	ld	r24, Z
    2474:	88 23       	and	r24, r24
    2476:	09 f4       	brne	.+2      	; 0x247a <prvTimerTask+0x28>
    2478:	03 c1       	rjmp	.+518    	; 0x2680 <prvTimerTask+0x22e>
    247a:	07 80       	ldd	r0, Z+7	; 0x07
    247c:	f0 85       	ldd	r31, Z+8	; 0x08
    247e:	e0 2d       	mov	r30, r0
    2480:	40 80       	ld	r4, Z
    2482:	51 80       	ldd	r5, Z+1	; 0x01
    2484:	62 80       	ldd	r6, Z+2	; 0x02
    2486:	73 80       	ldd	r7, Z+3	; 0x03
    2488:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskSuspendAll>
    248c:	c1 01       	movw	r24, r2
    248e:	0e 94 91 11 	call	0x2322	; 0x2322 <prvSampleTimeNow>
    2492:	6b 87       	std	Y+11, r22	; 0x0b
    2494:	7c 87       	std	Y+12, r23	; 0x0c
    2496:	8d 87       	std	Y+13, r24	; 0x0d
    2498:	9e 87       	std	Y+14, r25	; 0x0e
    249a:	89 81       	ldd	r24, Y+1	; 0x01
    249c:	81 11       	cpse	r24, r1
    249e:	5e c0       	rjmp	.+188    	; 0x255c <prvTimerTask+0x10a>
    24a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    24a2:	9c 85       	ldd	r25, Y+12	; 0x0c
    24a4:	ad 85       	ldd	r26, Y+13	; 0x0d
    24a6:	be 85       	ldd	r27, Y+14	; 0x0e
    24a8:	84 15       	cp	r24, r4
    24aa:	95 05       	cpc	r25, r5
    24ac:	a6 05       	cpc	r26, r6
    24ae:	b7 05       	cpc	r27, r7
    24b0:	e8 f1       	brcs	.+122    	; 0x252c <prvTimerTask+0xda>
    24b2:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    24b6:	e0 91 d2 2c 	lds	r30, 0x2CD2	; 0x802cd2 <pxCurrentTimerList>
    24ba:	f0 91 d3 2c 	lds	r31, 0x2CD3	; 0x802cd3 <pxCurrentTimerList+0x1>
    24be:	07 80       	ldd	r0, Z+7	; 0x07
    24c0:	f0 85       	ldd	r31, Z+8	; 0x08
    24c2:	e0 2d       	mov	r30, r0
    24c4:	80 84       	ldd	r8, Z+8	; 0x08
    24c6:	91 84       	ldd	r9, Z+9	; 0x09
    24c8:	c4 01       	movw	r24, r8
    24ca:	02 96       	adiw	r24, 0x02	; 2
    24cc:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    24d0:	d4 01       	movw	r26, r8
    24d2:	52 96       	adiw	r26, 0x12	; 18
    24d4:	8c 91       	ld	r24, X
    24d6:	52 97       	sbiw	r26, 0x12	; 18
    24d8:	81 30       	cpi	r24, 0x01	; 1
    24da:	01 f5       	brne	.+64     	; 0x251c <prvTimerTask+0xca>
    24dc:	1e 96       	adiw	r26, 0x0e	; 14
    24de:	4d 91       	ld	r20, X+
    24e0:	5d 91       	ld	r21, X+
    24e2:	6d 91       	ld	r22, X+
    24e4:	7c 91       	ld	r23, X
    24e6:	51 97       	sbiw	r26, 0x11	; 17
    24e8:	44 0d       	add	r20, r4
    24ea:	55 1d       	adc	r21, r5
    24ec:	66 1d       	adc	r22, r6
    24ee:	77 1d       	adc	r23, r7
    24f0:	73 01       	movw	r14, r6
    24f2:	62 01       	movw	r12, r4
    24f4:	0b 85       	ldd	r16, Y+11	; 0x0b
    24f6:	1c 85       	ldd	r17, Y+12	; 0x0c
    24f8:	2d 85       	ldd	r18, Y+13	; 0x0d
    24fa:	3e 85       	ldd	r19, Y+14	; 0x0e
    24fc:	c4 01       	movw	r24, r8
    24fe:	0e 94 a0 10 	call	0x2140	; 0x2140 <prvInsertTimerInActiveList>
    2502:	88 23       	and	r24, r24
    2504:	59 f0       	breq	.+22     	; 0x251c <prvTimerTask+0xca>
    2506:	c1 2c       	mov	r12, r1
    2508:	d1 2c       	mov	r13, r1
    250a:	76 01       	movw	r14, r12
    250c:	00 e0       	ldi	r16, 0x00	; 0
    250e:	10 e0       	ldi	r17, 0x00	; 0
    2510:	a3 01       	movw	r20, r6
    2512:	92 01       	movw	r18, r4
    2514:	60 e0       	ldi	r22, 0x00	; 0
    2516:	c4 01       	movw	r24, r8
    2518:	0e 94 38 11 	call	0x2270	; 0x2270 <xTimerGenericCommand>
    251c:	d4 01       	movw	r26, r8
    251e:	55 96       	adiw	r26, 0x15	; 21
    2520:	ed 91       	ld	r30, X+
    2522:	fc 91       	ld	r31, X
    2524:	56 97       	sbiw	r26, 0x16	; 22
    2526:	c4 01       	movw	r24, r8
    2528:	19 95       	eicall
    252a:	9c c0       	rjmp	.+312    	; 0x2664 <prvTimerTask+0x212>
    252c:	20 e0       	ldi	r18, 0x00	; 0
    252e:	b3 01       	movw	r22, r6
    2530:	a2 01       	movw	r20, r4
    2532:	8b 85       	ldd	r24, Y+11	; 0x0b
    2534:	9c 85       	ldd	r25, Y+12	; 0x0c
    2536:	ad 85       	ldd	r26, Y+13	; 0x0d
    2538:	be 85       	ldd	r27, Y+14	; 0x0e
    253a:	48 1b       	sub	r20, r24
    253c:	59 0b       	sbc	r21, r25
    253e:	6a 0b       	sbc	r22, r26
    2540:	7b 0b       	sbc	r23, r27
    2542:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    2546:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    254a:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <vQueueWaitForMessageRestricted>
    254e:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    2552:	81 11       	cpse	r24, r1
    2554:	87 c0       	rjmp	.+270    	; 0x2664 <prvTimerTask+0x212>
    2556:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    255a:	84 c0       	rjmp	.+264    	; 0x2664 <prvTimerTask+0x212>
    255c:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <xTaskResumeAll>
    2560:	81 c0       	rjmp	.+258    	; 0x2664 <prvTimerTask+0x212>
    2562:	89 81       	ldd	r24, Y+1	; 0x01
    2564:	88 23       	and	r24, r24
    2566:	6c f4       	brge	.+26     	; 0x2582 <prvTimerTask+0x130>
    2568:	4e 81       	ldd	r20, Y+6	; 0x06
    256a:	5f 81       	ldd	r21, Y+7	; 0x07
    256c:	68 85       	ldd	r22, Y+8	; 0x08
    256e:	79 85       	ldd	r23, Y+9	; 0x09
    2570:	ea 81       	ldd	r30, Y+2	; 0x02
    2572:	fb 81       	ldd	r31, Y+3	; 0x03
    2574:	8c 81       	ldd	r24, Y+4	; 0x04
    2576:	9d 81       	ldd	r25, Y+5	; 0x05
    2578:	19 95       	eicall
    257a:	89 81       	ldd	r24, Y+1	; 0x01
    257c:	88 23       	and	r24, r24
    257e:	0c f4       	brge	.+2      	; 0x2582 <prvTimerTask+0x130>
    2580:	71 c0       	rjmp	.+226    	; 0x2664 <prvTimerTask+0x212>
    2582:	8e 80       	ldd	r8, Y+6	; 0x06
    2584:	9f 80       	ldd	r9, Y+7	; 0x07
    2586:	d4 01       	movw	r26, r8
    2588:	1c 96       	adiw	r26, 0x0c	; 12
    258a:	8d 91       	ld	r24, X+
    258c:	9c 91       	ld	r25, X
    258e:	1d 97       	sbiw	r26, 0x0d	; 13
    2590:	89 2b       	or	r24, r25
    2592:	21 f0       	breq	.+8      	; 0x259c <prvTimerTask+0x14a>
    2594:	c4 01       	movw	r24, r8
    2596:	02 96       	adiw	r24, 0x02	; 2
    2598:	0e 94 98 05 	call	0xb30	; 0xb30 <uxListRemove>
    259c:	ce 01       	movw	r24, r28
    259e:	0a 96       	adiw	r24, 0x0a	; 10
    25a0:	0e 94 91 11 	call	0x2322	; 0x2322 <prvSampleTimeNow>
    25a4:	8b 01       	movw	r16, r22
    25a6:	9c 01       	movw	r18, r24
    25a8:	89 81       	ldd	r24, Y+1	; 0x01
    25aa:	08 2e       	mov	r0, r24
    25ac:	00 0c       	add	r0, r0
    25ae:	99 0b       	sbc	r25, r25
    25b0:	aa 0b       	sbc	r26, r26
    25b2:	bb 0b       	sbc	r27, r27
    25b4:	8a 30       	cpi	r24, 0x0A	; 10
    25b6:	91 05       	cpc	r25, r1
    25b8:	08 f0       	brcs	.+2      	; 0x25bc <prvTimerTask+0x16a>
    25ba:	54 c0       	rjmp	.+168    	; 0x2664 <prvTimerTask+0x212>
    25bc:	fc 01       	movw	r30, r24
    25be:	88 27       	eor	r24, r24
    25c0:	e2 50       	subi	r30, 0x02	; 2
    25c2:	ff 4f       	sbci	r31, 0xFF	; 255
    25c4:	8f 4f       	sbci	r24, 0xFF	; 255
    25c6:	0c 94 a3 20 	jmp	0x4146	; 0x4146 <__tablejump2__>
    25ca:	ca 80       	ldd	r12, Y+2	; 0x02
    25cc:	db 80       	ldd	r13, Y+3	; 0x03
    25ce:	ec 80       	ldd	r14, Y+4	; 0x04
    25d0:	fd 80       	ldd	r15, Y+5	; 0x05
    25d2:	f4 01       	movw	r30, r8
    25d4:	46 85       	ldd	r20, Z+14	; 0x0e
    25d6:	57 85       	ldd	r21, Z+15	; 0x0f
    25d8:	60 89       	ldd	r22, Z+16	; 0x10
    25da:	71 89       	ldd	r23, Z+17	; 0x11
    25dc:	4c 0d       	add	r20, r12
    25de:	5d 1d       	adc	r21, r13
    25e0:	6e 1d       	adc	r22, r14
    25e2:	7f 1d       	adc	r23, r15
    25e4:	c4 01       	movw	r24, r8
    25e6:	0e 94 a0 10 	call	0x2140	; 0x2140 <prvInsertTimerInActiveList>
    25ea:	88 23       	and	r24, r24
    25ec:	d9 f1       	breq	.+118    	; 0x2664 <prvTimerTask+0x212>
    25ee:	d4 01       	movw	r26, r8
    25f0:	55 96       	adiw	r26, 0x15	; 21
    25f2:	ed 91       	ld	r30, X+
    25f4:	fc 91       	ld	r31, X
    25f6:	56 97       	sbiw	r26, 0x16	; 22
    25f8:	c4 01       	movw	r24, r8
    25fa:	19 95       	eicall
    25fc:	f4 01       	movw	r30, r8
    25fe:	82 89       	ldd	r24, Z+18	; 0x12
    2600:	81 30       	cpi	r24, 0x01	; 1
    2602:	81 f5       	brne	.+96     	; 0x2664 <prvTimerTask+0x212>
    2604:	4a 81       	ldd	r20, Y+2	; 0x02
    2606:	5b 81       	ldd	r21, Y+3	; 0x03
    2608:	6c 81       	ldd	r22, Y+4	; 0x04
    260a:	7d 81       	ldd	r23, Y+5	; 0x05
    260c:	86 85       	ldd	r24, Z+14	; 0x0e
    260e:	97 85       	ldd	r25, Z+15	; 0x0f
    2610:	a0 89       	ldd	r26, Z+16	; 0x10
    2612:	b1 89       	ldd	r27, Z+17	; 0x11
    2614:	9a 01       	movw	r18, r20
    2616:	ab 01       	movw	r20, r22
    2618:	28 0f       	add	r18, r24
    261a:	39 1f       	adc	r19, r25
    261c:	4a 1f       	adc	r20, r26
    261e:	5b 1f       	adc	r21, r27
    2620:	c1 2c       	mov	r12, r1
    2622:	d1 2c       	mov	r13, r1
    2624:	76 01       	movw	r14, r12
    2626:	00 e0       	ldi	r16, 0x00	; 0
    2628:	10 e0       	ldi	r17, 0x00	; 0
    262a:	60 e0       	ldi	r22, 0x00	; 0
    262c:	c4 01       	movw	r24, r8
    262e:	0e 94 38 11 	call	0x2270	; 0x2270 <xTimerGenericCommand>
    2632:	18 c0       	rjmp	.+48     	; 0x2664 <prvTimerTask+0x212>
    2634:	4a 81       	ldd	r20, Y+2	; 0x02
    2636:	5b 81       	ldd	r21, Y+3	; 0x03
    2638:	6c 81       	ldd	r22, Y+4	; 0x04
    263a:	7d 81       	ldd	r23, Y+5	; 0x05
    263c:	d4 01       	movw	r26, r8
    263e:	1e 96       	adiw	r26, 0x0e	; 14
    2640:	4d 93       	st	X+, r20
    2642:	5d 93       	st	X+, r21
    2644:	6d 93       	st	X+, r22
    2646:	7c 93       	st	X, r23
    2648:	51 97       	sbiw	r26, 0x11	; 17
    264a:	40 0f       	add	r20, r16
    264c:	51 1f       	adc	r21, r17
    264e:	62 1f       	adc	r22, r18
    2650:	73 1f       	adc	r23, r19
    2652:	68 01       	movw	r12, r16
    2654:	79 01       	movw	r14, r18
    2656:	c4 01       	movw	r24, r8
    2658:	0e 94 a0 10 	call	0x2140	; 0x2140 <prvInsertTimerInActiveList>
    265c:	03 c0       	rjmp	.+6      	; 0x2664 <prvTimerTask+0x212>
    265e:	c4 01       	movw	r24, r8
    2660:	0e 94 24 05 	call	0xa48	; 0xa48 <vPortFree>
    2664:	20 e0       	ldi	r18, 0x00	; 0
    2666:	30 e0       	ldi	r19, 0x00	; 0
    2668:	a9 01       	movw	r20, r18
    266a:	6a 2d       	mov	r22, r10
    266c:	7b 2d       	mov	r23, r11
    266e:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    2672:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    2676:	0e 94 a4 09 	call	0x1348	; 0x1348 <xQueueReceive>
    267a:	81 11       	cpse	r24, r1
    267c:	72 cf       	rjmp	.-284    	; 0x2562 <prvTimerTask+0x110>
    267e:	f5 ce       	rjmp	.-534    	; 0x246a <prvTimerTask+0x18>
    2680:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskSuspendAll>
    2684:	c1 01       	movw	r24, r2
    2686:	0e 94 91 11 	call	0x2322	; 0x2322 <prvSampleTimeNow>
    268a:	6b 87       	std	Y+11, r22	; 0x0b
    268c:	7c 87       	std	Y+12, r23	; 0x0c
    268e:	8d 87       	std	Y+13, r24	; 0x0d
    2690:	9e 87       	std	Y+14, r25	; 0x0e
    2692:	89 81       	ldd	r24, Y+1	; 0x01
    2694:	81 11       	cpse	r24, r1
    2696:	62 cf       	rjmp	.-316    	; 0x255c <prvTimerTask+0x10a>
    2698:	e0 91 d0 2c 	lds	r30, 0x2CD0	; 0x802cd0 <pxOverflowTimerList>
    269c:	f0 91 d1 2c 	lds	r31, 0x2CD1	; 0x802cd1 <pxOverflowTimerList+0x1>
    26a0:	80 81       	ld	r24, Z
    26a2:	21 e0       	ldi	r18, 0x01	; 1
    26a4:	81 11       	cpse	r24, r1
    26a6:	20 e0       	ldi	r18, 0x00	; 0
    26a8:	41 2c       	mov	r4, r1
    26aa:	51 2c       	mov	r5, r1
    26ac:	32 01       	movw	r6, r4
    26ae:	3f cf       	rjmp	.-386    	; 0x252e <prvTimerTask+0xdc>

000026b0 <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
    26b0:	0f 93       	push	r16
    26b2:	1f 93       	push	r17
    26b4:	cf 93       	push	r28
    26b6:	df 93       	push	r29
    26b8:	cd b7       	in	r28, 0x3d	; 61
    26ba:	de b7       	in	r29, 0x3e	; 62
    26bc:	29 97       	sbiw	r28, 0x09	; 9
    26be:	cd bf       	out	0x3d, r28	; 61
    26c0:	de bf       	out	0x3e, r29	; 62
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    26c2:	ee ef       	ldi	r30, 0xFE	; 254
    26c4:	e9 83       	std	Y+1, r30	; 0x01
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    26c6:	8a 83       	std	Y+2, r24	; 0x02
    26c8:	9b 83       	std	Y+3, r25	; 0x03
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    26ca:	6c 83       	std	Y+4, r22	; 0x04
    26cc:	7d 83       	std	Y+5, r23	; 0x05
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    26ce:	2e 83       	std	Y+6, r18	; 0x06
    26d0:	3f 83       	std	Y+7, r19	; 0x07
    26d2:	48 87       	std	Y+8, r20	; 0x08
    26d4:	59 87       	std	Y+9, r21	; 0x09

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    26d6:	20 e0       	ldi	r18, 0x00	; 0
    26d8:	a8 01       	movw	r20, r16
    26da:	be 01       	movw	r22, r28
    26dc:	6f 5f       	subi	r22, 0xFF	; 255
    26de:	7f 4f       	sbci	r23, 0xFF	; 255
    26e0:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    26e4:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    26e8:	0e 94 5f 09 	call	0x12be	; 0x12be <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
    26ec:	29 96       	adiw	r28, 0x09	; 9
    26ee:	cd bf       	out	0x3d, r28	; 61
    26f0:	de bf       	out	0x3e, r29	; 62
    26f2:	df 91       	pop	r29
    26f4:	cf 91       	pop	r28
    26f6:	1f 91       	pop	r17
    26f8:	0f 91       	pop	r16
    26fa:	08 95       	ret

000026fc <vInitClock>:
#include "clksys_driver.h"


void vInitClock(void)
{
	CLKSYS_Enable( OSC_RC2MEN_bm );
    26fc:	e0 e5       	ldi	r30, 0x50	; 80
    26fe:	f0 e0       	ldi	r31, 0x00	; 0
    2700:	80 81       	ld	r24, Z
    2702:	81 60       	ori	r24, 0x01	; 1
    2704:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC2MRDY_bm ) == 0 );
    2706:	81 81       	ldd	r24, Z+1	; 0x01
    2708:	80 ff       	sbrs	r24, 0
    270a:	fd cf       	rjmp	.-6      	; 0x2706 <vInitClock+0xa>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC2M_gc );
    270c:	80 e0       	ldi	r24, 0x00	; 0
    270e:	0e 94 30 03 	call	0x660	; 0x660 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
    2712:	8e e1       	ldi	r24, 0x1E	; 30
    2714:	0e 94 20 03 	call	0x640	; 0x640 <CLKSYS_Disable>
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    2718:	60 e0       	ldi	r22, 0x00	; 0
    271a:	80 e0       	ldi	r24, 0x00	; 0
    271c:	0e 94 2a 03 	call	0x654	; 0x654 <CLKSYS_Prescalers_Config>
	CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,false,OSC_XOSCSEL_XTAL_256CLK_gc );
    2720:	43 e0       	ldi	r20, 0x03	; 3
    2722:	60 e0       	ldi	r22, 0x00	; 0
    2724:	80 e4       	ldi	r24, 0x40	; 64
    2726:	0e 94 11 03 	call	0x622	; 0x622 <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
    272a:	e0 e5       	ldi	r30, 0x50	; 80
    272c:	f0 e0       	ldi	r31, 0x00	; 0
    272e:	80 81       	ld	r24, Z
    2730:	88 60       	ori	r24, 0x08	; 8
    2732:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    2734:	81 81       	ldd	r24, Z+1	; 0x01
    2736:	83 ff       	sbrs	r24, 3
    2738:	fd cf       	rjmp	.-6      	; 0x2734 <vInitClock+0x38>
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 4 );
    273a:	64 e0       	ldi	r22, 0x04	; 4
    273c:	80 ec       	ldi	r24, 0xC0	; 192
    273e:	0e 94 1b 03 	call	0x636	; 0x636 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    2742:	e0 e5       	ldi	r30, 0x50	; 80
    2744:	f0 e0       	ldi	r31, 0x00	; 0
    2746:	80 81       	ld	r24, Z
    2748:	80 61       	ori	r24, 0x10	; 16
    274a:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    274c:	60 e0       	ldi	r22, 0x00	; 0
    274e:	80 e0       	ldi	r24, 0x00	; 0
    2750:	0e 94 2a 03 	call	0x654	; 0x654 <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    2754:	e0 e5       	ldi	r30, 0x50	; 80
    2756:	f0 e0       	ldi	r31, 0x00	; 0
    2758:	81 81       	ldd	r24, Z+1	; 0x01
    275a:	84 ff       	sbrs	r24, 4
    275c:	fd cf       	rjmp	.-6      	; 0x2758 <vInitClock+0x5c>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    275e:	84 e0       	ldi	r24, 0x04	; 4
    2760:	0e 94 30 03 	call	0x660	; 0x660 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm);
    2764:	87 e0       	ldi	r24, 0x07	; 7
    2766:	0e 94 20 03 	call	0x640	; 0x640 <CLKSYS_Disable>
    276a:	08 95       	ret

0000276c <vLedBlink>:
	return 0;
}

void vLedBlink(void *pvParameters) {
	(void) pvParameters;
	PORTE.DIRSET = PIN3_bm; /*LED1*/
    276c:	e0 e8       	ldi	r30, 0x80	; 128
    276e:	f6 e0       	ldi	r31, 0x06	; 6
    2770:	88 e0       	ldi	r24, 0x08	; 8
    2772:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUT = 0x08;
    2774:	84 83       	std	Z+4, r24	; 0x04
	for(;;) {
		PORTE.OUTTGL = 0x08;				
    2776:	00 e8       	ldi	r16, 0x80	; 128
    2778:	16 e0       	ldi	r17, 0x06	; 6
    277a:	c8 e0       	ldi	r28, 0x08	; 8
    277c:	f8 01       	movw	r30, r16
    277e:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(100 / portTICK_RATE_MS);
    2780:	64 e6       	ldi	r22, 0x64	; 100
    2782:	70 e0       	ldi	r23, 0x00	; 0
    2784:	80 e0       	ldi	r24, 0x00	; 0
    2786:	90 e0       	ldi	r25, 0x00	; 0
    2788:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskDelay>
    278c:	f7 cf       	rjmp	.-18     	; 0x277c <vLedBlink+0x10>

0000278e <vWrite_Display>:

	for (;;)
	{
		
			vDisplayClear();
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    278e:	0f 2e       	mov	r0, r31
    2790:	fe e0       	ldi	r31, 0x0E	; 14
    2792:	ef 2e       	mov	r14, r31
    2794:	f0 e2       	ldi	r31, 0x20	; 32
    2796:	ff 2e       	mov	r15, r31
    2798:	f0 2d       	mov	r31, r0
			vDisplayWriteStringAtPos(1,0,"a: %d b: %d",buffer_a[1],buffer_b[1]);
    279a:	0f 2e       	mov	r0, r31
    279c:	fc ec       	ldi	r31, 0xCC	; 204
    279e:	af 2e       	mov	r10, r31
    27a0:	f0 e3       	ldi	r31, 0x30	; 48
    27a2:	bf 2e       	mov	r11, r31
    27a4:	f0 2d       	mov	r31, r0
    27a6:	0f 2e       	mov	r0, r31
    27a8:	fc e0       	ldi	r31, 0x0C	; 12
    27aa:	cf 2e       	mov	r12, r31
    27ac:	f1 e3       	ldi	r31, 0x31	; 49
    27ae:	df 2e       	mov	r13, r31
    27b0:	f0 2d       	mov	r31, r0
    27b2:	0e e1       	ldi	r16, 0x1E	; 30
    27b4:	10 e2       	ldi	r17, 0x20	; 32
    27b6:	88 24       	eor	r8, r8
    27b8:	83 94       	inc	r8
			vDisplayWriteStringAtPos(2,0,"H: %d L: %d ",high_peak, low_peak);
    27ba:	ca e2       	ldi	r28, 0x2A	; 42
    27bc:	d0 e2       	ldi	r29, 0x20	; 32
    27be:	68 94       	set
    27c0:	99 24       	eor	r9, r9
    27c2:	91 f8       	bld	r9, 1
void vWrite_Display(void *pvParameters){

	for (;;)
	{
		
			vDisplayClear();
    27c4:	0e 94 43 17 	call	0x2e86	; 0x2e86 <vDisplayClear>
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    27c8:	ff 92       	push	r15
    27ca:	ef 92       	push	r14
    27cc:	1f 92       	push	r1
    27ce:	1f 92       	push	r1
    27d0:	1f 92       	push	r1
    27d2:	1f 92       	push	r1
    27d4:	0e 94 4e 17 	call	0x2e9c	; 0x2e9c <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(1,0,"a: %d b: %d",buffer_a[1],buffer_b[1]);
    27d8:	f5 01       	movw	r30, r10
    27da:	91 81       	ldd	r25, Z+1	; 0x01
    27dc:	f6 01       	movw	r30, r12
    27de:	81 81       	ldd	r24, Z+1	; 0x01
    27e0:	1f 92       	push	r1
    27e2:	9f 93       	push	r25
    27e4:	1f 92       	push	r1
    27e6:	8f 93       	push	r24
    27e8:	1f 93       	push	r17
    27ea:	0f 93       	push	r16
    27ec:	1f 92       	push	r1
    27ee:	1f 92       	push	r1
    27f0:	1f 92       	push	r1
    27f2:	8f 92       	push	r8
    27f4:	0e 94 4e 17 	call	0x2e9c	; 0x2e9c <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(2,0,"H: %d L: %d ",high_peak, low_peak);
    27f8:	80 91 d4 31 	lds	r24, 0x31D4	; 0x8031d4 <low_peak+0x1>
    27fc:	8f 93       	push	r24
    27fe:	80 91 d3 31 	lds	r24, 0x31D3	; 0x8031d3 <low_peak>
    2802:	8f 93       	push	r24
    2804:	80 91 d8 31 	lds	r24, 0x31D8	; 0x8031d8 <high_peak+0x1>
    2808:	8f 93       	push	r24
    280a:	80 91 d7 31 	lds	r24, 0x31D7	; 0x8031d7 <high_peak>
    280e:	8f 93       	push	r24
    2810:	df 93       	push	r29
    2812:	cf 93       	push	r28
    2814:	1f 92       	push	r1
    2816:	1f 92       	push	r1
    2818:	1f 92       	push	r1
    281a:	9f 92       	push	r9
    281c:	0e 94 4e 17 	call	0x2e9c	; 0x2e9c <vDisplayWriteStringAtPos>
			//vDisplayWriteStringAtPos(3,0,"Control: %lu ",control_result );
			//vDisplayWriteStringAtPos(3,0,"Hoi");
			vTaskStartScheduler();
    2820:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskStartScheduler>
			vTaskDelay(100 / portTICK_RATE_MS);
    2824:	64 e6       	ldi	r22, 0x64	; 100
    2826:	70 e0       	ldi	r23, 0x00	; 0
    2828:	80 e0       	ldi	r24, 0x00	; 0
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskDelay>
    2830:	ed b7       	in	r30, 0x3d	; 61
    2832:	fe b7       	in	r31, 0x3e	; 62
    2834:	7a 96       	adiw	r30, 0x1a	; 26
    2836:	ed bf       	out	0x3d, r30	; 61
    2838:	fe bf       	out	0x3e, r31	; 62
    283a:	c4 cf       	rjmp	.-120    	; 0x27c4 <vWrite_Display+0x36>

0000283c <vApplicationIdleHook>:
TaskHandle_t my_Display;
TaskHandle_t TaskDMAHandler;


void vApplicationIdleHook( void )
{	
    283c:	08 95       	ret

0000283e <main>:
	
}

int main(void)
{
    283e:	ef 92       	push	r14
    2840:	ff 92       	push	r15
    2842:	0f 93       	push	r16
    2844:	cf 93       	push	r28
    resetReason_t reason = getResetReason();
    2846:	0e 94 2b 1e 	call	0x3c56	; 0x3c56 <getResetReason>
    284a:	c8 2f       	mov	r28, r24

	vInitClock();
    284c:	0e 94 7e 13 	call	0x26fc	; 0x26fc <vInitClock>
	vInitDisplay();
    2850:	0e 94 c7 15 	call	0x2b8e	; 0x2b8e <vInitDisplay>
	
	xTaskCreate( vLedBlink, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+10, NULL, 1, &ledTask);
    2854:	0f 2e       	mov	r0, r31
    2856:	fd ec       	ldi	r31, 0xCD	; 205
    2858:	ef 2e       	mov	r14, r31
    285a:	f1 e3       	ldi	r31, 0x31	; 49
    285c:	ff 2e       	mov	r15, r31
    285e:	f0 2d       	mov	r31, r0
    2860:	01 e0       	ldi	r16, 0x01	; 1
    2862:	20 e0       	ldi	r18, 0x00	; 0
    2864:	30 e0       	ldi	r19, 0x00	; 0
    2866:	42 ed       	ldi	r20, 0xD2	; 210
    2868:	50 e0       	ldi	r21, 0x00	; 0
    286a:	67 e3       	ldi	r22, 0x37	; 55
    286c:	70 e2       	ldi	r23, 0x20	; 32
    286e:	86 eb       	ldi	r24, 0xB6	; 182
    2870:	93 e1       	ldi	r25, 0x13	; 19
    2872:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskCreate>
	xTaskCreate( vRead_Peaks, (const char *) "read_Peaks", configMINIMAL_STACK_SIZE+100, NULL, 1, &my_read_Peaks);
    2876:	0f 2e       	mov	r0, r31
    2878:	f1 ed       	ldi	r31, 0xD1	; 209
    287a:	ef 2e       	mov	r14, r31
    287c:	f1 e3       	ldi	r31, 0x31	; 49
    287e:	ff 2e       	mov	r15, r31
    2880:	f0 2d       	mov	r31, r0
    2882:	20 e0       	ldi	r18, 0x00	; 0
    2884:	30 e0       	ldi	r19, 0x00	; 0
    2886:	4c e2       	ldi	r20, 0x2C	; 44
    2888:	51 e0       	ldi	r21, 0x01	; 1
    288a:	60 e4       	ldi	r22, 0x40	; 64
    288c:	70 e2       	ldi	r23, 0x20	; 32
    288e:	87 e3       	ldi	r24, 0x37	; 55
    2890:	9c e1       	ldi	r25, 0x1C	; 28
    2892:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskCreate>
	xTaskCreate( vPhase_Detection, (const char *) "phase_detect", configMINIMAL_STACK_SIZE+10, NULL, 1, &my_phase_detection);
    2896:	0f 2e       	mov	r0, r31
    2898:	ff ec       	ldi	r31, 0xCF	; 207
    289a:	ef 2e       	mov	r14, r31
    289c:	f1 e3       	ldi	r31, 0x31	; 49
    289e:	ff 2e       	mov	r15, r31
    28a0:	f0 2d       	mov	r31, r0
    28a2:	20 e0       	ldi	r18, 0x00	; 0
    28a4:	30 e0       	ldi	r19, 0x00	; 0
    28a6:	42 ed       	ldi	r20, 0xD2	; 210
    28a8:	50 e0       	ldi	r21, 0x00	; 0
    28aa:	6b e4       	ldi	r22, 0x4B	; 75
    28ac:	70 e2       	ldi	r23, 0x20	; 32
    28ae:	81 ef       	ldi	r24, 0xF1	; 241
    28b0:	9a e1       	ldi	r25, 0x1A	; 26
    28b2:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskCreate>
	xTaskCreate( vWrite_Display, (const char *) "display", configMINIMAL_STACK_SIZE+10, NULL, 1, &my_Display);
    28b6:	0f 2e       	mov	r0, r31
    28b8:	f9 e5       	ldi	r31, 0x59	; 89
    28ba:	ef 2e       	mov	r14, r31
    28bc:	f2 e3       	ldi	r31, 0x32	; 50
    28be:	ff 2e       	mov	r15, r31
    28c0:	f0 2d       	mov	r31, r0
    28c2:	20 e0       	ldi	r18, 0x00	; 0
    28c4:	30 e0       	ldi	r19, 0x00	; 0
    28c6:	42 ed       	ldi	r20, 0xD2	; 210
    28c8:	50 e0       	ldi	r21, 0x00	; 0
    28ca:	68 e5       	ldi	r22, 0x58	; 88
    28cc:	70 e2       	ldi	r23, 0x20	; 32
    28ce:	87 ec       	ldi	r24, 0xC7	; 199
    28d0:	93 e1       	ldi	r25, 0x13	; 19
    28d2:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskCreate>
	xTaskCreate( vTask_DMAHandler, (const char *) "dmaHandler", configMINIMAL_STACK_SIZE + 100, NULL, 1, &TaskDMAHandler);		
    28d6:	0f 2e       	mov	r0, r31
    28d8:	fb e5       	ldi	r31, 0x5B	; 91
    28da:	ef 2e       	mov	r14, r31
    28dc:	f2 e3       	ldi	r31, 0x32	; 50
    28de:	ff 2e       	mov	r15, r31
    28e0:	f0 2d       	mov	r31, r0
    28e2:	20 e0       	ldi	r18, 0x00	; 0
    28e4:	30 e0       	ldi	r19, 0x00	; 0
    28e6:	4c e2       	ldi	r20, 0x2C	; 44
    28e8:	51 e0       	ldi	r21, 0x01	; 1
    28ea:	60 e6       	ldi	r22, 0x60	; 96
    28ec:	70 e2       	ldi	r23, 0x20	; 32
    28ee:	86 e4       	ldi	r24, 0x46	; 70
    28f0:	92 e0       	ldi	r25, 0x02	; 2
    28f2:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskCreate>
	xSignalProcessEventGroup = xEventGroupCreate();
    28f6:	0e 94 61 03 	call	0x6c2	; 0x6c2 <xEventGroupCreate>
    28fa:	80 93 4e 2e 	sts	0x2E4E, r24	; 0x802e4e <xSignalProcessEventGroup>
    28fe:	90 93 4f 2e 	sts	0x2E4F, r25	; 0x802e4f <xSignalProcessEventGroup+0x1>
	xPhaseDetectionEventGroup = xEventGroupCreate();
    2902:	0e 94 61 03 	call	0x6c2	; 0x6c2 <xEventGroupCreate>
    2906:	80 93 d5 31 	sts	0x31D5, r24	; 0x8031d5 <xPhaseDetectionEventGroup>
    290a:	90 93 d6 31 	sts	0x31D6, r25	; 0x8031d6 <xPhaseDetectionEventGroup+0x1>
	vInitDMA();			
    290e:	0e 94 6d 01 	call	0x2da	; 0x2da <vInitDMA>

	vDisplayClear();
    2912:	0e 94 43 17 	call	0x2e86	; 0x2e86 <vDisplayClear>
	vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    2916:	8e e0       	ldi	r24, 0x0E	; 14
    2918:	90 e2       	ldi	r25, 0x20	; 32
    291a:	9f 93       	push	r25
    291c:	8f 93       	push	r24
    291e:	1f 92       	push	r1
    2920:	1f 92       	push	r1
    2922:	1f 92       	push	r1
    2924:	1f 92       	push	r1
    2926:	0e 94 4e 17 	call	0x2e9c	; 0x2e9c <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(1,0,"EDUBoard 1.0");
    292a:	8b e6       	ldi	r24, 0x6B	; 107
    292c:	90 e2       	ldi	r25, 0x20	; 32
    292e:	9f 93       	push	r25
    2930:	8f 93       	push	r24
    2932:	1f 92       	push	r1
    2934:	1f 92       	push	r1
    2936:	1f 92       	push	r1
    2938:	81 e0       	ldi	r24, 0x01	; 1
    293a:	8f 93       	push	r24
    293c:	0e 94 4e 17 	call	0x2e9c	; 0x2e9c <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(2,0,"Template");
    2940:	88 e7       	ldi	r24, 0x78	; 120
    2942:	90 e2       	ldi	r25, 0x20	; 32
    2944:	9f 93       	push	r25
    2946:	8f 93       	push	r24
    2948:	1f 92       	push	r1
    294a:	1f 92       	push	r1
    294c:	1f 92       	push	r1
    294e:	82 e0       	ldi	r24, 0x02	; 2
    2950:	8f 93       	push	r24
    2952:	0e 94 4e 17 	call	0x2e9c	; 0x2e9c <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(3,0,"ResetReason: %d", reason);
    2956:	1f 92       	push	r1
    2958:	cf 93       	push	r28
    295a:	81 e8       	ldi	r24, 0x81	; 129
    295c:	90 e2       	ldi	r25, 0x20	; 32
    295e:	9f 93       	push	r25
    2960:	8f 93       	push	r24
    2962:	1f 92       	push	r1
    2964:	1f 92       	push	r1
    2966:	1f 92       	push	r1
    2968:	83 e0       	ldi	r24, 0x03	; 3
    296a:	8f 93       	push	r24
    296c:	0e 94 4e 17 	call	0x2e9c	; 0x2e9c <vDisplayWriteStringAtPos>
	vTaskStartScheduler();
    2970:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskStartScheduler>
    2974:	8d b7       	in	r24, 0x3d	; 61
    2976:	9e b7       	in	r25, 0x3e	; 62
    2978:	4a 96       	adiw	r24, 0x1a	; 26
    297a:	8d bf       	out	0x3d, r24	; 61
    297c:	9e bf       	out	0x3e, r25	; 62
	return 0;
}
    297e:	80 e0       	ldi	r24, 0x00	; 0
    2980:	90 e0       	ldi	r25, 0x00	; 0
    2982:	cf 91       	pop	r28
    2984:	0f 91       	pop	r16
    2986:	ff 90       	pop	r15
    2988:	ef 90       	pop	r14
    298a:	08 95       	ret

0000298c <__vector_108>:
 void displayHome() {
	 command(0x02);
 }
 void _displayClear() {
	 command(0x01);
	 delayUS(2000);
    298c:	1f 92       	push	r1
    298e:	0f 92       	push	r0
    2990:	0f b6       	in	r0, 0x3f	; 63
    2992:	0f 92       	push	r0
    2994:	11 24       	eor	r1, r1
    2996:	0b b6       	in	r0, 0x3b	; 59
    2998:	0f 92       	push	r0
    299a:	2f 93       	push	r18
    299c:	3f 93       	push	r19
    299e:	4f 93       	push	r20
    29a0:	5f 93       	push	r21
    29a2:	6f 93       	push	r22
    29a4:	7f 93       	push	r23
    29a6:	8f 93       	push	r24
    29a8:	9f 93       	push	r25
    29aa:	af 93       	push	r26
    29ac:	bf 93       	push	r27
    29ae:	ef 93       	push	r30
    29b0:	ff 93       	push	r31
    29b2:	cf 93       	push	r28
    29b4:	df 93       	push	r29
    29b6:	1f 92       	push	r1
    29b8:	cd b7       	in	r28, 0x3d	; 61
    29ba:	de b7       	in	r29, 0x3e	; 62
    29bc:	19 82       	std	Y+1, r1	; 0x01
    29be:	9e 01       	movw	r18, r28
    29c0:	2f 5f       	subi	r18, 0xFF	; 255
    29c2:	3f 4f       	sbci	r19, 0xFF	; 255
    29c4:	41 e0       	ldi	r20, 0x01	; 1
    29c6:	50 e0       	ldi	r21, 0x00	; 0
    29c8:	60 e0       	ldi	r22, 0x00	; 0
    29ca:	70 e0       	ldi	r23, 0x00	; 0
    29cc:	80 91 5f 32 	lds	r24, 0x325F	; 0x80325f <egDisplayTiming>
    29d0:	90 91 60 32 	lds	r25, 0x3260	; 0x803260 <egDisplayTiming+0x1>
    29d4:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <xEventGroupSetBitsFromISR>
    29d8:	60 e0       	ldi	r22, 0x00	; 0
    29da:	80 e0       	ldi	r24, 0x00	; 0
    29dc:	9b e0       	ldi	r25, 0x0B	; 11
    29de:	0e 94 45 03 	call	0x68a	; 0x68a <TC0_ConfigClockSource>
    29e2:	10 92 06 0b 	sts	0x0B06, r1	; 0x800b06 <__TEXT_REGION_LENGTH__+0x700b06>
    29e6:	0f 90       	pop	r0
    29e8:	df 91       	pop	r29
    29ea:	cf 91       	pop	r28
    29ec:	ff 91       	pop	r31
    29ee:	ef 91       	pop	r30
    29f0:	bf 91       	pop	r27
    29f2:	af 91       	pop	r26
    29f4:	9f 91       	pop	r25
    29f6:	8f 91       	pop	r24
    29f8:	7f 91       	pop	r23
    29fa:	6f 91       	pop	r22
    29fc:	5f 91       	pop	r21
    29fe:	4f 91       	pop	r20
    2a00:	3f 91       	pop	r19
    2a02:	2f 91       	pop	r18
    2a04:	0f 90       	pop	r0
    2a06:	0b be       	out	0x3b, r0	; 59
    2a08:	0f 90       	pop	r0
    2a0a:	0f be       	out	0x3f, r0	; 63
    2a0c:	0f 90       	pop	r0
    2a0e:	1f 90       	pop	r1
    2a10:	18 95       	reti

00002a12 <delayUS>:
    2a12:	cf 92       	push	r12
    2a14:	df 92       	push	r13
    2a16:	ef 92       	push	r14
    2a18:	ff 92       	push	r15
    2a1a:	0f 93       	push	r16
    2a1c:	6b 01       	movw	r12, r22
    2a1e:	7c 01       	movw	r14, r24
    2a20:	82 e0       	ldi	r24, 0x02	; 2
    2a22:	c8 16       	cp	r12, r24
    2a24:	d1 04       	cpc	r13, r1
    2a26:	e1 04       	cpc	r14, r1
    2a28:	f1 04       	cpc	r15, r1
    2a2a:	08 f4       	brcc	.+2      	; 0x2a2e <delayUS+0x1c>
    2a2c:	4e c0       	rjmp	.+156    	; 0x2aca <delayUS+0xb8>
    2a2e:	e0 e0       	ldi	r30, 0x00	; 0
    2a30:	fb e0       	ldi	r31, 0x0B	; 11
    2a32:	81 e0       	ldi	r24, 0x01	; 1
    2a34:	86 83       	std	Z+6, r24	; 0x06
    2a36:	10 a2       	std	Z+32, r1	; 0x20
    2a38:	11 a2       	std	Z+33, r1	; 0x21
    2a3a:	60 e0       	ldi	r22, 0x00	; 0
    2a3c:	80 e0       	ldi	r24, 0x00	; 0
    2a3e:	9b e0       	ldi	r25, 0x0B	; 11
    2a40:	0e 94 4b 03 	call	0x696	; 0x696 <TC0_ConfigWGM>
    2a44:	8e ef       	ldi	r24, 0xFE	; 254
    2a46:	c8 16       	cp	r12, r24
    2a48:	8f ef       	ldi	r24, 0xFF	; 255
    2a4a:	d8 06       	cpc	r13, r24
    2a4c:	e1 04       	cpc	r14, r1
    2a4e:	f1 04       	cpc	r15, r1
    2a50:	70 f4       	brcc	.+28     	; 0x2a6e <delayUS+0x5c>
    2a52:	f6 94       	lsr	r15
    2a54:	e7 94       	ror	r14
    2a56:	d7 94       	ror	r13
    2a58:	c7 94       	ror	r12
    2a5a:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2a5e:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2a62:	65 e0       	ldi	r22, 0x05	; 5
    2a64:	80 e0       	ldi	r24, 0x00	; 0
    2a66:	9b e0       	ldi	r25, 0x0B	; 11
    2a68:	0e 94 45 03 	call	0x68a	; 0x68a <TC0_ConfigClockSource>
    2a6c:	19 c0       	rjmp	.+50     	; 0x2aa0 <delayUS+0x8e>
    2a6e:	80 e4       	ldi	r24, 0x40	; 64
    2a70:	c8 16       	cp	r12, r24
    2a72:	82 e4       	ldi	r24, 0x42	; 66
    2a74:	d8 06       	cpc	r13, r24
    2a76:	8f e0       	ldi	r24, 0x0F	; 15
    2a78:	e8 06       	cpc	r14, r24
    2a7a:	f1 04       	cpc	r15, r1
    2a7c:	88 f4       	brcc	.+34     	; 0x2aa0 <delayUS+0x8e>
    2a7e:	68 94       	set
    2a80:	14 f8       	bld	r1, 4
    2a82:	f6 94       	lsr	r15
    2a84:	e7 94       	ror	r14
    2a86:	d7 94       	ror	r13
    2a88:	c7 94       	ror	r12
    2a8a:	16 94       	lsr	r1
    2a8c:	d1 f7       	brne	.-12     	; 0x2a82 <delayUS+0x70>
    2a8e:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2a92:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2a96:	67 e0       	ldi	r22, 0x07	; 7
    2a98:	80 e0       	ldi	r24, 0x00	; 0
    2a9a:	9b e0       	ldi	r25, 0x0B	; 11
    2a9c:	0e 94 45 03 	call	0x68a	; 0x68a <TC0_ConfigClockSource>
    2aa0:	0f 2e       	mov	r0, r31
    2aa2:	f4 ef       	ldi	r31, 0xF4	; 244
    2aa4:	cf 2e       	mov	r12, r31
    2aa6:	dd 24       	eor	r13, r13
    2aa8:	d3 94       	inc	r13
    2aaa:	e1 2c       	mov	r14, r1
    2aac:	f1 2c       	mov	r15, r1
    2aae:	f0 2d       	mov	r31, r0
    2ab0:	00 e0       	ldi	r16, 0x00	; 0
    2ab2:	21 e0       	ldi	r18, 0x01	; 1
    2ab4:	41 e0       	ldi	r20, 0x01	; 1
    2ab6:	50 e0       	ldi	r21, 0x00	; 0
    2ab8:	60 e0       	ldi	r22, 0x00	; 0
    2aba:	70 e0       	ldi	r23, 0x00	; 0
    2abc:	80 91 5f 32 	lds	r24, 0x325F	; 0x80325f <egDisplayTiming>
    2ac0:	90 91 60 32 	lds	r25, 0x3260	; 0x803260 <egDisplayTiming+0x1>
    2ac4:	0e 94 76 03 	call	0x6ec	; 0x6ec <xEventGroupWaitBits>
    2ac8:	11 c0       	rjmp	.+34     	; 0x2aec <delayUS+0xda>
    2aca:	e0 e0       	ldi	r30, 0x00	; 0
    2acc:	fb e0       	ldi	r31, 0x0B	; 11
    2ace:	81 e0       	ldi	r24, 0x01	; 1
    2ad0:	86 83       	std	Z+6, r24	; 0x06
    2ad2:	10 a2       	std	Z+32, r1	; 0x20
    2ad4:	11 a2       	std	Z+33, r1	; 0x21
    2ad6:	60 e0       	ldi	r22, 0x00	; 0
    2ad8:	80 e0       	ldi	r24, 0x00	; 0
    2ada:	9b e0       	ldi	r25, 0x0B	; 11
    2adc:	0e 94 4b 03 	call	0x696	; 0x696 <TC0_ConfigWGM>
    2ae0:	c1 2c       	mov	r12, r1
    2ae2:	d1 2c       	mov	r13, r1
    2ae4:	76 01       	movw	r14, r12
    2ae6:	68 94       	set
    2ae8:	c1 f8       	bld	r12, 1
    2aea:	b3 cf       	rjmp	.-154    	; 0x2a52 <delayUS+0x40>
    2aec:	0f 91       	pop	r16
    2aee:	ff 90       	pop	r15
    2af0:	ef 90       	pop	r14
    2af2:	df 90       	pop	r13
    2af4:	cf 90       	pop	r12
    2af6:	08 95       	ret

00002af8 <setPort>:
    2af8:	82 95       	swap	r24
    2afa:	80 7f       	andi	r24, 0xF0	; 240
    2afc:	e0 e0       	ldi	r30, 0x00	; 0
    2afe:	f6 e0       	ldi	r31, 0x06	; 6
    2b00:	94 81       	ldd	r25, Z+4	; 0x04
    2b02:	28 2f       	mov	r18, r24
    2b04:	2f 60       	ori	r18, 0x0F	; 15
    2b06:	92 23       	and	r25, r18
    2b08:	94 83       	std	Z+4, r25	; 0x04
    2b0a:	94 81       	ldd	r25, Z+4	; 0x04
    2b0c:	89 2b       	or	r24, r25
    2b0e:	84 83       	std	Z+4, r24	; 0x04
    2b10:	08 95       	ret

00002b12 <Nybble>:
    2b12:	1f 93       	push	r17
    2b14:	cf 93       	push	r28
    2b16:	df 93       	push	r29
    2b18:	c0 e6       	ldi	r28, 0x60	; 96
    2b1a:	d6 e0       	ldi	r29, 0x06	; 6
    2b1c:	14 e0       	ldi	r17, 0x04	; 4
    2b1e:	1d 83       	std	Y+5, r17	; 0x05
    2b20:	61 e0       	ldi	r22, 0x01	; 1
    2b22:	70 e0       	ldi	r23, 0x00	; 0
    2b24:	80 e0       	ldi	r24, 0x00	; 0
    2b26:	90 e0       	ldi	r25, 0x00	; 0
    2b28:	0e 94 09 15 	call	0x2a12	; 0x2a12 <delayUS>
    2b2c:	1e 83       	std	Y+6, r17	; 0x06
    2b2e:	df 91       	pop	r29
    2b30:	cf 91       	pop	r28
    2b32:	1f 91       	pop	r17
    2b34:	08 95       	ret

00002b36 <command>:
    2b36:	cf 93       	push	r28
    2b38:	c8 2f       	mov	r28, r24
    2b3a:	82 95       	swap	r24
    2b3c:	8f 70       	andi	r24, 0x0F	; 15
    2b3e:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <setPort>
    2b42:	e0 e6       	ldi	r30, 0x60	; 96
    2b44:	f6 e0       	ldi	r31, 0x06	; 6
    2b46:	81 e0       	ldi	r24, 0x01	; 1
    2b48:	86 83       	std	Z+6, r24	; 0x06
    2b4a:	82 e0       	ldi	r24, 0x02	; 2
    2b4c:	86 83       	std	Z+6, r24	; 0x06
    2b4e:	0e 94 89 15 	call	0x2b12	; 0x2b12 <Nybble>
    2b52:	8c 2f       	mov	r24, r28
    2b54:	8f 70       	andi	r24, 0x0F	; 15
    2b56:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <setPort>
    2b5a:	0e 94 89 15 	call	0x2b12	; 0x2b12 <Nybble>
    2b5e:	cf 91       	pop	r28
    2b60:	08 95       	ret

00002b62 <write>:
    2b62:	cf 93       	push	r28
    2b64:	c8 2f       	mov	r28, r24
    2b66:	82 95       	swap	r24
    2b68:	8f 70       	andi	r24, 0x0F	; 15
    2b6a:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <setPort>
    2b6e:	e0 e6       	ldi	r30, 0x60	; 96
    2b70:	f6 e0       	ldi	r31, 0x06	; 6
    2b72:	81 e0       	ldi	r24, 0x01	; 1
    2b74:	85 83       	std	Z+5, r24	; 0x05
    2b76:	82 e0       	ldi	r24, 0x02	; 2
    2b78:	86 83       	std	Z+6, r24	; 0x06
    2b7a:	0e 94 89 15 	call	0x2b12	; 0x2b12 <Nybble>
    2b7e:	8c 2f       	mov	r24, r28
    2b80:	8f 70       	andi	r24, 0x0F	; 15
    2b82:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <setPort>
    2b86:	0e 94 89 15 	call	0x2b12	; 0x2b12 <Nybble>
    2b8a:	cf 91       	pop	r28
    2b8c:	08 95       	ret

00002b8e <vInitDisplay>:
 }
 
 void vInitDisplay() {
    2b8e:	ef 92       	push	r14
    2b90:	ff 92       	push	r15
    2b92:	0f 93       	push	r16
	PORTA.DIRSET = PIN4_bm;
    2b94:	e0 e0       	ldi	r30, 0x00	; 0
    2b96:	f6 e0       	ldi	r31, 0x06	; 6
    2b98:	80 e1       	ldi	r24, 0x10	; 16
    2b9a:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN5_bm;
    2b9c:	80 e2       	ldi	r24, 0x20	; 32
    2b9e:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN6_bm;
    2ba0:	80 e4       	ldi	r24, 0x40	; 64
    2ba2:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN7_bm;
    2ba4:	80 e8       	ldi	r24, 0x80	; 128
    2ba6:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN0_bm;
    2ba8:	a0 e6       	ldi	r26, 0x60	; 96
    2baa:	b6 e0       	ldi	r27, 0x06	; 6
    2bac:	81 e0       	ldi	r24, 0x01	; 1
    2bae:	11 96       	adiw	r26, 0x01	; 1
    2bb0:	8c 93       	st	X, r24
    2bb2:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN1_bm;
    2bb4:	82 e0       	ldi	r24, 0x02	; 2
    2bb6:	11 96       	adiw	r26, 0x01	; 1
    2bb8:	8c 93       	st	X, r24
    2bba:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN2_bm;
    2bbc:	84 e0       	ldi	r24, 0x04	; 4
    2bbe:	11 96       	adiw	r26, 0x01	; 1
    2bc0:	8c 93       	st	X, r24
    2bc2:	11 97       	sbiw	r26, 0x01	; 1
	PORTA.OUT &= 0x0F;
    2bc4:	84 81       	ldd	r24, Z+4	; 0x04
    2bc6:	8f 70       	andi	r24, 0x0F	; 15
    2bc8:	84 83       	std	Z+4, r24	; 0x04
	PORTD.OUT &= 0xF8;
    2bca:	14 96       	adiw	r26, 0x04	; 4
    2bcc:	8c 91       	ld	r24, X
    2bce:	14 97       	sbiw	r26, 0x04	; 4
    2bd0:	88 7f       	andi	r24, 0xF8	; 248
    2bd2:	14 96       	adiw	r26, 0x04	; 4
    2bd4:	8c 93       	st	X, r24

	if((displayLineQueue = xQueueCreate(DISPLAY_QUEUE_DEPTH, sizeof(displayLine_t))) == NULL)
    2bd6:	40 e0       	ldi	r20, 0x00	; 0
    2bd8:	66 e1       	ldi	r22, 0x16	; 22
    2bda:	88 e0       	ldi	r24, 0x08	; 8
    2bdc:	0e 94 88 08 	call	0x1110	; 0x1110 <xQueueGenericCreate>
    2be0:	80 93 5d 32 	sts	0x325D, r24	; 0x80325d <displayLineQueue>
    2be4:	90 93 5e 32 	sts	0x325E, r25	; 0x80325e <displayLineQueue+0x1>
	{
		//error(ERR_QUEUE_CREATE_HANDLE_NULL);
	}
	
	egDisplayTiming = xEventGroupCreate();
    2be8:	0e 94 61 03 	call	0x6c2	; 0x6c2 <xEventGroupCreate>
    2bec:	80 93 5f 32 	sts	0x325F, r24	; 0x80325f <egDisplayTiming>
    2bf0:	90 93 60 32 	sts	0x3260, r25	; 0x803260 <egDisplayTiming+0x1>
	

	xTaskCreate(vDisplayUpdateTask, (const char*) "dispUpdate", configMINIMAL_STACK_SIZE+150, NULL, 1, NULL);	
    2bf4:	e1 2c       	mov	r14, r1
    2bf6:	f1 2c       	mov	r15, r1
    2bf8:	01 e0       	ldi	r16, 0x01	; 1
    2bfa:	20 e0       	ldi	r18, 0x00	; 0
    2bfc:	30 e0       	ldi	r19, 0x00	; 0
    2bfe:	4e e5       	ldi	r20, 0x5E	; 94
    2c00:	51 e0       	ldi	r21, 0x01	; 1
    2c02:	61 e9       	ldi	r22, 0x91	; 145
    2c04:	70 e2       	ldi	r23, 0x20	; 32
    2c06:	85 e6       	ldi	r24, 0x65	; 101
    2c08:	96 e1       	ldi	r25, 0x16	; 22
    2c0a:	0e 94 bc 0b 	call	0x1778	; 0x1778 <xTaskCreate>
 }
    2c0e:	0f 91       	pop	r16
    2c10:	ff 90       	pop	r15
    2c12:	ef 90       	pop	r14
    2c14:	08 95       	ret

00002c16 <_displaySetPos>:
 
 void _displaySetPos(int line, int pos) {
	 switch(line) {
    2c16:	81 30       	cpi	r24, 0x01	; 1
    2c18:	91 05       	cpc	r25, r1
    2c1a:	79 f0       	breq	.+30     	; 0x2c3a <_displaySetPos+0x24>
    2c1c:	1c f4       	brge	.+6      	; 0x2c24 <_displaySetPos+0xe>
    2c1e:	89 2b       	or	r24, r25
    2c20:	39 f0       	breq	.+14     	; 0x2c30 <_displaySetPos+0x1a>
    2c22:	19 c0       	rjmp	.+50     	; 0x2c56 <_displaySetPos+0x40>
    2c24:	82 30       	cpi	r24, 0x02	; 2
    2c26:	91 05       	cpc	r25, r1
    2c28:	69 f0       	breq	.+26     	; 0x2c44 <_displaySetPos+0x2e>
    2c2a:	03 97       	sbiw	r24, 0x03	; 3
    2c2c:	81 f0       	breq	.+32     	; 0x2c4e <_displaySetPos+0x38>
    2c2e:	13 c0       	rjmp	.+38     	; 0x2c56 <_displaySetPos+0x40>
		 case 0:
		 command(0x80 + 0x00 + pos);
    2c30:	80 e8       	ldi	r24, 0x80	; 128
    2c32:	86 0f       	add	r24, r22
    2c34:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <command>
		 break;
    2c38:	0e c0       	rjmp	.+28     	; 0x2c56 <_displaySetPos+0x40>
		 case 1:
		 command(0x80 + 0x40 + pos);
    2c3a:	80 ec       	ldi	r24, 0xC0	; 192
    2c3c:	86 0f       	add	r24, r22
    2c3e:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <command>
		 break;
    2c42:	09 c0       	rjmp	.+18     	; 0x2c56 <_displaySetPos+0x40>
		 case 2:
		 command(0x80 + 0x14 + pos);
    2c44:	84 e9       	ldi	r24, 0x94	; 148
    2c46:	86 0f       	add	r24, r22
    2c48:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <command>
		 break;
    2c4c:	04 c0       	rjmp	.+8      	; 0x2c56 <_displaySetPos+0x40>
		 case 3:
		 command(0x80 + 0x54 + pos);
    2c4e:	84 ed       	ldi	r24, 0xD4	; 212
    2c50:	86 0f       	add	r24, r22
    2c52:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <command>
		 break;
	 }
	 delayUS(39);
    2c56:	67 e2       	ldi	r22, 0x27	; 39
    2c58:	70 e0       	ldi	r23, 0x00	; 0
    2c5a:	80 e0       	ldi	r24, 0x00	; 0
    2c5c:	90 e0       	ldi	r25, 0x00	; 0
    2c5e:	0e 94 09 15 	call	0x2a12	; 0x2a12 <delayUS>
    2c62:	08 95       	ret

00002c64 <_displayWriteChar>:
 }

 void _displayWriteChar(char c) {
	 write(c);
    2c64:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <write>
	 delayUS(43);
    2c68:	6b e2       	ldi	r22, 0x2B	; 43
    2c6a:	70 e0       	ldi	r23, 0x00	; 0
    2c6c:	80 e0       	ldi	r24, 0x00	; 0
    2c6e:	90 e0       	ldi	r25, 0x00	; 0
    2c70:	0e 94 09 15 	call	0x2a12	; 0x2a12 <delayUS>
    2c74:	08 95       	ret

00002c76 <_displayWriteString>:
 }
 
 void _displayWriteString(char* s) {
    2c76:	0f 93       	push	r16
    2c78:	1f 93       	push	r17
    2c7a:	cf 93       	push	r28
    2c7c:	df 93       	push	r29
    2c7e:	fc 01       	movw	r30, r24
	 for(int i = 0; i < 20; i++) {
		 if(s[i] == '\0') {
    2c80:	80 81       	ld	r24, Z
    2c82:	81 11       	cpse	r24, r1
    2c84:	0a c0       	rjmp	.+20     	; 0x2c9a <_displayWriteString+0x24>
    2c86:	11 c0       	rjmp	.+34     	; 0x2caa <_displayWriteString+0x34>
    2c88:	89 91       	ld	r24, Y+
    2c8a:	88 23       	and	r24, r24
    2c8c:	71 f0       	breq	.+28     	; 0x2caa <_displayWriteString+0x34>
			 break;
		 }
		 _displayWriteChar(s[i]);
    2c8e:	0e 94 32 16 	call	0x2c64	; 0x2c64 <_displayWriteChar>
	 write(c);
	 delayUS(43);
 }
 
 void _displayWriteString(char* s) {
	 for(int i = 0; i < 20; i++) {
    2c92:	0c 17       	cp	r16, r28
    2c94:	1d 07       	cpc	r17, r29
    2c96:	c1 f7       	brne	.-16     	; 0x2c88 <_displayWriteString+0x12>
    2c98:	08 c0       	rjmp	.+16     	; 0x2caa <_displayWriteString+0x34>
    2c9a:	8f 01       	movw	r16, r30
		 if(s[i] == '\0') {
			 break;
		 }
		 _displayWriteChar(s[i]);
    2c9c:	0e 94 32 16 	call	0x2c64	; 0x2c64 <_displayWriteChar>
    2ca0:	e8 01       	movw	r28, r16
    2ca2:	21 96       	adiw	r28, 0x01	; 1
    2ca4:	0c 5e       	subi	r16, 0xEC	; 236
    2ca6:	1f 4f       	sbci	r17, 0xFF	; 255
    2ca8:	ef cf       	rjmp	.-34     	; 0x2c88 <_displayWriteString+0x12>
	 }
 }
    2caa:	df 91       	pop	r29
    2cac:	cf 91       	pop	r28
    2cae:	1f 91       	pop	r17
    2cb0:	0f 91       	pop	r16
    2cb2:	08 95       	ret

00002cb4 <_displayWriteStringAtPos>:

 void _displayWriteStringAtPos(int line, int pos, char* s) {
    2cb4:	cf 93       	push	r28
    2cb6:	df 93       	push	r29
    2cb8:	ea 01       	movw	r28, r20
	 _displaySetPos(line, pos);
    2cba:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <_displaySetPos>
	 _displayWriteString(s);
    2cbe:	ce 01       	movw	r24, r28
    2cc0:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <_displayWriteString>
 }
    2cc4:	df 91       	pop	r29
    2cc6:	cf 91       	pop	r28
    2cc8:	08 95       	ret

00002cca <vDisplayUpdateTask>:

 void vDisplayUpdateTask(void *pvParameters) {
    2cca:	cf 93       	push	r28
    2ccc:	df 93       	push	r29
    2cce:	cd b7       	in	r28, 0x3d	; 61
    2cd0:	de b7       	in	r29, 0x3e	; 62
    2cd2:	c6 56       	subi	r28, 0x66	; 102
    2cd4:	d1 09       	sbc	r29, r1
    2cd6:	cd bf       	out	0x3d, r28	; 61
    2cd8:	de bf       	out	0x3e, r29	; 62
    2cda:	5e 01       	movw	r10, r28
    2cdc:	41 e5       	ldi	r20, 0x51	; 81
    2cde:	a4 0e       	add	r10, r20
    2ce0:	b1 1c       	adc	r11, r1
    2ce2:	fe 01       	movw	r30, r28
    2ce4:	31 96       	adiw	r30, 0x01	; 1
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
			displayLines[i][j] = 0x20;
    2ce6:	20 e2       	ldi	r18, 0x20	; 32
    2ce8:	08 c0       	rjmp	.+16     	; 0x2cfa <vDisplayUpdateTask+0x30>
    2cea:	21 93       	st	Z+, r18
 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
    2cec:	e8 17       	cp	r30, r24
    2cee:	f9 07       	cpc	r31, r25
    2cf0:	e1 f7       	brne	.-8      	; 0x2cea <vDisplayUpdateTask+0x20>
    2cf2:	fc 01       	movw	r30, r24

 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
    2cf4:	a8 16       	cp	r10, r24
    2cf6:	b9 06       	cpc	r11, r25
    2cf8:	19 f0       	breq	.+6      	; 0x2d00 <vDisplayUpdateTask+0x36>
    2cfa:	cf 01       	movw	r24, r30
    2cfc:	44 96       	adiw	r24, 0x14	; 20
    2cfe:	f5 cf       	rjmp	.-22     	; 0x2cea <vDisplayUpdateTask+0x20>
			displayLines[i][j] = 0x20;
		}
	 }
	 displayLine_t newLine;

	 delayUS(40000);
    2d00:	60 e4       	ldi	r22, 0x40	; 64
    2d02:	7c e9       	ldi	r23, 0x9C	; 156
    2d04:	80 e0       	ldi	r24, 0x00	; 0
    2d06:	90 e0       	ldi	r25, 0x00	; 0
    2d08:	0e 94 09 15 	call	0x2a12	; 0x2a12 <delayUS>
	 setPort(0x03);
    2d0c:	83 e0       	ldi	r24, 0x03	; 3
    2d0e:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <setPort>
	 delayUS(5000);
    2d12:	68 e8       	ldi	r22, 0x88	; 136
    2d14:	73 e1       	ldi	r23, 0x13	; 19
    2d16:	80 e0       	ldi	r24, 0x00	; 0
    2d18:	90 e0       	ldi	r25, 0x00	; 0
    2d1a:	0e 94 09 15 	call	0x2a12	; 0x2a12 <delayUS>
	 Nybble();
    2d1e:	0e 94 89 15 	call	0x2b12	; 0x2b12 <Nybble>
	 delayUS(160);
    2d22:	60 ea       	ldi	r22, 0xA0	; 160
    2d24:	70 e0       	ldi	r23, 0x00	; 0
    2d26:	80 e0       	ldi	r24, 0x00	; 0
    2d28:	90 e0       	ldi	r25, 0x00	; 0
    2d2a:	0e 94 09 15 	call	0x2a12	; 0x2a12 <delayUS>
	 Nybble();
    2d2e:	0e 94 89 15 	call	0x2b12	; 0x2b12 <Nybble>
	 delayUS(160);
    2d32:	60 ea       	ldi	r22, 0xA0	; 160
    2d34:	70 e0       	ldi	r23, 0x00	; 0
    2d36:	80 e0       	ldi	r24, 0x00	; 0
    2d38:	90 e0       	ldi	r25, 0x00	; 0
    2d3a:	0e 94 09 15 	call	0x2a12	; 0x2a12 <delayUS>
	 Nybble();
    2d3e:	0e 94 89 15 	call	0x2b12	; 0x2b12 <Nybble>
	 delayUS(160);
    2d42:	60 ea       	ldi	r22, 0xA0	; 160
    2d44:	70 e0       	ldi	r23, 0x00	; 0
    2d46:	80 e0       	ldi	r24, 0x00	; 0
    2d48:	90 e0       	ldi	r25, 0x00	; 0
    2d4a:	0e 94 09 15 	call	0x2a12	; 0x2a12 <delayUS>
	 setPort(0x02);
    2d4e:	82 e0       	ldi	r24, 0x02	; 2
    2d50:	0e 94 7c 15 	call	0x2af8	; 0x2af8 <setPort>
	 Nybble();
    2d54:	0e 94 89 15 	call	0x2b12	; 0x2b12 <Nybble>
	 command(0x28);
    2d58:	88 e2       	ldi	r24, 0x28	; 40
    2d5a:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <command>
	 command(0x10);
    2d5e:	80 e1       	ldi	r24, 0x10	; 16
    2d60:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <command>
	 command(0x0C); //Cursor and Blinking off
    2d64:	8c e0       	ldi	r24, 0x0C	; 12
    2d66:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <command>
	 command(0x06);
    2d6a:	86 e0       	ldi	r24, 0x06	; 6
    2d6c:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <command>
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2d70:	10 e2       	ldi	r17, 0x20	; 32
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2d72:	6e 01       	movw	r12, r28
    2d74:	51 e5       	ldi	r21, 0x51	; 81
    2d76:	c5 0e       	add	r12, r21
    2d78:	d1 1c       	adc	r13, r1
    2d7a:	0f 2e       	mov	r0, r31
    2d7c:	f4 e1       	ldi	r31, 0x14	; 20
    2d7e:	4f 2e       	mov	r4, r31
    2d80:	f0 2d       	mov	r31, r0
    2d82:	0f 2e       	mov	r0, r31
    2d84:	f6 e1       	ldi	r31, 0x16	; 22
    2d86:	8f 2e       	mov	r8, r31
    2d88:	91 2c       	mov	r9, r1
    2d8a:	f0 2d       	mov	r31, r0
    2d8c:	5c 2c       	mov	r5, r12
    2d8e:	0d 2d       	mov	r16, r13
	 command(0x10);
	 command(0x0C); //Cursor and Blinking off
	 command(0x06);
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
    2d90:	68 ec       	ldi	r22, 0xC8	; 200
    2d92:	70 e0       	ldi	r23, 0x00	; 0
    2d94:	80 e0       	ldi	r24, 0x00	; 0
    2d96:	90 e0       	ldi	r25, 0x00	; 0
    2d98:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskDelay>
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
    2d9c:	40 e0       	ldi	r20, 0x00	; 0
    2d9e:	50 e0       	ldi	r21, 0x00	; 0
    2da0:	ba 01       	movw	r22, r20
    2da2:	80 91 5f 32 	lds	r24, 0x325F	; 0x80325f <egDisplayTiming>
    2da6:	90 91 60 32 	lds	r25, 0x3260	; 0x803260 <egDisplayTiming+0x1>
    2daa:	0e 94 3b 04 	call	0x876	; 0x876 <xEventGroupClearBits>
    2dae:	67 2b       	or	r22, r23
    2db0:	68 2b       	or	r22, r24
    2db2:	69 2b       	or	r22, r25
    2db4:	09 f4       	brne	.+2      	; 0x2db8 <vDisplayUpdateTask+0xee>
    2db6:	49 c0       	rjmp	.+146    	; 0x2e4a <vDisplayUpdateTask+0x180>
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2db8:	42 e0       	ldi	r20, 0x02	; 2
    2dba:	50 e0       	ldi	r21, 0x00	; 0
    2dbc:	60 e0       	ldi	r22, 0x00	; 0
    2dbe:	70 e0       	ldi	r23, 0x00	; 0
    2dc0:	80 91 5f 32 	lds	r24, 0x325F	; 0x80325f <egDisplayTiming>
    2dc4:	90 91 60 32 	lds	r25, 0x3260	; 0x803260 <egDisplayTiming+0x1>
    2dc8:	0e 94 3b 04 	call	0x876	; 0x876 <xEventGroupClearBits>
    2dcc:	fe 01       	movw	r30, r28
    2dce:	31 96       	adiw	r30, 0x01	; 1
    2dd0:	08 c0       	rjmp	.+16     	; 0x2de2 <vDisplayUpdateTask+0x118>
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2dd2:	11 93       	st	Z+, r17
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
    2dd4:	e8 17       	cp	r30, r24
    2dd6:	f9 07       	cpc	r31, r25
    2dd8:	e1 f7       	brne	.-8      	; 0x2dd2 <vDisplayUpdateTask+0x108>
    2dda:	fc 01       	movw	r30, r24
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
    2ddc:	8a 15       	cp	r24, r10
    2dde:	9b 05       	cpc	r25, r11
    2de0:	a1 f1       	breq	.+104    	; 0x2e4a <vDisplayUpdateTask+0x180>
    2de2:	cf 01       	movw	r24, r30
    2de4:	44 96       	adiw	r24, 0x14	; 20
    2de6:	f5 cf       	rjmp	.-22     	; 0x2dd2 <vDisplayUpdateTask+0x108>
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2de8:	2f ef       	ldi	r18, 0xFF	; 255
    2dea:	3f ef       	ldi	r19, 0xFF	; 255
    2dec:	a9 01       	movw	r20, r18
    2dee:	65 2d       	mov	r22, r5
    2df0:	70 2f       	mov	r23, r16
    2df2:	80 91 5d 32 	lds	r24, 0x325D	; 0x80325d <displayLineQueue>
    2df6:	90 91 5e 32 	lds	r25, 0x325E	; 0x80325e <displayLineQueue+0x1>
    2dfa:	0e 94 a4 09 	call	0x1348	; 0x1348 <xQueueReceive>
    2dfe:	88 23       	and	r24, r24
    2e00:	21 f1       	breq	.+72     	; 0x2e4a <vDisplayUpdateTask+0x180>
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2e02:	f6 01       	movw	r30, r12
    2e04:	21 81       	ldd	r18, Z+1	; 0x01
    2e06:	82 2f       	mov	r24, r18
    2e08:	90 e0       	ldi	r25, 0x00	; 0
    2e0a:	44 97       	sbiw	r24, 0x14	; 20
    2e0c:	f4 f4       	brge	.+60     	; 0x2e4a <vDisplayUpdateTask+0x180>
    2e0e:	82 81       	ldd	r24, Z+2	; 0x02
    2e10:	88 23       	and	r24, r24
    2e12:	d9 f0       	breq	.+54     	; 0x2e4a <vDisplayUpdateTask+0x180>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
    2e14:	90 81       	ld	r25, Z
    2e16:	30 e0       	ldi	r19, 0x00	; 0
    2e18:	d9 01       	movw	r26, r18
    2e1a:	49 9e       	mul	r4, r25
    2e1c:	a0 0d       	add	r26, r0
    2e1e:	b1 1d       	adc	r27, r1
    2e20:	11 24       	eor	r1, r1
    2e22:	41 e0       	ldi	r20, 0x01	; 1
    2e24:	50 e0       	ldi	r21, 0x00	; 0
    2e26:	4c 0f       	add	r20, r28
    2e28:	5d 1f       	adc	r21, r29
    2e2a:	a4 0f       	add	r26, r20
    2e2c:	b5 1f       	adc	r27, r21
    2e2e:	33 96       	adiw	r30, 0x03	; 3
    2e30:	a4 01       	movw	r20, r8
    2e32:	42 1b       	sub	r20, r18
    2e34:	53 0b       	sbc	r21, r19
    2e36:	9a 01       	movw	r18, r20
    2e38:	2c 0d       	add	r18, r12
    2e3a:	3d 1d       	adc	r19, r13
    2e3c:	8d 93       	st	X+, r24
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2e3e:	e2 17       	cp	r30, r18
    2e40:	f3 07       	cpc	r31, r19
    2e42:	19 f0       	breq	.+6      	; 0x2e4a <vDisplayUpdateTask+0x180>
    2e44:	81 91       	ld	r24, Z+
    2e46:	81 11       	cpse	r24, r1
    2e48:	f9 cf       	rjmp	.-14     	; 0x2e3c <vDisplayUpdateTask+0x172>
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
    2e4a:	80 91 5d 32 	lds	r24, 0x325D	; 0x80325d <displayLineQueue>
    2e4e:	90 91 5e 32 	lds	r25, 0x325E	; 0x80325e <displayLineQueue+0x1>
    2e52:	0e 94 e4 0a 	call	0x15c8	; 0x15c8 <uxQueueMessagesWaiting>
    2e56:	81 11       	cpse	r24, r1
    2e58:	c7 cf       	rjmp	.-114    	; 0x2de8 <vDisplayUpdateTask+0x11e>
    2e5a:	ce 01       	movw	r24, r28
    2e5c:	01 96       	adiw	r24, 0x01	; 1
    2e5e:	7c 01       	movw	r14, r24
    2e60:	61 2c       	mov	r6, r1
    2e62:	71 2c       	mov	r7, r1
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
			 _displayWriteStringAtPos(i,0,&displayLines[i][0]);
    2e64:	a7 01       	movw	r20, r14
    2e66:	60 e0       	ldi	r22, 0x00	; 0
    2e68:	70 e0       	ldi	r23, 0x00	; 0
    2e6a:	c3 01       	movw	r24, r6
    2e6c:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <_displayWriteStringAtPos>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
    2e70:	9f ef       	ldi	r25, 0xFF	; 255
    2e72:	69 1a       	sub	r6, r25
    2e74:	79 0a       	sbc	r7, r25
    2e76:	e4 e1       	ldi	r30, 0x14	; 20
    2e78:	ee 0e       	add	r14, r30
    2e7a:	f1 1c       	adc	r15, r1
    2e7c:	f4 e0       	ldi	r31, 0x04	; 4
    2e7e:	6f 16       	cp	r6, r31
    2e80:	71 04       	cpc	r7, r1
    2e82:	81 f7       	brne	.-32     	; 0x2e64 <vDisplayUpdateTask+0x19a>
    2e84:	85 cf       	rjmp	.-246    	; 0x2d90 <vDisplayUpdateTask+0xc6>

00002e86 <vDisplayClear>:
	 }
 }
 

void vDisplayClear() {
	xEventGroupSetBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2e86:	42 e0       	ldi	r20, 0x02	; 2
    2e88:	50 e0       	ldi	r21, 0x00	; 0
    2e8a:	60 e0       	ldi	r22, 0x00	; 0
    2e8c:	70 e0       	ldi	r23, 0x00	; 0
    2e8e:	80 91 5f 32 	lds	r24, 0x325F	; 0x80325f <egDisplayTiming>
    2e92:	90 91 60 32 	lds	r25, 0x3260	; 0x803260 <egDisplayTiming+0x1>
    2e96:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <xEventGroupSetBits>
    2e9a:	08 95       	ret

00002e9c <vDisplayWriteStringAtPos>:
}

void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
    2e9c:	2f 92       	push	r2
    2e9e:	3f 92       	push	r3
    2ea0:	4f 92       	push	r4
    2ea2:	5f 92       	push	r5
    2ea4:	6f 92       	push	r6
    2ea6:	7f 92       	push	r7
    2ea8:	8f 92       	push	r8
    2eaa:	9f 92       	push	r9
    2eac:	af 92       	push	r10
    2eae:	bf 92       	push	r11
    2eb0:	cf 92       	push	r12
    2eb2:	df 92       	push	r13
    2eb4:	ef 92       	push	r14
    2eb6:	ff 92       	push	r15
    2eb8:	0f 93       	push	r16
    2eba:	1f 93       	push	r17
    2ebc:	cf 93       	push	r28
    2ebe:	df 93       	push	r29
    2ec0:	cd b7       	in	r28, 0x3d	; 61
    2ec2:	de b7       	in	r29, 0x3e	; 62
    2ec4:	6d 97       	sbiw	r28, 0x1d	; 29
    2ec6:	cd bf       	out	0x3d, r28	; 61
    2ec8:	de bf       	out	0x3e, r29	; 62
    2eca:	2b a9       	ldd	r18, Y+51	; 0x33
    2ecc:	2b 8f       	std	Y+27, r18	; 0x1b
    2ece:	af a9       	ldd	r26, Y+55	; 0x37
    2ed0:	b8 ad       	ldd	r27, Y+56	; 0x38
	va_list arg;	
	va_start(arg, fmt);
    2ed2:	7e 01       	movw	r14, r28
    2ed4:	39 e3       	ldi	r19, 0x39	; 57
    2ed6:	e3 0e       	add	r14, r19
    2ed8:	f1 1c       	adc	r15, r1
    2eda:	22 e1       	ldi	r18, 0x12	; 18
    2edc:	3d e2       	ldi	r19, 0x2D	; 45
	display_vprintf(line, pos, fmt, arg);
    2ede:	ee ef       	ldi	r30, 0xFE	; 254
    2ee0:	fc e2       	ldi	r31, 0x2C	; 44
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
    2ee2:	11 92       	st	Z+, r1
	char ch;
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
    2ee4:	e2 17       	cp	r30, r18
    2ee6:	f3 07       	cpc	r31, r19
    2ee8:	e1 f7       	brne	.-8      	; 0x2ee2 <vDisplayWriteStringAtPos+0x46>
    2eea:	0f 2e       	mov	r0, r31
    2eec:	fa ee       	ldi	r31, 0xEA	; 234
    2eee:	af 2e       	mov	r10, r31
    2ef0:	fc e2       	ldi	r31, 0x2C	; 44
    2ef2:	bf 2e       	mov	r11, r31
    2ef4:	f0 2d       	mov	r31, r0
    2ef6:	2e ef       	ldi	r18, 0xFE	; 254
    2ef8:	3c e2       	ldi	r19, 0x2C	; 44
    2efa:	f5 01       	movw	r30, r10
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
    2efc:	11 92       	st	Z+, r1
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    2efe:	e2 17       	cp	r30, r18
    2f00:	f3 07       	cpc	r31, r19
    2f02:	e1 f7       	brne	.-8      	; 0x2efc <vDisplayWriteStringAtPos+0x60>
    2f04:	81 2c       	mov	r8, r1
    2f06:	91 2c       	mov	r9, r1
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    2f08:	0f 2e       	mov	r0, r31
    2f0a:	fe ef       	ldi	r31, 0xFE	; 254
    2f0c:	cf 2e       	mov	r12, r31
    2f0e:	fc e2       	ldi	r31, 0x2C	; 44
    2f10:	df 2e       	mov	r13, r31
    2f12:	f0 2d       	mov	r31, r0
    2f14:	fc c2       	rjmp	.+1528   	; 0x350e <vDisplayWriteStringAtPos+0x672>
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
    2f16:	85 32       	cpi	r24, 0x25	; 37
    2f18:	09 f0       	breq	.+2      	; 0x2f1c <vDisplayWriteStringAtPos+0x80>
    2f1a:	e8 c2       	rjmp	.+1488   	; 0x34ec <vDisplayWriteStringAtPos+0x650>
			switch (ch = *fmt++) {
    2f1c:	2d 01       	movw	r4, r26
    2f1e:	82 e0       	ldi	r24, 0x02	; 2
    2f20:	48 0e       	add	r4, r24
    2f22:	51 1c       	adc	r5, r1
    2f24:	11 96       	adiw	r26, 0x01	; 1
    2f26:	8c 91       	ld	r24, X
    2f28:	85 36       	cpi	r24, 0x65	; 101
    2f2a:	09 f4       	brne	.+2      	; 0x2f2e <vDisplayWriteStringAtPos+0x92>
    2f2c:	db c1       	rjmp	.+950    	; 0x32e4 <vDisplayWriteStringAtPos+0x448>
    2f2e:	38 f4       	brcc	.+14     	; 0x2f3e <vDisplayWriteStringAtPos+0xa2>
    2f30:	83 36       	cpi	r24, 0x63	; 99
    2f32:	c1 f0       	breq	.+48     	; 0x2f64 <vDisplayWriteStringAtPos+0xc8>
    2f34:	08 f0       	brcs	.+2      	; 0x2f38 <vDisplayWriteStringAtPos+0x9c>
    2f36:	48 c0       	rjmp	.+144    	; 0x2fc8 <vDisplayWriteStringAtPos+0x12c>
    2f38:	85 32       	cpi	r24, 0x25	; 37
    2f3a:	51 f0       	breq	.+20     	; 0x2f50 <vDisplayWriteStringAtPos+0xb4>
    2f3c:	e7 c2       	rjmp	.+1486   	; 0x350c <vDisplayWriteStringAtPos+0x670>
    2f3e:	83 37       	cpi	r24, 0x73	; 115
    2f40:	f9 f0       	breq	.+62     	; 0x2f80 <vDisplayWriteStringAtPos+0xe4>
    2f42:	88 37       	cpi	r24, 0x78	; 120
    2f44:	09 f4       	brne	.+2      	; 0x2f48 <vDisplayWriteStringAtPos+0xac>
    2f46:	68 c0       	rjmp	.+208    	; 0x3018 <vDisplayWriteStringAtPos+0x17c>
    2f48:	86 36       	cpi	r24, 0x66	; 102
    2f4a:	09 f0       	breq	.+2      	; 0x2f4e <vDisplayWriteStringAtPos+0xb2>
    2f4c:	df c2       	rjmp	.+1470   	; 0x350c <vDisplayWriteStringAtPos+0x670>
    2f4e:	8c c0       	rjmp	.+280    	; 0x3068 <vDisplayWriteStringAtPos+0x1cc>
				/* %% - print out a single %    */
				case '%':
				str[length] = '%';
    2f50:	f4 01       	movw	r30, r8
    2f52:	e6 51       	subi	r30, 0x16	; 22
    2f54:	f3 4d       	sbci	r31, 0xD3	; 211
    2f56:	95 e2       	ldi	r25, 0x25	; 37
    2f58:	90 83       	st	Z, r25
				length++;
    2f5a:	af ef       	ldi	r26, 0xFF	; 255
    2f5c:	8a 1a       	sub	r8, r26
    2f5e:	9a 0a       	sbc	r9, r26
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2f60:	d2 01       	movw	r26, r4
    2f62:	d5 c2       	rjmp	.+1450   	; 0x350e <vDisplayWriteStringAtPos+0x672>
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
				str[length] = char_temp;
    2f64:	f4 01       	movw	r30, r8
    2f66:	e6 51       	subi	r30, 0x16	; 22
    2f68:	f3 4d       	sbci	r31, 0xD3	; 211
    2f6a:	d7 01       	movw	r26, r14
    2f6c:	8c 91       	ld	r24, X
    2f6e:	80 83       	st	Z, r24
				length++;
    2f70:	bf ef       	ldi	r27, 0xFF	; 255
    2f72:	8b 1a       	sub	r8, r27
    2f74:	9b 0a       	sbc	r9, r27
				length++;
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
    2f76:	f7 01       	movw	r30, r14
    2f78:	32 96       	adiw	r30, 0x02	; 2
    2f7a:	7f 01       	movw	r14, r30
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2f7c:	d2 01       	movw	r26, r4
    2f7e:	c7 c2       	rjmp	.+1422   	; 0x350e <vDisplayWriteStringAtPos+0x672>
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2f80:	a7 01       	movw	r20, r14
    2f82:	4e 5f       	subi	r20, 0xFE	; 254
    2f84:	5f 4f       	sbci	r21, 0xFF	; 255
    2f86:	d7 01       	movw	r26, r14
    2f88:	8d 91       	ld	r24, X+
    2f8a:	9c 91       	ld	r25, X
    2f8c:	9c 01       	movw	r18, r24
    2f8e:	b4 01       	movw	r22, r8
    2f90:	f4 01       	movw	r30, r8
    2f92:	e6 51       	subi	r30, 0x16	; 22
    2f94:	f3 4d       	sbci	r31, 0xD3	; 211
				for(int i = 0; i < strlen(string_temp);i++) {
    2f96:	00 e0       	ldi	r16, 0x00	; 0
    2f98:	10 e0       	ldi	r17, 0x00	; 0
    2f9a:	06 c0       	rjmp	.+12     	; 0x2fa8 <vDisplayWriteStringAtPos+0x10c>
					str[length+i] = string_temp[i];
    2f9c:	d9 01       	movw	r26, r18
    2f9e:	fd 90       	ld	r15, X+
    2fa0:	9d 01       	movw	r18, r26
    2fa2:	f1 92       	st	Z+, r15
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
				for(int i = 0; i < strlen(string_temp);i++) {
    2fa4:	0f 5f       	subi	r16, 0xFF	; 255
    2fa6:	1f 4f       	sbci	r17, 0xFF	; 255
    2fa8:	dc 01       	movw	r26, r24
    2faa:	0d 90       	ld	r0, X+
    2fac:	00 20       	and	r0, r0
    2fae:	e9 f7       	brne	.-6      	; 0x2faa <vDisplayWriteStringAtPos+0x10e>
    2fb0:	11 97       	sbiw	r26, 0x01	; 1
    2fb2:	a8 1b       	sub	r26, r24
    2fb4:	b9 0b       	sbc	r27, r25
    2fb6:	0a 17       	cp	r16, r26
    2fb8:	1b 07       	cpc	r17, r27
    2fba:	80 f3       	brcs	.-32     	; 0x2f9c <vDisplayWriteStringAtPos+0x100>
					str[length+i] = string_temp[i];
				}
				length += strlen(string_temp);
    2fbc:	4d 01       	movw	r8, r26
    2fbe:	86 0e       	add	r8, r22
    2fc0:	97 1e       	adc	r9, r23
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2fc2:	7a 01       	movw	r14, r20
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2fc4:	d2 01       	movw	r26, r4
    2fc6:	a3 c2       	rjmp	.+1350   	; 0x350e <vDisplayWriteStringAtPos+0x672>
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    2fc8:	87 01       	movw	r16, r14
    2fca:	0e 5f       	subi	r16, 0xFE	; 254
    2fcc:	1f 4f       	sbci	r17, 0xFF	; 255
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    2fce:	4a e0       	ldi	r20, 0x0A	; 10
    2fd0:	b6 01       	movw	r22, r12
    2fd2:	f7 01       	movw	r30, r14
    2fd4:	80 81       	ld	r24, Z
    2fd6:	91 81       	ldd	r25, Z+1	; 0x01
    2fd8:	0e 94 cf 20 	call	0x419e	; 0x419e <__itoa_ncheck>
    2fdc:	94 01       	movw	r18, r8
    2fde:	d4 01       	movw	r26, r8
    2fe0:	a6 51       	subi	r26, 0x16	; 22
    2fe2:	b3 4d       	sbci	r27, 0xD3	; 211
    2fe4:	4e ef       	ldi	r20, 0xFE	; 254
    2fe6:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    2fe8:	80 e0       	ldi	r24, 0x00	; 0
    2fea:	90 e0       	ldi	r25, 0x00	; 0
    2fec:	05 c0       	rjmp	.+10     	; 0x2ff8 <vDisplayWriteStringAtPos+0x15c>
					str[length+i] = buffer[i];
    2fee:	fa 01       	movw	r30, r20
    2ff0:	61 91       	ld	r22, Z+
    2ff2:	af 01       	movw	r20, r30
    2ff4:	6d 93       	st	X+, r22

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    2ff6:	01 96       	adiw	r24, 0x01	; 1
    2ff8:	f6 01       	movw	r30, r12
    2ffa:	01 90       	ld	r0, Z+
    2ffc:	00 20       	and	r0, r0
    2ffe:	e9 f7       	brne	.-6      	; 0x2ffa <vDisplayWriteStringAtPos+0x15e>
    3000:	31 97       	sbiw	r30, 0x01	; 1
    3002:	ee 5f       	subi	r30, 0xFE	; 254
    3004:	fc 42       	sbci	r31, 0x2C	; 44
    3006:	8e 17       	cp	r24, r30
    3008:	9f 07       	cpc	r25, r31
    300a:	88 f3       	brcs	.-30     	; 0x2fee <vDisplayWriteStringAtPos+0x152>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    300c:	4f 01       	movw	r8, r30
    300e:	82 0e       	add	r8, r18
    3010:	93 1e       	adc	r9, r19
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    3012:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3014:	d2 01       	movw	r26, r4
    3016:	7b c2       	rjmp	.+1270   	; 0x350e <vDisplayWriteStringAtPos+0x672>
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    3018:	87 01       	movw	r16, r14
    301a:	0e 5f       	subi	r16, 0xFE	; 254
    301c:	1f 4f       	sbci	r17, 0xFF	; 255
    301e:	40 e1       	ldi	r20, 0x10	; 16
    3020:	b6 01       	movw	r22, r12
    3022:	d7 01       	movw	r26, r14
    3024:	8d 91       	ld	r24, X+
    3026:	9c 91       	ld	r25, X
    3028:	0e 94 cf 20 	call	0x419e	; 0x419e <__itoa_ncheck>
    302c:	94 01       	movw	r18, r8
    302e:	f4 01       	movw	r30, r8
    3030:	e6 51       	subi	r30, 0x16	; 22
    3032:	f3 4d       	sbci	r31, 0xD3	; 211
    3034:	4e ef       	ldi	r20, 0xFE	; 254
    3036:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    3038:	80 e0       	ldi	r24, 0x00	; 0
    303a:	90 e0       	ldi	r25, 0x00	; 0
    303c:	05 c0       	rjmp	.+10     	; 0x3048 <vDisplayWriteStringAtPos+0x1ac>
					str[length+i] = buffer[i];
    303e:	da 01       	movw	r26, r20
    3040:	6d 91       	ld	r22, X+
    3042:	ad 01       	movw	r20, r26
    3044:	61 93       	st	Z+, r22

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    3046:	01 96       	adiw	r24, 0x01	; 1
    3048:	d6 01       	movw	r26, r12
    304a:	0d 90       	ld	r0, X+
    304c:	00 20       	and	r0, r0
    304e:	e9 f7       	brne	.-6      	; 0x304a <vDisplayWriteStringAtPos+0x1ae>
    3050:	11 97       	sbiw	r26, 0x01	; 1
    3052:	ae 5f       	subi	r26, 0xFE	; 254
    3054:	bc 42       	sbci	r27, 0x2C	; 44
    3056:	8a 17       	cp	r24, r26
    3058:	9b 07       	cpc	r25, r27
    305a:	88 f3       	brcs	.-30     	; 0x303e <vDisplayWriteStringAtPos+0x1a2>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    305c:	4d 01       	movw	r8, r26
    305e:	82 0e       	add	r8, r18
    3060:	93 1e       	adc	r9, r19
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    3062:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3064:	d2 01       	movw	r26, r4
    3066:	53 c2       	rjmp	.+1190   	; 0x350e <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    3068:	17 01       	movw	r2, r14
    306a:	b4 e0       	ldi	r27, 0x04	; 4
    306c:	2b 0e       	add	r2, r27
    306e:	31 1c       	adc	r3, r1
    3070:	d7 01       	movw	r26, r14
    3072:	8d 91       	ld	r24, X+
    3074:	9d 91       	ld	r25, X+
    3076:	0d 90       	ld	r0, X+
    3078:	bc 91       	ld	r27, X
    307a:	a0 2d       	mov	r26, r0
    307c:	8f 8b       	std	Y+23, r24	; 0x17
    307e:	98 8f       	std	Y+24, r25	; 0x18
    3080:	a9 8f       	std	Y+25, r26	; 0x19
    3082:	ba 8f       	std	Y+26, r27	; 0x1a

    int exponent = 0;
    int places = 0;
    static const int width = 4;

    if (value == 0.0) {
    3084:	20 e0       	ldi	r18, 0x00	; 0
    3086:	30 e0       	ldi	r19, 0x00	; 0
    3088:	a9 01       	movw	r20, r18
    308a:	bc 01       	movw	r22, r24
    308c:	cd 01       	movw	r24, r26
    308e:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__cmpsf2>
    3092:	81 11       	cpse	r24, r1
    3094:	05 c0       	rjmp	.+10     	; 0x30a0 <vDisplayWriteStringAtPos+0x204>
        buffer[0] = '0';
    3096:	20 e3       	ldi	r18, 0x30	; 48
    3098:	f6 01       	movw	r30, r12
    309a:	20 83       	st	Z, r18
        buffer[1] = '\0';
    309c:	11 82       	std	Z+1, r1	; 0x01
    309e:	04 c1       	rjmp	.+520    	; 0x32a8 <vDisplayWriteStringAtPos+0x40c>
        return;
    }         

    if (value < 0.0) {
    30a0:	20 e0       	ldi	r18, 0x00	; 0
    30a2:	30 e0       	ldi	r19, 0x00	; 0
    30a4:	a9 01       	movw	r20, r18
    30a6:	6f 89       	ldd	r22, Y+23	; 0x17
    30a8:	78 8d       	ldd	r23, Y+24	; 0x18
    30aa:	89 8d       	ldd	r24, Y+25	; 0x19
    30ac:	9a 8d       	ldd	r25, Y+26	; 0x1a
    30ae:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__cmpsf2>
    30b2:	88 23       	and	r24, r24
    30b4:	9c f4       	brge	.+38     	; 0x30dc <vDisplayWriteStringAtPos+0x240>
        *buffer++ = '-';
    30b6:	ed e2       	ldi	r30, 0x2D	; 45
    30b8:	d6 01       	movw	r26, r12
    30ba:	ec 93       	st	X, r30
        value = -value;
    30bc:	8f 89       	ldd	r24, Y+23	; 0x17
    30be:	98 8d       	ldd	r25, Y+24	; 0x18
    30c0:	a9 8d       	ldd	r26, Y+25	; 0x19
    30c2:	ba 8d       	ldd	r27, Y+26	; 0x1a
    30c4:	b0 58       	subi	r27, 0x80	; 128
    30c6:	8f 8b       	std	Y+23, r24	; 0x17
    30c8:	98 8f       	std	Y+24, r25	; 0x18
    30ca:	a9 8f       	std	Y+25, r26	; 0x19
    30cc:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
        *buffer++ = '-';
    30ce:	0f 2e       	mov	r0, r31
    30d0:	ff ef       	ldi	r31, 0xFF	; 255
    30d2:	6f 2e       	mov	r6, r31
    30d4:	fc e2       	ldi	r31, 0x2C	; 44
    30d6:	7f 2e       	mov	r7, r31
    30d8:	f0 2d       	mov	r31, r0
    30da:	01 c0       	rjmp	.+2      	; 0x30de <vDisplayWriteStringAtPos+0x242>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
    30dc:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    30de:	20 e0       	ldi	r18, 0x00	; 0
    30e0:	30 e0       	ldi	r19, 0x00	; 0
    30e2:	40 e8       	ldi	r20, 0x80	; 128
    30e4:	5f e3       	ldi	r21, 0x3F	; 63
    30e6:	6f 89       	ldd	r22, Y+23	; 0x17
    30e8:	78 8d       	ldd	r23, Y+24	; 0x18
    30ea:	89 8d       	ldd	r24, Y+25	; 0x19
    30ec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    30ee:	0e 94 1d 20 	call	0x403a	; 0x403a <__gesf2>
    30f2:	88 23       	and	r24, r24
    30f4:	0c f4       	brge	.+2      	; 0x30f8 <vDisplayWriteStringAtPos+0x25c>
    30f6:	44 c2       	rjmp	.+1160   	; 0x3580 <vDisplayWriteStringAtPos+0x6e4>
    30f8:	00 e0       	ldi	r16, 0x00	; 0
    30fa:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    30fc:	20 e0       	ldi	r18, 0x00	; 0
    30fe:	30 e0       	ldi	r19, 0x00	; 0
    3100:	40 e2       	ldi	r20, 0x20	; 32
    3102:	51 e4       	ldi	r21, 0x41	; 65
    3104:	6f 89       	ldd	r22, Y+23	; 0x17
    3106:	78 8d       	ldd	r23, Y+24	; 0x18
    3108:	89 8d       	ldd	r24, Y+25	; 0x19
    310a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    310c:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <__divsf3>
    3110:	6f 8b       	std	Y+23, r22	; 0x17
    3112:	78 8f       	std	Y+24, r23	; 0x18
    3114:	89 8f       	std	Y+25, r24	; 0x19
    3116:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    3118:	0f 5f       	subi	r16, 0xFF	; 255
    311a:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    311c:	20 e0       	ldi	r18, 0x00	; 0
    311e:	30 e0       	ldi	r19, 0x00	; 0
    3120:	40 e8       	ldi	r20, 0x80	; 128
    3122:	5f e3       	ldi	r21, 0x3F	; 63
    3124:	0e 94 1d 20 	call	0x403a	; 0x403a <__gesf2>
    3128:	88 23       	and	r24, r24
    312a:	44 f7       	brge	.-48     	; 0x30fc <vDisplayWriteStringAtPos+0x260>
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    312c:	2d ec       	ldi	r18, 0xCD	; 205
    312e:	3c ec       	ldi	r19, 0xCC	; 204
    3130:	4c ec       	ldi	r20, 0xCC	; 204
    3132:	5d e3       	ldi	r21, 0x3D	; 61
    3134:	6f 89       	ldd	r22, Y+23	; 0x17
    3136:	78 8d       	ldd	r23, Y+24	; 0x18
    3138:	89 8d       	ldd	r24, Y+25	; 0x19
    313a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    313c:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__cmpsf2>
    3140:	88 23       	and	r24, r24
    3142:	1c f0       	brlt	.+6      	; 0x314a <vDisplayWriteStringAtPos+0x2ae>
    3144:	1a c0       	rjmp	.+52     	; 0x317a <vDisplayWriteStringAtPos+0x2de>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    3146:	00 e0       	ldi	r16, 0x00	; 0
    3148:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
        value *= 10.0;
    314a:	20 e0       	ldi	r18, 0x00	; 0
    314c:	30 e0       	ldi	r19, 0x00	; 0
    314e:	40 e2       	ldi	r20, 0x20	; 32
    3150:	51 e4       	ldi	r21, 0x41	; 65
    3152:	6f 89       	ldd	r22, Y+23	; 0x17
    3154:	78 8d       	ldd	r23, Y+24	; 0x18
    3156:	89 8d       	ldd	r24, Y+25	; 0x19
    3158:	9a 8d       	ldd	r25, Y+26	; 0x1a
    315a:	0e 94 22 20 	call	0x4044	; 0x4044 <__mulsf3>
    315e:	6f 8b       	std	Y+23, r22	; 0x17
    3160:	78 8f       	std	Y+24, r23	; 0x18
    3162:	89 8f       	std	Y+25, r24	; 0x19
    3164:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    3166:	01 50       	subi	r16, 0x01	; 1
    3168:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    316a:	2d ec       	ldi	r18, 0xCD	; 205
    316c:	3c ec       	ldi	r19, 0xCC	; 204
    316e:	4c ec       	ldi	r20, 0xCC	; 204
    3170:	5d e3       	ldi	r21, 0x3D	; 61
    3172:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__cmpsf2>
    3176:	88 23       	and	r24, r24
    3178:	44 f3       	brlt	.-48     	; 0x314a <vDisplayWriteStringAtPos+0x2ae>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    317a:	10 16       	cp	r1, r16
    317c:	11 06       	cpc	r1, r17
    317e:	ac f5       	brge	.+106    	; 0x31ea <vDisplayWriteStringAtPos+0x34e>
    3180:	73 01       	movw	r14, r6
    3182:	d3 01       	movw	r26, r6
    3184:	a0 0f       	add	r26, r16
    3186:	b1 1f       	adc	r27, r17
    3188:	ac 8f       	std	Y+28, r26	; 0x1c
    318a:	bd 8f       	std	Y+29, r27	; 0x1d
    318c:	3d 01       	movw	r6, r26
    318e:	6f 89       	ldd	r22, Y+23	; 0x17
    3190:	78 8d       	ldd	r23, Y+24	; 0x18
    3192:	89 8d       	ldd	r24, Y+25	; 0x19
    3194:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10;
    3196:	20 e0       	ldi	r18, 0x00	; 0
    3198:	30 e0       	ldi	r19, 0x00	; 0
    319a:	40 e2       	ldi	r20, 0x20	; 32
    319c:	51 e4       	ldi	r21, 0x41	; 65
    319e:	0e 94 22 20 	call	0x4044	; 0x4044 <__mulsf3>
    31a2:	6f 8b       	std	Y+23, r22	; 0x17
    31a4:	78 8f       	std	Y+24, r23	; 0x18
    31a6:	89 8f       	std	Y+25, r24	; 0x19
    31a8:	9a 8f       	std	Y+26, r25	; 0x1a
    31aa:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <__fixsfsi>
        *buffer++ = digit + '0';
    31ae:	20 e3       	ldi	r18, 0x30	; 48
    31b0:	26 0f       	add	r18, r22
    31b2:	f7 01       	movw	r30, r14
    31b4:	21 93       	st	Z+, r18
    31b6:	7f 01       	movw	r14, r30
        value = value * 10 - digit;
    31b8:	07 2e       	mov	r0, r23
    31ba:	00 0c       	add	r0, r0
    31bc:	88 0b       	sbc	r24, r24
    31be:	99 0b       	sbc	r25, r25
    31c0:	0e 94 6d 1f 	call	0x3eda	; 0x3eda <__floatsisf>
    31c4:	9b 01       	movw	r18, r22
    31c6:	ac 01       	movw	r20, r24
    31c8:	6f 89       	ldd	r22, Y+23	; 0x17
    31ca:	78 8d       	ldd	r23, Y+24	; 0x18
    31cc:	89 8d       	ldd	r24, Y+25	; 0x19
    31ce:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31d0:	0e 94 51 1e 	call	0x3ca2	; 0x3ca2 <__subsf3>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    31d4:	e6 14       	cp	r14, r6
    31d6:	f7 04       	cpc	r15, r7
    31d8:	f1 f6       	brne	.-68     	; 0x3196 <vDisplayWriteStringAtPos+0x2fa>
    31da:	6f 8b       	std	Y+23, r22	; 0x17
    31dc:	78 8f       	std	Y+24, r23	; 0x18
    31de:	89 8f       	std	Y+25, r24	; 0x19
    31e0:	9a 8f       	std	Y+26, r25	; 0x1a
        value = value * 10 - digit;
        ++places;
        --exponent;
    }

    if (places == 0)
    31e2:	01 15       	cp	r16, r1
    31e4:	11 05       	cpc	r17, r1
    31e6:	89 f4       	brne	.+34     	; 0x320a <vDisplayWriteStringAtPos+0x36e>
    31e8:	db c1       	rjmp	.+950    	; 0x35a0 <vDisplayWriteStringAtPos+0x704>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    31ea:	c8 01       	movw	r24, r16
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    31ec:	e0 e3       	ldi	r30, 0x30	; 48
    31ee:	d3 01       	movw	r26, r6
    31f0:	ec 93       	st	X, r30

    *buffer++ = '.';
    31f2:	73 01       	movw	r14, r6
    31f4:	f2 e0       	ldi	r31, 0x02	; 2
    31f6:	ef 0e       	add	r14, r31
    31f8:	f1 1c       	adc	r15, r1
    31fa:	2e e2       	ldi	r18, 0x2E	; 46
    31fc:	11 96       	adiw	r26, 0x01	; 1
    31fe:	2c 93       	st	X, r18

    while (exponent < 0 && places < width) {
    3200:	99 23       	and	r25, r25
    3202:	6c f0       	brlt	.+26     	; 0x321e <vDisplayWriteStringAtPos+0x382>
    3204:	00 e0       	ldi	r16, 0x00	; 0
    3206:	10 e0       	ldi	r17, 0x00	; 0
    3208:	1f c0       	rjmp	.+62     	; 0x3248 <vDisplayWriteStringAtPos+0x3ac>
    }

    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';
    320a:	ec 8c       	ldd	r14, Y+28	; 0x1c
    320c:	fd 8c       	ldd	r15, Y+29	; 0x1d
    320e:	3f ef       	ldi	r19, 0xFF	; 255
    3210:	e3 1a       	sub	r14, r19
    3212:	f3 0a       	sbc	r15, r19
    3214:	ee e2       	ldi	r30, 0x2E	; 46
    3216:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3218:	bd 8d       	ldd	r27, Y+29	; 0x1d
    321a:	ec 93       	st	X, r30
    321c:	12 c0       	rjmp	.+36     	; 0x3242 <vDisplayWriteStringAtPos+0x3a6>

    while (exponent < 0 && places < width) {
    321e:	00 e0       	ldi	r16, 0x00	; 0
    3220:	10 e0       	ldi	r17, 0x00	; 0
        *buffer++ = '0';
    3222:	ff ef       	ldi	r31, 0xFF	; 255
    3224:	ef 1a       	sub	r14, r31
    3226:	ff 0a       	sbc	r15, r31
    3228:	f7 01       	movw	r30, r14
    322a:	31 97       	sbiw	r30, 0x01	; 1
    322c:	20 e3       	ldi	r18, 0x30	; 48
    322e:	20 83       	st	Z, r18
        --exponent;
    3230:	01 97       	sbiw	r24, 0x01	; 1
        ++places;
    3232:	0f 5f       	subi	r16, 0xFF	; 255
    3234:	1f 4f       	sbci	r17, 0xFF	; 255
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    3236:	99 23       	and	r25, r25
    3238:	24 f4       	brge	.+8      	; 0x3242 <vDisplayWriteStringAtPos+0x3a6>
    323a:	04 30       	cpi	r16, 0x04	; 4
    323c:	11 05       	cpc	r17, r1
    323e:	8c f3       	brlt	.-30     	; 0x3222 <vDisplayWriteStringAtPos+0x386>
    3240:	31 c0       	rjmp	.+98     	; 0x32a4 <vDisplayWriteStringAtPos+0x408>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    3242:	04 30       	cpi	r16, 0x04	; 4
    3244:	11 05       	cpc	r17, r1
    3246:	74 f5       	brge	.+92     	; 0x32a4 <vDisplayWriteStringAtPos+0x408>
    3248:	37 01       	movw	r6, r14
    324a:	84 e0       	ldi	r24, 0x04	; 4
    324c:	90 e0       	ldi	r25, 0x00	; 0
    324e:	80 1b       	sub	r24, r16
    3250:	91 0b       	sbc	r25, r17
    3252:	e8 0e       	add	r14, r24
    3254:	f9 1e       	adc	r15, r25
    3256:	87 01       	movw	r16, r14
    3258:	6f 89       	ldd	r22, Y+23	; 0x17
    325a:	78 8d       	ldd	r23, Y+24	; 0x18
    325c:	89 8d       	ldd	r24, Y+25	; 0x19
    325e:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10.0;
    3260:	20 e0       	ldi	r18, 0x00	; 0
    3262:	30 e0       	ldi	r19, 0x00	; 0
    3264:	40 e2       	ldi	r20, 0x20	; 32
    3266:	51 e4       	ldi	r21, 0x41	; 65
    3268:	0e 94 22 20 	call	0x4044	; 0x4044 <__mulsf3>
    326c:	6f 8b       	std	Y+23, r22	; 0x17
    326e:	78 8f       	std	Y+24, r23	; 0x18
    3270:	89 8f       	std	Y+25, r24	; 0x19
    3272:	9a 8f       	std	Y+26, r25	; 0x1a
    3274:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <__fixsfsi>
        *buffer++ = digit + '0';
    3278:	20 e3       	ldi	r18, 0x30	; 48
    327a:	26 0f       	add	r18, r22
    327c:	d3 01       	movw	r26, r6
    327e:	2d 93       	st	X+, r18
    3280:	3d 01       	movw	r6, r26
        value = value * 10.0 - digit;
    3282:	07 2e       	mov	r0, r23
    3284:	00 0c       	add	r0, r0
    3286:	88 0b       	sbc	r24, r24
    3288:	99 0b       	sbc	r25, r25
    328a:	0e 94 6d 1f 	call	0x3eda	; 0x3eda <__floatsisf>
    328e:	9b 01       	movw	r18, r22
    3290:	ac 01       	movw	r20, r24
    3292:	6f 89       	ldd	r22, Y+23	; 0x17
    3294:	78 8d       	ldd	r23, Y+24	; 0x18
    3296:	89 8d       	ldd	r24, Y+25	; 0x19
    3298:	9a 8d       	ldd	r25, Y+26	; 0x1a
    329a:	0e 94 51 1e 	call	0x3ca2	; 0x3ca2 <__subsf3>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    329e:	60 16       	cp	r6, r16
    32a0:	71 06       	cpc	r7, r17
    32a2:	f1 f6       	brne	.-68     	; 0x3260 <vDisplayWriteStringAtPos+0x3c4>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
        ++places;
    }
    *buffer = '\0';
    32a4:	f7 01       	movw	r30, r14
    32a6:	10 82       	st	Z, r1
    32a8:	94 01       	movw	r18, r8
    32aa:	f4 01       	movw	r30, r8
    32ac:	e6 51       	subi	r30, 0x16	; 22
    32ae:	f3 4d       	sbci	r31, 0xD3	; 211
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    32b0:	4e ef       	ldi	r20, 0xFE	; 254
    32b2:	5c e2       	ldi	r21, 0x2C	; 44
    32b4:	80 e0       	ldi	r24, 0x00	; 0
    32b6:	90 e0       	ldi	r25, 0x00	; 0
    32b8:	05 c0       	rjmp	.+10     	; 0x32c4 <vDisplayWriteStringAtPos+0x428>

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    32ba:	da 01       	movw	r26, r20
    32bc:	6d 91       	ld	r22, X+
    32be:	ad 01       	movw	r20, r26
    32c0:	61 93       	st	Z+, r22
				break;

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    32c2:	01 96       	adiw	r24, 0x01	; 1
    32c4:	d6 01       	movw	r26, r12
    32c6:	0d 90       	ld	r0, X+
    32c8:	00 20       	and	r0, r0
    32ca:	e9 f7       	brne	.-6      	; 0x32c6 <vDisplayWriteStringAtPos+0x42a>
    32cc:	11 97       	sbiw	r26, 0x01	; 1
    32ce:	ae 5f       	subi	r26, 0xFE	; 254
    32d0:	bc 42       	sbci	r27, 0x2C	; 44
    32d2:	8a 17       	cp	r24, r26
    32d4:	9b 07       	cpc	r25, r27
    32d6:	88 f3       	brcs	.-30     	; 0x32ba <vDisplayWriteStringAtPos+0x41e>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    32d8:	4d 01       	movw	r8, r26
    32da:	82 0e       	add	r8, r18
    32dc:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    32de:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    32e0:	d2 01       	movw	r26, r4
    32e2:	15 c1       	rjmp	.+554    	; 0x350e <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    32e4:	17 01       	movw	r2, r14
    32e6:	b4 e0       	ldi	r27, 0x04	; 4
    32e8:	2b 0e       	add	r2, r27
    32ea:	31 1c       	adc	r3, r1
    32ec:	d7 01       	movw	r26, r14
    32ee:	8d 91       	ld	r24, X+
    32f0:	9d 91       	ld	r25, X+
    32f2:	0d 90       	ld	r0, X+
    32f4:	bc 91       	ld	r27, X
    32f6:	a0 2d       	mov	r26, r0
    32f8:	8f 8b       	std	Y+23, r24	; 0x17
    32fa:	98 8f       	std	Y+24, r25	; 0x18
    32fc:	a9 8f       	std	Y+25, r26	; 0x19
    32fe:	ba 8f       	std	Y+26, r27	; 0x1a

void ftoa_sci(char *buffer, double value) {
    int exponent = 0;    
    static const int width = 4;

    if (value == 0.0) {
    3300:	20 e0       	ldi	r18, 0x00	; 0
    3302:	30 e0       	ldi	r19, 0x00	; 0
    3304:	a9 01       	movw	r20, r18
    3306:	bc 01       	movw	r22, r24
    3308:	cd 01       	movw	r24, r26
    330a:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__cmpsf2>
    330e:	81 11       	cpse	r24, r1
    3310:	05 c0       	rjmp	.+10     	; 0x331c <vDisplayWriteStringAtPos+0x480>
        buffer[0] = '0';
    3312:	20 e3       	ldi	r18, 0x30	; 48
    3314:	f6 01       	movw	r30, r12
    3316:	20 83       	st	Z, r18
        buffer[1] = '\0';
    3318:	11 82       	std	Z+1, r1	; 0x01
    331a:	ca c0       	rjmp	.+404    	; 0x34b0 <vDisplayWriteStringAtPos+0x614>
        return;
    }

    if (value < 0.0) {
    331c:	20 e0       	ldi	r18, 0x00	; 0
    331e:	30 e0       	ldi	r19, 0x00	; 0
    3320:	a9 01       	movw	r20, r18
    3322:	6f 89       	ldd	r22, Y+23	; 0x17
    3324:	78 8d       	ldd	r23, Y+24	; 0x18
    3326:	89 8d       	ldd	r24, Y+25	; 0x19
    3328:	9a 8d       	ldd	r25, Y+26	; 0x1a
    332a:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__cmpsf2>
    332e:	88 23       	and	r24, r24
    3330:	9c f4       	brge	.+38     	; 0x3358 <vDisplayWriteStringAtPos+0x4bc>
        *buffer++ = '-';
    3332:	ed e2       	ldi	r30, 0x2D	; 45
    3334:	d6 01       	movw	r26, r12
    3336:	ec 93       	st	X, r30
        value = -value;
    3338:	8f 89       	ldd	r24, Y+23	; 0x17
    333a:	98 8d       	ldd	r25, Y+24	; 0x18
    333c:	a9 8d       	ldd	r26, Y+25	; 0x19
    333e:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3340:	b0 58       	subi	r27, 0x80	; 128
    3342:	8f 8b       	std	Y+23, r24	; 0x17
    3344:	98 8f       	std	Y+24, r25	; 0x18
    3346:	a9 8f       	std	Y+25, r26	; 0x19
    3348:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
        *buffer++ = '-';
    334a:	0f 2e       	mov	r0, r31
    334c:	ff ef       	ldi	r31, 0xFF	; 255
    334e:	6f 2e       	mov	r6, r31
    3350:	fc e2       	ldi	r31, 0x2C	; 44
    3352:	7f 2e       	mov	r7, r31
    3354:	f0 2d       	mov	r31, r0
    3356:	01 c0       	rjmp	.+2      	; 0x335a <vDisplayWriteStringAtPos+0x4be>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
    3358:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    335a:	20 e0       	ldi	r18, 0x00	; 0
    335c:	30 e0       	ldi	r19, 0x00	; 0
    335e:	40 e8       	ldi	r20, 0x80	; 128
    3360:	5f e3       	ldi	r21, 0x3F	; 63
    3362:	6f 89       	ldd	r22, Y+23	; 0x17
    3364:	78 8d       	ldd	r23, Y+24	; 0x18
    3366:	89 8d       	ldd	r24, Y+25	; 0x19
    3368:	9a 8d       	ldd	r25, Y+26	; 0x1a
    336a:	0e 94 1d 20 	call	0x403a	; 0x403a <__gesf2>
    336e:	88 23       	and	r24, r24
    3370:	dc f0       	brlt	.+54     	; 0x33a8 <vDisplayWriteStringAtPos+0x50c>
    3372:	00 e0       	ldi	r16, 0x00	; 0
    3374:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    3376:	20 e0       	ldi	r18, 0x00	; 0
    3378:	30 e0       	ldi	r19, 0x00	; 0
    337a:	40 e2       	ldi	r20, 0x20	; 32
    337c:	51 e4       	ldi	r21, 0x41	; 65
    337e:	6f 89       	ldd	r22, Y+23	; 0x17
    3380:	78 8d       	ldd	r23, Y+24	; 0x18
    3382:	89 8d       	ldd	r24, Y+25	; 0x19
    3384:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3386:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <__divsf3>
    338a:	6f 8b       	std	Y+23, r22	; 0x17
    338c:	78 8f       	std	Y+24, r23	; 0x18
    338e:	89 8f       	std	Y+25, r24	; 0x19
    3390:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    3392:	0f 5f       	subi	r16, 0xFF	; 255
    3394:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3396:	20 e0       	ldi	r18, 0x00	; 0
    3398:	30 e0       	ldi	r19, 0x00	; 0
    339a:	40 e8       	ldi	r20, 0x80	; 128
    339c:	5f e3       	ldi	r21, 0x3F	; 63
    339e:	0e 94 1d 20 	call	0x403a	; 0x403a <__gesf2>
    33a2:	88 23       	and	r24, r24
    33a4:	44 f7       	brge	.-48     	; 0x3376 <vDisplayWriteStringAtPos+0x4da>
    33a6:	02 c0       	rjmp	.+4      	; 0x33ac <vDisplayWriteStringAtPos+0x510>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    33a8:	00 e0       	ldi	r16, 0x00	; 0
    33aa:	10 e0       	ldi	r17, 0x00	; 0
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    33ac:	2d ec       	ldi	r18, 0xCD	; 205
    33ae:	3c ec       	ldi	r19, 0xCC	; 204
    33b0:	4c ec       	ldi	r20, 0xCC	; 204
    33b2:	5d e3       	ldi	r21, 0x3D	; 61
    33b4:	6f 89       	ldd	r22, Y+23	; 0x17
    33b6:	78 8d       	ldd	r23, Y+24	; 0x18
    33b8:	89 8d       	ldd	r24, Y+25	; 0x19
    33ba:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33bc:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__cmpsf2>
    33c0:	88 23       	and	r24, r24
    33c2:	c4 f4       	brge	.+48     	; 0x33f4 <vDisplayWriteStringAtPos+0x558>
        value *= 10.0;
    33c4:	20 e0       	ldi	r18, 0x00	; 0
    33c6:	30 e0       	ldi	r19, 0x00	; 0
    33c8:	40 e2       	ldi	r20, 0x20	; 32
    33ca:	51 e4       	ldi	r21, 0x41	; 65
    33cc:	6f 89       	ldd	r22, Y+23	; 0x17
    33ce:	78 8d       	ldd	r23, Y+24	; 0x18
    33d0:	89 8d       	ldd	r24, Y+25	; 0x19
    33d2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33d4:	0e 94 22 20 	call	0x4044	; 0x4044 <__mulsf3>
    33d8:	6f 8b       	std	Y+23, r22	; 0x17
    33da:	78 8f       	std	Y+24, r23	; 0x18
    33dc:	89 8f       	std	Y+25, r24	; 0x19
    33de:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    33e0:	01 50       	subi	r16, 0x01	; 1
    33e2:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    33e4:	2d ec       	ldi	r18, 0xCD	; 205
    33e6:	3c ec       	ldi	r19, 0xCC	; 204
    33e8:	4c ec       	ldi	r20, 0xCC	; 204
    33ea:	5d e3       	ldi	r21, 0x3D	; 61
    33ec:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__cmpsf2>
    33f0:	88 23       	and	r24, r24
    33f2:	44 f3       	brlt	.-48     	; 0x33c4 <vDisplayWriteStringAtPos+0x528>
        value = -value;
    }

    exponent = normalize(&value);

    int digit = value * 10.0;
    33f4:	20 e0       	ldi	r18, 0x00	; 0
    33f6:	30 e0       	ldi	r19, 0x00	; 0
    33f8:	40 e2       	ldi	r20, 0x20	; 32
    33fa:	51 e4       	ldi	r21, 0x41	; 65
    33fc:	6f 89       	ldd	r22, Y+23	; 0x17
    33fe:	78 8d       	ldd	r23, Y+24	; 0x18
    3400:	89 8d       	ldd	r24, Y+25	; 0x19
    3402:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3404:	0e 94 22 20 	call	0x4044	; 0x4044 <__mulsf3>
    3408:	6f 8b       	std	Y+23, r22	; 0x17
    340a:	78 8f       	std	Y+24, r23	; 0x18
    340c:	89 8f       	std	Y+25, r24	; 0x19
    340e:	9a 8f       	std	Y+26, r25	; 0x1a
    3410:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <__fixsfsi>
    *buffer++ = digit + '0';
    3414:	20 e3       	ldi	r18, 0x30	; 48
    3416:	26 0f       	add	r18, r22
    3418:	d3 01       	movw	r26, r6
    341a:	2c 93       	st	X, r18
    value = value * 10.0 - digit;
    341c:	07 2e       	mov	r0, r23
    341e:	00 0c       	add	r0, r0
    3420:	88 0b       	sbc	r24, r24
    3422:	99 0b       	sbc	r25, r25
    3424:	0e 94 6d 1f 	call	0x3eda	; 0x3eda <__floatsisf>
    3428:	9b 01       	movw	r18, r22
    342a:	ac 01       	movw	r20, r24
    342c:	6f 89       	ldd	r22, Y+23	; 0x17
    342e:	78 8d       	ldd	r23, Y+24	; 0x18
    3430:	89 8d       	ldd	r24, Y+25	; 0x19
    3432:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3434:	0e 94 51 1e 	call	0x3ca2	; 0x3ca2 <__subsf3>
    --exponent;
    3438:	f8 01       	movw	r30, r16
    343a:	31 97       	sbiw	r30, 0x01	; 1
    343c:	ec 8f       	std	Y+28, r30	; 0x1c
    343e:	fd 8f       	std	Y+29, r31	; 0x1d

    *buffer++ = '.';
    3440:	ee e2       	ldi	r30, 0x2E	; 46
    3442:	d3 01       	movw	r26, r6
    3444:	11 96       	adiw	r26, 0x01	; 1
    3446:	ec 93       	st	X, r30
    3448:	83 01       	movw	r16, r6
    344a:	0e 5f       	subi	r16, 0xFE	; 254
    344c:	1f 4f       	sbci	r17, 0xFF	; 255
    344e:	73 01       	movw	r14, r6
    3450:	f6 e0       	ldi	r31, 0x06	; 6
    3452:	ef 0e       	add	r14, r31
    3454:	f1 1c       	adc	r15, r1

    for (int i = 0; i < width; i++) {
        int digit = value * 10.0;
    3456:	20 e0       	ldi	r18, 0x00	; 0
    3458:	30 e0       	ldi	r19, 0x00	; 0
    345a:	40 e2       	ldi	r20, 0x20	; 32
    345c:	51 e4       	ldi	r21, 0x41	; 65
    345e:	0e 94 22 20 	call	0x4044	; 0x4044 <__mulsf3>
    3462:	6f 8b       	std	Y+23, r22	; 0x17
    3464:	78 8f       	std	Y+24, r23	; 0x18
    3466:	89 8f       	std	Y+25, r24	; 0x19
    3468:	9a 8f       	std	Y+26, r25	; 0x1a
    346a:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <__fixsfsi>
        *buffer++ = digit + '0';
    346e:	20 e3       	ldi	r18, 0x30	; 48
    3470:	26 0f       	add	r18, r22
    3472:	d8 01       	movw	r26, r16
    3474:	2d 93       	st	X+, r18
    3476:	8d 01       	movw	r16, r26
        value = value * 10.0 - digit;
    3478:	07 2e       	mov	r0, r23
    347a:	00 0c       	add	r0, r0
    347c:	88 0b       	sbc	r24, r24
    347e:	99 0b       	sbc	r25, r25
    3480:	0e 94 6d 1f 	call	0x3eda	; 0x3eda <__floatsisf>
    3484:	9b 01       	movw	r18, r22
    3486:	ac 01       	movw	r20, r24
    3488:	6f 89       	ldd	r22, Y+23	; 0x17
    348a:	78 8d       	ldd	r23, Y+24	; 0x18
    348c:	89 8d       	ldd	r24, Y+25	; 0x19
    348e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3490:	0e 94 51 1e 	call	0x3ca2	; 0x3ca2 <__subsf3>
    value = value * 10.0 - digit;
    --exponent;

    *buffer++ = '.';

    for (int i = 0; i < width; i++) {
    3494:	0e 15       	cp	r16, r14
    3496:	1f 05       	cpc	r17, r15
    3498:	f1 f6       	brne	.-68     	; 0x3456 <vDisplayWriteStringAtPos+0x5ba>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
    }

    *buffer++ = 'e';
    349a:	25 e6       	ldi	r18, 0x65	; 101
    349c:	f3 01       	movw	r30, r6
    349e:	26 83       	std	Z+6, r18	; 0x06
    34a0:	b3 01       	movw	r22, r6
    34a2:	69 5f       	subi	r22, 0xF9	; 249
    34a4:	7f 4f       	sbci	r23, 0xFF	; 255
    34a6:	4a e0       	ldi	r20, 0x0A	; 10
    34a8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    34aa:	9d 8d       	ldd	r25, Y+29	; 0x1d
    34ac:	0e 94 cf 20 	call	0x419e	; 0x419e <__itoa_ncheck>
    34b0:	94 01       	movw	r18, r8
    34b2:	f4 01       	movw	r30, r8
    34b4:	e6 51       	subi	r30, 0x16	; 22
    34b6:	f3 4d       	sbci	r31, 0xD3	; 211
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    34b8:	4e ef       	ldi	r20, 0xFE	; 254
    34ba:	5c e2       	ldi	r21, 0x2C	; 44
    34bc:	80 e0       	ldi	r24, 0x00	; 0
    34be:	90 e0       	ldi	r25, 0x00	; 0
    34c0:	05 c0       	rjmp	.+10     	; 0x34cc <vDisplayWriteStringAtPos+0x630>

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    34c2:	da 01       	movw	r26, r20
    34c4:	6d 91       	ld	r22, X+
    34c6:	ad 01       	movw	r20, r26
    34c8:	61 93       	st	Z+, r22
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    34ca:	01 96       	adiw	r24, 0x01	; 1
    34cc:	d6 01       	movw	r26, r12
    34ce:	0d 90       	ld	r0, X+
    34d0:	00 20       	and	r0, r0
    34d2:	e9 f7       	brne	.-6      	; 0x34ce <vDisplayWriteStringAtPos+0x632>
    34d4:	11 97       	sbiw	r26, 0x01	; 1
    34d6:	ae 5f       	subi	r26, 0xFE	; 254
    34d8:	bc 42       	sbci	r27, 0x2C	; 44
    34da:	8a 17       	cp	r24, r26
    34dc:	9b 07       	cpc	r25, r27
    34de:	88 f3       	brcs	.-30     	; 0x34c2 <vDisplayWriteStringAtPos+0x626>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    34e0:	4d 01       	movw	r8, r26
    34e2:	82 0e       	add	r8, r18
    34e4:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    34e6:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    34e8:	d2 01       	movw	r26, r4
    34ea:	11 c0       	rjmp	.+34     	; 0x350e <vDisplayWriteStringAtPos+0x672>
				break;
			}
		}
		else {
			str[length] = ch;
			if(str[length] == '\n') {
    34ec:	8a 30       	cpi	r24, 0x0A	; 10
    34ee:	29 f0       	breq	.+10     	; 0x34fa <vDisplayWriteStringAtPos+0x65e>
				length += strlen(buffer);
				break;
			}
		}
		else {
			str[length] = ch;
    34f0:	f4 01       	movw	r30, r8
    34f2:	e6 51       	subi	r30, 0x16	; 22
    34f4:	f3 4d       	sbci	r31, 0xD3	; 211
    34f6:	80 83       	st	Z, r24
    34f8:	04 c0       	rjmp	.+8      	; 0x3502 <vDisplayWriteStringAtPos+0x666>
			if(str[length] == '\n') {
				str[length] = '\0';				
    34fa:	f4 01       	movw	r30, r8
    34fc:	e6 51       	subi	r30, 0x16	; 22
    34fe:	f3 4d       	sbci	r31, 0xD3	; 211
    3500:	10 82       	st	Z, r1
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    3502:	11 96       	adiw	r26, 0x01	; 1
		else {
			str[length] = ch;
			if(str[length] == '\n') {
				str[length] = '\0';				
			}
			length++;
    3504:	ef ef       	ldi	r30, 0xFF	; 255
    3506:	8e 1a       	sub	r8, r30
    3508:	9e 0a       	sbc	r9, r30
    350a:	01 c0       	rjmp	.+2      	; 0x350e <vDisplayWriteStringAtPos+0x672>
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    350c:	d2 01       	movw	r26, r4
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    350e:	8c 91       	ld	r24, X
    3510:	81 11       	cpse	r24, r1
    3512:	01 cd       	rjmp	.-1534   	; 0x2f16 <vDisplayWriteStringAtPos+0x7a>
				str[length] = '\0';				
			}
			length++;
		}
	}
	if(length + pos >= 20) {
    3514:	8d a9       	ldd	r24, Y+53	; 0x35
    3516:	9e a9       	ldd	r25, Y+54	; 0x36
    3518:	88 0d       	add	r24, r8
    351a:	99 1d       	adc	r25, r9
    351c:	44 97       	sbiw	r24, 0x14	; 20
    351e:	3c f0       	brlt	.+14     	; 0x352e <vDisplayWriteStringAtPos+0x692>
		length = 20-pos;
    3520:	84 e1       	ldi	r24, 0x14	; 20
    3522:	90 e0       	ldi	r25, 0x00	; 0
    3524:	4c 01       	movw	r8, r24
    3526:	2d a9       	ldd	r18, Y+53	; 0x35
    3528:	3e a9       	ldd	r19, Y+54	; 0x36
    352a:	82 1a       	sub	r8, r18
    352c:	93 0a       	sbc	r9, r19
    352e:	fe 01       	movw	r30, r28
    3530:	33 96       	adiw	r30, 0x03	; 3
    3532:	ce 01       	movw	r24, r28
    3534:	47 96       	adiw	r24, 0x17	; 23
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    3536:	df 01       	movw	r26, r30
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
    3538:	1d 92       	st	X+, r1
	}
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
    353a:	a8 17       	cp	r26, r24
    353c:	b9 07       	cpc	r27, r25
    353e:	e1 f7       	brne	.-8      	; 0x3538 <vDisplayWriteStringAtPos+0x69c>
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
    3540:	3b 8d       	ldd	r19, Y+27	; 0x1b
    3542:	39 83       	std	Y+1, r19	; 0x01
	newLine.displayPos = pos;
    3544:	8d a9       	ldd	r24, Y+53	; 0x35
    3546:	8a 83       	std	Y+2, r24	; 0x02
	for(int i = 0; i < length;i++) {
    3548:	18 14       	cp	r1, r8
    354a:	19 04       	cpc	r1, r9
    354c:	5c f4       	brge	.+22     	; 0x3564 <vDisplayWriteStringAtPos+0x6c8>
    354e:	ce 01       	movw	r24, r28
    3550:	88 0d       	add	r24, r8
    3552:	99 1d       	adc	r25, r9
    3554:	03 96       	adiw	r24, 0x03	; 3
		newLine.displayBuffer[i] = str[i];
    3556:	d5 01       	movw	r26, r10
    3558:	2d 91       	ld	r18, X+
    355a:	5d 01       	movw	r10, r26
    355c:	21 93       	st	Z+, r18
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
	newLine.displayPos = pos;
	for(int i = 0; i < length;i++) {
    355e:	8e 17       	cp	r24, r30
    3560:	9f 07       	cpc	r25, r31
    3562:	c9 f7       	brne	.-14     	; 0x3556 <vDisplayWriteStringAtPos+0x6ba>
		newLine.displayBuffer[i] = str[i];
	}	
	xQueueSend(displayLineQueue, (void *) &newLine, portMAX_DELAY);
    3564:	00 e0       	ldi	r16, 0x00	; 0
    3566:	2f ef       	ldi	r18, 0xFF	; 255
    3568:	3f ef       	ldi	r19, 0xFF	; 255
    356a:	a9 01       	movw	r20, r18
    356c:	be 01       	movw	r22, r28
    356e:	6f 5f       	subi	r22, 0xFF	; 255
    3570:	7f 4f       	sbci	r23, 0xFF	; 255
    3572:	80 91 5d 32 	lds	r24, 0x325D	; 0x80325d <displayLineQueue>
    3576:	90 91 5e 32 	lds	r25, 0x325E	; 0x80325e <displayLineQueue+0x1>
    357a:	0e 94 b9 08 	call	0x1172	; 0x1172 <xQueueGenericSend>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    357e:	1b c0       	rjmp	.+54     	; 0x35b6 <vDisplayWriteStringAtPos+0x71a>
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3580:	2d ec       	ldi	r18, 0xCD	; 205
    3582:	3c ec       	ldi	r19, 0xCC	; 204
    3584:	4c ec       	ldi	r20, 0xCC	; 204
    3586:	5d e3       	ldi	r21, 0x3D	; 61
    3588:	6f 89       	ldd	r22, Y+23	; 0x17
    358a:	78 8d       	ldd	r23, Y+24	; 0x18
    358c:	89 8d       	ldd	r24, Y+25	; 0x19
    358e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3590:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__cmpsf2>
    3594:	88 23       	and	r24, r24
    3596:	0c f4       	brge	.+2      	; 0x359a <vDisplayWriteStringAtPos+0x6fe>
    3598:	d6 cd       	rjmp	.-1108   	; 0x3146 <vDisplayWriteStringAtPos+0x2aa>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    359a:	80 e0       	ldi	r24, 0x00	; 0
    359c:	90 e0       	ldi	r25, 0x00	; 0
    359e:	26 ce       	rjmp	.-948    	; 0x31ec <vDisplayWriteStringAtPos+0x350>
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    35a0:	20 e3       	ldi	r18, 0x30	; 48
    35a2:	ec 8d       	ldd	r30, Y+28	; 0x1c
    35a4:	fd 8d       	ldd	r31, Y+29	; 0x1d
    35a6:	20 83       	st	Z, r18

    *buffer++ = '.';
    35a8:	7f 01       	movw	r14, r30
    35aa:	32 e0       	ldi	r19, 0x02	; 2
    35ac:	e3 0e       	add	r14, r19
    35ae:	f1 1c       	adc	r15, r1
    35b0:	8e e2       	ldi	r24, 0x2E	; 46
    35b2:	81 83       	std	Z+1, r24	; 0x01
    35b4:	46 ce       	rjmp	.-884    	; 0x3242 <vDisplayWriteStringAtPos+0x3a6>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    35b6:	6d 96       	adiw	r28, 0x1d	; 29
    35b8:	cd bf       	out	0x3d, r28	; 61
    35ba:	de bf       	out	0x3e, r29	; 62
    35bc:	df 91       	pop	r29
    35be:	cf 91       	pop	r28
    35c0:	1f 91       	pop	r17
    35c2:	0f 91       	pop	r16
    35c4:	ff 90       	pop	r15
    35c6:	ef 90       	pop	r14
    35c8:	df 90       	pop	r13
    35ca:	cf 90       	pop	r12
    35cc:	bf 90       	pop	r11
    35ce:	af 90       	pop	r10
    35d0:	9f 90       	pop	r9
    35d2:	8f 90       	pop	r8
    35d4:	7f 90       	pop	r7
    35d6:	6f 90       	pop	r6
    35d8:	5f 90       	pop	r5
    35da:	4f 90       	pop	r4
    35dc:	3f 90       	pop	r3
    35de:	2f 90       	pop	r2
    35e0:	08 95       	ret

000035e2 <vPhase_Detection>:
SemaphoreHandle_t xGlobalProtocolBuffer_A_Key;	//A-Resource for ucGlobalProtocolBuffer_A
SemaphoreHandle_t xGlobalProtocolBuffer_B_Key;	//A-Resource for ucGlobalProtocolBuffer_B


void vPhase_Detection(void *pvParameters) // becomes peak array and position -> detects the phase shift
{
    35e2:	cf 93       	push	r28
    35e4:	df 93       	push	r29
    35e6:	cd b7       	in	r28, 0x3d	; 61
    35e8:	de b7       	in	r29, 0x3e	; 62
    35ea:	c0 54       	subi	r28, 0x40	; 64
    35ec:	d1 09       	sbc	r29, r1
    35ee:	cd bf       	out	0x3d, r28	; 61
    35f0:	de bf       	out	0x3e, r29	; 62
	int	check_phase_1, check_phase_2;
	int phase_H[32], phase_L[32];
	int phase_detect_results;
	int check_peak_position;
	int i = 0, j = 0;
	uint16_t ucqambit , ucvalue , uci, ucj, ucl, ucm, uca=0, ucb=0, ucx=0, ucy=0;
    35f2:	21 2c       	mov	r2, r1
    35f4:	31 2c       	mov	r3, r1
	int xreference_H,xreference_L,periode_rms;
	int	check_phase_1, check_phase_2;
	int phase_H[32], phase_L[32];
	int phase_detect_results;
	int check_peak_position;
	int i = 0, j = 0;
    35f6:	a1 2c       	mov	r10, r1
    35f8:	b1 2c       	mov	r11, r1
    35fa:	0f 2e       	mov	r0, r31
    35fc:	f9 e1       	ldi	r31, 0x19	; 25
    35fe:	8f 2e       	mov	r8, r31
    3600:	f2 e3       	ldi	r31, 0x32	; 50
    3602:	9f 2e       	mov	r9, r31
    3604:	f0 2d       	mov	r31, r0
    3606:	0f 2e       	mov	r0, r31
    3608:	fa e1       	ldi	r31, 0x1A	; 26
    360a:	6f 2e       	mov	r6, r31
    360c:	fd e2       	ldi	r31, 0x2D	; 45
    360e:	7f 2e       	mov	r7, r31
    3610:	f0 2d       	mov	r31, r0
    3612:	0f 2e       	mov	r0, r31
    3614:	fa e3       	ldi	r31, 0x3A	; 58
    3616:	4f 2e       	mov	r4, r31
    3618:	fd e2       	ldi	r31, 0x2D	; 45
    361a:	5f 2e       	mov	r5, r31
    361c:	f0 2d       	mov	r31, r0
	uint16_t ucqambit , ucvalue , uci, ucj, ucl, ucm, uca=0, ucb=0, ucx=0, ucy=0;
	char xOutput1, xOutput2;
	for (;;)
	{
		uxBits = xEventGroupWaitBits(
    361e:	cc 24       	eor	r12, r12
    3620:	ca 94       	dec	r12
    3622:	dc 2c       	mov	r13, r12
    3624:	76 01       	movw	r14, r12
    3626:	00 e0       	ldi	r16, 0x00	; 0
    3628:	21 e0       	ldi	r18, 0x01	; 1
    362a:	43 e0       	ldi	r20, 0x03	; 3
    362c:	50 e0       	ldi	r21, 0x00	; 0
    362e:	60 e0       	ldi	r22, 0x00	; 0
    3630:	70 e0       	ldi	r23, 0x00	; 0
    3632:	80 91 d5 31 	lds	r24, 0x31D5	; 0x8031d5 <xPhaseDetectionEventGroup>
    3636:	90 91 d6 31 	lds	r25, 0x31D6	; 0x8031d6 <xPhaseDetectionEventGroup+0x1>
    363a:	0e 94 76 03 	call	0x6ec	; 0x6ec <xEventGroupWaitBits>
		portMAX_DELAY );																/* Wait a maximum for either bit to be set. */


		/*Phase Detection */
		
		if ((uxBits & Process_Phase_detectionA)||(uxBits & Process_Phase_detectionB))	/* if Bit phase detection is set -> read out peak array*/
    363e:	63 70       	andi	r22, 0x03	; 3
    3640:	77 27       	eor	r23, r23
    3642:	67 2b       	or	r22, r23
    3644:	09 f4       	brne	.+2      	; 0x3648 <vPhase_Detection+0x66>
    3646:	f3 c0       	rjmp	.+486    	; 0x382e <vPhase_Detection+0x24c>
		{
			xreference_H = position_array_H[0]*4;
    3648:	a9 ed       	ldi	r26, 0xD9	; 217
    364a:	b1 e3       	ldi	r27, 0x31	; 49
    364c:	ed 90       	ld	r14, X+
    364e:	fc 90       	ld	r15, X
    3650:	97 01       	movw	r18, r14
    3652:	22 0f       	add	r18, r18
    3654:	33 1f       	adc	r19, r19
    3656:	22 0f       	add	r18, r18
    3658:	33 1f       	adc	r19, r19
			xreference_L = position_array_L[0]*4/3;
    365a:	ad e4       	ldi	r26, 0x4D	; 77
    365c:	b1 e3       	ldi	r27, 0x31	; 49
    365e:	ed 91       	ld	r30, X+
    3660:	fc 91       	ld	r31, X
    3662:	cf 01       	movw	r24, r30
    3664:	88 0f       	add	r24, r24
    3666:	99 1f       	adc	r25, r25
    3668:	88 0f       	add	r24, r24
    366a:	99 1f       	adc	r25, r25
    366c:	63 e0       	ldi	r22, 0x03	; 3
    366e:	70 e0       	ldi	r23, 0x00	; 0
    3670:	0e 94 8f 20 	call	0x411e	; 0x411e <__divmodhi4>
			periode_rms = position_array_H[0] + position_array_L[0];									/*(peak position of referencsignal added together will give the number of sampels for one sinus periode;*/
    3674:	a7 01       	movw	r20, r14
    3676:	4e 0f       	add	r20, r30
    3678:	5f 1f       	adc	r21, r31
				
			check_phase_1 = xreference_L - xreference_H;								/*check differences between phase_H and phase_L to prove that no reading error happened*/
    367a:	7b 01       	movw	r14, r22
    367c:	e2 1a       	sub	r14, r18
    367e:	f3 0a       	sbc	r15, r19
			check_phase_2 = xreference_H - xreference_L;
    3680:	f9 01       	movw	r30, r18
    3682:	e6 1b       	sub	r30, r22
    3684:	f7 0b       	sbc	r31, r23
    3686:	bf 01       	movw	r22, r30
    3688:	e9 ed       	ldi	r30, 0xD9	; 217
    368a:	f1 e3       	ldi	r31, 0x31	; 49
    368c:	de 01       	movw	r26, r28
    368e:	11 96       	adiw	r26, 0x01	; 1
				
			for (i=0; i<PROTOCOL_BUFFER_SIZE; i++)															/*original variable after testing: peak_array_length*/
			{
		
					position_array_H[i] = position_array_H[i]; /* Debugging*/
    3690:	21 91       	ld	r18, Z+
    3692:	31 91       	ld	r19, Z+
					position_array_L[i] = position_array_L[i]; /* Debugging*/
					phase_H[i] = (periode_rms*(j+1) - position_array_H[i]);					/* calculates the distance from high peak to start of next periode.*/
    3694:	8f ef       	ldi	r24, 0xFF	; 255
    3696:	a8 1a       	sub	r10, r24
    3698:	b8 0a       	sbc	r11, r24
    369a:	4a 9d       	mul	r20, r10
    369c:	c0 01       	movw	r24, r0
    369e:	4b 9d       	mul	r20, r11
    36a0:	90 0d       	add	r25, r0
    36a2:	5a 9d       	mul	r21, r10
    36a4:	90 0d       	add	r25, r0
    36a6:	11 24       	eor	r1, r1
    36a8:	82 1b       	sub	r24, r18
    36aa:	93 0b       	sbc	r25, r19
    36ac:	8d 93       	st	X+, r24
    36ae:	9d 93       	st	X+, r25
					phase_L[i] = (periode_rms*(j+1) - position_array_L[i]);					/* calculates the distance from low peak to start of next periode.*/
					// Phase High detect
					j++;
					if (j == 5)
    36b0:	95 e0       	ldi	r25, 0x05	; 5
    36b2:	a9 16       	cp	r10, r25
    36b4:	b1 04       	cpc	r11, r1
    36b6:	11 f4       	brne	.+4      	; 0x36bc <vPhase_Detection+0xda>
					{
						j = 0;
    36b8:	a1 2c       	mov	r10, r1
    36ba:	b1 2c       	mov	r11, r1
			periode_rms = position_array_H[0] + position_array_L[0];									/*(peak position of referencsignal added together will give the number of sampels for one sinus periode;*/
				
			check_phase_1 = xreference_L - xreference_H;								/*check differences between phase_H and phase_L to prove that no reading error happened*/
			check_phase_2 = xreference_H - xreference_L;
				
			for (i=0; i<PROTOCOL_BUFFER_SIZE; i++)															/*original variable after testing: peak_array_length*/
    36bc:	e8 15       	cp	r30, r8
    36be:	f9 05       	cpc	r31, r9
    36c0:	39 f7       	brne	.-50     	; 0x3690 <vPhase_Detection+0xae>
					}

			
			
			}
				if (( check_phase_1 < 2 )||( check_phase_2 < 2 ))						/* check if theres no read out error with comparing low peak and high peak position of reference periode.*/
    36c2:	a2 e0       	ldi	r26, 0x02	; 2
    36c4:	ea 16       	cp	r14, r26
    36c6:	f1 04       	cpc	r15, r1
    36c8:	0c f4       	brge	.+2      	; 0x36cc <vPhase_Detection+0xea>
    36ca:	b8 c0       	rjmp	.+368    	; 0x383c <vPhase_Detection+0x25a>
    36cc:	62 30       	cpi	r22, 0x02	; 2
    36ce:	71 05       	cpc	r23, r1
    36d0:	0c f0       	brlt	.+2      	; 0x36d4 <vPhase_Detection+0xf2>
    36d2:	ad c0       	rjmp	.+346    	; 0x382e <vPhase_Detection+0x24c>
				{
				
					 if(xSemaphoreTake( xGlobalProtocolBuffer_A_Key, portMAX_DELAY )) /* has to get deactivated, if only demodulating code has to be tested */					{
    36d4:	4f ef       	ldi	r20, 0xFF	; 255
    36d6:	5f ef       	ldi	r21, 0xFF	; 255
    36d8:	ba 01       	movw	r22, r20
    36da:	80 91 61 32 	lds	r24, 0x3261	; 0x803261 <xGlobalProtocolBuffer_A_Key>
    36de:	90 91 62 32 	lds	r25, 0x3262	; 0x803262 <xGlobalProtocolBuffer_A_Key+0x1>
    36e2:	0e 94 4a 0a 	call	0x1494	; 0x1494 <xQueueSemaphoreTake>
    36e6:	81 11       	cpse	r24, r1
    36e8:	2d c0       	rjmp	.+90     	; 0x3744 <vPhase_Detection+0x162>
    36ea:	b5 c0       	rjmp	.+362    	; 0x3856 <vPhase_Detection+0x274>
						for (uci = 0; uci < 8; uci++)									/*For Schleife mit 8 Wiederholungen fr 8 Byte */
						{
							for (ucj = 0; ucj < 4; ucj++)								/*For Schleife mit 4 Wiederholungen fr 8 Bits (1Byte)*/
							{
								ucvalue = phase_H[ucy];									/* result will get calculated from high peak array (low peak array is only used for checking deviations */
    36ec:	21 91       	ld	r18, Z+
    36ee:	31 91       	ld	r19, Z+
								ucy++;
								if((ucvalue < 10) && (ucvalue > 1))	/* 180 */
    36f0:	b9 01       	movw	r22, r18
    36f2:	62 50       	subi	r22, 0x02	; 2
    36f4:	71 09       	sbc	r23, r1
    36f6:	68 30       	cpi	r22, 0x08	; 8
    36f8:	71 05       	cpc	r23, r1
    36fa:	88 f0       	brcs	.+34     	; 0x371e <vPhase_Detection+0x13c>
								{
									ucqambit = 0;
									check_peak_position = ucvalue * 4;
								}
								else if((ucvalue < 15) && (ucvalue > 9)) /* 270 */
    36fc:	68 50       	subi	r22, 0x08	; 8
    36fe:	71 09       	sbc	r23, r1
    3700:	65 30       	cpi	r22, 0x05	; 5
    3702:	71 05       	cpc	r23, r1
    3704:	70 f0       	brcs	.+28     	; 0x3722 <vPhase_Detection+0x140>
								{
									ucqambit = 1;
									check_peak_position = ucvalue * 2;
								}
								else if((ucvalue < 19) && (ucvalue > 14)) /* 0 */
    3706:	65 50       	subi	r22, 0x05	; 5
    3708:	71 09       	sbc	r23, r1
    370a:	64 30       	cpi	r22, 0x04	; 4
    370c:	71 05       	cpc	r23, r1
    370e:	58 f0       	brcs	.+22     	; 0x3726 <vPhase_Detection+0x144>
								{
									ucqambit = 2;
									check_peak_position = ucvalue * 4 / 3;
								}
								else if((ucvalue < 24) && (ucvalue > 18)) /* 90 */
    3710:	23 51       	subi	r18, 0x13	; 19
    3712:	31 09       	sbc	r19, r1
    3714:	25 30       	cpi	r18, 0x05	; 5
    3716:	31 05       	cpc	r19, r1
    3718:	38 f4       	brcc	.+14     	; 0x3728 <vPhase_Detection+0x146>
								{
									ucqambit = 3;
    371a:	13 e0       	ldi	r17, 0x03	; 3
    371c:	05 c0       	rjmp	.+10     	; 0x3728 <vPhase_Detection+0x146>
							{
								ucvalue = phase_H[ucy];									/* result will get calculated from high peak array (low peak array is only used for checking deviations */
								ucy++;
								if((ucvalue < 10) && (ucvalue > 1))	/* 180 */
								{
									ucqambit = 0;
    371e:	10 e0       	ldi	r17, 0x00	; 0
    3720:	03 c0       	rjmp	.+6      	; 0x3728 <vPhase_Detection+0x146>
									check_peak_position = ucvalue * 4;
								}
								else if((ucvalue < 15) && (ucvalue > 9)) /* 270 */
								{
									ucqambit = 1;
    3722:	11 e0       	ldi	r17, 0x01	; 1
    3724:	01 c0       	rjmp	.+2      	; 0x3728 <vPhase_Detection+0x146>
									check_peak_position = ucvalue * 2;
								}
								else if((ucvalue < 19) && (ucvalue > 14)) /* 0 */
								{
									ucqambit = 2;
    3726:	12 e0       	ldi	r17, 0x02	; 2
								else if((ucvalue < 24) && (ucvalue > 18)) /* 90 */
								{
									ucqambit = 3;
									check_peak_position = ucvalue;
								}
								xOutput1 = (xOutput1 << 2) | (ucqambit & 0x03);
    3728:	88 0f       	add	r24, r24
    372a:	88 0f       	add	r24, r24
    372c:	91 2f       	mov	r25, r17
    372e:	93 70       	andi	r25, 0x03	; 3
    3730:	89 2b       	or	r24, r25
				{
				
					 if(xSemaphoreTake( xGlobalProtocolBuffer_A_Key, portMAX_DELAY )) /* has to get deactivated, if only demodulating code has to be tested */					{
						for (uci = 0; uci < 8; uci++)									/*For Schleife mit 8 Wiederholungen fr 8 Byte */
						{
							for (ucj = 0; ucj < 4; ucj++)								/*For Schleife mit 4 Wiederholungen fr 8 Bits (1Byte)*/
    3732:	4e 17       	cp	r20, r30
    3734:	5f 07       	cpc	r21, r31
    3736:	d1 f6       	brne	.-76     	; 0x36ec <vPhase_Detection+0x10a>
									ucqambit = 3;
									check_peak_position = ucvalue;
								}
								xOutput1 = (xOutput1 << 2) | (ucqambit & 0x03);
							}
							ucGlobalProtocolBuffer_A[uca] = xOutput1;
    3738:	8d 93       	st	X+, r24
    373a:	fa 01       	movw	r30, r20
			}
				if (( check_phase_1 < 2 )||( check_phase_2 < 2 ))						/* check if theres no read out error with comparing low peak and high peak position of reference periode.*/
				{
				
					 if(xSemaphoreTake( xGlobalProtocolBuffer_A_Key, portMAX_DELAY )) /* has to get deactivated, if only demodulating code has to be tested */					{
						for (uci = 0; uci < 8; uci++)									/*For Schleife mit 8 Wiederholungen fr 8 Byte */
    373c:	4a 16       	cp	r4, r26
    373e:	5b 06       	cpc	r5, r27
    3740:	61 f4       	brne	.+24     	; 0x375a <vPhase_Detection+0x178>
    3742:	10 c0       	rjmp	.+32     	; 0x3764 <vPhase_Detection+0x182>
    3744:	a2 e3       	ldi	r26, 0x32	; 50
    3746:	bd e2       	ldi	r27, 0x2D	; 45
    3748:	f1 01       	movw	r30, r2
    374a:	ee 0f       	add	r30, r30
    374c:	ff 1f       	adc	r31, r31
    374e:	81 e0       	ldi	r24, 0x01	; 1
    3750:	90 e0       	ldi	r25, 0x00	; 0
    3752:	8c 0f       	add	r24, r28
    3754:	9d 1f       	adc	r25, r29
    3756:	e8 0f       	add	r30, r24
    3758:	f9 1f       	adc	r31, r25
    375a:	af 01       	movw	r20, r30
    375c:	48 5f       	subi	r20, 0xF8	; 248
    375e:	5f 4f       	sbci	r21, 0xFF	; 255
					phase_L[i] = (periode_rms*(j+1) - position_array_L[i]);					/* calculates the distance from low peak to start of next periode.*/
					// Phase High detect
					j++;
					if (j == 5)
					{
						j = 0;
    3760:	80 e0       	ldi	r24, 0x00	; 0
    3762:	c4 cf       	rjmp	.-120    	; 0x36ec <vPhase_Detection+0x10a>
    3764:	90 e2       	ldi	r25, 0x20	; 32
    3766:	29 0e       	add	r2, r25
    3768:	31 1c       	adc	r3, r1
							uca++;
							xOutput1 = 0;
						}
						ucx=0;
						uca=0;
					 xSemaphoreGive(xGlobalProtocolBuffer_A_Key);			/* has to get deactivated, if only demodulating code has to be tested */
    376a:	00 e0       	ldi	r16, 0x00	; 0
    376c:	20 e0       	ldi	r18, 0x00	; 0
    376e:	30 e0       	ldi	r19, 0x00	; 0
    3770:	a9 01       	movw	r20, r18
    3772:	60 e0       	ldi	r22, 0x00	; 0
    3774:	70 e0       	ldi	r23, 0x00	; 0
    3776:	80 91 61 32 	lds	r24, 0x3261	; 0x803261 <xGlobalProtocolBuffer_A_Key>
    377a:	90 91 62 32 	lds	r25, 0x3262	; 0x803262 <xGlobalProtocolBuffer_A_Key+0x1>
    377e:	0e 94 b9 08 	call	0x1172	; 0x1172 <xQueueGenericSend>
					}
					
					if(xSemaphoreTake( xGlobalProtocolBuffer_B_Key, portMAX_DELAY ))
    3782:	4f ef       	ldi	r20, 0xFF	; 255
    3784:	5f ef       	ldi	r21, 0xFF	; 255
    3786:	ba 01       	movw	r22, r20
    3788:	80 91 63 32 	lds	r24, 0x3263	; 0x803263 <xGlobalProtocolBuffer_B_Key>
    378c:	90 91 64 32 	lds	r25, 0x3264	; 0x803264 <xGlobalProtocolBuffer_B_Key+0x1>
    3790:	0e 94 4a 0a 	call	0x1494	; 0x1494 <xQueueSemaphoreTake>
    3794:	81 11       	cpse	r24, r1
    3796:	2d c0       	rjmp	.+90     	; 0x37f2 <vPhase_Detection+0x210>
    3798:	4a c0       	rjmp	.+148    	; 0x382e <vPhase_Detection+0x24c>
					{
						for (ucl = 0; ucl < 8; ucl++)
						{
							for (ucm = 0; ucm < 4; ucm++)
							{
								ucvalue = phase_H[ucy];									/* result will get calculated from high peak array (low peak array is only used for checking deviations */
    379a:	21 91       	ld	r18, Z+
    379c:	31 91       	ld	r19, Z+
								ucy++;
								if((ucvalue < 10) && (ucvalue > 1))	/* 180 */
    379e:	b9 01       	movw	r22, r18
    37a0:	62 50       	subi	r22, 0x02	; 2
    37a2:	71 09       	sbc	r23, r1
    37a4:	68 30       	cpi	r22, 0x08	; 8
    37a6:	71 05       	cpc	r23, r1
    37a8:	88 f0       	brcs	.+34     	; 0x37cc <vPhase_Detection+0x1ea>
								{
									ucqambit = 0;
									check_peak_position = ucvalue * 4;
								}
								else if((ucvalue < 15) && (ucvalue > 9)) /* 270 */
    37aa:	68 50       	subi	r22, 0x08	; 8
    37ac:	71 09       	sbc	r23, r1
    37ae:	65 30       	cpi	r22, 0x05	; 5
    37b0:	71 05       	cpc	r23, r1
    37b2:	70 f0       	brcs	.+28     	; 0x37d0 <vPhase_Detection+0x1ee>
								{
									ucqambit = 1;
									check_peak_position = ucvalue * 2;
								}
								else if((ucvalue < 19) && (ucvalue > 14)) /* 0 */
    37b4:	65 50       	subi	r22, 0x05	; 5
    37b6:	71 09       	sbc	r23, r1
    37b8:	64 30       	cpi	r22, 0x04	; 4
    37ba:	71 05       	cpc	r23, r1
    37bc:	58 f0       	brcs	.+22     	; 0x37d4 <vPhase_Detection+0x1f2>
								{
									ucqambit = 2;
									check_peak_position = ucvalue * 4 / 3;
								}
								else if((ucvalue < 23) && (ucvalue > 18)) /* 90 */
    37be:	23 51       	subi	r18, 0x13	; 19
    37c0:	31 09       	sbc	r19, r1
    37c2:	24 30       	cpi	r18, 0x04	; 4
    37c4:	31 05       	cpc	r19, r1
    37c6:	38 f4       	brcc	.+14     	; 0x37d6 <vPhase_Detection+0x1f4>
								{
									ucqambit = 3;
    37c8:	13 e0       	ldi	r17, 0x03	; 3
    37ca:	05 c0       	rjmp	.+10     	; 0x37d6 <vPhase_Detection+0x1f4>
							{
								ucvalue = phase_H[ucy];									/* result will get calculated from high peak array (low peak array is only used for checking deviations */
								ucy++;
								if((ucvalue < 10) && (ucvalue > 1))	/* 180 */
								{
									ucqambit = 0;
    37cc:	10 e0       	ldi	r17, 0x00	; 0
    37ce:	03 c0       	rjmp	.+6      	; 0x37d6 <vPhase_Detection+0x1f4>
									check_peak_position = ucvalue * 4;
								}
								else if((ucvalue < 15) && (ucvalue > 9)) /* 270 */
								{
									ucqambit = 1;
    37d0:	11 e0       	ldi	r17, 0x01	; 1
    37d2:	01 c0       	rjmp	.+2      	; 0x37d6 <vPhase_Detection+0x1f4>
									check_peak_position = ucvalue * 2;
								}
								else if((ucvalue < 19) && (ucvalue > 14)) /* 0 */
								{
									ucqambit = 2;
    37d4:	12 e0       	ldi	r17, 0x02	; 2
								else if((ucvalue < 23) && (ucvalue > 18)) /* 90 */
								{
									ucqambit = 3;
									check_peak_position = ucvalue;
								}
								xOutput2 = (xOutput2 << 2) | (ucqambit & 0x03);
    37d6:	88 0f       	add	r24, r24
    37d8:	88 0f       	add	r24, r24
    37da:	91 2f       	mov	r25, r17
    37dc:	93 70       	andi	r25, 0x03	; 3
    37de:	89 2b       	or	r24, r25
					
					if(xSemaphoreTake( xGlobalProtocolBuffer_B_Key, portMAX_DELAY ))
					{
						for (ucl = 0; ucl < 8; ucl++)
						{
							for (ucm = 0; ucm < 4; ucm++)
    37e0:	4e 17       	cp	r20, r30
    37e2:	5f 07       	cpc	r21, r31
    37e4:	d1 f6       	brne	.-76     	; 0x379a <vPhase_Detection+0x1b8>
									ucqambit = 3;
									check_peak_position = ucvalue;
								}
								xOutput2 = (xOutput2 << 2) | (ucqambit & 0x03);
							}
							ucGlobalProtocolBuffer_B[ucb] = xOutput2;
    37e6:	8d 93       	st	X+, r24
    37e8:	fa 01       	movw	r30, r20
					 xSemaphoreGive(xGlobalProtocolBuffer_A_Key);			/* has to get deactivated, if only demodulating code has to be tested */
					}
					
					if(xSemaphoreTake( xGlobalProtocolBuffer_B_Key, portMAX_DELAY ))
					{
						for (ucl = 0; ucl < 8; ucl++)
    37ea:	6a 16       	cp	r6, r26
    37ec:	7b 06       	cpc	r7, r27
    37ee:	61 f4       	brne	.+24     	; 0x3808 <vPhase_Detection+0x226>
    37f0:	10 c0       	rjmp	.+32     	; 0x3812 <vPhase_Detection+0x230>
    37f2:	a2 e1       	ldi	r26, 0x12	; 18
    37f4:	bd e2       	ldi	r27, 0x2D	; 45
    37f6:	f1 01       	movw	r30, r2
    37f8:	ee 0f       	add	r30, r30
    37fa:	ff 1f       	adc	r31, r31
    37fc:	81 e0       	ldi	r24, 0x01	; 1
    37fe:	90 e0       	ldi	r25, 0x00	; 0
    3800:	8c 0f       	add	r24, r28
    3802:	9d 1f       	adc	r25, r29
    3804:	e8 0f       	add	r30, r24
    3806:	f9 1f       	adc	r31, r25
    3808:	af 01       	movw	r20, r30
    380a:	48 5f       	subi	r20, 0xF8	; 248
    380c:	5f 4f       	sbci	r21, 0xFF	; 255
									ucqambit = 2;
									check_peak_position = ucvalue * 4 / 3;
								}
								else if((ucvalue < 24) && (ucvalue > 18)) /* 90 */
								{
									ucqambit = 3;
    380e:	80 e0       	ldi	r24, 0x00	; 0
    3810:	c4 cf       	rjmp	.-120    	; 0x379a <vPhase_Detection+0x1b8>
							ucb++;
							xOutput2 = 0;
						}
						ucy=0;
						ucb=0;
						xSemaphoreGive(xGlobalProtocolBuffer_B_Key);
    3812:	00 e0       	ldi	r16, 0x00	; 0
    3814:	20 e0       	ldi	r18, 0x00	; 0
    3816:	30 e0       	ldi	r19, 0x00	; 0
    3818:	a9 01       	movw	r20, r18
    381a:	60 e0       	ldi	r22, 0x00	; 0
    381c:	70 e0       	ldi	r23, 0x00	; 0
    381e:	80 91 63 32 	lds	r24, 0x3263	; 0x803263 <xGlobalProtocolBuffer_B_Key>
    3822:	90 91 64 32 	lds	r25, 0x3264	; 0x803264 <xGlobalProtocolBuffer_B_Key+0x1>
    3826:	0e 94 b9 08 	call	0x1172	; 0x1172 <xQueueGenericSend>
							}
							ucGlobalProtocolBuffer_B[ucb] = xOutput2;
							ucb++;
							xOutput2 = 0;
						}
						ucy=0;
    382a:	21 2c       	mov	r2, r1
    382c:	31 2c       	mov	r3, r1
				}
		}
		
		
		
		vTaskDelay(100 / portTICK_RATE_MS);
    382e:	64 e6       	ldi	r22, 0x64	; 100
    3830:	70 e0       	ldi	r23, 0x00	; 0
    3832:	80 e0       	ldi	r24, 0x00	; 0
    3834:	90 e0       	ldi	r25, 0x00	; 0
    3836:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskDelay>
	}
    383a:	f1 ce       	rjmp	.-542    	; 0x361e <vPhase_Detection+0x3c>
			
			}
				if (( check_phase_1 < 2 )||( check_phase_2 < 2 ))						/* check if theres no read out error with comparing low peak and high peak position of reference periode.*/
				{
				
					 if(xSemaphoreTake( xGlobalProtocolBuffer_A_Key, portMAX_DELAY )) /* has to get deactivated, if only demodulating code has to be tested */					{
    383c:	4f ef       	ldi	r20, 0xFF	; 255
    383e:	5f ef       	ldi	r21, 0xFF	; 255
    3840:	ba 01       	movw	r22, r20
    3842:	80 91 61 32 	lds	r24, 0x3261	; 0x803261 <xGlobalProtocolBuffer_A_Key>
    3846:	90 91 62 32 	lds	r25, 0x3262	; 0x803262 <xGlobalProtocolBuffer_A_Key+0x1>
    384a:	0e 94 4a 0a 	call	0x1494	; 0x1494 <xQueueSemaphoreTake>
    384e:	88 23       	and	r24, r24
    3850:	09 f4       	brne	.+2      	; 0x3854 <vPhase_Detection+0x272>
    3852:	97 cf       	rjmp	.-210    	; 0x3782 <vPhase_Detection+0x1a0>
    3854:	77 cf       	rjmp	.-274    	; 0x3744 <vPhase_Detection+0x162>
						ucx=0;
						uca=0;
					 xSemaphoreGive(xGlobalProtocolBuffer_A_Key);			/* has to get deactivated, if only demodulating code has to be tested */
					}
					
					if(xSemaphoreTake( xGlobalProtocolBuffer_B_Key, portMAX_DELAY ))
    3856:	4f ef       	ldi	r20, 0xFF	; 255
    3858:	5f ef       	ldi	r21, 0xFF	; 255
    385a:	ba 01       	movw	r22, r20
    385c:	80 91 63 32 	lds	r24, 0x3263	; 0x803263 <xGlobalProtocolBuffer_B_Key>
    3860:	90 91 64 32 	lds	r25, 0x3264	; 0x803264 <xGlobalProtocolBuffer_B_Key+0x1>
    3864:	0e 94 4a 0a 	call	0x1494	; 0x1494 <xQueueSemaphoreTake>
    3868:	81 11       	cpse	r24, r1
    386a:	c3 cf       	rjmp	.-122    	; 0x37f2 <vPhase_Detection+0x210>
    386c:	e0 cf       	rjmp	.-64     	; 0x382e <vPhase_Detection+0x24c>

0000386e <vRead_Peaks>:
#define peak_array_length 32



void vRead_Peaks(void *pvParameters)
{
    386e:	cf 93       	push	r28
    3870:	df 93       	push	r29
    3872:	cd b7       	in	r28, 0x3d	; 61
    3874:	de b7       	in	r29, 0x3e	; 62
    3876:	28 97       	sbiw	r28, 0x08	; 8
    3878:	cd bf       	out	0x3d, r28	; 61
    387a:	de bf       	out	0x3e, r29	; 62
	int high_peak_a = 127;
	 high_peak = 127;
    387c:	8f e7       	ldi	r24, 0x7F	; 127
    387e:	90 e0       	ldi	r25, 0x00	; 0
    3880:	80 93 d7 31 	sts	0x31D7, r24	; 0x8031d7 <high_peak>
    3884:	90 93 d8 31 	sts	0x31D8, r25	; 0x8031d8 <high_peak+0x1>
	int low_peak_a = 127;
	 low_peak = 127;
    3888:	80 93 d3 31 	sts	0x31D3, r24	; 0x8031d3 <low_peak>
    388c:	90 93 d4 31 	sts	0x31D4, r25	; 0x8031d4 <low_peak+0x1>
	int count_array_a = 0;
	int count_array_b = 0;
	int count_array_position_H = 0, count_array_position_L = 0;
    3890:	1b 82       	std	Y+3, r1	; 0x03
    3892:	1c 82       	std	Y+4, r1	; 0x04
    3894:	1d 82       	std	Y+5, r1	; 0x05
    3896:	1e 82       	std	Y+6, r1	; 0x06
	int high_peak_a = 127;
	 high_peak = 127;
	int low_peak_a = 127;
	 low_peak = 127;
	int count_array_a = 0;
	int count_array_b = 0;
    3898:	a1 2c       	mov	r10, r1
    389a:	b1 2c       	mov	r11, r1
{
	int high_peak_a = 127;
	 high_peak = 127;
	int low_peak_a = 127;
	 low_peak = 127;
	int count_array_a = 0;
    389c:	41 2c       	mov	r4, r1
    389e:	51 2c       	mov	r5, r1
									{
										peak_array_L[count_array_position_L] = low_peak;
										position_array_L[count_array_position_L] = position_low_peak_a;
										count_array_position_L++;
										count_array_b++;										/* Count up to activate event bit when 16 peaks got collected*/
										low_peak = 127;
    38a0:	29 82       	std	Y+1, r2	; 0x01
    38a2:	23 2c       	mov	r2, r3
    38a4:	31 2e       	mov	r3, r17
	//int count_array_a = 0;
	EventBits_t uxBits;
	BaseType_t xResult;
	for (;;)
	{
		uxBits = xEventGroupWaitBits(
    38a6:	cc 24       	eor	r12, r12
    38a8:	ca 94       	dec	r12
    38aa:	dc 2c       	mov	r13, r12
    38ac:	76 01       	movw	r14, r12
    38ae:	00 e0       	ldi	r16, 0x00	; 0
    38b0:	21 e0       	ldi	r18, 0x01	; 1
    38b2:	43 e0       	ldi	r20, 0x03	; 3
    38b4:	50 e0       	ldi	r21, 0x00	; 0
    38b6:	60 e0       	ldi	r22, 0x00	; 0
    38b8:	70 e0       	ldi	r23, 0x00	; 0
    38ba:	80 91 4e 2e 	lds	r24, 0x2E4E	; 0x802e4e <xSignalProcessEventGroup>
    38be:	90 91 4f 2e 	lds	r25, 0x2E4F	; 0x802e4f <xSignalProcessEventGroup+0x1>
    38c2:	0e 94 76 03 	call	0x6ec	; 0x6ec <xEventGroupWaitBits>
		Process_Signal_BufferA | Process_Signal_BufferB,		/* The bits within the event group to wait for. */
		pdTRUE,													/* Bits should be cleared before returning. */
		pdFALSE,												/* Don't wait for both bits, either bit will do. */
		portMAX_DELAY );										/* Wait a maximum for either bit to be set. */
		//process signal values
		if (uxBits & Process_Signal_BufferA)											/* if "BufferA" bit is set, read out bufferA*/
    38c6:	60 ff       	sbrs	r22, 0
    38c8:	df c0       	rjmp	.+446    	; 0x3a88 <vRead_Peaks+0x21a>
		{
			i = 0;
			for(i=0;i<buffer_length;i++)
    38ca:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    38ce:	88 23       	and	r24, r24
    38d0:	09 f4       	brne	.+2      	; 0x38d4 <vRead_Peaks+0x66>
    38d2:	ba c1       	rjmp	.+884    	; 0x3c48 <vRead_Peaks+0x3da>
    38d4:	00 e0       	ldi	r16, 0x00	; 0
    38d6:	10 e0       	ldi	r17, 0x00	; 0
			{
				/* HIGH PEAK A*/
				if(count_array_a >= peak_array_length)									/* check if a package is ready to transmit*/
    38d8:	90 e2       	ldi	r25, 0x20	; 32
    38da:	49 16       	cp	r4, r25
    38dc:	51 04       	cpc	r5, r1
    38de:	6c f0       	brlt	.+26     	; 0x38fa <vRead_Peaks+0x8c>
				{
						position_array_H[count_array_position_H] =position_array_H[count_array_position_H];		/*debugging*/
						position_array_L[count_array_position_L] = position_array_L[count_array_position_L];	/*debugging*/
					count_array_a = 0;
					xResult = xEventGroupSetBits(										/* Set bit 0 and bit 4 in xEventGroup. */
    38e0:	41 e0       	ldi	r20, 0x01	; 1
    38e2:	50 e0       	ldi	r21, 0x00	; 0
    38e4:	60 e0       	ldi	r22, 0x00	; 0
    38e6:	70 e0       	ldi	r23, 0x00	; 0
    38e8:	80 91 d5 31 	lds	r24, 0x31D5	; 0x8031d5 <xPhaseDetectionEventGroup>
    38ec:	90 91 d6 31 	lds	r25, 0x31D6	; 0x8031d6 <xPhaseDetectionEventGroup+0x1>
    38f0:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <xEventGroupSetBits>
				/* HIGH PEAK A*/
				if(count_array_a >= peak_array_length)									/* check if a package is ready to transmit*/
				{
						position_array_H[count_array_position_H] =position_array_H[count_array_position_H];		/*debugging*/
						position_array_L[count_array_position_L] = position_array_L[count_array_position_L];	/*debugging*/
					count_array_a = 0;
    38f4:	41 2c       	mov	r4, r1
    38f6:	51 2c       	mov	r5, r1
    38f8:	bd c0       	rjmp	.+378    	; 0x3a74 <vRead_Peaks+0x206>
					Process_Phase_detectionA											/* The bits being set. */
					);
				}
				else
				{
					if (buffer_a[i] > 127)
    38fa:	f8 01       	movw	r30, r16
    38fc:	e4 5f       	subi	r30, 0xF4	; 244
    38fe:	fe 4c       	sbci	r31, 0xCE	; 206
    3900:	80 81       	ld	r24, Z
    3902:	88 23       	and	r24, r24
    3904:	0c f0       	brlt	.+2      	; 0x3908 <vRead_Peaks+0x9a>
    3906:	5e c0       	rjmp	.+188    	; 0x39c4 <vRead_Peaks+0x156>
					{
						if (buffer_a[i] > high_peak)									/* after test use buffer_a		//		if buffer bigger than current high_peak*/
    3908:	f8 01       	movw	r30, r16
    390a:	e4 5f       	subi	r30, 0xF4	; 244
    390c:	fe 4c       	sbci	r31, 0xCE	; 206
    390e:	80 81       	ld	r24, Z
    3910:	90 e0       	ldi	r25, 0x00	; 0
    3912:	20 91 d7 31 	lds	r18, 0x31D7	; 0x8031d7 <high_peak>
    3916:	30 91 d8 31 	lds	r19, 0x31D8	; 0x8031d8 <high_peak+0x1>
    391a:	28 17       	cp	r18, r24
    391c:	39 07       	cpc	r19, r25
    391e:	c4 f4       	brge	.+48     	; 0x3950 <vRead_Peaks+0xe2>
						{
							if (buffer_a[i] > 220)
    3920:	f8 01       	movw	r30, r16
    3922:	e4 5f       	subi	r30, 0xF4	; 244
    3924:	fe 4c       	sbci	r31, 0xCE	; 206
    3926:	80 81       	ld	r24, Z
    3928:	8d 3d       	cpi	r24, 0xDD	; 221
    392a:	08 f4       	brcc	.+2      	; 0x392e <vRead_Peaks+0xc0>
    392c:	a3 c0       	rjmp	.+326    	; 0x3a74 <vRead_Peaks+0x206>
							{
								high_peak = buffer_a[i];								// store new peak
    392e:	f8 01       	movw	r30, r16
    3930:	e4 5f       	subi	r30, 0xF4	; 244
    3932:	fe 4c       	sbci	r31, 0xCE	; 206
    3934:	80 81       	ld	r24, Z
    3936:	90 e0       	ldi	r25, 0x00	; 0
    3938:	80 93 d7 31 	sts	0x31D7, r24	; 0x8031d7 <high_peak>
    393c:	90 93 d8 31 	sts	0x31D8, r25	; 0x8031d8 <high_peak+0x1>
    3940:	0a 83       	std	Y+2, r16	; 0x02
    3942:	19 83       	std	Y+1, r17	; 0x01
								position_high_peak_a = i;								// store array position of new peak
								flag_H = 1;
								flag_L = 0;
    3944:	81 2c       	mov	r8, r1
    3946:	91 2c       	mov	r9, r1
						{
							if (buffer_a[i] > 220)
							{
								high_peak = buffer_a[i];								// store new peak
								position_high_peak_a = i;								// store array position of new peak
								flag_H = 1;
    3948:	66 24       	eor	r6, r6
    394a:	63 94       	inc	r6
    394c:	71 2c       	mov	r7, r1
    394e:	92 c0       	rjmp	.+292    	; 0x3a74 <vRead_Peaks+0x206>
								flag_L = 0;
							}
						}
						else
						{
							if (buffer_a[i] > 170 )
    3950:	f8 01       	movw	r30, r16
    3952:	e4 5f       	subi	r30, 0xF4	; 244
    3954:	fe 4c       	sbci	r31, 0xCE	; 206
    3956:	80 81       	ld	r24, Z
    3958:	8b 3a       	cpi	r24, 0xAB	; 171
    395a:	30 f0       	brcs	.+12     	; 0x3968 <vRead_Peaks+0xfa>
							{
								count_after_peak++;
    395c:	8f 81       	ldd	r24, Y+7	; 0x07
    395e:	98 85       	ldd	r25, Y+8	; 0x08
    3960:	01 96       	adiw	r24, 0x01	; 1
    3962:	8f 83       	std	Y+7, r24	; 0x07
    3964:	98 87       	std	Y+8, r25	; 0x08
    3966:	86 c0       	rjmp	.+268    	; 0x3a74 <vRead_Peaks+0x206>
							}
							else if(buffer_a[i] < 170)
    3968:	f8 01       	movw	r30, r16
    396a:	e4 5f       	subi	r30, 0xF4	; 244
    396c:	fe 4c       	sbci	r31, 0xCE	; 206
    396e:	80 81       	ld	r24, Z
    3970:	8a 3a       	cpi	r24, 0xAA	; 170
    3972:	08 f0       	brcs	.+2      	; 0x3976 <vRead_Peaks+0x108>
    3974:	7f c0       	rjmp	.+254    	; 0x3a74 <vRead_Peaks+0x206>
							{
								if(flag_H == 1)
    3976:	91 e0       	ldi	r25, 0x01	; 1
    3978:	69 16       	cp	r6, r25
    397a:	71 04       	cpc	r7, r1
    397c:	09 f0       	breq	.+2      	; 0x3980 <vRead_Peaks+0x112>
    397e:	7a c0       	rjmp	.+244    	; 0x3a74 <vRead_Peaks+0x206>
								{
									if (count_after_peak > 2)
    3980:	8f 81       	ldd	r24, Y+7	; 0x07
    3982:	98 85       	ldd	r25, Y+8	; 0x08
    3984:	03 97       	sbiw	r24, 0x03	; 3
    3986:	0c f4       	brge	.+2      	; 0x398a <vRead_Peaks+0x11c>
    3988:	75 c0       	rjmp	.+234    	; 0x3a74 <vRead_Peaks+0x206>
									{
										peak_array_H[count_array_position_H] = high_peak;
										position_array_H[count_array_position_H] = position_high_peak_a;
    398a:	ed 81       	ldd	r30, Y+5	; 0x05
    398c:	fe 81       	ldd	r31, Y+6	; 0x06
    398e:	ee 0f       	add	r30, r30
    3990:	ff 1f       	adc	r31, r31
    3992:	e7 52       	subi	r30, 0x27	; 39
    3994:	fe 4c       	sbci	r31, 0xCE	; 206
    3996:	9a 81       	ldd	r25, Y+2	; 0x02
    3998:	90 83       	st	Z, r25
    399a:	89 81       	ldd	r24, Y+1	; 0x01
    399c:	81 83       	std	Z+1, r24	; 0x01
										count_array_position_H++;
    399e:	8d 81       	ldd	r24, Y+5	; 0x05
    39a0:	9e 81       	ldd	r25, Y+6	; 0x06
    39a2:	01 96       	adiw	r24, 0x01	; 1
    39a4:	8d 83       	std	Y+5, r24	; 0x05
    39a6:	9e 83       	std	Y+6, r25	; 0x06
										count_array_a++;									/* Count up to activate event bit when 16 peaks got collected*/
    39a8:	9f ef       	ldi	r25, 0xFF	; 255
    39aa:	49 1a       	sub	r4, r25
    39ac:	59 0a       	sbc	r5, r25
										high_peak = 127;
    39ae:	8f e7       	ldi	r24, 0x7F	; 127
    39b0:	90 e0       	ldi	r25, 0x00	; 0
    39b2:	80 93 d7 31 	sts	0x31D7, r24	; 0x8031d7 <high_peak>
    39b6:	90 93 d8 31 	sts	0x31D8, r25	; 0x8031d8 <high_peak+0x1>
										flag_H = 0;
    39ba:	61 2c       	mov	r6, r1
    39bc:	71 2c       	mov	r7, r1
										count_after_peak = 0;
    39be:	1f 82       	std	Y+7, r1	; 0x07
    39c0:	18 86       	std	Y+8, r1	; 0x08
    39c2:	58 c0       	rjmp	.+176    	; 0x3a74 <vRead_Peaks+0x206>
						}
					}
					// LOW PEAK	A
					else
					{
						if (buffer_a[i] < low_peak)										/*if buffer bigger than current high_peak*/
    39c4:	f8 01       	movw	r30, r16
    39c6:	e4 5f       	subi	r30, 0xF4	; 244
    39c8:	fe 4c       	sbci	r31, 0xCE	; 206
    39ca:	80 81       	ld	r24, Z
    39cc:	90 e0       	ldi	r25, 0x00	; 0
    39ce:	20 91 d3 31 	lds	r18, 0x31D3	; 0x8031d3 <low_peak>
    39d2:	30 91 d4 31 	lds	r19, 0x31D4	; 0x8031d4 <low_peak+0x1>
    39d6:	82 17       	cp	r24, r18
    39d8:	93 07       	cpc	r25, r19
    39da:	c4 f4       	brge	.+48     	; 0x3a0c <vRead_Peaks+0x19e>
						{
							if (buffer_a[i] < 40)
    39dc:	f8 01       	movw	r30, r16
    39de:	e4 5f       	subi	r30, 0xF4	; 244
    39e0:	fe 4c       	sbci	r31, 0xCE	; 206
    39e2:	80 81       	ld	r24, Z
    39e4:	88 32       	cpi	r24, 0x28	; 40
    39e6:	08 f0       	brcs	.+2      	; 0x39ea <vRead_Peaks+0x17c>
    39e8:	45 c0       	rjmp	.+138    	; 0x3a74 <vRead_Peaks+0x206>
							{
								low_peak = buffer_a[i];									/* store new peak*/
    39ea:	f8 01       	movw	r30, r16
    39ec:	e4 5f       	subi	r30, 0xF4	; 244
    39ee:	fe 4c       	sbci	r31, 0xCE	; 206
    39f0:	80 81       	ld	r24, Z
    39f2:	90 e0       	ldi	r25, 0x00	; 0
    39f4:	80 93 d3 31 	sts	0x31D3, r24	; 0x8031d3 <low_peak>
    39f8:	90 93 d4 31 	sts	0x31D4, r25	; 0x8031d4 <low_peak+0x1>
    39fc:	30 2e       	mov	r3, r16
    39fe:	21 2e       	mov	r2, r17
								position_low_peak_a = i;									/* store array position of new peak*/
								flag_L = 1;
    3a00:	88 24       	eor	r8, r8
    3a02:	83 94       	inc	r8
    3a04:	91 2c       	mov	r9, r1
								flag_H = 0;
    3a06:	61 2c       	mov	r6, r1
    3a08:	71 2c       	mov	r7, r1
    3a0a:	34 c0       	rjmp	.+104    	; 0x3a74 <vRead_Peaks+0x206>
							}
						}
						else
						{
							if (buffer_a[i] < 85)
    3a0c:	f8 01       	movw	r30, r16
    3a0e:	e4 5f       	subi	r30, 0xF4	; 244
    3a10:	fe 4c       	sbci	r31, 0xCE	; 206
    3a12:	80 81       	ld	r24, Z
    3a14:	85 35       	cpi	r24, 0x55	; 85
    3a16:	30 f4       	brcc	.+12     	; 0x3a24 <vRead_Peaks+0x1b6>
							{
								count_after_peak++;
    3a18:	8f 81       	ldd	r24, Y+7	; 0x07
    3a1a:	98 85       	ldd	r25, Y+8	; 0x08
    3a1c:	01 96       	adiw	r24, 0x01	; 1
    3a1e:	8f 83       	std	Y+7, r24	; 0x07
    3a20:	98 87       	std	Y+8, r25	; 0x08
    3a22:	28 c0       	rjmp	.+80     	; 0x3a74 <vRead_Peaks+0x206>
							}
							else if (buffer_a[i] > 88)
    3a24:	f8 01       	movw	r30, r16
    3a26:	e4 5f       	subi	r30, 0xF4	; 244
    3a28:	fe 4c       	sbci	r31, 0xCE	; 206
    3a2a:	80 81       	ld	r24, Z
    3a2c:	89 35       	cpi	r24, 0x59	; 89
    3a2e:	10 f1       	brcs	.+68     	; 0x3a74 <vRead_Peaks+0x206>
							{
								if (flag_L == 1)
    3a30:	91 e0       	ldi	r25, 0x01	; 1
    3a32:	89 16       	cp	r8, r25
    3a34:	91 04       	cpc	r9, r1
    3a36:	f1 f4       	brne	.+60     	; 0x3a74 <vRead_Peaks+0x206>
								{
									if (count_after_peak > 2)
    3a38:	8f 81       	ldd	r24, Y+7	; 0x07
    3a3a:	98 85       	ldd	r25, Y+8	; 0x08
    3a3c:	03 97       	sbiw	r24, 0x03	; 3
    3a3e:	d4 f0       	brlt	.+52     	; 0x3a74 <vRead_Peaks+0x206>
									{
										peak_array_L[count_array_position_L] = low_peak;
										position_array_L[count_array_position_L] = position_low_peak_a;
    3a40:	eb 81       	ldd	r30, Y+3	; 0x03
    3a42:	fc 81       	ldd	r31, Y+4	; 0x04
    3a44:	ee 0f       	add	r30, r30
    3a46:	ff 1f       	adc	r31, r31
    3a48:	e3 5b       	subi	r30, 0xB3	; 179
    3a4a:	fe 4c       	sbci	r31, 0xCE	; 206
    3a4c:	30 82       	st	Z, r3
    3a4e:	21 82       	std	Z+1, r2	; 0x01
										count_array_position_L++;
    3a50:	8b 81       	ldd	r24, Y+3	; 0x03
    3a52:	9c 81       	ldd	r25, Y+4	; 0x04
    3a54:	01 96       	adiw	r24, 0x01	; 1
    3a56:	8b 83       	std	Y+3, r24	; 0x03
    3a58:	9c 83       	std	Y+4, r25	; 0x04
										count_array_a++;										/* Count up to activate event bit when 16 peaks got collected*/
    3a5a:	9f ef       	ldi	r25, 0xFF	; 255
    3a5c:	49 1a       	sub	r4, r25
    3a5e:	59 0a       	sbc	r5, r25
										low_peak = 127;
    3a60:	8f e7       	ldi	r24, 0x7F	; 127
    3a62:	90 e0       	ldi	r25, 0x00	; 0
    3a64:	80 93 d3 31 	sts	0x31D3, r24	; 0x8031d3 <low_peak>
    3a68:	90 93 d4 31 	sts	0x31D4, r25	; 0x8031d4 <low_peak+0x1>
										flag_L = 0;
    3a6c:	81 2c       	mov	r8, r1
    3a6e:	91 2c       	mov	r9, r1
										count_after_peak = 0;
    3a70:	1f 82       	std	Y+7, r1	; 0x07
    3a72:	18 86       	std	Y+8, r1	; 0x08
		portMAX_DELAY );										/* Wait a maximum for either bit to be set. */
		//process signal values
		if (uxBits & Process_Signal_BufferA)											/* if "BufferA" bit is set, read out bufferA*/
		{
			i = 0;
			for(i=0;i<buffer_length;i++)
    3a74:	0f 5f       	subi	r16, 0xFF	; 255
    3a76:	1f 4f       	sbci	r17, 0xFF	; 255
    3a78:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    3a7c:	90 e0       	ldi	r25, 0x00	; 0
    3a7e:	08 17       	cp	r16, r24
    3a80:	19 07       	cpc	r17, r25
    3a82:	0c f4       	brge	.+2      	; 0x3a86 <vRead_Peaks+0x218>
    3a84:	29 cf       	rjmp	.-430    	; 0x38d8 <vRead_Peaks+0x6a>
    3a86:	e0 c0       	rjmp	.+448    	; 0x3c48 <vRead_Peaks+0x3da>
						}
					}
				}
			}
		}
		else if (uxBits & Process_Signal_BufferB)
    3a88:	61 ff       	sbrs	r22, 1
    3a8a:	de c0       	rjmp	.+444    	; 0x3c48 <vRead_Peaks+0x3da>
		{
			for (i=0;i<buffer_length;i++)													/* after test will be variable buffer_length*/
    3a8c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    3a90:	88 23       	and	r24, r24
    3a92:	09 f4       	brne	.+2      	; 0x3a96 <vRead_Peaks+0x228>
    3a94:	d9 c0       	rjmp	.+434    	; 0x3c48 <vRead_Peaks+0x3da>
    3a96:	00 e0       	ldi	r16, 0x00	; 0
    3a98:	10 e0       	ldi	r17, 0x00	; 0
			{
				if(count_array_b >= peak_array_length)											/* check if package ready to send*/
    3a9a:	90 e2       	ldi	r25, 0x20	; 32
    3a9c:	a9 16       	cp	r10, r25
    3a9e:	b1 04       	cpc	r11, r1
    3aa0:	6c f0       	brlt	.+26     	; 0x3abc <vRead_Peaks+0x24e>
				{
					position_array_H[count_array_position_H] =position_array_H[count_array_position_H];		/*debugging*/
					position_array_L[count_array_position_L] = position_array_L[count_array_position_L];	/*debugging*/
					count_array_b = 0;
					xResult = xEventGroupSetBits(												/* Set bit 0 and bit 4 in xEventGroup. */
    3aa2:	42 e0       	ldi	r20, 0x02	; 2
    3aa4:	50 e0       	ldi	r21, 0x00	; 0
    3aa6:	60 e0       	ldi	r22, 0x00	; 0
    3aa8:	70 e0       	ldi	r23, 0x00	; 0
    3aaa:	80 91 d5 31 	lds	r24, 0x31D5	; 0x8031d5 <xPhaseDetectionEventGroup>
    3aae:	90 91 d6 31 	lds	r25, 0x31D6	; 0x8031d6 <xPhaseDetectionEventGroup+0x1>
    3ab2:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <xEventGroupSetBits>
			{
				if(count_array_b >= peak_array_length)											/* check if package ready to send*/
				{
					position_array_H[count_array_position_H] =position_array_H[count_array_position_H];		/*debugging*/
					position_array_L[count_array_position_L] = position_array_L[count_array_position_L];	/*debugging*/
					count_array_b = 0;
    3ab6:	a1 2c       	mov	r10, r1
    3ab8:	b1 2c       	mov	r11, r1
    3aba:	bd c0       	rjmp	.+378    	; 0x3c36 <vRead_Peaks+0x3c8>
					);
				}
				else
				{
					/* HIGH PEAK B */
					if (buffer_b[i] > 127)													/* after test: use variable buffer_b */
    3abc:	f8 01       	movw	r30, r16
    3abe:	e4 53       	subi	r30, 0x34	; 52
    3ac0:	ff 4c       	sbci	r31, 0xCF	; 207
    3ac2:	80 81       	ld	r24, Z
    3ac4:	88 23       	and	r24, r24
    3ac6:	0c f0       	brlt	.+2      	; 0x3aca <vRead_Peaks+0x25c>
    3ac8:	5e c0       	rjmp	.+188    	; 0x3b86 <vRead_Peaks+0x318>
					{
						if (buffer_b[i] > high_peak)											/*if buffer bigger than current high_peak*/
    3aca:	f8 01       	movw	r30, r16
    3acc:	e4 53       	subi	r30, 0x34	; 52
    3ace:	ff 4c       	sbci	r31, 0xCF	; 207
    3ad0:	80 81       	ld	r24, Z
    3ad2:	90 e0       	ldi	r25, 0x00	; 0
    3ad4:	20 91 d7 31 	lds	r18, 0x31D7	; 0x8031d7 <high_peak>
    3ad8:	30 91 d8 31 	lds	r19, 0x31D8	; 0x8031d8 <high_peak+0x1>
    3adc:	28 17       	cp	r18, r24
    3ade:	39 07       	cpc	r19, r25
    3ae0:	c4 f4       	brge	.+48     	; 0x3b12 <vRead_Peaks+0x2a4>
						{
							if (buffer_b[i] > 220)
    3ae2:	f8 01       	movw	r30, r16
    3ae4:	e4 53       	subi	r30, 0x34	; 52
    3ae6:	ff 4c       	sbci	r31, 0xCF	; 207
    3ae8:	80 81       	ld	r24, Z
    3aea:	8d 3d       	cpi	r24, 0xDD	; 221
    3aec:	08 f4       	brcc	.+2      	; 0x3af0 <vRead_Peaks+0x282>
    3aee:	a3 c0       	rjmp	.+326    	; 0x3c36 <vRead_Peaks+0x3c8>
							{
								high_peak = buffer_b[i];										/* store new peak*/
    3af0:	f8 01       	movw	r30, r16
    3af2:	e4 53       	subi	r30, 0x34	; 52
    3af4:	ff 4c       	sbci	r31, 0xCF	; 207
    3af6:	80 81       	ld	r24, Z
    3af8:	90 e0       	ldi	r25, 0x00	; 0
    3afa:	80 93 d7 31 	sts	0x31D7, r24	; 0x8031d7 <high_peak>
    3afe:	90 93 d8 31 	sts	0x31D8, r25	; 0x8031d8 <high_peak+0x1>
    3b02:	0a 83       	std	Y+2, r16	; 0x02
    3b04:	19 83       	std	Y+1, r17	; 0x01
								position_high_peak_a = i;										/* store array position of new peak*/
								flag_H = 1;
								flag_L = 0;
    3b06:	81 2c       	mov	r8, r1
    3b08:	91 2c       	mov	r9, r1
						{
							if (buffer_b[i] > 220)
							{
								high_peak = buffer_b[i];										/* store new peak*/
								position_high_peak_a = i;										/* store array position of new peak*/
								flag_H = 1;
    3b0a:	66 24       	eor	r6, r6
    3b0c:	63 94       	inc	r6
    3b0e:	71 2c       	mov	r7, r1
    3b10:	92 c0       	rjmp	.+292    	; 0x3c36 <vRead_Peaks+0x3c8>
								flag_L = 0;
							}
						}
						else
						{
							if (buffer_b[i] > 170 )											
    3b12:	f8 01       	movw	r30, r16
    3b14:	e4 53       	subi	r30, 0x34	; 52
    3b16:	ff 4c       	sbci	r31, 0xCF	; 207
    3b18:	80 81       	ld	r24, Z
    3b1a:	8b 3a       	cpi	r24, 0xAB	; 171
    3b1c:	30 f0       	brcs	.+12     	; 0x3b2a <vRead_Peaks+0x2bc>
							{
								count_after_peak++;
    3b1e:	8f 81       	ldd	r24, Y+7	; 0x07
    3b20:	98 85       	ldd	r25, Y+8	; 0x08
    3b22:	01 96       	adiw	r24, 0x01	; 1
    3b24:	8f 83       	std	Y+7, r24	; 0x07
    3b26:	98 87       	std	Y+8, r25	; 0x08
    3b28:	86 c0       	rjmp	.+268    	; 0x3c36 <vRead_Peaks+0x3c8>
							}
							else if(buffer_b[i] < 170)
    3b2a:	f8 01       	movw	r30, r16
    3b2c:	e4 53       	subi	r30, 0x34	; 52
    3b2e:	ff 4c       	sbci	r31, 0xCF	; 207
    3b30:	80 81       	ld	r24, Z
    3b32:	8a 3a       	cpi	r24, 0xAA	; 170
    3b34:	08 f0       	brcs	.+2      	; 0x3b38 <vRead_Peaks+0x2ca>
    3b36:	7f c0       	rjmp	.+254    	; 0x3c36 <vRead_Peaks+0x3c8>
							{
								if(flag_H == 1)
    3b38:	91 e0       	ldi	r25, 0x01	; 1
    3b3a:	69 16       	cp	r6, r25
    3b3c:	71 04       	cpc	r7, r1
    3b3e:	09 f0       	breq	.+2      	; 0x3b42 <vRead_Peaks+0x2d4>
    3b40:	7a c0       	rjmp	.+244    	; 0x3c36 <vRead_Peaks+0x3c8>
								{
									if (count_after_peak > 2)
    3b42:	8f 81       	ldd	r24, Y+7	; 0x07
    3b44:	98 85       	ldd	r25, Y+8	; 0x08
    3b46:	03 97       	sbiw	r24, 0x03	; 3
    3b48:	0c f4       	brge	.+2      	; 0x3b4c <vRead_Peaks+0x2de>
    3b4a:	75 c0       	rjmp	.+234    	; 0x3c36 <vRead_Peaks+0x3c8>
									{
										peak_array_H[count_array_position_H] = high_peak;
										position_array_H[count_array_position_H] = position_high_peak_a;
    3b4c:	ed 81       	ldd	r30, Y+5	; 0x05
    3b4e:	fe 81       	ldd	r31, Y+6	; 0x06
    3b50:	ee 0f       	add	r30, r30
    3b52:	ff 1f       	adc	r31, r31
    3b54:	e7 52       	subi	r30, 0x27	; 39
    3b56:	fe 4c       	sbci	r31, 0xCE	; 206
    3b58:	9a 81       	ldd	r25, Y+2	; 0x02
    3b5a:	90 83       	st	Z, r25
    3b5c:	89 81       	ldd	r24, Y+1	; 0x01
    3b5e:	81 83       	std	Z+1, r24	; 0x01
										count_array_position_H++;
    3b60:	8d 81       	ldd	r24, Y+5	; 0x05
    3b62:	9e 81       	ldd	r25, Y+6	; 0x06
    3b64:	01 96       	adiw	r24, 0x01	; 1
    3b66:	8d 83       	std	Y+5, r24	; 0x05
    3b68:	9e 83       	std	Y+6, r25	; 0x06
										count_array_b++;										/* Count up to activate event bit when 16 peaks got collected*/
    3b6a:	9f ef       	ldi	r25, 0xFF	; 255
    3b6c:	a9 1a       	sub	r10, r25
    3b6e:	b9 0a       	sbc	r11, r25
										high_peak = 127;
    3b70:	8f e7       	ldi	r24, 0x7F	; 127
    3b72:	90 e0       	ldi	r25, 0x00	; 0
    3b74:	80 93 d7 31 	sts	0x31D7, r24	; 0x8031d7 <high_peak>
    3b78:	90 93 d8 31 	sts	0x31D8, r25	; 0x8031d8 <high_peak+0x1>
										flag_H = 0;
    3b7c:	61 2c       	mov	r6, r1
    3b7e:	71 2c       	mov	r7, r1
										count_after_peak = 0;
    3b80:	1f 82       	std	Y+7, r1	; 0x07
    3b82:	18 86       	std	Y+8, r1	; 0x08
    3b84:	58 c0       	rjmp	.+176    	; 0x3c36 <vRead_Peaks+0x3c8>
						}
					}
					/* LOW PEAK	B*/
					else
					{
						if (buffer_b[i] < low_peak)											/*if buffer bigger than current high_peak*/
    3b86:	f8 01       	movw	r30, r16
    3b88:	e4 53       	subi	r30, 0x34	; 52
    3b8a:	ff 4c       	sbci	r31, 0xCF	; 207
    3b8c:	80 81       	ld	r24, Z
    3b8e:	90 e0       	ldi	r25, 0x00	; 0
    3b90:	20 91 d3 31 	lds	r18, 0x31D3	; 0x8031d3 <low_peak>
    3b94:	30 91 d4 31 	lds	r19, 0x31D4	; 0x8031d4 <low_peak+0x1>
    3b98:	82 17       	cp	r24, r18
    3b9a:	93 07       	cpc	r25, r19
    3b9c:	c4 f4       	brge	.+48     	; 0x3bce <vRead_Peaks+0x360>
						{
							if (buffer_b[i] < 40)
    3b9e:	f8 01       	movw	r30, r16
    3ba0:	e4 53       	subi	r30, 0x34	; 52
    3ba2:	ff 4c       	sbci	r31, 0xCF	; 207
    3ba4:	80 81       	ld	r24, Z
    3ba6:	88 32       	cpi	r24, 0x28	; 40
    3ba8:	08 f0       	brcs	.+2      	; 0x3bac <vRead_Peaks+0x33e>
    3baa:	45 c0       	rjmp	.+138    	; 0x3c36 <vRead_Peaks+0x3c8>
							{
								low_peak = buffer_b[i];										/* store new peak*/
    3bac:	f8 01       	movw	r30, r16
    3bae:	e4 53       	subi	r30, 0x34	; 52
    3bb0:	ff 4c       	sbci	r31, 0xCF	; 207
    3bb2:	80 81       	ld	r24, Z
    3bb4:	90 e0       	ldi	r25, 0x00	; 0
    3bb6:	80 93 d3 31 	sts	0x31D3, r24	; 0x8031d3 <low_peak>
    3bba:	90 93 d4 31 	sts	0x31D4, r25	; 0x8031d4 <low_peak+0x1>
    3bbe:	30 2e       	mov	r3, r16
    3bc0:	21 2e       	mov	r2, r17
								position_low_peak_a = i;										/* store array position of new peak*/
								flag_L = 1;
    3bc2:	88 24       	eor	r8, r8
    3bc4:	83 94       	inc	r8
    3bc6:	91 2c       	mov	r9, r1
								flag_H = 0;
    3bc8:	61 2c       	mov	r6, r1
    3bca:	71 2c       	mov	r7, r1
    3bcc:	34 c0       	rjmp	.+104    	; 0x3c36 <vRead_Peaks+0x3c8>
							}
						}
						else
						{
							if (buffer_b[i] < 88)
    3bce:	f8 01       	movw	r30, r16
    3bd0:	e4 53       	subi	r30, 0x34	; 52
    3bd2:	ff 4c       	sbci	r31, 0xCF	; 207
    3bd4:	80 81       	ld	r24, Z
    3bd6:	88 35       	cpi	r24, 0x58	; 88
    3bd8:	30 f4       	brcc	.+12     	; 0x3be6 <vRead_Peaks+0x378>
							{
								count_after_peak++;
    3bda:	8f 81       	ldd	r24, Y+7	; 0x07
    3bdc:	98 85       	ldd	r25, Y+8	; 0x08
    3bde:	01 96       	adiw	r24, 0x01	; 1
    3be0:	8f 83       	std	Y+7, r24	; 0x07
    3be2:	98 87       	std	Y+8, r25	; 0x08
    3be4:	28 c0       	rjmp	.+80     	; 0x3c36 <vRead_Peaks+0x3c8>
							}
							else if (buffer_b[i] > 85)
    3be6:	f8 01       	movw	r30, r16
    3be8:	e4 53       	subi	r30, 0x34	; 52
    3bea:	ff 4c       	sbci	r31, 0xCF	; 207
    3bec:	80 81       	ld	r24, Z
    3bee:	86 35       	cpi	r24, 0x56	; 86
    3bf0:	10 f1       	brcs	.+68     	; 0x3c36 <vRead_Peaks+0x3c8>
							{
								if (flag_L == 1)
    3bf2:	91 e0       	ldi	r25, 0x01	; 1
    3bf4:	89 16       	cp	r8, r25
    3bf6:	91 04       	cpc	r9, r1
    3bf8:	f1 f4       	brne	.+60     	; 0x3c36 <vRead_Peaks+0x3c8>
								{
									if (count_after_peak > 2)
    3bfa:	8f 81       	ldd	r24, Y+7	; 0x07
    3bfc:	98 85       	ldd	r25, Y+8	; 0x08
    3bfe:	03 97       	sbiw	r24, 0x03	; 3
    3c00:	d4 f0       	brlt	.+52     	; 0x3c36 <vRead_Peaks+0x3c8>
									{
										peak_array_L[count_array_position_L] = low_peak;
										position_array_L[count_array_position_L] = position_low_peak_a;
    3c02:	eb 81       	ldd	r30, Y+3	; 0x03
    3c04:	fc 81       	ldd	r31, Y+4	; 0x04
    3c06:	ee 0f       	add	r30, r30
    3c08:	ff 1f       	adc	r31, r31
    3c0a:	e3 5b       	subi	r30, 0xB3	; 179
    3c0c:	fe 4c       	sbci	r31, 0xCE	; 206
    3c0e:	30 82       	st	Z, r3
    3c10:	21 82       	std	Z+1, r2	; 0x01
										count_array_position_L++;
    3c12:	8b 81       	ldd	r24, Y+3	; 0x03
    3c14:	9c 81       	ldd	r25, Y+4	; 0x04
    3c16:	01 96       	adiw	r24, 0x01	; 1
    3c18:	8b 83       	std	Y+3, r24	; 0x03
    3c1a:	9c 83       	std	Y+4, r25	; 0x04
										count_array_b++;										/* Count up to activate event bit when 16 peaks got collected*/
    3c1c:	9f ef       	ldi	r25, 0xFF	; 255
    3c1e:	a9 1a       	sub	r10, r25
    3c20:	b9 0a       	sbc	r11, r25
										low_peak = 127;
    3c22:	8f e7       	ldi	r24, 0x7F	; 127
    3c24:	90 e0       	ldi	r25, 0x00	; 0
    3c26:	80 93 d3 31 	sts	0x31D3, r24	; 0x8031d3 <low_peak>
    3c2a:	90 93 d4 31 	sts	0x31D4, r25	; 0x8031d4 <low_peak+0x1>
										flag_L = 0;
    3c2e:	81 2c       	mov	r8, r1
    3c30:	91 2c       	mov	r9, r1
										count_after_peak = 0;
    3c32:	1f 82       	std	Y+7, r1	; 0x07
    3c34:	18 86       	std	Y+8, r1	; 0x08
				}
			}
		}
		else if (uxBits & Process_Signal_BufferB)
		{
			for (i=0;i<buffer_length;i++)													/* after test will be variable buffer_length*/
    3c36:	0f 5f       	subi	r16, 0xFF	; 255
    3c38:	1f 4f       	sbci	r17, 0xFF	; 255
    3c3a:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    3c3e:	90 e0       	ldi	r25, 0x00	; 0
    3c40:	08 17       	cp	r16, r24
    3c42:	19 07       	cpc	r17, r25
    3c44:	0c f4       	brge	.+2      	; 0x3c48 <vRead_Peaks+0x3da>
    3c46:	29 cf       	rjmp	.-430    	; 0x3a9a <vRead_Peaks+0x22c>
						}
					}
				}
			}
		}
		vTaskDelay(100 / portTICK_RATE_MS);
    3c48:	64 e6       	ldi	r22, 0x64	; 100
    3c4a:	70 e0       	ldi	r23, 0x00	; 0
    3c4c:	80 e0       	ldi	r24, 0x00	; 0
    3c4e:	90 e0       	ldi	r25, 0x00	; 0
    3c50:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <vTaskDelay>
	}
    3c54:	28 ce       	rjmp	.-944    	; 0x38a6 <vRead_Peaks+0x38>

00003c56 <getResetReason>:
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
	 // software reset ?
	 if( RST.STATUS & RST_SRF_bm )
    3c56:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3c5a:	85 ff       	sbrs	r24, 5
    3c5c:	05 c0       	rjmp	.+10     	; 0x3c68 <getResetReason+0x12>
	 {
		 // reset this bit
		 RST.STATUS = RST_SRF_bm;
    3c5e:	80 e2       	ldi	r24, 0x20	; 32
    3c60:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_SOFTWARERESET;
    3c64:	81 e0       	ldi	r24, 0x01	; 1
    3c66:	08 95       	ret
	 }
	 // power on reset ?
	 else if( RST.STATUS & RST_PORF_bm)
    3c68:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3c6c:	80 ff       	sbrs	r24, 0
    3c6e:	05 c0       	rjmp	.+10     	; 0x3c7a <getResetReason+0x24>
	 {
		 // reset this bit
		 RST.STATUS = RST_PORF_bm;
    3c70:	81 e0       	ldi	r24, 0x01	; 1
    3c72:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_POWERONRESET;
    3c76:	82 e0       	ldi	r24, 0x02	; 2
    3c78:	08 95       	ret
	 }
	 // debugger reset ?
	 else if( RST.STATUS & RST_PDIRF_bm)
    3c7a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3c7e:	84 ff       	sbrs	r24, 4
    3c80:	05 c0       	rjmp	.+10     	; 0x3c8c <getResetReason+0x36>
	 {
		 // reset this bit
		 RST.STATUS = RST_PDIRF_bm;
    3c82:	80 e1       	ldi	r24, 0x10	; 16
    3c84:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_DEBUGGERRESET;
    3c88:	83 e0       	ldi	r24, 0x03	; 3
    3c8a:	08 95       	ret
	 }
	 // external reset ?
	 else if( RST.STATUS & RST_EXTRF_bm)
    3c8c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3c90:	81 ff       	sbrs	r24, 1
    3c92:	05 c0       	rjmp	.+10     	; 0x3c9e <getResetReason+0x48>
	 {
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
    3c94:	82 e0       	ldi	r24, 0x02	; 2
    3c96:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_EXTERNALRESET;
    3c9a:	84 e0       	ldi	r24, 0x04	; 4
    3c9c:	08 95       	ret
 */ 
 #include "avr_compiler.h"
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
    3c9e:	82 e0       	ldi	r24, 0x02	; 2
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
		 returnValue = RESETREASON_EXTERNALRESET;
	 }
	 return returnValue;
    3ca0:	08 95       	ret

00003ca2 <__subsf3>:
    3ca2:	50 58       	subi	r21, 0x80	; 128

00003ca4 <__addsf3>:
    3ca4:	bb 27       	eor	r27, r27
    3ca6:	aa 27       	eor	r26, r26
    3ca8:	0e 94 69 1e 	call	0x3cd2	; 0x3cd2 <__addsf3x>
    3cac:	0c 94 e3 1f 	jmp	0x3fc6	; 0x3fc6 <__fp_round>
    3cb0:	0e 94 d5 1f 	call	0x3faa	; 0x3faa <__fp_pscA>
    3cb4:	38 f0       	brcs	.+14     	; 0x3cc4 <__addsf3+0x20>
    3cb6:	0e 94 dc 1f 	call	0x3fb8	; 0x3fb8 <__fp_pscB>
    3cba:	20 f0       	brcs	.+8      	; 0x3cc4 <__addsf3+0x20>
    3cbc:	39 f4       	brne	.+14     	; 0x3ccc <__addsf3+0x28>
    3cbe:	9f 3f       	cpi	r25, 0xFF	; 255
    3cc0:	19 f4       	brne	.+6      	; 0x3cc8 <__addsf3+0x24>
    3cc2:	26 f4       	brtc	.+8      	; 0x3ccc <__addsf3+0x28>
    3cc4:	0c 94 d2 1f 	jmp	0x3fa4	; 0x3fa4 <__fp_nan>
    3cc8:	0e f4       	brtc	.+2      	; 0x3ccc <__addsf3+0x28>
    3cca:	e0 95       	com	r30
    3ccc:	e7 fb       	bst	r30, 7
    3cce:	0c 94 cc 1f 	jmp	0x3f98	; 0x3f98 <__fp_inf>

00003cd2 <__addsf3x>:
    3cd2:	e9 2f       	mov	r30, r25
    3cd4:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <__fp_split3>
    3cd8:	58 f3       	brcs	.-42     	; 0x3cb0 <__addsf3+0xc>
    3cda:	ba 17       	cp	r27, r26
    3cdc:	62 07       	cpc	r22, r18
    3cde:	73 07       	cpc	r23, r19
    3ce0:	84 07       	cpc	r24, r20
    3ce2:	95 07       	cpc	r25, r21
    3ce4:	20 f0       	brcs	.+8      	; 0x3cee <__addsf3x+0x1c>
    3ce6:	79 f4       	brne	.+30     	; 0x3d06 <__addsf3x+0x34>
    3ce8:	a6 f5       	brtc	.+104    	; 0x3d52 <__addsf3x+0x80>
    3cea:	0c 94 16 20 	jmp	0x402c	; 0x402c <__fp_zero>
    3cee:	0e f4       	brtc	.+2      	; 0x3cf2 <__addsf3x+0x20>
    3cf0:	e0 95       	com	r30
    3cf2:	0b 2e       	mov	r0, r27
    3cf4:	ba 2f       	mov	r27, r26
    3cf6:	a0 2d       	mov	r26, r0
    3cf8:	0b 01       	movw	r0, r22
    3cfa:	b9 01       	movw	r22, r18
    3cfc:	90 01       	movw	r18, r0
    3cfe:	0c 01       	movw	r0, r24
    3d00:	ca 01       	movw	r24, r20
    3d02:	a0 01       	movw	r20, r0
    3d04:	11 24       	eor	r1, r1
    3d06:	ff 27       	eor	r31, r31
    3d08:	59 1b       	sub	r21, r25
    3d0a:	99 f0       	breq	.+38     	; 0x3d32 <__addsf3x+0x60>
    3d0c:	59 3f       	cpi	r21, 0xF9	; 249
    3d0e:	50 f4       	brcc	.+20     	; 0x3d24 <__addsf3x+0x52>
    3d10:	50 3e       	cpi	r21, 0xE0	; 224
    3d12:	68 f1       	brcs	.+90     	; 0x3d6e <__addsf3x+0x9c>
    3d14:	1a 16       	cp	r1, r26
    3d16:	f0 40       	sbci	r31, 0x00	; 0
    3d18:	a2 2f       	mov	r26, r18
    3d1a:	23 2f       	mov	r18, r19
    3d1c:	34 2f       	mov	r19, r20
    3d1e:	44 27       	eor	r20, r20
    3d20:	58 5f       	subi	r21, 0xF8	; 248
    3d22:	f3 cf       	rjmp	.-26     	; 0x3d0a <__addsf3x+0x38>
    3d24:	46 95       	lsr	r20
    3d26:	37 95       	ror	r19
    3d28:	27 95       	ror	r18
    3d2a:	a7 95       	ror	r26
    3d2c:	f0 40       	sbci	r31, 0x00	; 0
    3d2e:	53 95       	inc	r21
    3d30:	c9 f7       	brne	.-14     	; 0x3d24 <__addsf3x+0x52>
    3d32:	7e f4       	brtc	.+30     	; 0x3d52 <__addsf3x+0x80>
    3d34:	1f 16       	cp	r1, r31
    3d36:	ba 0b       	sbc	r27, r26
    3d38:	62 0b       	sbc	r22, r18
    3d3a:	73 0b       	sbc	r23, r19
    3d3c:	84 0b       	sbc	r24, r20
    3d3e:	ba f0       	brmi	.+46     	; 0x3d6e <__addsf3x+0x9c>
    3d40:	91 50       	subi	r25, 0x01	; 1
    3d42:	a1 f0       	breq	.+40     	; 0x3d6c <__addsf3x+0x9a>
    3d44:	ff 0f       	add	r31, r31
    3d46:	bb 1f       	adc	r27, r27
    3d48:	66 1f       	adc	r22, r22
    3d4a:	77 1f       	adc	r23, r23
    3d4c:	88 1f       	adc	r24, r24
    3d4e:	c2 f7       	brpl	.-16     	; 0x3d40 <__addsf3x+0x6e>
    3d50:	0e c0       	rjmp	.+28     	; 0x3d6e <__addsf3x+0x9c>
    3d52:	ba 0f       	add	r27, r26
    3d54:	62 1f       	adc	r22, r18
    3d56:	73 1f       	adc	r23, r19
    3d58:	84 1f       	adc	r24, r20
    3d5a:	48 f4       	brcc	.+18     	; 0x3d6e <__addsf3x+0x9c>
    3d5c:	87 95       	ror	r24
    3d5e:	77 95       	ror	r23
    3d60:	67 95       	ror	r22
    3d62:	b7 95       	ror	r27
    3d64:	f7 95       	ror	r31
    3d66:	9e 3f       	cpi	r25, 0xFE	; 254
    3d68:	08 f0       	brcs	.+2      	; 0x3d6c <__addsf3x+0x9a>
    3d6a:	b0 cf       	rjmp	.-160    	; 0x3ccc <__addsf3+0x28>
    3d6c:	93 95       	inc	r25
    3d6e:	88 0f       	add	r24, r24
    3d70:	08 f0       	brcs	.+2      	; 0x3d74 <__addsf3x+0xa2>
    3d72:	99 27       	eor	r25, r25
    3d74:	ee 0f       	add	r30, r30
    3d76:	97 95       	ror	r25
    3d78:	87 95       	ror	r24
    3d7a:	08 95       	ret

00003d7c <__cmpsf2>:
    3d7c:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <__fp_cmp>
    3d80:	08 f4       	brcc	.+2      	; 0x3d84 <__cmpsf2+0x8>
    3d82:	81 e0       	ldi	r24, 0x01	; 1
    3d84:	08 95       	ret

00003d86 <__divsf3>:
    3d86:	0e 94 d7 1e 	call	0x3dae	; 0x3dae <__divsf3x>
    3d8a:	0c 94 e3 1f 	jmp	0x3fc6	; 0x3fc6 <__fp_round>
    3d8e:	0e 94 dc 1f 	call	0x3fb8	; 0x3fb8 <__fp_pscB>
    3d92:	58 f0       	brcs	.+22     	; 0x3daa <__divsf3+0x24>
    3d94:	0e 94 d5 1f 	call	0x3faa	; 0x3faa <__fp_pscA>
    3d98:	40 f0       	brcs	.+16     	; 0x3daa <__divsf3+0x24>
    3d9a:	29 f4       	brne	.+10     	; 0x3da6 <__divsf3+0x20>
    3d9c:	5f 3f       	cpi	r21, 0xFF	; 255
    3d9e:	29 f0       	breq	.+10     	; 0x3daa <__divsf3+0x24>
    3da0:	0c 94 cc 1f 	jmp	0x3f98	; 0x3f98 <__fp_inf>
    3da4:	51 11       	cpse	r21, r1
    3da6:	0c 94 17 20 	jmp	0x402e	; 0x402e <__fp_szero>
    3daa:	0c 94 d2 1f 	jmp	0x3fa4	; 0x3fa4 <__fp_nan>

00003dae <__divsf3x>:
    3dae:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <__fp_split3>
    3db2:	68 f3       	brcs	.-38     	; 0x3d8e <__divsf3+0x8>

00003db4 <__divsf3_pse>:
    3db4:	99 23       	and	r25, r25
    3db6:	b1 f3       	breq	.-20     	; 0x3da4 <__divsf3+0x1e>
    3db8:	55 23       	and	r21, r21
    3dba:	91 f3       	breq	.-28     	; 0x3da0 <__divsf3+0x1a>
    3dbc:	95 1b       	sub	r25, r21
    3dbe:	55 0b       	sbc	r21, r21
    3dc0:	bb 27       	eor	r27, r27
    3dc2:	aa 27       	eor	r26, r26
    3dc4:	62 17       	cp	r22, r18
    3dc6:	73 07       	cpc	r23, r19
    3dc8:	84 07       	cpc	r24, r20
    3dca:	38 f0       	brcs	.+14     	; 0x3dda <__divsf3_pse+0x26>
    3dcc:	9f 5f       	subi	r25, 0xFF	; 255
    3dce:	5f 4f       	sbci	r21, 0xFF	; 255
    3dd0:	22 0f       	add	r18, r18
    3dd2:	33 1f       	adc	r19, r19
    3dd4:	44 1f       	adc	r20, r20
    3dd6:	aa 1f       	adc	r26, r26
    3dd8:	a9 f3       	breq	.-22     	; 0x3dc4 <__divsf3_pse+0x10>
    3dda:	35 d0       	rcall	.+106    	; 0x3e46 <__divsf3_pse+0x92>
    3ddc:	0e 2e       	mov	r0, r30
    3dde:	3a f0       	brmi	.+14     	; 0x3dee <__divsf3_pse+0x3a>
    3de0:	e0 e8       	ldi	r30, 0x80	; 128
    3de2:	32 d0       	rcall	.+100    	; 0x3e48 <__divsf3_pse+0x94>
    3de4:	91 50       	subi	r25, 0x01	; 1
    3de6:	50 40       	sbci	r21, 0x00	; 0
    3de8:	e6 95       	lsr	r30
    3dea:	00 1c       	adc	r0, r0
    3dec:	ca f7       	brpl	.-14     	; 0x3de0 <__divsf3_pse+0x2c>
    3dee:	2b d0       	rcall	.+86     	; 0x3e46 <__divsf3_pse+0x92>
    3df0:	fe 2f       	mov	r31, r30
    3df2:	29 d0       	rcall	.+82     	; 0x3e46 <__divsf3_pse+0x92>
    3df4:	66 0f       	add	r22, r22
    3df6:	77 1f       	adc	r23, r23
    3df8:	88 1f       	adc	r24, r24
    3dfa:	bb 1f       	adc	r27, r27
    3dfc:	26 17       	cp	r18, r22
    3dfe:	37 07       	cpc	r19, r23
    3e00:	48 07       	cpc	r20, r24
    3e02:	ab 07       	cpc	r26, r27
    3e04:	b0 e8       	ldi	r27, 0x80	; 128
    3e06:	09 f0       	breq	.+2      	; 0x3e0a <__divsf3_pse+0x56>
    3e08:	bb 0b       	sbc	r27, r27
    3e0a:	80 2d       	mov	r24, r0
    3e0c:	bf 01       	movw	r22, r30
    3e0e:	ff 27       	eor	r31, r31
    3e10:	93 58       	subi	r25, 0x83	; 131
    3e12:	5f 4f       	sbci	r21, 0xFF	; 255
    3e14:	3a f0       	brmi	.+14     	; 0x3e24 <__divsf3_pse+0x70>
    3e16:	9e 3f       	cpi	r25, 0xFE	; 254
    3e18:	51 05       	cpc	r21, r1
    3e1a:	78 f0       	brcs	.+30     	; 0x3e3a <__divsf3_pse+0x86>
    3e1c:	0c 94 cc 1f 	jmp	0x3f98	; 0x3f98 <__fp_inf>
    3e20:	0c 94 17 20 	jmp	0x402e	; 0x402e <__fp_szero>
    3e24:	5f 3f       	cpi	r21, 0xFF	; 255
    3e26:	e4 f3       	brlt	.-8      	; 0x3e20 <__divsf3_pse+0x6c>
    3e28:	98 3e       	cpi	r25, 0xE8	; 232
    3e2a:	d4 f3       	brlt	.-12     	; 0x3e20 <__divsf3_pse+0x6c>
    3e2c:	86 95       	lsr	r24
    3e2e:	77 95       	ror	r23
    3e30:	67 95       	ror	r22
    3e32:	b7 95       	ror	r27
    3e34:	f7 95       	ror	r31
    3e36:	9f 5f       	subi	r25, 0xFF	; 255
    3e38:	c9 f7       	brne	.-14     	; 0x3e2c <__divsf3_pse+0x78>
    3e3a:	88 0f       	add	r24, r24
    3e3c:	91 1d       	adc	r25, r1
    3e3e:	96 95       	lsr	r25
    3e40:	87 95       	ror	r24
    3e42:	97 f9       	bld	r25, 7
    3e44:	08 95       	ret
    3e46:	e1 e0       	ldi	r30, 0x01	; 1
    3e48:	66 0f       	add	r22, r22
    3e4a:	77 1f       	adc	r23, r23
    3e4c:	88 1f       	adc	r24, r24
    3e4e:	bb 1f       	adc	r27, r27
    3e50:	62 17       	cp	r22, r18
    3e52:	73 07       	cpc	r23, r19
    3e54:	84 07       	cpc	r24, r20
    3e56:	ba 07       	cpc	r27, r26
    3e58:	20 f0       	brcs	.+8      	; 0x3e62 <__divsf3_pse+0xae>
    3e5a:	62 1b       	sub	r22, r18
    3e5c:	73 0b       	sbc	r23, r19
    3e5e:	84 0b       	sbc	r24, r20
    3e60:	ba 0b       	sbc	r27, r26
    3e62:	ee 1f       	adc	r30, r30
    3e64:	88 f7       	brcc	.-30     	; 0x3e48 <__divsf3_pse+0x94>
    3e66:	e0 95       	com	r30
    3e68:	08 95       	ret

00003e6a <__fixsfsi>:
    3e6a:	0e 94 3c 1f 	call	0x3e78	; 0x3e78 <__fixunssfsi>
    3e6e:	68 94       	set
    3e70:	b1 11       	cpse	r27, r1
    3e72:	0c 94 17 20 	jmp	0x402e	; 0x402e <__fp_szero>
    3e76:	08 95       	ret

00003e78 <__fixunssfsi>:
    3e78:	0e 94 fc 1f 	call	0x3ff8	; 0x3ff8 <__fp_splitA>
    3e7c:	88 f0       	brcs	.+34     	; 0x3ea0 <__fixunssfsi+0x28>
    3e7e:	9f 57       	subi	r25, 0x7F	; 127
    3e80:	98 f0       	brcs	.+38     	; 0x3ea8 <__fixunssfsi+0x30>
    3e82:	b9 2f       	mov	r27, r25
    3e84:	99 27       	eor	r25, r25
    3e86:	b7 51       	subi	r27, 0x17	; 23
    3e88:	b0 f0       	brcs	.+44     	; 0x3eb6 <__fixunssfsi+0x3e>
    3e8a:	e1 f0       	breq	.+56     	; 0x3ec4 <__fixunssfsi+0x4c>
    3e8c:	66 0f       	add	r22, r22
    3e8e:	77 1f       	adc	r23, r23
    3e90:	88 1f       	adc	r24, r24
    3e92:	99 1f       	adc	r25, r25
    3e94:	1a f0       	brmi	.+6      	; 0x3e9c <__fixunssfsi+0x24>
    3e96:	ba 95       	dec	r27
    3e98:	c9 f7       	brne	.-14     	; 0x3e8c <__fixunssfsi+0x14>
    3e9a:	14 c0       	rjmp	.+40     	; 0x3ec4 <__fixunssfsi+0x4c>
    3e9c:	b1 30       	cpi	r27, 0x01	; 1
    3e9e:	91 f0       	breq	.+36     	; 0x3ec4 <__fixunssfsi+0x4c>
    3ea0:	0e 94 16 20 	call	0x402c	; 0x402c <__fp_zero>
    3ea4:	b1 e0       	ldi	r27, 0x01	; 1
    3ea6:	08 95       	ret
    3ea8:	0c 94 16 20 	jmp	0x402c	; 0x402c <__fp_zero>
    3eac:	67 2f       	mov	r22, r23
    3eae:	78 2f       	mov	r23, r24
    3eb0:	88 27       	eor	r24, r24
    3eb2:	b8 5f       	subi	r27, 0xF8	; 248
    3eb4:	39 f0       	breq	.+14     	; 0x3ec4 <__fixunssfsi+0x4c>
    3eb6:	b9 3f       	cpi	r27, 0xF9	; 249
    3eb8:	cc f3       	brlt	.-14     	; 0x3eac <__fixunssfsi+0x34>
    3eba:	86 95       	lsr	r24
    3ebc:	77 95       	ror	r23
    3ebe:	67 95       	ror	r22
    3ec0:	b3 95       	inc	r27
    3ec2:	d9 f7       	brne	.-10     	; 0x3eba <__fixunssfsi+0x42>
    3ec4:	3e f4       	brtc	.+14     	; 0x3ed4 <__fixunssfsi+0x5c>
    3ec6:	90 95       	com	r25
    3ec8:	80 95       	com	r24
    3eca:	70 95       	com	r23
    3ecc:	61 95       	neg	r22
    3ece:	7f 4f       	sbci	r23, 0xFF	; 255
    3ed0:	8f 4f       	sbci	r24, 0xFF	; 255
    3ed2:	9f 4f       	sbci	r25, 0xFF	; 255
    3ed4:	08 95       	ret

00003ed6 <__floatunsisf>:
    3ed6:	e8 94       	clt
    3ed8:	09 c0       	rjmp	.+18     	; 0x3eec <__floatsisf+0x12>

00003eda <__floatsisf>:
    3eda:	97 fb       	bst	r25, 7
    3edc:	3e f4       	brtc	.+14     	; 0x3eec <__floatsisf+0x12>
    3ede:	90 95       	com	r25
    3ee0:	80 95       	com	r24
    3ee2:	70 95       	com	r23
    3ee4:	61 95       	neg	r22
    3ee6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ee8:	8f 4f       	sbci	r24, 0xFF	; 255
    3eea:	9f 4f       	sbci	r25, 0xFF	; 255
    3eec:	99 23       	and	r25, r25
    3eee:	a9 f0       	breq	.+42     	; 0x3f1a <__floatsisf+0x40>
    3ef0:	f9 2f       	mov	r31, r25
    3ef2:	96 e9       	ldi	r25, 0x96	; 150
    3ef4:	bb 27       	eor	r27, r27
    3ef6:	93 95       	inc	r25
    3ef8:	f6 95       	lsr	r31
    3efa:	87 95       	ror	r24
    3efc:	77 95       	ror	r23
    3efe:	67 95       	ror	r22
    3f00:	b7 95       	ror	r27
    3f02:	f1 11       	cpse	r31, r1
    3f04:	f8 cf       	rjmp	.-16     	; 0x3ef6 <__floatsisf+0x1c>
    3f06:	fa f4       	brpl	.+62     	; 0x3f46 <__floatsisf+0x6c>
    3f08:	bb 0f       	add	r27, r27
    3f0a:	11 f4       	brne	.+4      	; 0x3f10 <__floatsisf+0x36>
    3f0c:	60 ff       	sbrs	r22, 0
    3f0e:	1b c0       	rjmp	.+54     	; 0x3f46 <__floatsisf+0x6c>
    3f10:	6f 5f       	subi	r22, 0xFF	; 255
    3f12:	7f 4f       	sbci	r23, 0xFF	; 255
    3f14:	8f 4f       	sbci	r24, 0xFF	; 255
    3f16:	9f 4f       	sbci	r25, 0xFF	; 255
    3f18:	16 c0       	rjmp	.+44     	; 0x3f46 <__floatsisf+0x6c>
    3f1a:	88 23       	and	r24, r24
    3f1c:	11 f0       	breq	.+4      	; 0x3f22 <__floatsisf+0x48>
    3f1e:	96 e9       	ldi	r25, 0x96	; 150
    3f20:	11 c0       	rjmp	.+34     	; 0x3f44 <__floatsisf+0x6a>
    3f22:	77 23       	and	r23, r23
    3f24:	21 f0       	breq	.+8      	; 0x3f2e <__floatsisf+0x54>
    3f26:	9e e8       	ldi	r25, 0x8E	; 142
    3f28:	87 2f       	mov	r24, r23
    3f2a:	76 2f       	mov	r23, r22
    3f2c:	05 c0       	rjmp	.+10     	; 0x3f38 <__floatsisf+0x5e>
    3f2e:	66 23       	and	r22, r22
    3f30:	71 f0       	breq	.+28     	; 0x3f4e <__floatsisf+0x74>
    3f32:	96 e8       	ldi	r25, 0x86	; 134
    3f34:	86 2f       	mov	r24, r22
    3f36:	70 e0       	ldi	r23, 0x00	; 0
    3f38:	60 e0       	ldi	r22, 0x00	; 0
    3f3a:	2a f0       	brmi	.+10     	; 0x3f46 <__floatsisf+0x6c>
    3f3c:	9a 95       	dec	r25
    3f3e:	66 0f       	add	r22, r22
    3f40:	77 1f       	adc	r23, r23
    3f42:	88 1f       	adc	r24, r24
    3f44:	da f7       	brpl	.-10     	; 0x3f3c <__floatsisf+0x62>
    3f46:	88 0f       	add	r24, r24
    3f48:	96 95       	lsr	r25
    3f4a:	87 95       	ror	r24
    3f4c:	97 f9       	bld	r25, 7
    3f4e:	08 95       	ret

00003f50 <__fp_cmp>:
    3f50:	99 0f       	add	r25, r25
    3f52:	00 08       	sbc	r0, r0
    3f54:	55 0f       	add	r21, r21
    3f56:	aa 0b       	sbc	r26, r26
    3f58:	e0 e8       	ldi	r30, 0x80	; 128
    3f5a:	fe ef       	ldi	r31, 0xFE	; 254
    3f5c:	16 16       	cp	r1, r22
    3f5e:	17 06       	cpc	r1, r23
    3f60:	e8 07       	cpc	r30, r24
    3f62:	f9 07       	cpc	r31, r25
    3f64:	c0 f0       	brcs	.+48     	; 0x3f96 <__fp_cmp+0x46>
    3f66:	12 16       	cp	r1, r18
    3f68:	13 06       	cpc	r1, r19
    3f6a:	e4 07       	cpc	r30, r20
    3f6c:	f5 07       	cpc	r31, r21
    3f6e:	98 f0       	brcs	.+38     	; 0x3f96 <__fp_cmp+0x46>
    3f70:	62 1b       	sub	r22, r18
    3f72:	73 0b       	sbc	r23, r19
    3f74:	84 0b       	sbc	r24, r20
    3f76:	95 0b       	sbc	r25, r21
    3f78:	39 f4       	brne	.+14     	; 0x3f88 <__fp_cmp+0x38>
    3f7a:	0a 26       	eor	r0, r26
    3f7c:	61 f0       	breq	.+24     	; 0x3f96 <__fp_cmp+0x46>
    3f7e:	23 2b       	or	r18, r19
    3f80:	24 2b       	or	r18, r20
    3f82:	25 2b       	or	r18, r21
    3f84:	21 f4       	brne	.+8      	; 0x3f8e <__fp_cmp+0x3e>
    3f86:	08 95       	ret
    3f88:	0a 26       	eor	r0, r26
    3f8a:	09 f4       	brne	.+2      	; 0x3f8e <__fp_cmp+0x3e>
    3f8c:	a1 40       	sbci	r26, 0x01	; 1
    3f8e:	a6 95       	lsr	r26
    3f90:	8f ef       	ldi	r24, 0xFF	; 255
    3f92:	81 1d       	adc	r24, r1
    3f94:	81 1d       	adc	r24, r1
    3f96:	08 95       	ret

00003f98 <__fp_inf>:
    3f98:	97 f9       	bld	r25, 7
    3f9a:	9f 67       	ori	r25, 0x7F	; 127
    3f9c:	80 e8       	ldi	r24, 0x80	; 128
    3f9e:	70 e0       	ldi	r23, 0x00	; 0
    3fa0:	60 e0       	ldi	r22, 0x00	; 0
    3fa2:	08 95       	ret

00003fa4 <__fp_nan>:
    3fa4:	9f ef       	ldi	r25, 0xFF	; 255
    3fa6:	80 ec       	ldi	r24, 0xC0	; 192
    3fa8:	08 95       	ret

00003faa <__fp_pscA>:
    3faa:	00 24       	eor	r0, r0
    3fac:	0a 94       	dec	r0
    3fae:	16 16       	cp	r1, r22
    3fb0:	17 06       	cpc	r1, r23
    3fb2:	18 06       	cpc	r1, r24
    3fb4:	09 06       	cpc	r0, r25
    3fb6:	08 95       	ret

00003fb8 <__fp_pscB>:
    3fb8:	00 24       	eor	r0, r0
    3fba:	0a 94       	dec	r0
    3fbc:	12 16       	cp	r1, r18
    3fbe:	13 06       	cpc	r1, r19
    3fc0:	14 06       	cpc	r1, r20
    3fc2:	05 06       	cpc	r0, r21
    3fc4:	08 95       	ret

00003fc6 <__fp_round>:
    3fc6:	09 2e       	mov	r0, r25
    3fc8:	03 94       	inc	r0
    3fca:	00 0c       	add	r0, r0
    3fcc:	11 f4       	brne	.+4      	; 0x3fd2 <__fp_round+0xc>
    3fce:	88 23       	and	r24, r24
    3fd0:	52 f0       	brmi	.+20     	; 0x3fe6 <__fp_round+0x20>
    3fd2:	bb 0f       	add	r27, r27
    3fd4:	40 f4       	brcc	.+16     	; 0x3fe6 <__fp_round+0x20>
    3fd6:	bf 2b       	or	r27, r31
    3fd8:	11 f4       	brne	.+4      	; 0x3fde <__fp_round+0x18>
    3fda:	60 ff       	sbrs	r22, 0
    3fdc:	04 c0       	rjmp	.+8      	; 0x3fe6 <__fp_round+0x20>
    3fde:	6f 5f       	subi	r22, 0xFF	; 255
    3fe0:	7f 4f       	sbci	r23, 0xFF	; 255
    3fe2:	8f 4f       	sbci	r24, 0xFF	; 255
    3fe4:	9f 4f       	sbci	r25, 0xFF	; 255
    3fe6:	08 95       	ret

00003fe8 <__fp_split3>:
    3fe8:	57 fd       	sbrc	r21, 7
    3fea:	90 58       	subi	r25, 0x80	; 128
    3fec:	44 0f       	add	r20, r20
    3fee:	55 1f       	adc	r21, r21
    3ff0:	59 f0       	breq	.+22     	; 0x4008 <__stack+0x9>
    3ff2:	5f 3f       	cpi	r21, 0xFF	; 255
    3ff4:	71 f0       	breq	.+28     	; 0x4012 <__stack+0x13>
    3ff6:	47 95       	ror	r20

00003ff8 <__fp_splitA>:
    3ff8:	88 0f       	add	r24, r24
    3ffa:	97 fb       	bst	r25, 7
    3ffc:	99 1f       	adc	r25, r25
    3ffe:	61 f0       	breq	.+24     	; 0x4018 <__stack+0x19>
    4000:	9f 3f       	cpi	r25, 0xFF	; 255
    4002:	79 f0       	breq	.+30     	; 0x4022 <__stack+0x23>
    4004:	87 95       	ror	r24
    4006:	08 95       	ret
    4008:	12 16       	cp	r1, r18
    400a:	13 06       	cpc	r1, r19
    400c:	14 06       	cpc	r1, r20
    400e:	55 1f       	adc	r21, r21
    4010:	f2 cf       	rjmp	.-28     	; 0x3ff6 <__fp_split3+0xe>
    4012:	46 95       	lsr	r20
    4014:	f1 df       	rcall	.-30     	; 0x3ff8 <__fp_splitA>
    4016:	08 c0       	rjmp	.+16     	; 0x4028 <__stack+0x29>
    4018:	16 16       	cp	r1, r22
    401a:	17 06       	cpc	r1, r23
    401c:	18 06       	cpc	r1, r24
    401e:	99 1f       	adc	r25, r25
    4020:	f1 cf       	rjmp	.-30     	; 0x4004 <__stack+0x5>
    4022:	86 95       	lsr	r24
    4024:	71 05       	cpc	r23, r1
    4026:	61 05       	cpc	r22, r1
    4028:	08 94       	sec
    402a:	08 95       	ret

0000402c <__fp_zero>:
    402c:	e8 94       	clt

0000402e <__fp_szero>:
    402e:	bb 27       	eor	r27, r27
    4030:	66 27       	eor	r22, r22
    4032:	77 27       	eor	r23, r23
    4034:	cb 01       	movw	r24, r22
    4036:	97 f9       	bld	r25, 7
    4038:	08 95       	ret

0000403a <__gesf2>:
    403a:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <__fp_cmp>
    403e:	08 f4       	brcc	.+2      	; 0x4042 <__gesf2+0x8>
    4040:	8f ef       	ldi	r24, 0xFF	; 255
    4042:	08 95       	ret

00004044 <__mulsf3>:
    4044:	0e 94 35 20 	call	0x406a	; 0x406a <__mulsf3x>
    4048:	0c 94 e3 1f 	jmp	0x3fc6	; 0x3fc6 <__fp_round>
    404c:	0e 94 d5 1f 	call	0x3faa	; 0x3faa <__fp_pscA>
    4050:	38 f0       	brcs	.+14     	; 0x4060 <__mulsf3+0x1c>
    4052:	0e 94 dc 1f 	call	0x3fb8	; 0x3fb8 <__fp_pscB>
    4056:	20 f0       	brcs	.+8      	; 0x4060 <__mulsf3+0x1c>
    4058:	95 23       	and	r25, r21
    405a:	11 f0       	breq	.+4      	; 0x4060 <__mulsf3+0x1c>
    405c:	0c 94 cc 1f 	jmp	0x3f98	; 0x3f98 <__fp_inf>
    4060:	0c 94 d2 1f 	jmp	0x3fa4	; 0x3fa4 <__fp_nan>
    4064:	11 24       	eor	r1, r1
    4066:	0c 94 17 20 	jmp	0x402e	; 0x402e <__fp_szero>

0000406a <__mulsf3x>:
    406a:	0e 94 f4 1f 	call	0x3fe8	; 0x3fe8 <__fp_split3>
    406e:	70 f3       	brcs	.-36     	; 0x404c <__mulsf3+0x8>

00004070 <__mulsf3_pse>:
    4070:	95 9f       	mul	r25, r21
    4072:	c1 f3       	breq	.-16     	; 0x4064 <__mulsf3+0x20>
    4074:	95 0f       	add	r25, r21
    4076:	50 e0       	ldi	r21, 0x00	; 0
    4078:	55 1f       	adc	r21, r21
    407a:	62 9f       	mul	r22, r18
    407c:	f0 01       	movw	r30, r0
    407e:	72 9f       	mul	r23, r18
    4080:	bb 27       	eor	r27, r27
    4082:	f0 0d       	add	r31, r0
    4084:	b1 1d       	adc	r27, r1
    4086:	63 9f       	mul	r22, r19
    4088:	aa 27       	eor	r26, r26
    408a:	f0 0d       	add	r31, r0
    408c:	b1 1d       	adc	r27, r1
    408e:	aa 1f       	adc	r26, r26
    4090:	64 9f       	mul	r22, r20
    4092:	66 27       	eor	r22, r22
    4094:	b0 0d       	add	r27, r0
    4096:	a1 1d       	adc	r26, r1
    4098:	66 1f       	adc	r22, r22
    409a:	82 9f       	mul	r24, r18
    409c:	22 27       	eor	r18, r18
    409e:	b0 0d       	add	r27, r0
    40a0:	a1 1d       	adc	r26, r1
    40a2:	62 1f       	adc	r22, r18
    40a4:	73 9f       	mul	r23, r19
    40a6:	b0 0d       	add	r27, r0
    40a8:	a1 1d       	adc	r26, r1
    40aa:	62 1f       	adc	r22, r18
    40ac:	83 9f       	mul	r24, r19
    40ae:	a0 0d       	add	r26, r0
    40b0:	61 1d       	adc	r22, r1
    40b2:	22 1f       	adc	r18, r18
    40b4:	74 9f       	mul	r23, r20
    40b6:	33 27       	eor	r19, r19
    40b8:	a0 0d       	add	r26, r0
    40ba:	61 1d       	adc	r22, r1
    40bc:	23 1f       	adc	r18, r19
    40be:	84 9f       	mul	r24, r20
    40c0:	60 0d       	add	r22, r0
    40c2:	21 1d       	adc	r18, r1
    40c4:	82 2f       	mov	r24, r18
    40c6:	76 2f       	mov	r23, r22
    40c8:	6a 2f       	mov	r22, r26
    40ca:	11 24       	eor	r1, r1
    40cc:	9f 57       	subi	r25, 0x7F	; 127
    40ce:	50 40       	sbci	r21, 0x00	; 0
    40d0:	9a f0       	brmi	.+38     	; 0x40f8 <__mulsf3_pse+0x88>
    40d2:	f1 f0       	breq	.+60     	; 0x4110 <__mulsf3_pse+0xa0>
    40d4:	88 23       	and	r24, r24
    40d6:	4a f0       	brmi	.+18     	; 0x40ea <__mulsf3_pse+0x7a>
    40d8:	ee 0f       	add	r30, r30
    40da:	ff 1f       	adc	r31, r31
    40dc:	bb 1f       	adc	r27, r27
    40de:	66 1f       	adc	r22, r22
    40e0:	77 1f       	adc	r23, r23
    40e2:	88 1f       	adc	r24, r24
    40e4:	91 50       	subi	r25, 0x01	; 1
    40e6:	50 40       	sbci	r21, 0x00	; 0
    40e8:	a9 f7       	brne	.-22     	; 0x40d4 <__mulsf3_pse+0x64>
    40ea:	9e 3f       	cpi	r25, 0xFE	; 254
    40ec:	51 05       	cpc	r21, r1
    40ee:	80 f0       	brcs	.+32     	; 0x4110 <__mulsf3_pse+0xa0>
    40f0:	0c 94 cc 1f 	jmp	0x3f98	; 0x3f98 <__fp_inf>
    40f4:	0c 94 17 20 	jmp	0x402e	; 0x402e <__fp_szero>
    40f8:	5f 3f       	cpi	r21, 0xFF	; 255
    40fa:	e4 f3       	brlt	.-8      	; 0x40f4 <__mulsf3_pse+0x84>
    40fc:	98 3e       	cpi	r25, 0xE8	; 232
    40fe:	d4 f3       	brlt	.-12     	; 0x40f4 <__mulsf3_pse+0x84>
    4100:	86 95       	lsr	r24
    4102:	77 95       	ror	r23
    4104:	67 95       	ror	r22
    4106:	b7 95       	ror	r27
    4108:	f7 95       	ror	r31
    410a:	e7 95       	ror	r30
    410c:	9f 5f       	subi	r25, 0xFF	; 255
    410e:	c1 f7       	brne	.-16     	; 0x4100 <__mulsf3_pse+0x90>
    4110:	fe 2b       	or	r31, r30
    4112:	88 0f       	add	r24, r24
    4114:	91 1d       	adc	r25, r1
    4116:	96 95       	lsr	r25
    4118:	87 95       	ror	r24
    411a:	97 f9       	bld	r25, 7
    411c:	08 95       	ret

0000411e <__divmodhi4>:
    411e:	97 fb       	bst	r25, 7
    4120:	07 2e       	mov	r0, r23
    4122:	16 f4       	brtc	.+4      	; 0x4128 <__divmodhi4+0xa>
    4124:	00 94       	com	r0
    4126:	07 d0       	rcall	.+14     	; 0x4136 <__divmodhi4_neg1>
    4128:	77 fd       	sbrc	r23, 7
    412a:	09 d0       	rcall	.+18     	; 0x413e <__divmodhi4_neg2>
    412c:	0e 94 ab 20 	call	0x4156	; 0x4156 <__udivmodhi4>
    4130:	07 fc       	sbrc	r0, 7
    4132:	05 d0       	rcall	.+10     	; 0x413e <__divmodhi4_neg2>
    4134:	3e f4       	brtc	.+14     	; 0x4144 <__divmodhi4_exit>

00004136 <__divmodhi4_neg1>:
    4136:	90 95       	com	r25
    4138:	81 95       	neg	r24
    413a:	9f 4f       	sbci	r25, 0xFF	; 255
    413c:	08 95       	ret

0000413e <__divmodhi4_neg2>:
    413e:	70 95       	com	r23
    4140:	61 95       	neg	r22
    4142:	7f 4f       	sbci	r23, 0xFF	; 255

00004144 <__divmodhi4_exit>:
    4144:	08 95       	ret

00004146 <__tablejump2__>:
    4146:	ee 0f       	add	r30, r30
    4148:	ff 1f       	adc	r31, r31
    414a:	88 1f       	adc	r24, r24
    414c:	8b bf       	out	0x3b, r24	; 59
    414e:	07 90       	elpm	r0, Z+
    4150:	f6 91       	elpm	r31, Z
    4152:	e0 2d       	mov	r30, r0
    4154:	19 94       	eijmp

00004156 <__udivmodhi4>:
    4156:	aa 1b       	sub	r26, r26
    4158:	bb 1b       	sub	r27, r27
    415a:	51 e1       	ldi	r21, 0x11	; 17
    415c:	07 c0       	rjmp	.+14     	; 0x416c <__udivmodhi4_ep>

0000415e <__udivmodhi4_loop>:
    415e:	aa 1f       	adc	r26, r26
    4160:	bb 1f       	adc	r27, r27
    4162:	a6 17       	cp	r26, r22
    4164:	b7 07       	cpc	r27, r23
    4166:	10 f0       	brcs	.+4      	; 0x416c <__udivmodhi4_ep>
    4168:	a6 1b       	sub	r26, r22
    416a:	b7 0b       	sbc	r27, r23

0000416c <__udivmodhi4_ep>:
    416c:	88 1f       	adc	r24, r24
    416e:	99 1f       	adc	r25, r25
    4170:	5a 95       	dec	r21
    4172:	a9 f7       	brne	.-22     	; 0x415e <__udivmodhi4_loop>
    4174:	80 95       	com	r24
    4176:	90 95       	com	r25
    4178:	bc 01       	movw	r22, r24
    417a:	cd 01       	movw	r24, r26
    417c:	08 95       	ret

0000417e <memcpy>:
    417e:	fb 01       	movw	r30, r22
    4180:	dc 01       	movw	r26, r24
    4182:	02 c0       	rjmp	.+4      	; 0x4188 <memcpy+0xa>
    4184:	01 90       	ld	r0, Z+
    4186:	0d 92       	st	X+, r0
    4188:	41 50       	subi	r20, 0x01	; 1
    418a:	50 40       	sbci	r21, 0x00	; 0
    418c:	d8 f7       	brcc	.-10     	; 0x4184 <memcpy+0x6>
    418e:	08 95       	ret

00004190 <memset>:
    4190:	dc 01       	movw	r26, r24
    4192:	01 c0       	rjmp	.+2      	; 0x4196 <memset+0x6>
    4194:	6d 93       	st	X+, r22
    4196:	41 50       	subi	r20, 0x01	; 1
    4198:	50 40       	sbci	r21, 0x00	; 0
    419a:	e0 f7       	brcc	.-8      	; 0x4194 <memset+0x4>
    419c:	08 95       	ret

0000419e <__itoa_ncheck>:
    419e:	bb 27       	eor	r27, r27
    41a0:	4a 30       	cpi	r20, 0x0A	; 10
    41a2:	31 f4       	brne	.+12     	; 0x41b0 <__itoa_ncheck+0x12>
    41a4:	99 23       	and	r25, r25
    41a6:	22 f4       	brpl	.+8      	; 0x41b0 <__itoa_ncheck+0x12>
    41a8:	bd e2       	ldi	r27, 0x2D	; 45
    41aa:	90 95       	com	r25
    41ac:	81 95       	neg	r24
    41ae:	9f 4f       	sbci	r25, 0xFF	; 255
    41b0:	0c 94 db 20 	jmp	0x41b6	; 0x41b6 <__utoa_common>

000041b4 <__utoa_ncheck>:
    41b4:	bb 27       	eor	r27, r27

000041b6 <__utoa_common>:
    41b6:	fb 01       	movw	r30, r22
    41b8:	55 27       	eor	r21, r21
    41ba:	aa 27       	eor	r26, r26
    41bc:	88 0f       	add	r24, r24
    41be:	99 1f       	adc	r25, r25
    41c0:	aa 1f       	adc	r26, r26
    41c2:	a4 17       	cp	r26, r20
    41c4:	10 f0       	brcs	.+4      	; 0x41ca <__utoa_common+0x14>
    41c6:	a4 1b       	sub	r26, r20
    41c8:	83 95       	inc	r24
    41ca:	50 51       	subi	r21, 0x10	; 16
    41cc:	b9 f7       	brne	.-18     	; 0x41bc <__utoa_common+0x6>
    41ce:	a0 5d       	subi	r26, 0xD0	; 208
    41d0:	aa 33       	cpi	r26, 0x3A	; 58
    41d2:	08 f0       	brcs	.+2      	; 0x41d6 <__utoa_common+0x20>
    41d4:	a9 5d       	subi	r26, 0xD9	; 217
    41d6:	a1 93       	st	Z+, r26
    41d8:	00 97       	sbiw	r24, 0x00	; 0
    41da:	79 f7       	brne	.-34     	; 0x41ba <__utoa_common+0x4>
    41dc:	b1 11       	cpse	r27, r1
    41de:	b1 93       	st	Z+, r27
    41e0:	11 92       	st	Z+, r1
    41e2:	cb 01       	movw	r24, r22
    41e4:	0c 94 f4 20 	jmp	0x41e8	; 0x41e8 <strrev>

000041e8 <strrev>:
    41e8:	dc 01       	movw	r26, r24
    41ea:	fc 01       	movw	r30, r24
    41ec:	67 2f       	mov	r22, r23
    41ee:	71 91       	ld	r23, Z+
    41f0:	77 23       	and	r23, r23
    41f2:	e1 f7       	brne	.-8      	; 0x41ec <strrev+0x4>
    41f4:	32 97       	sbiw	r30, 0x02	; 2
    41f6:	04 c0       	rjmp	.+8      	; 0x4200 <strrev+0x18>
    41f8:	7c 91       	ld	r23, X
    41fa:	6d 93       	st	X+, r22
    41fc:	70 83       	st	Z, r23
    41fe:	62 91       	ld	r22, -Z
    4200:	ae 17       	cp	r26, r30
    4202:	bf 07       	cpc	r27, r31
    4204:	c8 f3       	brcs	.-14     	; 0x41f8 <strrev+0x10>
    4206:	08 95       	ret

00004208 <_exit>:
    4208:	f8 94       	cli

0000420a <__stop_program>:
    420a:	ff cf       	rjmp	.-2      	; 0x420a <__stop_program>
