
QAMDecFS2019.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003be6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000084  00802000  00003be6  00003c7a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00001e8d  00802084  00802084  00003cfe  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003cfe  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003d30  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000790  00000000  00000000  00003d70  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001005d  00000000  00000000  00004500  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000051c4  00000000  00000000  0001455d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000050d6  00000000  00000000  00019721  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000190c  00000000  00000000  0001e7f8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000075c0  00000000  00000000  00020104  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000091f0  00000000  00000000  000276c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000820  00000000  00000000  000308b4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 20 01 	jmp	0x240	; 0x240 <__ctors_end>
       4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
       8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
       c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      10:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      14:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      18:	0c 94 b7 01 	jmp	0x36e	; 0x36e <__vector_6>
      1c:	0c 94 fd 01 	jmp	0x3fa	; 0x3fa <__vector_7>
      20:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      24:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      28:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      2c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      30:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      34:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      38:	0c 94 4a 06 	jmp	0xc94	; 0xc94 <__vector_14>
      3c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      40:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      44:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      48:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      4c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      50:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      54:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      58:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      5c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      60:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      64:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      68:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      6c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      70:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      74:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      78:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      7c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      80:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      84:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      88:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      8c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      90:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      94:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      98:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      9c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      ac:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      bc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      cc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      dc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      ec:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      fc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     100:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     104:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     108:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     10c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     110:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     114:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     118:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     11c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     120:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     124:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     128:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     12c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     130:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     134:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     138:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     13c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     140:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     144:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     148:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     14c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     150:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     154:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     158:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     15c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     160:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     164:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     168:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     16c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     170:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     174:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     178:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     17c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     180:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     184:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     188:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     18c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     190:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     194:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     198:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     19c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1ac:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1b0:	0c 94 5c 14 	jmp	0x28b8	; 0x28b8 <__vector_108>
     1b4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1b8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1bc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1cc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1dc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1ec:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1fc:	92 11       	cpse	r25, r2
     1fe:	92 11       	cpse	r25, r2
     200:	92 11       	cpse	r25, r2
     202:	df 11       	cpse	r29, r15
     204:	c7 11       	cpse	r28, r7
     206:	dc 11       	cpse	r29, r12
     208:	92 11       	cpse	r25, r2
     20a:	92 11       	cpse	r25, r2
     20c:	df 11       	cpse	r29, r15
     20e:	c7 11       	cpse	r28, r7

00000210 <__trampolines_start>:
     210:	0c 94 df 11 	jmp	0x23be	; 0x23be <prvTimerTask+0x212>
     214:	0c 94 63 12 	jmp	0x24c6	; 0x24c6 <vLedBlink>
     218:	0c 94 d8 12 	jmp	0x25b0	; 0x25b0 <vRead_DMA>
     21c:	0c 94 35 04 	jmp	0x86a	; 0x86a <vEventGroupSetBitsCallback>
     220:	0c 94 5f 0a 	jmp	0x14be	; 0x14be <prvIdleTask>
     224:	0c 94 92 11 	jmp	0x2324	; 0x2324 <prvTimerTask+0x178>
     228:	0c 94 d6 10 	jmp	0x21ac	; 0x21ac <prvTimerTask>
     22c:	0c 94 dc 11 	jmp	0x23b8	; 0x23b8 <prvTimerTask+0x20c>
     230:	0c 94 87 1a 	jmp	0x350e	; 0x350e <vTask_DMAHandler>
     234:	0c 94 fb 15 	jmp	0x2bf6	; 0x2bf6 <vDisplayUpdateTask>
     238:	0c 94 c7 11 	jmp	0x238e	; 0x238e <prvTimerTask+0x1e2>
     23c:	0c 94 6f 12 	jmp	0x24de	; 0x24de <vWrite_Display>

00000240 <__ctors_end>:
     240:	11 24       	eor	r1, r1
     242:	1f be       	out	0x3f, r1	; 63
     244:	cf ef       	ldi	r28, 0xFF	; 255
     246:	cd bf       	out	0x3d, r28	; 61
     248:	df e3       	ldi	r29, 0x3F	; 63
     24a:	de bf       	out	0x3e, r29	; 62
     24c:	00 e0       	ldi	r16, 0x00	; 0
     24e:	0c bf       	out	0x3c, r16	; 60

00000250 <init_mem>:
// !!! Never call this function, it is part of .init-Code
void __attribute__ ((naked, section(".init3"))) init_mem (void);
void init_mem (void)
{
   //  Use inline assembler so it works even with optimization turned off
   __asm volatile (
     250:	e1 e1       	ldi	r30, 0x11	; 17
     252:	ff e3       	ldi	r31, 0x3F	; 63
     254:	8a ea       	ldi	r24, 0xAA	; 170
     256:	90 e4       	ldi	r25, 0x40	; 64
     258:	81 93       	st	Z+, r24
     25a:	e0 30       	cpi	r30, 0x00	; 0
     25c:	f9 07       	cpc	r31, r25
     25e:	e0 f3       	brcs	.-8      	; 0x258 <init_mem+0x8>

00000260 <__do_copy_data>:
     260:	10 e2       	ldi	r17, 0x20	; 32
     262:	a0 e0       	ldi	r26, 0x00	; 0
     264:	b0 e2       	ldi	r27, 0x20	; 32
     266:	e6 ee       	ldi	r30, 0xE6	; 230
     268:	fb e3       	ldi	r31, 0x3B	; 59
     26a:	00 e0       	ldi	r16, 0x00	; 0
     26c:	0b bf       	out	0x3b, r16	; 59
     26e:	02 c0       	rjmp	.+4      	; 0x274 <__do_copy_data+0x14>
     270:	07 90       	elpm	r0, Z+
     272:	0d 92       	st	X+, r0
     274:	a4 38       	cpi	r26, 0x84	; 132
     276:	b1 07       	cpc	r27, r17
     278:	d9 f7       	brne	.-10     	; 0x270 <__do_copy_data+0x10>

0000027a <__do_clear_bss>:
     27a:	2f e3       	ldi	r18, 0x3F	; 63
     27c:	a4 e8       	ldi	r26, 0x84	; 132
     27e:	b0 e2       	ldi	r27, 0x20	; 32
     280:	01 c0       	rjmp	.+2      	; 0x284 <.do_clear_bss_start>

00000282 <.do_clear_bss_loop>:
     282:	1d 92       	st	X+, r1

00000284 <.do_clear_bss_start>:
     284:	a1 31       	cpi	r26, 0x11	; 17
     286:	b2 07       	cpc	r27, r18
     288:	e1 f7       	brne	.-8      	; 0x282 <.do_clear_bss_loop>
     28a:	0e 94 cb 13 	call	0x2796	; 0x2796 <main>
     28e:	0c 94 f1 1d 	jmp	0x3be2	; 0x3be2 <_exit>

00000292 <__bad_interrupt>:
     292:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000296 <sys_InitADC>:
void sys_InitADC(void)
{
	
	// Free Running mode: On
	// Conversion mode: Unsigned, 8Bit
	ADCB.CTRLB=(ADCB.CTRLB & (~(ADC_CONMODE_bm | ADC_FREERUN_bm | ADC_RESOLUTION_gm))) | ADC_RESOLUTION_8BIT_gc | ADC_FREERUN_bm;
     296:	e0 e4       	ldi	r30, 0x40	; 64
     298:	f2 e0       	ldi	r31, 0x02	; 2
     29a:	81 81       	ldd	r24, Z+1	; 0x01
     29c:	81 7e       	andi	r24, 0xE1	; 225
     29e:	8c 60       	ori	r24, 0x0C	; 12
     2a0:	81 83       	std	Z+1, r24	; 0x01
	// Reference 1V and configuration of prescaler to 256
	ADCB.PRESCALER=(ADCB.PRESCALER & (~ADC_PRESCALER_gm)) | ADC_PRESCALER_DIV256_gc; //?????
     2a2:	84 81       	ldd	r24, Z+4	; 0x04
     2a4:	88 7f       	andi	r24, 0xF8	; 248
     2a6:	86 60       	ori	r24, 0x06	; 6
     2a8:	84 83       	std	Z+4, r24	; 0x04
	ADCB.REFCTRL = ADC_REFSEL_INT1V_gc | ADC_TEMPREF_bm;;			//internal 1V
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	82 83       	std	Z+2, r24	; 0x02

	// Read and save the ADC offset using channel 0
	ADCB.CH0.CTRL=(ADCB.CH0.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2ae:	80 a1       	ldd	r24, Z+32	; 0x20
     2b0:	80 76       	andi	r24, 0x60	; 96
     2b2:	81 60       	ori	r24, 0x01	; 1
     2b4:	80 a3       	std	Z+32, r24	; 0x20
	ADCB.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN0_gc ;	// PORTB:0
     2b6:	11 a2       	std	Z+33, r1	; 0x21
	
	ADCB.CH1.CTRL=(ADCB.CH1.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2b8:	80 a5       	ldd	r24, Z+40	; 0x28
     2ba:	80 76       	andi	r24, 0x60	; 96
     2bc:	81 60       	ori	r24, 0x01	; 1
     2be:	80 a7       	std	Z+40, r24	; 0x28
	ADCB.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc ;	// PORTB:1	
     2c0:	88 e0       	ldi	r24, 0x08	; 8
     2c2:	81 a7       	std	Z+41, r24	; 0x29
	
	ADCB.CH2.CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_INTERNAL_gc;
     2c4:	10 aa       	std	Z+48, r1	; 0x30
	ADCB.CH2.MUXCTRL = ADC_CH_MUXINT_TEMP_gc;  //Temp Mux
     2c6:	11 aa       	std	Z+49, r1	; 0x31
	
	ADCB.EVCTRL = ADC_SWEEP_012_gc;
     2c8:	80 e8       	ldi	r24, 0x80	; 128
     2ca:	83 83       	std	Z+3, r24	; 0x03
	
	// Enable the ADC in order to read the offset
	ADCB.CTRLA|=ADC_ENABLE_bm;
     2cc:	80 81       	ld	r24, Z
     2ce:	81 60       	ori	r24, 0x01	; 1
     2d0:	80 83       	st	Z, r24
     2d2:	08 95       	ret

000002d4 <vInitDMA>:
void vInitDMA()
{
	uint8_t i = 0;
	
	//ADC8 PB0 Input
	PORTB.DIRCLR = PIN0_bm;
     2d4:	e0 e2       	ldi	r30, 0x20	; 32
     2d6:	f6 e0       	ldi	r31, 0x06	; 6
     2d8:	81 e0       	ldi	r24, 0x01	; 1
     2da:	82 83       	std	Z+2, r24	; 0x02
	PORTB.DIRCLR = PIN1_bm;
     2dc:	82 e0       	ldi	r24, 0x02	; 2
     2de:	82 83       	std	Z+2, r24	; 0x02
	
	sys_InitADC();
     2e0:	0e 94 4b 01 	call	0x296	; 0x296 <sys_InitADC>

	// set TCC1 to 11024Hz overflow, actually 11019.2838Hz (-0.052% error)
	TCC1.CTRLA = 0; // stop if running
     2e4:	e0 e4       	ldi	r30, 0x40	; 64
     2e6:	f8 e0       	ldi	r31, 0x08	; 8
     2e8:	10 82       	st	Z, r1
	TCC1.CNT = 0;
     2ea:	10 a2       	std	Z+32, r1	; 0x20
     2ec:	11 a2       	std	Z+33, r1	; 0x21
	TCC1.PER = 0x0FFF;
     2ee:	8f ef       	ldi	r24, 0xFF	; 255
     2f0:	9f e0       	ldi	r25, 0x0F	; 15
     2f2:	86 a3       	std	Z+38, r24	; 0x26
     2f4:	97 a3       	std	Z+39, r25	; 0x27

	EVSYS.CH0MUX = EVSYS_CHMUX_TCC1_OVF_gc; // trigger on timer overflow
     2f6:	88 ec       	ldi	r24, 0xC8	; 200
     2f8:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>


	// reset DMA controller
	DMA.CTRL = 0;
     2fc:	e0 e0       	ldi	r30, 0x00	; 0
     2fe:	f1 e0       	ldi	r31, 0x01	; 1
     300:	10 82       	st	Z, r1
	DMA.CTRL = DMA_RESET_bm;
     302:	80 e4       	ldi	r24, 0x40	; 64
     304:	80 83       	st	Z, r24
	while ((DMA.CTRL & DMA_RESET_bm) != 0);
     306:	80 81       	ld	r24, Z
     308:	86 fd       	sbrc	r24, 6
     30a:	fd cf       	rjmp	.-6      	; 0x306 <vInitDMA+0x32>
	
	DMA.CTRL			= DMA_CH_ENABLE_bm | DMA_DBUFMODE_CH01_gc; // double buffered with channels 0 and 1
     30c:	e0 e0       	ldi	r30, 0x00	; 0
     30e:	f1 e0       	ldi	r31, 0x01	; 1
     310:	84 e8       	ldi	r24, 0x84	; 132
     312:	80 83       	st	Z, r24
	//Bei Double Buffering wird automatisch aus Channel 0 und 1 ein "Pair" gebildet. 
	//Siehe dazu AVR1304.P8
	
	// channel 0
	// **** TODO: reset dma channels
	DMA.CH0.REPCNT		= 0;
     314:	16 8a       	std	Z+22, r1	; 0x16
	DMA.CH0.CTRLA		=  DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 1 byte (8 bit word)
     316:	74 e2       	ldi	r23, 0x24	; 36
     318:	70 8b       	std	Z+16, r23	; 0x10
	DMA.CH0.CTRLB		= 0x1;
     31a:	61 e0       	ldi	r22, 0x01	; 1
     31c:	61 8b       	std	Z+17, r22	; 0x11
	DMA.CH0.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     31e:	5d e9       	ldi	r21, 0x9D	; 157
     320:	52 8b       	std	Z+18, r21	; 0x12
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH0.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc;	//DMA0 gets synched by TCC1
     322:	46 e4       	ldi	r20, 0x46	; 70
     324:	43 8b       	std	Z+19, r20	; 0x13
	DMA.CH0.TRFCNT		= 2048; // always the number of bytes, even if burst length > 1
     326:	20 e0       	ldi	r18, 0x00	; 0
     328:	38 e0       	ldi	r19, 0x08	; 8
     32a:	24 8b       	std	Z+20, r18	; 0x14
     32c:	35 8b       	std	Z+21, r19	; 0x15
	DMA.CH0.DESTADDR0	= (( (uint16_t) buffer_a) >> 0) & 0xFF;
     32e:	86 ef       	ldi	r24, 0xF6	; 246
     330:	96 e3       	ldi	r25, 0x36	; 54
     332:	84 8f       	std	Z+28, r24	; 0x1c
	DMA.CH0.DESTADDR1	= (( (uint16_t) buffer_a) >> 8) & 0xFF;
     334:	95 8f       	std	Z+29, r25	; 0x1d
	DMA.CH0.DESTADDR2	= 0;
     336:	16 8e       	std	Z+30, r1	; 0x1e
	DMA.CH0.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     338:	9c e6       	ldi	r25, 0x6C	; 108
     33a:	90 8f       	std	Z+24, r25	; 0x18
	DMA.CH0.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     33c:	82 e0       	ldi	r24, 0x02	; 2
     33e:	81 8f       	std	Z+25, r24	; 0x19
	DMA.CH0.SRCADDR2	= 0;
     340:	12 8e       	std	Z+26, r1	; 0x1a

	// channel 1
	DMA.CH1.REPCNT		= 0;
     342:	16 a2       	std	Z+38, r1	; 0x26
	DMA.CH1.CTRLA		= DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 1 byte (8 bit word)
     344:	70 a3       	std	Z+32, r23	; 0x20
	DMA.CH1.CTRLB		= 0x1;
     346:	61 a3       	std	Z+33, r22	; 0x21
	DMA.CH1.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     348:	52 a3       	std	Z+34, r21	; 0x22
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH1.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc; //DMA1 gets synched by TCC1
     34a:	43 a3       	std	Z+35, r20	; 0x23
	DMA.CH1.TRFCNT		= 2048;
     34c:	24 a3       	std	Z+36, r18	; 0x24
     34e:	35 a3       	std	Z+37, r19	; 0x25
	DMA.CH1.DESTADDR0	= (( (uint16_t) buffer_b) >> 0) & 0xFF;
     350:	24 ef       	ldi	r18, 0xF4	; 244
     352:	3e e2       	ldi	r19, 0x2E	; 46
     354:	24 a7       	std	Z+44, r18	; 0x2c
	DMA.CH1.DESTADDR1	= (( (uint16_t) buffer_b) >> 8) & 0xFF;
     356:	35 a7       	std	Z+45, r19	; 0x2d
	DMA.CH1.DESTADDR2	= 0;
     358:	16 a6       	std	Z+46, r1	; 0x2e
	DMA.CH1.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     35a:	90 a7       	std	Z+40, r25	; 0x28
	DMA.CH1.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     35c:	81 a7       	std	Z+41, r24	; 0x29
	DMA.CH1.SRCADDR2	= 0;
     35e:	12 a6       	std	Z+42, r1	; 0x2a

	DMA.CH0.CTRLA		|= DMA_CH_ENABLE_bm;
     360:	80 89       	ldd	r24, Z+16	; 0x10
     362:	80 68       	ori	r24, 0x80	; 128
     364:	80 8b       	std	Z+16, r24	; 0x10
	TCC1.CTRLA			= TC_CLKSEL_DIV1024_gc; // start timer, and in turn ADC
     366:	87 e0       	ldi	r24, 0x07	; 7
     368:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
     36c:	08 95       	ret

0000036e <__vector_6>:
// 		DMA.INTFLAGS = DMA_CH0TRNIF_bm;

}

ISR(DMA_CH0_vect)
{
     36e:	1f 92       	push	r1
     370:	0f 92       	push	r0
     372:	0f b6       	in	r0, 0x3f	; 63
     374:	0f 92       	push	r0
     376:	11 24       	eor	r1, r1
     378:	0b b6       	in	r0, 0x3b	; 59
     37a:	0f 92       	push	r0
     37c:	2f 93       	push	r18
     37e:	3f 93       	push	r19
     380:	4f 93       	push	r20
     382:	5f 93       	push	r21
     384:	6f 93       	push	r22
     386:	7f 93       	push	r23
     388:	8f 93       	push	r24
     38a:	9f 93       	push	r25
     38c:	af 93       	push	r26
     38e:	bf 93       	push	r27
     390:	ef 93       	push	r30
     392:	ff 93       	push	r31
     394:	cf 93       	push	r28
     396:	df 93       	push	r29
     398:	1f 92       	push	r1
     39a:	cd b7       	in	r28, 0x3d	; 61
     39c:	de b7       	in	r29, 0x3e	; 62
	
	//Interrupt quittieren
	DMA.CH0.CTRLB |= 0x10;
     39e:	e0 e0       	ldi	r30, 0x00	; 0
     3a0:	f1 e0       	ldi	r31, 0x01	; 1
     3a2:	81 89       	ldd	r24, Z+17	; 0x11
     3a4:	80 61       	ori	r24, 0x10	; 16
     3a6:	81 8b       	std	Z+17, r24	; 0x11
	TCC1.INTFLAGS |= 0x01;
     3a8:	e0 e4       	ldi	r30, 0x40	; 64
     3aa:	f8 e0       	ldi	r31, 0x08	; 8
     3ac:	84 85       	ldd	r24, Z+12	; 0x0c
     3ae:	81 60       	ori	r24, 0x01	; 1
     3b0:	84 87       	std	Z+12, r24	; 0x0c
	//PORTF.OUTTGL = 0x01;
		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     3b2:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     3b4:	9e 01       	movw	r18, r28
     3b6:	2f 5f       	subi	r18, 0xFF	; 255
     3b8:	3f 4f       	sbci	r19, 0xFF	; 255
     3ba:	41 e0       	ldi	r20, 0x01	; 1
     3bc:	50 e0       	ldi	r21, 0x00	; 0
     3be:	60 e0       	ldi	r22, 0x00	; 0
     3c0:	70 e0       	ldi	r23, 0x00	; 0
     3c2:	80 91 fa 2c 	lds	r24, 0x2CFA	; 0x802cfa <xDMAProcessEventGroup>
     3c6:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <xDMAProcessEventGroup+0x1>
     3ca:	0e 94 38 04 	call	0x870	; 0x870 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     3ce:	0f 90       	pop	r0
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	ff 91       	pop	r31
     3d6:	ef 91       	pop	r30
     3d8:	bf 91       	pop	r27
     3da:	af 91       	pop	r26
     3dc:	9f 91       	pop	r25
     3de:	8f 91       	pop	r24
     3e0:	7f 91       	pop	r23
     3e2:	6f 91       	pop	r22
     3e4:	5f 91       	pop	r21
     3e6:	4f 91       	pop	r20
     3e8:	3f 91       	pop	r19
     3ea:	2f 91       	pop	r18
     3ec:	0f 90       	pop	r0
     3ee:	0b be       	out	0x3b, r0	; 59
     3f0:	0f 90       	pop	r0
     3f2:	0f be       	out	0x3f, r0	; 63
     3f4:	0f 90       	pop	r0
     3f6:	1f 90       	pop	r1
     3f8:	18 95       	reti

000003fa <__vector_7>:

ISR(DMA_CH1_vect)
{
     3fa:	1f 92       	push	r1
     3fc:	0f 92       	push	r0
     3fe:	0f b6       	in	r0, 0x3f	; 63
     400:	0f 92       	push	r0
     402:	11 24       	eor	r1, r1
     404:	0b b6       	in	r0, 0x3b	; 59
     406:	0f 92       	push	r0
     408:	2f 93       	push	r18
     40a:	3f 93       	push	r19
     40c:	4f 93       	push	r20
     40e:	5f 93       	push	r21
     410:	6f 93       	push	r22
     412:	7f 93       	push	r23
     414:	8f 93       	push	r24
     416:	9f 93       	push	r25
     418:	af 93       	push	r26
     41a:	bf 93       	push	r27
     41c:	ef 93       	push	r30
     41e:	ff 93       	push	r31
     420:	cf 93       	push	r28
     422:	df 93       	push	r29
     424:	1f 92       	push	r1
     426:	cd b7       	in	r28, 0x3d	; 61
     428:	de b7       	in	r29, 0x3e	; 62
	//Interrupt quittieren
	DMA.CH1.CTRLB |= 0x10;
     42a:	e0 e0       	ldi	r30, 0x00	; 0
     42c:	f1 e0       	ldi	r31, 0x01	; 1
     42e:	81 a1       	ldd	r24, Z+33	; 0x21
     430:	80 61       	ori	r24, 0x10	; 16
     432:	81 a3       	std	Z+33, r24	; 0x21
	TCC1.INTFLAGS |= 0x01;
     434:	e0 e4       	ldi	r30, 0x40	; 64
     436:	f8 e0       	ldi	r31, 0x08	; 8
     438:	84 85       	ldd	r24, Z+12	; 0x0c
     43a:	81 60       	ori	r24, 0x01	; 1
     43c:	84 87       	std	Z+12, r24	; 0x0c

		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     43e:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     440:	9e 01       	movw	r18, r28
     442:	2f 5f       	subi	r18, 0xFF	; 255
     444:	3f 4f       	sbci	r19, 0xFF	; 255
     446:	42 e0       	ldi	r20, 0x02	; 2
     448:	50 e0       	ldi	r21, 0x00	; 0
     44a:	60 e0       	ldi	r22, 0x00	; 0
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	80 91 fa 2c 	lds	r24, 0x2CFA	; 0x802cfa <xDMAProcessEventGroup>
     452:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <xDMAProcessEventGroup+0x1>
     456:	0e 94 38 04 	call	0x870	; 0x870 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     45a:	0f 90       	pop	r0
     45c:	df 91       	pop	r29
     45e:	cf 91       	pop	r28
     460:	ff 91       	pop	r31
     462:	ef 91       	pop	r30
     464:	bf 91       	pop	r27
     466:	af 91       	pop	r26
     468:	9f 91       	pop	r25
     46a:	8f 91       	pop	r24
     46c:	7f 91       	pop	r23
     46e:	6f 91       	pop	r22
     470:	5f 91       	pop	r21
     472:	4f 91       	pop	r20
     474:	3f 91       	pop	r19
     476:	2f 91       	pop	r18
     478:	0f 90       	pop	r0
     47a:	0b be       	out	0x3b, r0	; 59
     47c:	0f 90       	pop	r0
     47e:	0f be       	out	0x3f, r0	; 63
     480:	0f 90       	pop	r0
     482:	1f 90       	pop	r1
     484:	18 95       	reti

00000486 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     486:	0f 93       	push	r16
     488:	cf 93       	push	r28
     48a:	df 93       	push	r29
     48c:	1f 92       	push	r1
     48e:	cd b7       	in	r28, 0x3d	; 61
     490:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     492:	2f b7       	in	r18, 0x3f	; 63
     494:	29 83       	std	Y+1, r18	; 0x01
     496:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     498:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     49a:	fc 01       	movw	r30, r24
     49c:	08 ed       	ldi	r16, 0xD8	; 216
     49e:	04 bf       	out	0x34, r16	; 52
     4a0:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     4a2:	89 81       	ldd	r24, Y+1	; 0x01
     4a4:	8f bf       	out	0x3f, r24	; 63
#endif
}
     4a6:	0f 90       	pop	r0
     4a8:	df 91       	pop	r29
     4aa:	cf 91       	pop	r28
     4ac:	0f 91       	pop	r16
     4ae:	08 95       	ret

000004b0 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     4b0:	61 11       	cpse	r22, r1
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <CLKSYS_XOSC_Config+0x8>
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	01 c0       	rjmp	.+2      	; 0x4ba <CLKSYS_XOSC_Config+0xa>
     4b8:	90 e2       	ldi	r25, 0x20	; 32
     4ba:	84 2b       	or	r24, r20
     4bc:	89 2b       	or	r24, r25
     4be:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
     4c2:	08 95       	ret

000004c4 <CLKSYS_PLL_Config>:
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     4c4:	6f 71       	andi	r22, 0x1F	; 31
     4c6:	86 2b       	or	r24, r22
     4c8:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
     4cc:	08 95       	ret

000004ce <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     4ce:	e0 e5       	ldi	r30, 0x50	; 80
     4d0:	f0 e0       	ldi	r31, 0x00	; 0
     4d2:	90 81       	ld	r25, Z
     4d4:	28 2f       	mov	r18, r24
     4d6:	20 95       	com	r18
     4d8:	92 23       	and	r25, r18
     4da:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     4dc:	90 81       	ld	r25, Z
	return clkEnabled;
}
     4de:	89 23       	and	r24, r25
     4e0:	08 95       	ret

000004e2 <CLKSYS_Prescalers_Config>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
     4e2:	68 2b       	or	r22, r24
     4e4:	81 e4       	ldi	r24, 0x41	; 65
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	0e 94 43 02 	call	0x486	; 0x486 <CCPWrite>
     4ec:	08 95       	ret

000004ee <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     4ee:	0f 93       	push	r16
     4f0:	1f 93       	push	r17
     4f2:	cf 93       	push	r28
     4f4:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     4f6:	00 e4       	ldi	r16, 0x40	; 64
     4f8:	10 e0       	ldi	r17, 0x00	; 0
     4fa:	f8 01       	movw	r30, r16
     4fc:	60 81       	ld	r22, Z
	CCPWrite( &CLK.CTRL, clkCtrl );
     4fe:	68 7f       	andi	r22, 0xF8	; 248
     500:	68 2b       	or	r22, r24
     502:	80 e4       	ldi	r24, 0x40	; 64
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	0e 94 43 02 	call	0x486	; 0x486 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     50a:	f8 01       	movw	r30, r16
     50c:	80 81       	ld	r24, Z
	return clkCtrl;
}
     50e:	8c 23       	and	r24, r28
     510:	cf 91       	pop	r28
     512:	1f 91       	pop	r17
     514:	0f 91       	pop	r16
     516:	08 95       	ret

00000518 <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
     518:	fc 01       	movw	r30, r24
     51a:	90 81       	ld	r25, Z
     51c:	90 7f       	andi	r25, 0xF0	; 240
     51e:	69 2b       	or	r22, r25
     520:	60 83       	st	Z, r22
     522:	08 95       	ret

00000524 <TC0_ConfigWGM>:
     524:	fc 01       	movw	r30, r24
     526:	91 81       	ldd	r25, Z+1	; 0x01
     528:	98 7f       	andi	r25, 0xF8	; 248
     52a:	69 2b       	or	r22, r25
     52c:	61 83       	std	Z+1, r22	; 0x01
     52e:	08 95       	ret

00000530 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
     530:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     532:	96 81       	ldd	r25, Z+6	; 0x06
     534:	9c 7f       	andi	r25, 0xFC	; 252
     536:	69 2b       	or	r22, r25
     538:	66 83       	std	Z+6, r22	; 0x06
     53a:	08 95       	ret

0000053c <software_reset>:
	 // TODO from here:
	 //
	 // - log the occurance of any error in flash mem (inc counter)
	 // - print a message

	 software_reset();
     53c:	00 00       	nop
     53e:	88 ed       	ldi	r24, 0xD8	; 216
     540:	84 bf       	out	0x34, r24	; 52
     542:	81 e0       	ldi	r24, 0x01	; 1
     544:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     548:	08 95       	ret

0000054a <vApplicationStackOverflowHook>:
     54a:	0e 94 9e 02 	call	0x53c	; 0x53c <software_reset>
     54e:	08 95       	ret

00000550 <xEventGroupCreate>:
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
}
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	80 e1       	ldi	r24, 0x10	; 16
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
     55c:	ec 01       	movw	r28, r24
     55e:	00 97       	sbiw	r24, 0x00	; 0
     560:	41 f0       	breq	.+16     	; 0x572 <xEventGroupCreate+0x22>
     562:	fc 01       	movw	r30, r24
     564:	11 92       	st	Z+, r1
     566:	11 92       	st	Z+, r1
     568:	11 92       	st	Z+, r1
     56a:	11 92       	st	Z+, r1
     56c:	cf 01       	movw	r24, r30
     56e:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
     572:	ce 01       	movw	r24, r28
     574:	df 91       	pop	r29
     576:	cf 91       	pop	r28
     578:	08 95       	ret

0000057a <xEventGroupWaitBits>:
     57a:	2f 92       	push	r2
     57c:	3f 92       	push	r3
     57e:	4f 92       	push	r4
     580:	5f 92       	push	r5
     582:	6f 92       	push	r6
     584:	7f 92       	push	r7
     586:	8f 92       	push	r8
     588:	9f 92       	push	r9
     58a:	af 92       	push	r10
     58c:	bf 92       	push	r11
     58e:	cf 92       	push	r12
     590:	df 92       	push	r13
     592:	ef 92       	push	r14
     594:	ff 92       	push	r15
     596:	0f 93       	push	r16
     598:	1f 93       	push	r17
     59a:	cf 93       	push	r28
     59c:	df 93       	push	r29
     59e:	ec 01       	movw	r28, r24
     5a0:	4a 01       	movw	r8, r20
     5a2:	5b 01       	movw	r10, r22
     5a4:	62 2e       	mov	r6, r18
     5a6:	70 2e       	mov	r7, r16
     5a8:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
     5ac:	28 80       	ld	r2, Y
     5ae:	39 80       	ldd	r3, Y+1	; 0x01
     5b0:	4a 80       	ldd	r4, Y+2	; 0x02
     5b2:	5b 80       	ldd	r5, Y+3	; 0x03
     5b4:	01 11       	cpse	r16, r1
     5b6:	0d c0       	rjmp	.+26     	; 0x5d2 <xEventGroupWaitBits+0x58>
     5b8:	81 e0       	ldi	r24, 0x01	; 1
     5ba:	b2 01       	movw	r22, r4
     5bc:	a1 01       	movw	r20, r2
     5be:	48 21       	and	r20, r8
     5c0:	59 21       	and	r21, r9
     5c2:	6a 21       	and	r22, r10
     5c4:	7b 21       	and	r23, r11
     5c6:	45 2b       	or	r20, r21
     5c8:	46 2b       	or	r20, r22
     5ca:	47 2b       	or	r20, r23
     5cc:	79 f4       	brne	.+30     	; 0x5ec <xEventGroupWaitBits+0x72>
     5ce:	80 e0       	ldi	r24, 0x00	; 0
     5d0:	0d c0       	rjmp	.+26     	; 0x5ec <xEventGroupWaitBits+0x72>
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	b2 01       	movw	r22, r4
     5d6:	a1 01       	movw	r20, r2
     5d8:	48 21       	and	r20, r8
     5da:	59 21       	and	r21, r9
     5dc:	6a 21       	and	r22, r10
     5de:	7b 21       	and	r23, r11
     5e0:	48 15       	cp	r20, r8
     5e2:	59 05       	cpc	r21, r9
     5e4:	6a 05       	cpc	r22, r10
     5e6:	7b 05       	cpc	r23, r11
     5e8:	09 f0       	breq	.+2      	; 0x5ec <xEventGroupWaitBits+0x72>
     5ea:	80 e0       	ldi	r24, 0x00	; 0
     5ec:	88 23       	and	r24, r24
     5ee:	81 f0       	breq	.+32     	; 0x610 <xEventGroupWaitBits+0x96>
     5f0:	66 20       	and	r6, r6
     5f2:	09 f4       	brne	.+2      	; 0x5f6 <xEventGroupWaitBits+0x7c>
     5f4:	70 c0       	rjmp	.+224    	; 0x6d6 <xEventGroupWaitBits+0x15c>
     5f6:	80 94       	com	r8
     5f8:	90 94       	com	r9
     5fa:	a0 94       	com	r10
     5fc:	b0 94       	com	r11
     5fe:	82 20       	and	r8, r2
     600:	93 20       	and	r9, r3
     602:	a4 20       	and	r10, r4
     604:	b5 20       	and	r11, r5
     606:	88 82       	st	Y, r8
     608:	99 82       	std	Y+1, r9	; 0x01
     60a:	aa 82       	std	Y+2, r10	; 0x02
     60c:	bb 82       	std	Y+3, r11	; 0x03
     60e:	63 c0       	rjmp	.+198    	; 0x6d6 <xEventGroupWaitBits+0x15c>
     610:	c1 14       	cp	r12, r1
     612:	d1 04       	cpc	r13, r1
     614:	e1 04       	cpc	r14, r1
     616:	f1 04       	cpc	r15, r1
     618:	09 f4       	brne	.+2      	; 0x61c <xEventGroupWaitBits+0xa2>
     61a:	5d c0       	rjmp	.+186    	; 0x6d6 <xEventGroupWaitBits+0x15c>
     61c:	66 20       	and	r6, r6
     61e:	29 f0       	breq	.+10     	; 0x62a <xEventGroupWaitBits+0xb0>
     620:	40 e0       	ldi	r20, 0x00	; 0
     622:	50 e0       	ldi	r21, 0x00	; 0
     624:	60 e0       	ldi	r22, 0x00	; 0
     626:	71 e0       	ldi	r23, 0x01	; 1
     628:	03 c0       	rjmp	.+6      	; 0x630 <xEventGroupWaitBits+0xb6>
     62a:	40 e0       	ldi	r20, 0x00	; 0
     62c:	50 e0       	ldi	r21, 0x00	; 0
     62e:	ba 01       	movw	r22, r20
     630:	71 10       	cpse	r7, r1
     632:	74 60       	ori	r23, 0x04	; 4
     634:	48 29       	or	r20, r8
     636:	59 29       	or	r21, r9
     638:	6a 29       	or	r22, r10
     63a:	7b 29       	or	r23, r11
     63c:	97 01       	movw	r18, r14
     63e:	86 01       	movw	r16, r12
     640:	ce 01       	movw	r24, r28
     642:	04 96       	adiw	r24, 0x04	; 4
     644:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <vTaskPlaceOnUnorderedEventList>
     648:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
     64c:	81 11       	cpse	r24, r1
     64e:	02 c0       	rjmp	.+4      	; 0x654 <xEventGroupWaitBits+0xda>
     650:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
     654:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <uxTaskResetEventItemValue>
     658:	91 fd       	sbrc	r25, 1
     65a:	39 c0       	rjmp	.+114    	; 0x6ce <xEventGroupWaitBits+0x154>
     65c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     660:	ff 93       	push	r31
     662:	f8 7f       	andi	r31, 0xF8	; 248
     664:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     668:	68 81       	ld	r22, Y
     66a:	79 81       	ldd	r23, Y+1	; 0x01
     66c:	8a 81       	ldd	r24, Y+2	; 0x02
     66e:	9b 81       	ldd	r25, Y+3	; 0x03
     670:	71 10       	cpse	r7, r1
     672:	0d c0       	rjmp	.+26     	; 0x68e <xEventGroupWaitBits+0x114>
     674:	21 e0       	ldi	r18, 0x01	; 1
     676:	75 01       	movw	r14, r10
     678:	64 01       	movw	r12, r8
     67a:	c6 22       	and	r12, r22
     67c:	d7 22       	and	r13, r23
     67e:	e8 22       	and	r14, r24
     680:	f9 22       	and	r15, r25
     682:	cd 28       	or	r12, r13
     684:	ce 28       	or	r12, r14
     686:	cf 28       	or	r12, r15
     688:	79 f4       	brne	.+30     	; 0x6a8 <xEventGroupWaitBits+0x12e>
     68a:	20 e0       	ldi	r18, 0x00	; 0
     68c:	0d c0       	rjmp	.+26     	; 0x6a8 <xEventGroupWaitBits+0x12e>
     68e:	21 e0       	ldi	r18, 0x01	; 1
     690:	75 01       	movw	r14, r10
     692:	64 01       	movw	r12, r8
     694:	c6 22       	and	r12, r22
     696:	d7 22       	and	r13, r23
     698:	e8 22       	and	r14, r24
     69a:	f9 22       	and	r15, r25
     69c:	c8 14       	cp	r12, r8
     69e:	d9 04       	cpc	r13, r9
     6a0:	ea 04       	cpc	r14, r10
     6a2:	fb 04       	cpc	r15, r11
     6a4:	09 f0       	breq	.+2      	; 0x6a8 <xEventGroupWaitBits+0x12e>
     6a6:	20 e0       	ldi	r18, 0x00	; 0
     6a8:	22 23       	and	r18, r18
     6aa:	71 f0       	breq	.+28     	; 0x6c8 <xEventGroupWaitBits+0x14e>
     6ac:	66 20       	and	r6, r6
     6ae:	61 f0       	breq	.+24     	; 0x6c8 <xEventGroupWaitBits+0x14e>
     6b0:	80 94       	com	r8
     6b2:	90 94       	com	r9
     6b4:	a0 94       	com	r10
     6b6:	b0 94       	com	r11
     6b8:	86 22       	and	r8, r22
     6ba:	97 22       	and	r9, r23
     6bc:	a8 22       	and	r10, r24
     6be:	b9 22       	and	r11, r25
     6c0:	88 82       	st	Y, r8
     6c2:	99 82       	std	Y+1, r9	; 0x01
     6c4:	aa 82       	std	Y+2, r10	; 0x02
     6c6:	bb 82       	std	Y+3, r11	; 0x03
     6c8:	ff 91       	pop	r31
     6ca:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     6ce:	1b 01       	movw	r2, r22
     6d0:	2c 01       	movw	r4, r24
     6d2:	55 24       	eor	r5, r5
     6d4:	02 c0       	rjmp	.+4      	; 0x6da <xEventGroupWaitBits+0x160>
     6d6:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
     6da:	c2 01       	movw	r24, r4
     6dc:	b1 01       	movw	r22, r2
     6de:	df 91       	pop	r29
     6e0:	cf 91       	pop	r28
     6e2:	1f 91       	pop	r17
     6e4:	0f 91       	pop	r16
     6e6:	ff 90       	pop	r15
     6e8:	ef 90       	pop	r14
     6ea:	df 90       	pop	r13
     6ec:	cf 90       	pop	r12
     6ee:	bf 90       	pop	r11
     6f0:	af 90       	pop	r10
     6f2:	9f 90       	pop	r9
     6f4:	8f 90       	pop	r8
     6f6:	7f 90       	pop	r7
     6f8:	6f 90       	pop	r6
     6fa:	5f 90       	pop	r5
     6fc:	4f 90       	pop	r4
     6fe:	3f 90       	pop	r3
     700:	2f 90       	pop	r2
     702:	08 95       	ret

00000704 <xEventGroupClearBits>:
     704:	0f 93       	push	r16
     706:	1f 93       	push	r17
     708:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     70c:	ff 93       	push	r31
     70e:	f8 7f       	andi	r31, 0xF8	; 248
     710:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     714:	fc 01       	movw	r30, r24
     716:	00 81       	ld	r16, Z
     718:	11 81       	ldd	r17, Z+1	; 0x01
     71a:	22 81       	ldd	r18, Z+2	; 0x02
     71c:	33 81       	ldd	r19, Z+3	; 0x03
     71e:	40 95       	com	r20
     720:	50 95       	com	r21
     722:	60 95       	com	r22
     724:	70 95       	com	r23
     726:	40 23       	and	r20, r16
     728:	51 23       	and	r21, r17
     72a:	62 23       	and	r22, r18
     72c:	73 23       	and	r23, r19
     72e:	40 83       	st	Z, r20
     730:	51 83       	std	Z+1, r21	; 0x01
     732:	62 83       	std	Z+2, r22	; 0x02
     734:	73 83       	std	Z+3, r23	; 0x03
     736:	ff 91       	pop	r31
     738:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     73c:	c9 01       	movw	r24, r18
     73e:	b8 01       	movw	r22, r16
     740:	1f 91       	pop	r17
     742:	0f 91       	pop	r16
     744:	08 95       	ret

00000746 <xEventGroupSetBits>:
     746:	4f 92       	push	r4
     748:	5f 92       	push	r5
     74a:	6f 92       	push	r6
     74c:	7f 92       	push	r7
     74e:	af 92       	push	r10
     750:	bf 92       	push	r11
     752:	cf 92       	push	r12
     754:	df 92       	push	r13
     756:	ef 92       	push	r14
     758:	ff 92       	push	r15
     75a:	0f 93       	push	r16
     75c:	1f 93       	push	r17
     75e:	cf 93       	push	r28
     760:	df 93       	push	r29
     762:	ec 01       	movw	r28, r24
     764:	6a 01       	movw	r12, r20
     766:	7b 01       	movw	r14, r22
     768:	8c 01       	movw	r16, r24
     76a:	09 5f       	subi	r16, 0xF9	; 249
     76c:	1f 4f       	sbci	r17, 0xFF	; 255
     76e:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
     772:	eb 85       	ldd	r30, Y+11	; 0x0b
     774:	fc 85       	ldd	r31, Y+12	; 0x0c
     776:	88 81       	ld	r24, Y
     778:	99 81       	ldd	r25, Y+1	; 0x01
     77a:	aa 81       	ldd	r26, Y+2	; 0x02
     77c:	bb 81       	ldd	r27, Y+3	; 0x03
     77e:	c8 2a       	or	r12, r24
     780:	d9 2a       	or	r13, r25
     782:	ea 2a       	or	r14, r26
     784:	fb 2a       	or	r15, r27
     786:	c8 82       	st	Y, r12
     788:	d9 82       	std	Y+1, r13	; 0x01
     78a:	ea 82       	std	Y+2, r14	; 0x02
     78c:	fb 82       	std	Y+3, r15	; 0x03
     78e:	0e 17       	cp	r16, r30
     790:	1f 07       	cpc	r17, r31
     792:	09 f4       	brne	.+2      	; 0x796 <xEventGroupSetBits+0x50>
     794:	42 c0       	rjmp	.+132    	; 0x81a <xEventGroupSetBits+0xd4>
     796:	c1 2c       	mov	r12, r1
     798:	d1 2c       	mov	r13, r1
     79a:	76 01       	movw	r14, r12
     79c:	a4 80       	ldd	r10, Z+4	; 0x04
     79e:	b5 80       	ldd	r11, Z+5	; 0x05
     7a0:	80 81       	ld	r24, Z
     7a2:	91 81       	ldd	r25, Z+1	; 0x01
     7a4:	a2 81       	ldd	r26, Z+2	; 0x02
     7a6:	b3 81       	ldd	r27, Z+3	; 0x03
     7a8:	ac 01       	movw	r20, r24
     7aa:	bd 01       	movw	r22, r26
     7ac:	77 27       	eor	r23, r23
     7ae:	b2 fd       	sbrc	r27, 2
     7b0:	0f c0       	rjmp	.+30     	; 0x7d0 <xEventGroupSetBits+0x8a>
     7b2:	48 80       	ld	r4, Y
     7b4:	59 80       	ldd	r5, Y+1	; 0x01
     7b6:	6a 80       	ldd	r6, Y+2	; 0x02
     7b8:	7b 80       	ldd	r7, Y+3	; 0x03
     7ba:	44 22       	and	r4, r20
     7bc:	55 22       	and	r5, r21
     7be:	66 22       	and	r6, r22
     7c0:	77 22       	and	r7, r23
     7c2:	21 e0       	ldi	r18, 0x01	; 1
     7c4:	45 28       	or	r4, r5
     7c6:	46 28       	or	r4, r6
     7c8:	47 28       	or	r4, r7
     7ca:	89 f4       	brne	.+34     	; 0x7ee <xEventGroupSetBits+0xa8>
     7cc:	20 e0       	ldi	r18, 0x00	; 0
     7ce:	0f c0       	rjmp	.+30     	; 0x7ee <xEventGroupSetBits+0xa8>
     7d0:	48 80       	ld	r4, Y
     7d2:	59 80       	ldd	r5, Y+1	; 0x01
     7d4:	6a 80       	ldd	r6, Y+2	; 0x02
     7d6:	7b 80       	ldd	r7, Y+3	; 0x03
     7d8:	44 22       	and	r4, r20
     7da:	55 22       	and	r5, r21
     7dc:	66 22       	and	r6, r22
     7de:	77 22       	and	r7, r23
     7e0:	21 e0       	ldi	r18, 0x01	; 1
     7e2:	44 16       	cp	r4, r20
     7e4:	55 06       	cpc	r5, r21
     7e6:	66 06       	cpc	r6, r22
     7e8:	77 06       	cpc	r7, r23
     7ea:	09 f0       	breq	.+2      	; 0x7ee <xEventGroupSetBits+0xa8>
     7ec:	20 e0       	ldi	r18, 0x00	; 0
     7ee:	22 23       	and	r18, r18
     7f0:	71 f0       	breq	.+28     	; 0x80e <xEventGroupSetBits+0xc8>
     7f2:	b0 ff       	sbrs	r27, 0
     7f4:	04 c0       	rjmp	.+8      	; 0x7fe <xEventGroupSetBits+0xb8>
     7f6:	c4 2a       	or	r12, r20
     7f8:	d5 2a       	or	r13, r21
     7fa:	e6 2a       	or	r14, r22
     7fc:	f7 2a       	or	r15, r23
     7fe:	48 81       	ld	r20, Y
     800:	59 81       	ldd	r21, Y+1	; 0x01
     802:	6a 81       	ldd	r22, Y+2	; 0x02
     804:	7b 81       	ldd	r23, Y+3	; 0x03
     806:	72 60       	ori	r23, 0x02	; 2
     808:	cf 01       	movw	r24, r30
     80a:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <vTaskRemoveFromUnorderedEventList>
     80e:	ea 2d       	mov	r30, r10
     810:	fb 2d       	mov	r31, r11
     812:	0e 17       	cp	r16, r30
     814:	1f 07       	cpc	r17, r31
     816:	11 f6       	brne	.-124    	; 0x79c <xEventGroupSetBits+0x56>
     818:	03 c0       	rjmp	.+6      	; 0x820 <xEventGroupSetBits+0xda>
     81a:	c1 2c       	mov	r12, r1
     81c:	d1 2c       	mov	r13, r1
     81e:	76 01       	movw	r14, r12
     820:	c0 94       	com	r12
     822:	d0 94       	com	r13
     824:	e0 94       	com	r14
     826:	f0 94       	com	r15
     828:	88 81       	ld	r24, Y
     82a:	99 81       	ldd	r25, Y+1	; 0x01
     82c:	aa 81       	ldd	r26, Y+2	; 0x02
     82e:	bb 81       	ldd	r27, Y+3	; 0x03
     830:	c8 22       	and	r12, r24
     832:	d9 22       	and	r13, r25
     834:	ea 22       	and	r14, r26
     836:	fb 22       	and	r15, r27
     838:	c8 82       	st	Y, r12
     83a:	d9 82       	std	Y+1, r13	; 0x01
     83c:	ea 82       	std	Y+2, r14	; 0x02
     83e:	fb 82       	std	Y+3, r15	; 0x03
     840:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
     844:	68 81       	ld	r22, Y
     846:	79 81       	ldd	r23, Y+1	; 0x01
     848:	8a 81       	ldd	r24, Y+2	; 0x02
     84a:	9b 81       	ldd	r25, Y+3	; 0x03
     84c:	df 91       	pop	r29
     84e:	cf 91       	pop	r28
     850:	1f 91       	pop	r17
     852:	0f 91       	pop	r16
     854:	ff 90       	pop	r15
     856:	ef 90       	pop	r14
     858:	df 90       	pop	r13
     85a:	cf 90       	pop	r12
     85c:	bf 90       	pop	r11
     85e:	af 90       	pop	r10
     860:	7f 90       	pop	r7
     862:	6f 90       	pop	r6
     864:	5f 90       	pop	r5
     866:	4f 90       	pop	r4
     868:	08 95       	ret

0000086a <vEventGroupSetBitsCallback>:
     86a:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
     86e:	08 95       	ret

00000870 <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
     870:	0f 93       	push	r16
     872:	1f 93       	push	r17
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
     874:	89 01       	movw	r16, r18
     876:	9a 01       	movw	r18, r20
     878:	ab 01       	movw	r20, r22
     87a:	bc 01       	movw	r22, r24
     87c:	85 e3       	ldi	r24, 0x35	; 53
     87e:	94 e0       	ldi	r25, 0x04	; 4
     880:	0e 94 05 12 	call	0x240a	; 0x240a <xTimerPendFunctionCallFromISR>

		return xReturn;
	}
     884:	1f 91       	pop	r17
     886:	0f 91       	pop	r16
     888:	08 95       	ret

0000088a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
     88e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     890:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     894:	20 91 84 20 	lds	r18, 0x2084	; 0x802084 <__data_end>
     898:	30 91 85 20 	lds	r19, 0x2085	; 0x802085 <__data_end+0x1>
     89c:	c9 01       	movw	r24, r18
     89e:	8c 0f       	add	r24, r28
     8a0:	9d 1f       	adc	r25, r29
     8a2:	88 3b       	cpi	r24, 0xB8	; 184
     8a4:	4b e0       	ldi	r20, 0x0B	; 11
     8a6:	94 07       	cpc	r25, r20
     8a8:	58 f4       	brcc	.+22     	; 0x8c0 <pvPortMalloc+0x36>
     8aa:	28 17       	cp	r18, r24
     8ac:	39 07       	cpc	r19, r25
     8ae:	58 f4       	brcc	.+22     	; 0x8c6 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     8b0:	e9 01       	movw	r28, r18
     8b2:	ca 57       	subi	r28, 0x7A	; 122
     8b4:	df 4d       	sbci	r29, 0xDF	; 223
			xNextFreeByte += xWantedSize;			
     8b6:	80 93 84 20 	sts	0x2084, r24	; 0x802084 <__data_end>
     8ba:	90 93 85 20 	sts	0x2085, r25	; 0x802085 <__data_end+0x1>
     8be:	05 c0       	rjmp	.+10     	; 0x8ca <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     8c0:	c0 e0       	ldi	r28, 0x00	; 0
     8c2:	d0 e0       	ldi	r29, 0x00	; 0
     8c4:	02 c0       	rjmp	.+4      	; 0x8ca <pvPortMalloc+0x40>
     8c6:	c0 e0       	ldi	r28, 0x00	; 0
     8c8:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     8ca:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     8ce:	ce 01       	movw	r24, r28
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	08 95       	ret

000008d6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     8d6:	08 95       	ret

000008d8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     8d8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8da:	03 96       	adiw	r24, 0x03	; 3
     8dc:	81 83       	std	Z+1, r24	; 0x01
     8de:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8e0:	4f ef       	ldi	r20, 0xFF	; 255
     8e2:	5f ef       	ldi	r21, 0xFF	; 255
     8e4:	ba 01       	movw	r22, r20
     8e6:	43 83       	std	Z+3, r20	; 0x03
     8e8:	54 83       	std	Z+4, r21	; 0x04
     8ea:	65 83       	std	Z+5, r22	; 0x05
     8ec:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8ee:	87 83       	std	Z+7, r24	; 0x07
     8f0:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8f2:	81 87       	std	Z+9, r24	; 0x09
     8f4:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8f6:	10 82       	st	Z, r1
     8f8:	08 95       	ret

000008fa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8fa:	fc 01       	movw	r30, r24
     8fc:	12 86       	std	Z+10, r1	; 0x0a
     8fe:	13 86       	std	Z+11, r1	; 0x0b
     900:	08 95       	ret

00000902 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
     906:	9c 01       	movw	r18, r24
     908:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     90a:	dc 01       	movw	r26, r24
     90c:	11 96       	adiw	r26, 0x01	; 1
     90e:	cd 91       	ld	r28, X+
     910:	dc 91       	ld	r29, X
     912:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     914:	c4 83       	std	Z+4, r28	; 0x04
     916:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     918:	8e 81       	ldd	r24, Y+6	; 0x06
     91a:	9f 81       	ldd	r25, Y+7	; 0x07
     91c:	86 83       	std	Z+6, r24	; 0x06
     91e:	97 83       	std	Z+7, r25	; 0x07

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     920:	8e 81       	ldd	r24, Y+6	; 0x06
     922:	9f 81       	ldd	r25, Y+7	; 0x07
     924:	dc 01       	movw	r26, r24
     926:	14 96       	adiw	r26, 0x04	; 4
     928:	6d 93       	st	X+, r22
     92a:	7c 93       	st	X, r23
     92c:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxPrevious = pxNewListItem;
     92e:	6e 83       	std	Y+6, r22	; 0x06
     930:	7f 83       	std	Y+7, r23	; 0x07

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     932:	22 87       	std	Z+10, r18	; 0x0a
     934:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     936:	f9 01       	movw	r30, r18
     938:	80 81       	ld	r24, Z
     93a:	8f 5f       	subi	r24, 0xFF	; 255
     93c:	80 83       	st	Z, r24
}
     93e:	df 91       	pop	r29
     940:	cf 91       	pop	r28
     942:	08 95       	ret

00000944 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     944:	0f 93       	push	r16
     946:	1f 93       	push	r17
     948:	cf 93       	push	r28
     94a:	df 93       	push	r29
     94c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     94e:	08 81       	ld	r16, Y
     950:	19 81       	ldd	r17, Y+1	; 0x01
     952:	2a 81       	ldd	r18, Y+2	; 0x02
     954:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     956:	0f 3f       	cpi	r16, 0xFF	; 255
     958:	4f ef       	ldi	r20, 0xFF	; 255
     95a:	14 07       	cpc	r17, r20
     95c:	24 07       	cpc	r18, r20
     95e:	34 07       	cpc	r19, r20
     960:	21 f4       	brne	.+8      	; 0x96a <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     962:	fc 01       	movw	r30, r24
     964:	a1 85       	ldd	r26, Z+9	; 0x09
     966:	b2 85       	ldd	r27, Z+10	; 0x0a
     968:	11 c0       	rjmp	.+34     	; 0x98c <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     96a:	dc 01       	movw	r26, r24
     96c:	13 96       	adiw	r26, 0x03	; 3
     96e:	01 c0       	rjmp	.+2      	; 0x972 <vListInsert+0x2e>
     970:	df 01       	movw	r26, r30
     972:	14 96       	adiw	r26, 0x04	; 4
     974:	ed 91       	ld	r30, X+
     976:	fc 91       	ld	r31, X
     978:	15 97       	sbiw	r26, 0x05	; 5
     97a:	40 81       	ld	r20, Z
     97c:	51 81       	ldd	r21, Z+1	; 0x01
     97e:	62 81       	ldd	r22, Z+2	; 0x02
     980:	73 81       	ldd	r23, Z+3	; 0x03
     982:	04 17       	cp	r16, r20
     984:	15 07       	cpc	r17, r21
     986:	26 07       	cpc	r18, r22
     988:	37 07       	cpc	r19, r23
     98a:	90 f7       	brcc	.-28     	; 0x970 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     98c:	14 96       	adiw	r26, 0x04	; 4
     98e:	ed 91       	ld	r30, X+
     990:	fc 91       	ld	r31, X
     992:	15 97       	sbiw	r26, 0x05	; 5
     994:	ec 83       	std	Y+4, r30	; 0x04
     996:	fd 83       	std	Y+5, r31	; 0x05
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     998:	c6 83       	std	Z+6, r28	; 0x06
     99a:	d7 83       	std	Z+7, r29	; 0x07
	pxNewListItem->pxPrevious = pxIterator;
     99c:	ae 83       	std	Y+6, r26	; 0x06
     99e:	bf 83       	std	Y+7, r27	; 0x07
	pxIterator->pxNext = pxNewListItem;
     9a0:	14 96       	adiw	r26, 0x04	; 4
     9a2:	cd 93       	st	X+, r28
     9a4:	dc 93       	st	X, r29
     9a6:	15 97       	sbiw	r26, 0x05	; 5

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9a8:	8a 87       	std	Y+10, r24	; 0x0a
     9aa:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     9ac:	fc 01       	movw	r30, r24
     9ae:	20 81       	ld	r18, Z
     9b0:	2f 5f       	subi	r18, 0xFF	; 255
     9b2:	20 83       	st	Z, r18
}
     9b4:	df 91       	pop	r29
     9b6:	cf 91       	pop	r28
     9b8:	1f 91       	pop	r17
     9ba:	0f 91       	pop	r16
     9bc:	08 95       	ret

000009be <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
     9c2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     9c4:	a2 85       	ldd	r26, Z+10	; 0x0a
     9c6:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9c8:	c4 81       	ldd	r28, Z+4	; 0x04
     9ca:	d5 81       	ldd	r29, Z+5	; 0x05
     9cc:	86 81       	ldd	r24, Z+6	; 0x06
     9ce:	97 81       	ldd	r25, Z+7	; 0x07
     9d0:	8e 83       	std	Y+6, r24	; 0x06
     9d2:	9f 83       	std	Y+7, r25	; 0x07
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     9d4:	c6 81       	ldd	r28, Z+6	; 0x06
     9d6:	d7 81       	ldd	r29, Z+7	; 0x07
     9d8:	84 81       	ldd	r24, Z+4	; 0x04
     9da:	95 81       	ldd	r25, Z+5	; 0x05
     9dc:	8c 83       	std	Y+4, r24	; 0x04
     9de:	9d 83       	std	Y+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9e0:	11 96       	adiw	r26, 0x01	; 1
     9e2:	8d 91       	ld	r24, X+
     9e4:	9c 91       	ld	r25, X
     9e6:	12 97       	sbiw	r26, 0x02	; 2
     9e8:	e8 17       	cp	r30, r24
     9ea:	f9 07       	cpc	r31, r25
     9ec:	31 f4       	brne	.+12     	; 0x9fa <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9ee:	86 81       	ldd	r24, Z+6	; 0x06
     9f0:	97 81       	ldd	r25, Z+7	; 0x07
     9f2:	11 96       	adiw	r26, 0x01	; 1
     9f4:	8d 93       	st	X+, r24
     9f6:	9c 93       	st	X, r25
     9f8:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9fa:	12 86       	std	Z+10, r1	; 0x0a
     9fc:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     9fe:	8c 91       	ld	r24, X
     a00:	81 50       	subi	r24, 0x01	; 1
     a02:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     a04:	8c 91       	ld	r24, X
}
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	08 95       	ret

00000a0c <_portSetInterruptMaskFromIsr>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a0c:	e0 ea       	ldi	r30, 0xA0	; 160
     a0e:	f0 e0       	ldi	r31, 0x00	; 0
     a10:	82 81       	ldd	r24, Z+2	; 0x02
     a12:	92 81       	ldd	r25, Z+2	; 0x02
     a14:	98 7f       	andi	r25, 0xF8	; 248
     a16:	92 83       	std	Z+2, r25	; 0x02
     a18:	08 95       	ret

00000a1a <pxPortInitialiseStack>:
     a1a:	cf 92       	push	r12
     a1c:	df 92       	push	r13
     a1e:	ef 92       	push	r14
     a20:	ff 92       	push	r15
     a22:	31 e1       	ldi	r19, 0x11	; 17
     a24:	fc 01       	movw	r30, r24
     a26:	30 83       	st	Z, r19
     a28:	31 97       	sbiw	r30, 0x01	; 1
     a2a:	22 e2       	ldi	r18, 0x22	; 34
     a2c:	20 83       	st	Z, r18
     a2e:	31 97       	sbiw	r30, 0x01	; 1
     a30:	a3 e3       	ldi	r26, 0x33	; 51
     a32:	a0 83       	st	Z, r26
     a34:	6b 01       	movw	r12, r22
     a36:	e1 2c       	mov	r14, r1
     a38:	f1 2c       	mov	r15, r1
     a3a:	31 97       	sbiw	r30, 0x01	; 1
     a3c:	60 83       	st	Z, r22
     a3e:	31 97       	sbiw	r30, 0x01	; 1
     a40:	d0 82       	st	Z, r13
     a42:	31 97       	sbiw	r30, 0x01	; 1
     a44:	e0 82       	st	Z, r14
     a46:	31 97       	sbiw	r30, 0x01	; 1
     a48:	61 e3       	ldi	r22, 0x31	; 49
     a4a:	60 83       	st	Z, r22
     a4c:	31 97       	sbiw	r30, 0x01	; 1
     a4e:	60 e8       	ldi	r22, 0x80	; 128
     a50:	60 83       	st	Z, r22
     a52:	31 97       	sbiw	r30, 0x01	; 1
     a54:	67 e8       	ldi	r22, 0x87	; 135
     a56:	60 83       	st	Z, r22
     a58:	31 97       	sbiw	r30, 0x01	; 1
     a5a:	10 82       	st	Z, r1
     a5c:	31 97       	sbiw	r30, 0x01	; 1
     a5e:	10 82       	st	Z, r1
     a60:	31 97       	sbiw	r30, 0x01	; 1
     a62:	62 e0       	ldi	r22, 0x02	; 2
     a64:	60 83       	st	Z, r22
     a66:	31 97       	sbiw	r30, 0x01	; 1
     a68:	63 e0       	ldi	r22, 0x03	; 3
     a6a:	60 83       	st	Z, r22
     a6c:	31 97       	sbiw	r30, 0x01	; 1
     a6e:	64 e0       	ldi	r22, 0x04	; 4
     a70:	60 83       	st	Z, r22
     a72:	31 97       	sbiw	r30, 0x01	; 1
     a74:	65 e0       	ldi	r22, 0x05	; 5
     a76:	60 83       	st	Z, r22
     a78:	31 97       	sbiw	r30, 0x01	; 1
     a7a:	66 e0       	ldi	r22, 0x06	; 6
     a7c:	60 83       	st	Z, r22
     a7e:	31 97       	sbiw	r30, 0x01	; 1
     a80:	67 e0       	ldi	r22, 0x07	; 7
     a82:	60 83       	st	Z, r22
     a84:	31 97       	sbiw	r30, 0x01	; 1
     a86:	68 e0       	ldi	r22, 0x08	; 8
     a88:	60 83       	st	Z, r22
     a8a:	31 97       	sbiw	r30, 0x01	; 1
     a8c:	69 e0       	ldi	r22, 0x09	; 9
     a8e:	60 83       	st	Z, r22
     a90:	31 97       	sbiw	r30, 0x01	; 1
     a92:	60 e1       	ldi	r22, 0x10	; 16
     a94:	60 83       	st	Z, r22
     a96:	31 97       	sbiw	r30, 0x01	; 1
     a98:	30 83       	st	Z, r19
     a9a:	31 97       	sbiw	r30, 0x01	; 1
     a9c:	32 e1       	ldi	r19, 0x12	; 18
     a9e:	30 83       	st	Z, r19
     aa0:	31 97       	sbiw	r30, 0x01	; 1
     aa2:	33 e1       	ldi	r19, 0x13	; 19
     aa4:	30 83       	st	Z, r19
     aa6:	31 97       	sbiw	r30, 0x01	; 1
     aa8:	34 e1       	ldi	r19, 0x14	; 20
     aaa:	30 83       	st	Z, r19
     aac:	31 97       	sbiw	r30, 0x01	; 1
     aae:	35 e1       	ldi	r19, 0x15	; 21
     ab0:	30 83       	st	Z, r19
     ab2:	31 97       	sbiw	r30, 0x01	; 1
     ab4:	36 e1       	ldi	r19, 0x16	; 22
     ab6:	30 83       	st	Z, r19
     ab8:	31 97       	sbiw	r30, 0x01	; 1
     aba:	37 e1       	ldi	r19, 0x17	; 23
     abc:	30 83       	st	Z, r19
     abe:	31 97       	sbiw	r30, 0x01	; 1
     ac0:	38 e1       	ldi	r19, 0x18	; 24
     ac2:	30 83       	st	Z, r19
     ac4:	31 97       	sbiw	r30, 0x01	; 1
     ac6:	39 e1       	ldi	r19, 0x19	; 25
     ac8:	30 83       	st	Z, r19
     aca:	31 97       	sbiw	r30, 0x01	; 1
     acc:	30 e2       	ldi	r19, 0x20	; 32
     ace:	30 83       	st	Z, r19
     ad0:	31 97       	sbiw	r30, 0x01	; 1
     ad2:	31 e2       	ldi	r19, 0x21	; 33
     ad4:	30 83       	st	Z, r19
     ad6:	31 97       	sbiw	r30, 0x01	; 1
     ad8:	20 83       	st	Z, r18
     ada:	31 97       	sbiw	r30, 0x01	; 1
     adc:	23 e2       	ldi	r18, 0x23	; 35
     ade:	20 83       	st	Z, r18
     ae0:	6a 01       	movw	r12, r20
     ae2:	31 97       	sbiw	r30, 0x01	; 1
     ae4:	40 83       	st	Z, r20
     ae6:	31 97       	sbiw	r30, 0x01	; 1
     ae8:	d0 82       	st	Z, r13
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	26 e2       	ldi	r18, 0x26	; 38
     aee:	20 83       	st	Z, r18
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	27 e2       	ldi	r18, 0x27	; 39
     af4:	20 83       	st	Z, r18
     af6:	31 97       	sbiw	r30, 0x01	; 1
     af8:	28 e2       	ldi	r18, 0x28	; 40
     afa:	20 83       	st	Z, r18
     afc:	31 97       	sbiw	r30, 0x01	; 1
     afe:	29 e2       	ldi	r18, 0x29	; 41
     b00:	20 83       	st	Z, r18
     b02:	31 97       	sbiw	r30, 0x01	; 1
     b04:	20 e3       	ldi	r18, 0x30	; 48
     b06:	20 83       	st	Z, r18
     b08:	88 97       	sbiw	r24, 0x28	; 40
     b0a:	ff 90       	pop	r15
     b0c:	ef 90       	pop	r14
     b0e:	df 90       	pop	r13
     b10:	cf 90       	pop	r12
     b12:	08 95       	ret

00000b14 <xPortStartScheduler>:
     b14:	83 ef       	ldi	r24, 0xF3	; 243
     b16:	91 e0       	ldi	r25, 0x01	; 1
     b18:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     b1c:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
     b20:	65 e0       	ldi	r22, 0x05	; 5
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	98 e0       	ldi	r25, 0x08	; 8
     b26:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
     b2a:	61 e0       	ldi	r22, 0x01	; 1
     b2c:	80 e0       	ldi	r24, 0x00	; 0
     b2e:	98 e0       	ldi	r25, 0x08	; 8
     b30:	0e 94 98 02 	call	0x530	; 0x530 <TC0_SetOverflowIntLevel>
     b34:	a0 91 ac 2c 	lds	r26, 0x2CAC	; 0x802cac <pxCurrentTCB>
     b38:	b0 91 ad 2c 	lds	r27, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
     b3c:	0d 90       	ld	r0, X+
     b3e:	0d be       	out	0x3d, r0	; 61
     b40:	0d 90       	ld	r0, X+
     b42:	0e be       	out	0x3e, r0	; 62
     b44:	ef 91       	pop	r30
     b46:	df 91       	pop	r29
     b48:	cf 91       	pop	r28
     b4a:	bf 91       	pop	r27
     b4c:	af 91       	pop	r26
     b4e:	9f 91       	pop	r25
     b50:	8f 91       	pop	r24
     b52:	7f 91       	pop	r23
     b54:	6f 91       	pop	r22
     b56:	5f 91       	pop	r21
     b58:	4f 91       	pop	r20
     b5a:	3f 91       	pop	r19
     b5c:	2f 91       	pop	r18
     b5e:	1f 91       	pop	r17
     b60:	0f 91       	pop	r16
     b62:	ff 90       	pop	r15
     b64:	ef 90       	pop	r14
     b66:	df 90       	pop	r13
     b68:	cf 90       	pop	r12
     b6a:	bf 90       	pop	r11
     b6c:	af 90       	pop	r10
     b6e:	9f 90       	pop	r9
     b70:	8f 90       	pop	r8
     b72:	7f 90       	pop	r7
     b74:	6f 90       	pop	r6
     b76:	5f 90       	pop	r5
     b78:	4f 90       	pop	r4
     b7a:	3f 90       	pop	r3
     b7c:	2f 90       	pop	r2
     b7e:	1f 90       	pop	r1
     b80:	0f 90       	pop	r0
     b82:	ff 91       	pop	r31
     b84:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b88:	ff 91       	pop	r31
     b8a:	ff bf       	out	0x3f, r31	; 63
     b8c:	ff 91       	pop	r31
     b8e:	08 95       	ret
     b90:	81 e0       	ldi	r24, 0x01	; 1
     b92:	08 95       	ret

00000b94 <vPortYield>:
// 
//
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b94:	ff 93       	push	r31
     b96:	ff b7       	in	r31, 0x3f	; 63
     b98:	ff 93       	push	r31
     b9a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b9e:	ff 93       	push	r31
     ba0:	f8 7f       	andi	r31, 0xF8	; 248
     ba2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ba6:	0f 92       	push	r0
     ba8:	1f 92       	push	r1
     baa:	11 24       	eor	r1, r1
     bac:	2f 92       	push	r2
     bae:	3f 92       	push	r3
     bb0:	4f 92       	push	r4
     bb2:	5f 92       	push	r5
     bb4:	6f 92       	push	r6
     bb6:	7f 92       	push	r7
     bb8:	8f 92       	push	r8
     bba:	9f 92       	push	r9
     bbc:	af 92       	push	r10
     bbe:	bf 92       	push	r11
     bc0:	cf 92       	push	r12
     bc2:	df 92       	push	r13
     bc4:	ef 92       	push	r14
     bc6:	ff 92       	push	r15
     bc8:	0f 93       	push	r16
     bca:	1f 93       	push	r17
     bcc:	2f 93       	push	r18
     bce:	3f 93       	push	r19
     bd0:	4f 93       	push	r20
     bd2:	5f 93       	push	r21
     bd4:	6f 93       	push	r22
     bd6:	7f 93       	push	r23
     bd8:	8f 93       	push	r24
     bda:	9f 93       	push	r25
     bdc:	af 93       	push	r26
     bde:	bf 93       	push	r27
     be0:	cf 93       	push	r28
     be2:	df 93       	push	r29
     be4:	ef 93       	push	r30
     be6:	a0 91 ac 2c 	lds	r26, 0x2CAC	; 0x802cac <pxCurrentTCB>
     bea:	b0 91 ad 2c 	lds	r27, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
     bee:	0d b6       	in	r0, 0x3d	; 61
     bf0:	0d 92       	st	X+, r0
     bf2:	0e b6       	in	r0, 0x3e	; 62
     bf4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     bf6:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bfa:	a0 91 ac 2c 	lds	r26, 0x2CAC	; 0x802cac <pxCurrentTCB>
     bfe:	b0 91 ad 2c 	lds	r27, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
     c02:	0d 90       	ld	r0, X+
     c04:	0d be       	out	0x3d, r0	; 61
     c06:	0d 90       	ld	r0, X+
     c08:	0e be       	out	0x3e, r0	; 62
     c0a:	ef 91       	pop	r30
     c0c:	df 91       	pop	r29
     c0e:	cf 91       	pop	r28
     c10:	bf 91       	pop	r27
     c12:	af 91       	pop	r26
     c14:	9f 91       	pop	r25
     c16:	8f 91       	pop	r24
     c18:	7f 91       	pop	r23
     c1a:	6f 91       	pop	r22
     c1c:	5f 91       	pop	r21
     c1e:	4f 91       	pop	r20
     c20:	3f 91       	pop	r19
     c22:	2f 91       	pop	r18
     c24:	1f 91       	pop	r17
     c26:	0f 91       	pop	r16
     c28:	ff 90       	pop	r15
     c2a:	ef 90       	pop	r14
     c2c:	df 90       	pop	r13
     c2e:	cf 90       	pop	r12
     c30:	bf 90       	pop	r11
     c32:	af 90       	pop	r10
     c34:	9f 90       	pop	r9
     c36:	8f 90       	pop	r8
     c38:	7f 90       	pop	r7
     c3a:	6f 90       	pop	r6
     c3c:	5f 90       	pop	r5
     c3e:	4f 90       	pop	r4
     c40:	3f 90       	pop	r3
     c42:	2f 90       	pop	r2
     c44:	1f 90       	pop	r1
     c46:	0f 90       	pop	r0
     c48:	ff 91       	pop	r31
     c4a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     c4e:	ff 91       	pop	r31
     c50:	ff bf       	out	0x3f, r31	; 63
     c52:	ff 91       	pop	r31
	asm volatile ( "ret" );
     c54:	08 95       	ret

00000c56 <portTaskSwitchContext>:
	//-----------------------------------------------------------
	//
	// The task switch is deferred until there is no more nesting.
	//
	void portTaskSwitchContext(signed portBASE_TYPE xSwitchRequired)
	{
     c56:	cf 93       	push	r28
		intTaskSwitchPending |= xSwitchRequired;					
     c58:	90 91 f6 3e 	lds	r25, 0x3EF6	; 0x803ef6 <intTaskSwitchPending>
     c5c:	89 2b       	or	r24, r25
     c5e:	80 93 f6 3e 	sts	0x3EF6, r24	; 0x803ef6 <intTaskSwitchPending>
																
		if(NOT_NESTING() && intTaskSwitchPending)					
     c62:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c66:	91 30       	cpi	r25, 0x01	; 1
     c68:	41 f0       	breq	.+16     	; 0xc7a <portTaskSwitchContext+0x24>
     c6a:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c6e:	92 30       	cpi	r25, 0x02	; 2
     c70:	21 f0       	breq	.+8      	; 0xc7a <portTaskSwitchContext+0x24>
     c72:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c76:	94 30       	cpi	r25, 0x04	; 4
     c78:	59 f4       	brne	.+22     	; 0xc90 <portTaskSwitchContext+0x3a>
     c7a:	88 23       	and	r24, r24
     c7c:	49 f0       	breq	.+18     	; 0xc90 <portTaskSwitchContext+0x3a>
		{															
			register unsigned portBASE_TYPE uxSavedPmicCtrlReg; 				
			extern void vTaskSwitchContext(void);   				
																
			// Critical section used, because vTaskSwitchContext handles FreeRTOS internal data structures.
 			uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR(); 
     c7e:	0e 94 06 05 	call	0xa0c	; 0xa0c <_portSetInterruptMaskFromIsr>
     c82:	c8 2f       	mov	r28, r24
			intTaskSwitchPending = 0;								
     c84:	10 92 f6 3e 	sts	0x3EF6, r1	; 0x803ef6 <intTaskSwitchPending>
			vTaskSwitchContext();                   				
     c88:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <vTaskSwitchContext>
			portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedPmicCtrlReg);
     c8c:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		}                                          					
	}
     c90:	cf 91       	pop	r28
     c92:	08 95       	ret

00000c94 <__vector_14>:
	// the context is saved at the start of vPortYieldFromTick().  The tick
	// count is incremented after the context is saved.
	//
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
     c94:	ff 93       	push	r31
     c96:	ff b7       	in	r31, 0x3f	; 63
     c98:	ff 93       	push	r31
     c9a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     c9e:	ff 93       	push	r31
     ca0:	f8 7f       	andi	r31, 0xF8	; 248
     ca2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ca6:	0f 92       	push	r0
     ca8:	1f 92       	push	r1
     caa:	11 24       	eor	r1, r1
     cac:	2f 92       	push	r2
     cae:	3f 92       	push	r3
     cb0:	4f 92       	push	r4
     cb2:	5f 92       	push	r5
     cb4:	6f 92       	push	r6
     cb6:	7f 92       	push	r7
     cb8:	8f 92       	push	r8
     cba:	9f 92       	push	r9
     cbc:	af 92       	push	r10
     cbe:	bf 92       	push	r11
     cc0:	cf 92       	push	r12
     cc2:	df 92       	push	r13
     cc4:	ef 92       	push	r14
     cc6:	ff 92       	push	r15
     cc8:	0f 93       	push	r16
     cca:	1f 93       	push	r17
     ccc:	2f 93       	push	r18
     cce:	3f 93       	push	r19
     cd0:	4f 93       	push	r20
     cd2:	5f 93       	push	r21
     cd4:	6f 93       	push	r22
     cd6:	7f 93       	push	r23
     cd8:	8f 93       	push	r24
     cda:	9f 93       	push	r25
     cdc:	af 93       	push	r26
     cde:	bf 93       	push	r27
     ce0:	cf 93       	push	r28
     ce2:	df 93       	push	r29
     ce4:	ef 93       	push	r30
     ce6:	a0 91 ac 2c 	lds	r26, 0x2CAC	; 0x802cac <pxCurrentTCB>
     cea:	b0 91 ad 2c 	lds	r27, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
     cee:	0d b6       	in	r0, 0x3d	; 61
     cf0:	0d 92       	st	X+, r0
     cf2:	0e b6       	in	r0, 0x3e	; 62
     cf4:	0d 92       	st	X+, r0
	//
	static void portTaskIncrementTick( void )
	{
		register unsigned portBASE_TYPE uxSavedPmicCtrlReg;

 		uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR();
     cf6:	0e 94 06 05 	call	0xa0c	; 0xa0c <_portSetInterruptMaskFromIsr>
     cfa:	c8 2f       	mov	r28, r24
		xTaskIncrementTick();
     cfc:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <xTaskIncrementTick>
 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedPmicCtrlReg );
     d00:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
		portTaskIncrementTick();
		//always try a task switch, but only if on kernel interrupt level
		portEND_SWITCHING_ISR(pdTRUE); 
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	0e 94 2b 06 	call	0xc56	; 0xc56 <portTaskSwitchContext>
     d0a:	a0 91 ac 2c 	lds	r26, 0x2CAC	; 0x802cac <pxCurrentTCB>
     d0e:	b0 91 ad 2c 	lds	r27, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
     d12:	0d 90       	ld	r0, X+
     d14:	0d be       	out	0x3d, r0	; 61
     d16:	0d 90       	ld	r0, X+
     d18:	0e be       	out	0x3e, r0	; 62
     d1a:	ef 91       	pop	r30
     d1c:	df 91       	pop	r29
     d1e:	cf 91       	pop	r28
     d20:	bf 91       	pop	r27
     d22:	af 91       	pop	r26
     d24:	9f 91       	pop	r25
     d26:	8f 91       	pop	r24
     d28:	7f 91       	pop	r23
     d2a:	6f 91       	pop	r22
     d2c:	5f 91       	pop	r21
     d2e:	4f 91       	pop	r20
     d30:	3f 91       	pop	r19
     d32:	2f 91       	pop	r18
     d34:	1f 91       	pop	r17
     d36:	0f 91       	pop	r16
     d38:	ff 90       	pop	r15
     d3a:	ef 90       	pop	r14
     d3c:	df 90       	pop	r13
     d3e:	cf 90       	pop	r12
     d40:	bf 90       	pop	r11
     d42:	af 90       	pop	r10
     d44:	9f 90       	pop	r9
     d46:	8f 90       	pop	r8
     d48:	7f 90       	pop	r7
     d4a:	6f 90       	pop	r6
     d4c:	5f 90       	pop	r5
     d4e:	4f 90       	pop	r4
     d50:	3f 90       	pop	r3
     d52:	2f 90       	pop	r2
     d54:	1f 90       	pop	r1
     d56:	0f 90       	pop	r0
     d58:	ff 91       	pop	r31
     d5a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d5e:	ff 91       	pop	r31
     d60:	ff bf       	out	0x3f, r31	; 63
     d62:	ff 91       	pop	r31
     d64:	18 95       	reti

00000d66 <prvIsQueueEmpty>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
     d66:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d6a:	ff 93       	push	r31
     d6c:	f8 7f       	andi	r31, 0xF8	; 248
     d6e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d72:	fc 01       	movw	r30, r24
     d74:	96 8d       	ldd	r25, Z+30	; 0x1e
     d76:	ff 91       	pop	r31
     d78:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	91 11       	cpse	r25, r1
     d80:	80 e0       	ldi	r24, 0x00	; 0
     d82:	08 95       	ret

00000d84 <prvIsQueueFull>:
     d84:	dc 01       	movw	r26, r24
     d86:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d8a:	ff 93       	push	r31
     d8c:	f8 7f       	andi	r31, 0xF8	; 248
     d8e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d92:	5e 96       	adiw	r26, 0x1e	; 30
     d94:	9c 91       	ld	r25, X
     d96:	5e 97       	sbiw	r26, 0x1e	; 30
     d98:	ff 91       	pop	r31
     d9a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d9e:	81 e0       	ldi	r24, 0x01	; 1
     da0:	5f 96       	adiw	r26, 0x1f	; 31
     da2:	2c 91       	ld	r18, X
     da4:	29 13       	cpse	r18, r25
     da6:	80 e0       	ldi	r24, 0x00	; 0
     da8:	08 95       	ret

00000daa <prvCopyDataToQueue>:
     daa:	0f 93       	push	r16
     dac:	1f 93       	push	r17
     dae:	cf 93       	push	r28
     db0:	df 93       	push	r29
     db2:	ec 01       	movw	r28, r24
     db4:	04 2f       	mov	r16, r20
     db6:	1e 8d       	ldd	r17, Y+30	; 0x1e
     db8:	48 a1       	ldd	r20, Y+32	; 0x20
     dba:	44 23       	and	r20, r20
     dbc:	b9 f1       	breq	.+110    	; 0xe2c <prvCopyDataToQueue+0x82>
     dbe:	01 11       	cpse	r16, r1
     dc0:	16 c0       	rjmp	.+44     	; 0xdee <prvCopyDataToQueue+0x44>
     dc2:	50 e0       	ldi	r21, 0x00	; 0
     dc4:	8c 81       	ldd	r24, Y+4	; 0x04
     dc6:	9d 81       	ldd	r25, Y+5	; 0x05
     dc8:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <memcpy>
     dcc:	28 a1       	ldd	r18, Y+32	; 0x20
     dce:	8c 81       	ldd	r24, Y+4	; 0x04
     dd0:	9d 81       	ldd	r25, Y+5	; 0x05
     dd2:	82 0f       	add	r24, r18
     dd4:	91 1d       	adc	r25, r1
     dd6:	8c 83       	std	Y+4, r24	; 0x04
     dd8:	9d 83       	std	Y+5, r25	; 0x05
     dda:	2a 81       	ldd	r18, Y+2	; 0x02
     ddc:	3b 81       	ldd	r19, Y+3	; 0x03
     dde:	82 17       	cp	r24, r18
     de0:	93 07       	cpc	r25, r19
     de2:	20 f1       	brcs	.+72     	; 0xe2c <prvCopyDataToQueue+0x82>
     de4:	88 81       	ld	r24, Y
     de6:	99 81       	ldd	r25, Y+1	; 0x01
     de8:	8c 83       	std	Y+4, r24	; 0x04
     dea:	9d 83       	std	Y+5, r25	; 0x05
     dec:	1f c0       	rjmp	.+62     	; 0xe2c <prvCopyDataToQueue+0x82>
     dee:	50 e0       	ldi	r21, 0x00	; 0
     df0:	8e 81       	ldd	r24, Y+6	; 0x06
     df2:	9f 81       	ldd	r25, Y+7	; 0x07
     df4:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <memcpy>
     df8:	88 a1       	ldd	r24, Y+32	; 0x20
     dfa:	90 e0       	ldi	r25, 0x00	; 0
     dfc:	91 95       	neg	r25
     dfe:	81 95       	neg	r24
     e00:	91 09       	sbc	r25, r1
     e02:	2e 81       	ldd	r18, Y+6	; 0x06
     e04:	3f 81       	ldd	r19, Y+7	; 0x07
     e06:	28 0f       	add	r18, r24
     e08:	39 1f       	adc	r19, r25
     e0a:	2e 83       	std	Y+6, r18	; 0x06
     e0c:	3f 83       	std	Y+7, r19	; 0x07
     e0e:	48 81       	ld	r20, Y
     e10:	59 81       	ldd	r21, Y+1	; 0x01
     e12:	24 17       	cp	r18, r20
     e14:	35 07       	cpc	r19, r21
     e16:	30 f4       	brcc	.+12     	; 0xe24 <prvCopyDataToQueue+0x7a>
     e18:	2a 81       	ldd	r18, Y+2	; 0x02
     e1a:	3b 81       	ldd	r19, Y+3	; 0x03
     e1c:	82 0f       	add	r24, r18
     e1e:	93 1f       	adc	r25, r19
     e20:	8e 83       	std	Y+6, r24	; 0x06
     e22:	9f 83       	std	Y+7, r25	; 0x07
     e24:	02 30       	cpi	r16, 0x02	; 2
     e26:	11 f4       	brne	.+4      	; 0xe2c <prvCopyDataToQueue+0x82>
     e28:	11 11       	cpse	r17, r1
     e2a:	11 50       	subi	r17, 0x01	; 1
     e2c:	1f 5f       	subi	r17, 0xFF	; 255
     e2e:	1e 8f       	std	Y+30, r17	; 0x1e
     e30:	80 e0       	ldi	r24, 0x00	; 0
     e32:	df 91       	pop	r29
     e34:	cf 91       	pop	r28
     e36:	1f 91       	pop	r17
     e38:	0f 91       	pop	r16
     e3a:	08 95       	ret

00000e3c <prvCopyDataFromQueue>:
     e3c:	fc 01       	movw	r30, r24
     e3e:	40 a1       	ldd	r20, Z+32	; 0x20
     e40:	44 23       	and	r20, r20
     e42:	a9 f0       	breq	.+42     	; 0xe6e <prvCopyDataFromQueue+0x32>
     e44:	50 e0       	ldi	r21, 0x00	; 0
     e46:	26 81       	ldd	r18, Z+6	; 0x06
     e48:	37 81       	ldd	r19, Z+7	; 0x07
     e4a:	24 0f       	add	r18, r20
     e4c:	35 1f       	adc	r19, r21
     e4e:	26 83       	std	Z+6, r18	; 0x06
     e50:	37 83       	std	Z+7, r19	; 0x07
     e52:	82 81       	ldd	r24, Z+2	; 0x02
     e54:	93 81       	ldd	r25, Z+3	; 0x03
     e56:	28 17       	cp	r18, r24
     e58:	39 07       	cpc	r19, r25
     e5a:	20 f0       	brcs	.+8      	; 0xe64 <prvCopyDataFromQueue+0x28>
     e5c:	80 81       	ld	r24, Z
     e5e:	91 81       	ldd	r25, Z+1	; 0x01
     e60:	86 83       	std	Z+6, r24	; 0x06
     e62:	97 83       	std	Z+7, r25	; 0x07
     e64:	cb 01       	movw	r24, r22
     e66:	66 81       	ldd	r22, Z+6	; 0x06
     e68:	77 81       	ldd	r23, Z+7	; 0x07
     e6a:	0e 94 ac 1d 	call	0x3b58	; 0x3b58 <memcpy>
     e6e:	08 95       	ret

00000e70 <prvUnlockQueue>:
     e70:	ef 92       	push	r14
     e72:	ff 92       	push	r15
     e74:	0f 93       	push	r16
     e76:	1f 93       	push	r17
     e78:	cf 93       	push	r28
     e7a:	8c 01       	movw	r16, r24
     e7c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e80:	ff 93       	push	r31
     e82:	f8 7f       	andi	r31, 0xF8	; 248
     e84:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e88:	fc 01       	movw	r30, r24
     e8a:	c2 a1       	ldd	r28, Z+34	; 0x22
     e8c:	1c 16       	cp	r1, r28
     e8e:	ac f4       	brge	.+42     	; 0xeba <prvUnlockQueue+0x4a>
     e90:	83 89       	ldd	r24, Z+19	; 0x13
     e92:	81 11       	cpse	r24, r1
     e94:	06 c0       	rjmp	.+12     	; 0xea2 <prvUnlockQueue+0x32>
     e96:	11 c0       	rjmp	.+34     	; 0xeba <prvUnlockQueue+0x4a>
     e98:	f8 01       	movw	r30, r16
     e9a:	83 89       	ldd	r24, Z+19	; 0x13
     e9c:	81 11       	cpse	r24, r1
     e9e:	05 c0       	rjmp	.+10     	; 0xeaa <prvUnlockQueue+0x3a>
     ea0:	0c c0       	rjmp	.+24     	; 0xeba <prvUnlockQueue+0x4a>
     ea2:	78 01       	movw	r14, r16
     ea4:	f3 e1       	ldi	r31, 0x13	; 19
     ea6:	ef 0e       	add	r14, r31
     ea8:	f1 1c       	adc	r15, r1
     eaa:	c7 01       	movw	r24, r14
     eac:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
     eb0:	81 11       	cpse	r24, r1
     eb2:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vTaskMissedYield>
     eb6:	c1 50       	subi	r28, 0x01	; 1
     eb8:	79 f7       	brne	.-34     	; 0xe98 <prvUnlockQueue+0x28>
     eba:	8f ef       	ldi	r24, 0xFF	; 255
     ebc:	f8 01       	movw	r30, r16
     ebe:	82 a3       	std	Z+34, r24	; 0x22
     ec0:	ff 91       	pop	r31
     ec2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ec6:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     eca:	ff 93       	push	r31
     ecc:	f8 7f       	andi	r31, 0xF8	; 248
     ece:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ed2:	f8 01       	movw	r30, r16
     ed4:	c1 a1       	ldd	r28, Z+33	; 0x21
     ed6:	1c 16       	cp	r1, r28
     ed8:	ac f4       	brge	.+42     	; 0xf04 <prvUnlockQueue+0x94>
     eda:	80 85       	ldd	r24, Z+8	; 0x08
     edc:	81 11       	cpse	r24, r1
     ede:	06 c0       	rjmp	.+12     	; 0xeec <prvUnlockQueue+0x7c>
     ee0:	11 c0       	rjmp	.+34     	; 0xf04 <prvUnlockQueue+0x94>
     ee2:	f8 01       	movw	r30, r16
     ee4:	80 85       	ldd	r24, Z+8	; 0x08
     ee6:	81 11       	cpse	r24, r1
     ee8:	05 c0       	rjmp	.+10     	; 0xef4 <prvUnlockQueue+0x84>
     eea:	0c c0       	rjmp	.+24     	; 0xf04 <prvUnlockQueue+0x94>
     eec:	78 01       	movw	r14, r16
     eee:	f8 e0       	ldi	r31, 0x08	; 8
     ef0:	ef 0e       	add	r14, r31
     ef2:	f1 1c       	adc	r15, r1
     ef4:	c7 01       	movw	r24, r14
     ef6:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
     efa:	81 11       	cpse	r24, r1
     efc:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vTaskMissedYield>
     f00:	c1 50       	subi	r28, 0x01	; 1
     f02:	79 f7       	brne	.-34     	; 0xee2 <prvUnlockQueue+0x72>
     f04:	8f ef       	ldi	r24, 0xFF	; 255
     f06:	f8 01       	movw	r30, r16
     f08:	81 a3       	std	Z+33, r24	; 0x21
     f0a:	ff 91       	pop	r31
     f0c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f10:	cf 91       	pop	r28
     f12:	1f 91       	pop	r17
     f14:	0f 91       	pop	r16
     f16:	ff 90       	pop	r15
     f18:	ef 90       	pop	r14
     f1a:	08 95       	ret

00000f1c <xQueueGenericReset>:
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	ec 01       	movw	r28, r24
     f22:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f26:	ff 93       	push	r31
     f28:	f8 7f       	andi	r31, 0xF8	; 248
     f2a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f2e:	48 81       	ld	r20, Y
     f30:	59 81       	ldd	r21, Y+1	; 0x01
     f32:	28 a1       	ldd	r18, Y+32	; 0x20
     f34:	30 e0       	ldi	r19, 0x00	; 0
     f36:	7f 8d       	ldd	r23, Y+31	; 0x1f
     f38:	72 9f       	mul	r23, r18
     f3a:	c0 01       	movw	r24, r0
     f3c:	73 9f       	mul	r23, r19
     f3e:	90 0d       	add	r25, r0
     f40:	11 24       	eor	r1, r1
     f42:	fa 01       	movw	r30, r20
     f44:	e8 0f       	add	r30, r24
     f46:	f9 1f       	adc	r31, r25
     f48:	ea 83       	std	Y+2, r30	; 0x02
     f4a:	fb 83       	std	Y+3, r31	; 0x03
     f4c:	1e 8e       	std	Y+30, r1	; 0x1e
     f4e:	4c 83       	std	Y+4, r20	; 0x04
     f50:	5d 83       	std	Y+5, r21	; 0x05
     f52:	82 1b       	sub	r24, r18
     f54:	93 0b       	sbc	r25, r19
     f56:	84 0f       	add	r24, r20
     f58:	95 1f       	adc	r25, r21
     f5a:	8e 83       	std	Y+6, r24	; 0x06
     f5c:	9f 83       	std	Y+7, r25	; 0x07
     f5e:	8f ef       	ldi	r24, 0xFF	; 255
     f60:	89 a3       	std	Y+33, r24	; 0x21
     f62:	8a a3       	std	Y+34, r24	; 0x22
     f64:	61 11       	cpse	r22, r1
     f66:	0c c0       	rjmp	.+24     	; 0xf80 <xQueueGenericReset+0x64>
     f68:	88 85       	ldd	r24, Y+8	; 0x08
     f6a:	88 23       	and	r24, r24
     f6c:	89 f0       	breq	.+34     	; 0xf90 <xQueueGenericReset+0x74>
     f6e:	ce 01       	movw	r24, r28
     f70:	08 96       	adiw	r24, 0x08	; 8
     f72:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
     f76:	88 23       	and	r24, r24
     f78:	59 f0       	breq	.+22     	; 0xf90 <xQueueGenericReset+0x74>
     f7a:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
     f7e:	08 c0       	rjmp	.+16     	; 0xf90 <xQueueGenericReset+0x74>
     f80:	ce 01       	movw	r24, r28
     f82:	08 96       	adiw	r24, 0x08	; 8
     f84:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
     f88:	ce 01       	movw	r24, r28
     f8a:	43 96       	adiw	r24, 0x13	; 19
     f8c:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
     f90:	ff 91       	pop	r31
     f92:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f96:	81 e0       	ldi	r24, 0x01	; 1
     f98:	df 91       	pop	r29
     f9a:	cf 91       	pop	r28
     f9c:	08 95       	ret

00000f9e <xQueueGenericCreate>:
     f9e:	ff 92       	push	r15
     fa0:	0f 93       	push	r16
     fa2:	1f 93       	push	r17
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	08 2f       	mov	r16, r24
     faa:	16 2f       	mov	r17, r22
     fac:	f4 2e       	mov	r15, r20
     fae:	66 23       	and	r22, r22
     fb0:	c9 f0       	breq	.+50     	; 0xfe4 <xQueueGenericCreate+0x46>
     fb2:	86 9f       	mul	r24, r22
     fb4:	c0 01       	movw	r24, r0
     fb6:	11 24       	eor	r1, r1
     fb8:	85 96       	adiw	r24, 0x25	; 37
     fba:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
     fbe:	ec 01       	movw	r28, r24
     fc0:	00 97       	sbiw	r24, 0x00	; 0
     fc2:	49 f4       	brne	.+18     	; 0xfd6 <xQueueGenericCreate+0x38>
     fc4:	16 c0       	rjmp	.+44     	; 0xff2 <xQueueGenericCreate+0x54>
     fc6:	0f 8f       	std	Y+31, r16	; 0x1f
     fc8:	18 a3       	std	Y+32, r17	; 0x20
     fca:	61 e0       	ldi	r22, 0x01	; 1
     fcc:	ce 01       	movw	r24, r28
     fce:	0e 94 8e 07 	call	0xf1c	; 0xf1c <xQueueGenericReset>
     fd2:	fc a2       	std	Y+36, r15	; 0x24
     fd4:	0e c0       	rjmp	.+28     	; 0xff2 <xQueueGenericCreate+0x54>
     fd6:	85 96       	adiw	r24, 0x25	; 37
     fd8:	88 83       	st	Y, r24
     fda:	99 83       	std	Y+1, r25	; 0x01
     fdc:	f4 cf       	rjmp	.-24     	; 0xfc6 <xQueueGenericCreate+0x28>
     fde:	c8 83       	st	Y, r28
     fe0:	d9 83       	std	Y+1, r29	; 0x01
     fe2:	f1 cf       	rjmp	.-30     	; 0xfc6 <xQueueGenericCreate+0x28>
     fe4:	85 e2       	ldi	r24, 0x25	; 37
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
     fec:	ec 01       	movw	r28, r24
     fee:	89 2b       	or	r24, r25
     ff0:	b1 f7       	brne	.-20     	; 0xfde <xQueueGenericCreate+0x40>
     ff2:	ce 01       	movw	r24, r28
     ff4:	df 91       	pop	r29
     ff6:	cf 91       	pop	r28
     ff8:	1f 91       	pop	r17
     ffa:	0f 91       	pop	r16
     ffc:	ff 90       	pop	r15
     ffe:	08 95       	ret

00001000 <xQueueGenericSend>:
    1000:	af 92       	push	r10
    1002:	bf 92       	push	r11
    1004:	cf 92       	push	r12
    1006:	df 92       	push	r13
    1008:	ef 92       	push	r14
    100a:	ff 92       	push	r15
    100c:	0f 93       	push	r16
    100e:	1f 93       	push	r17
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	cd b7       	in	r28, 0x3d	; 61
    1016:	de b7       	in	r29, 0x3e	; 62
    1018:	29 97       	sbiw	r28, 0x09	; 9
    101a:	cd bf       	out	0x3d, r28	; 61
    101c:	de bf       	out	0x3e, r29	; 62
    101e:	7c 01       	movw	r14, r24
    1020:	5b 01       	movw	r10, r22
    1022:	2e 83       	std	Y+6, r18	; 0x06
    1024:	3f 83       	std	Y+7, r19	; 0x07
    1026:	48 87       	std	Y+8, r20	; 0x08
    1028:	59 87       	std	Y+9, r21	; 0x09
    102a:	10 e0       	ldi	r17, 0x00	; 0
    102c:	6c 01       	movw	r12, r24
    102e:	88 e0       	ldi	r24, 0x08	; 8
    1030:	c8 0e       	add	r12, r24
    1032:	d1 1c       	adc	r13, r1
    1034:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1038:	ff 93       	push	r31
    103a:	f8 7f       	andi	r31, 0xF8	; 248
    103c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1040:	f7 01       	movw	r30, r14
    1042:	96 8d       	ldd	r25, Z+30	; 0x1e
    1044:	87 8d       	ldd	r24, Z+31	; 0x1f
    1046:	98 17       	cp	r25, r24
    1048:	10 f0       	brcs	.+4      	; 0x104e <xQueueGenericSend+0x4e>
    104a:	02 30       	cpi	r16, 0x02	; 2
    104c:	d1 f4       	brne	.+52     	; 0x1082 <xQueueGenericSend+0x82>
    104e:	40 2f       	mov	r20, r16
    1050:	b5 01       	movw	r22, r10
    1052:	c7 01       	movw	r24, r14
    1054:	0e 94 d5 06 	call	0xdaa	; 0xdaa <prvCopyDataToQueue>
    1058:	f7 01       	movw	r30, r14
    105a:	93 89       	ldd	r25, Z+19	; 0x13
    105c:	99 23       	and	r25, r25
    105e:	49 f0       	breq	.+18     	; 0x1072 <xQueueGenericSend+0x72>
    1060:	c7 01       	movw	r24, r14
    1062:	43 96       	adiw	r24, 0x13	; 19
    1064:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
    1068:	88 23       	and	r24, r24
    106a:	31 f0       	breq	.+12     	; 0x1078 <xQueueGenericSend+0x78>
    106c:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1070:	03 c0       	rjmp	.+6      	; 0x1078 <xQueueGenericSend+0x78>
    1072:	81 11       	cpse	r24, r1
    1074:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1078:	ff 91       	pop	r31
    107a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	57 c0       	rjmp	.+174    	; 0x1130 <xQueueGenericSend+0x130>
    1082:	8e 81       	ldd	r24, Y+6	; 0x06
    1084:	9f 81       	ldd	r25, Y+7	; 0x07
    1086:	a8 85       	ldd	r26, Y+8	; 0x08
    1088:	b9 85       	ldd	r27, Y+9	; 0x09
    108a:	89 2b       	or	r24, r25
    108c:	8a 2b       	or	r24, r26
    108e:	8b 2b       	or	r24, r27
    1090:	29 f4       	brne	.+10     	; 0x109c <xQueueGenericSend+0x9c>
    1092:	ff 91       	pop	r31
    1094:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1098:	80 e0       	ldi	r24, 0x00	; 0
    109a:	4a c0       	rjmp	.+148    	; 0x1130 <xQueueGenericSend+0x130>
    109c:	11 11       	cpse	r17, r1
    109e:	05 c0       	rjmp	.+10     	; 0x10aa <xQueueGenericSend+0xaa>
    10a0:	ce 01       	movw	r24, r28
    10a2:	01 96       	adiw	r24, 0x01	; 1
    10a4:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskInternalSetTimeOutState>
    10a8:	11 e0       	ldi	r17, 0x01	; 1
    10aa:	ff 91       	pop	r31
    10ac:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10b0:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    10b4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10b8:	ff 93       	push	r31
    10ba:	f8 7f       	andi	r31, 0xF8	; 248
    10bc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10c0:	f7 01       	movw	r30, r14
    10c2:	81 a1       	ldd	r24, Z+33	; 0x21
    10c4:	8f 3f       	cpi	r24, 0xFF	; 255
    10c6:	09 f4       	brne	.+2      	; 0x10ca <xQueueGenericSend+0xca>
    10c8:	11 a2       	std	Z+33, r1	; 0x21
    10ca:	f7 01       	movw	r30, r14
    10cc:	82 a1       	ldd	r24, Z+34	; 0x22
    10ce:	8f 3f       	cpi	r24, 0xFF	; 255
    10d0:	09 f4       	brne	.+2      	; 0x10d4 <xQueueGenericSend+0xd4>
    10d2:	12 a2       	std	Z+34, r1	; 0x22
    10d4:	ff 91       	pop	r31
    10d6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10da:	be 01       	movw	r22, r28
    10dc:	6a 5f       	subi	r22, 0xFA	; 250
    10de:	7f 4f       	sbci	r23, 0xFF	; 255
    10e0:	ce 01       	movw	r24, r28
    10e2:	01 96       	adiw	r24, 0x01	; 1
    10e4:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <xTaskCheckForTimeOut>
    10e8:	81 11       	cpse	r24, r1
    10ea:	1c c0       	rjmp	.+56     	; 0x1124 <xQueueGenericSend+0x124>
    10ec:	c7 01       	movw	r24, r14
    10ee:	0e 94 c2 06 	call	0xd84	; 0xd84 <prvIsQueueFull>
    10f2:	88 23       	and	r24, r24
    10f4:	89 f0       	breq	.+34     	; 0x1118 <xQueueGenericSend+0x118>
    10f6:	4e 81       	ldd	r20, Y+6	; 0x06
    10f8:	5f 81       	ldd	r21, Y+7	; 0x07
    10fa:	68 85       	ldd	r22, Y+8	; 0x08
    10fc:	79 85       	ldd	r23, Y+9	; 0x09
    10fe:	c6 01       	movw	r24, r12
    1100:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <vTaskPlaceOnEventList>
    1104:	c7 01       	movw	r24, r14
    1106:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    110a:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    110e:	81 11       	cpse	r24, r1
    1110:	91 cf       	rjmp	.-222    	; 0x1034 <xQueueGenericSend+0x34>
    1112:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1116:	8e cf       	rjmp	.-228    	; 0x1034 <xQueueGenericSend+0x34>
    1118:	c7 01       	movw	r24, r14
    111a:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    111e:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    1122:	88 cf       	rjmp	.-240    	; 0x1034 <xQueueGenericSend+0x34>
    1124:	c7 01       	movw	r24, r14
    1126:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    112a:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    112e:	80 e0       	ldi	r24, 0x00	; 0
    1130:	29 96       	adiw	r28, 0x09	; 9
    1132:	cd bf       	out	0x3d, r28	; 61
    1134:	de bf       	out	0x3e, r29	; 62
    1136:	df 91       	pop	r29
    1138:	cf 91       	pop	r28
    113a:	1f 91       	pop	r17
    113c:	0f 91       	pop	r16
    113e:	ff 90       	pop	r15
    1140:	ef 90       	pop	r14
    1142:	df 90       	pop	r13
    1144:	cf 90       	pop	r12
    1146:	bf 90       	pop	r11
    1148:	af 90       	pop	r10
    114a:	08 95       	ret

0000114c <xQueueGenericSendFromISR>:
    114c:	af 92       	push	r10
    114e:	bf 92       	push	r11
    1150:	cf 92       	push	r12
    1152:	df 92       	push	r13
    1154:	ff 92       	push	r15
    1156:	0f 93       	push	r16
    1158:	1f 93       	push	r17
    115a:	cf 93       	push	r28
    115c:	df 93       	push	r29
    115e:	ec 01       	movw	r28, r24
    1160:	6b 01       	movw	r12, r22
    1162:	5a 01       	movw	r10, r20
    1164:	02 2f       	mov	r16, r18
    1166:	0e 94 06 05 	call	0xa0c	; 0xa0c <_portSetInterruptMaskFromIsr>
    116a:	f8 2e       	mov	r15, r24
    116c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    116e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1170:	98 17       	cp	r25, r24
    1172:	10 f0       	brcs	.+4      	; 0x1178 <xQueueGenericSendFromISR+0x2c>
    1174:	02 30       	cpi	r16, 0x02	; 2
    1176:	e1 f4       	brne	.+56     	; 0x11b0 <xQueueGenericSendFromISR+0x64>
    1178:	1a a1       	ldd	r17, Y+34	; 0x22
    117a:	40 2f       	mov	r20, r16
    117c:	b6 01       	movw	r22, r12
    117e:	ce 01       	movw	r24, r28
    1180:	0e 94 d5 06 	call	0xdaa	; 0xdaa <prvCopyDataToQueue>
    1184:	1f 3f       	cpi	r17, 0xFF	; 255
    1186:	81 f4       	brne	.+32     	; 0x11a8 <xQueueGenericSendFromISR+0x5c>
    1188:	8b 89       	ldd	r24, Y+19	; 0x13
    118a:	88 23       	and	r24, r24
    118c:	99 f0       	breq	.+38     	; 0x11b4 <xQueueGenericSendFromISR+0x68>
    118e:	ce 01       	movw	r24, r28
    1190:	43 96       	adiw	r24, 0x13	; 19
    1192:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
    1196:	88 23       	and	r24, r24
    1198:	79 f0       	breq	.+30     	; 0x11b8 <xQueueGenericSendFromISR+0x6c>
    119a:	a1 14       	cp	r10, r1
    119c:	b1 04       	cpc	r11, r1
    119e:	71 f0       	breq	.+28     	; 0x11bc <xQueueGenericSendFromISR+0x70>
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	f5 01       	movw	r30, r10
    11a4:	80 83       	st	Z, r24
    11a6:	0b c0       	rjmp	.+22     	; 0x11be <xQueueGenericSendFromISR+0x72>
    11a8:	1f 5f       	subi	r17, 0xFF	; 255
    11aa:	1a a3       	std	Y+34, r17	; 0x22
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	07 c0       	rjmp	.+14     	; 0x11be <xQueueGenericSendFromISR+0x72>
    11b0:	80 e0       	ldi	r24, 0x00	; 0
    11b2:	05 c0       	rjmp	.+10     	; 0x11be <xQueueGenericSendFromISR+0x72>
    11b4:	81 e0       	ldi	r24, 0x01	; 1
    11b6:	03 c0       	rjmp	.+6      	; 0x11be <xQueueGenericSendFromISR+0x72>
    11b8:	81 e0       	ldi	r24, 0x01	; 1
    11ba:	01 c0       	rjmp	.+2      	; 0x11be <xQueueGenericSendFromISR+0x72>
    11bc:	81 e0       	ldi	r24, 0x01	; 1
    11be:	f0 92 a2 00 	sts	0x00A2, r15	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	1f 91       	pop	r17
    11c8:	0f 91       	pop	r16
    11ca:	ff 90       	pop	r15
    11cc:	df 90       	pop	r13
    11ce:	cf 90       	pop	r12
    11d0:	bf 90       	pop	r11
    11d2:	af 90       	pop	r10
    11d4:	08 95       	ret

000011d6 <xQueueReceive>:
    11d6:	af 92       	push	r10
    11d8:	bf 92       	push	r11
    11da:	cf 92       	push	r12
    11dc:	df 92       	push	r13
    11de:	ef 92       	push	r14
    11e0:	ff 92       	push	r15
    11e2:	0f 93       	push	r16
    11e4:	1f 93       	push	r17
    11e6:	cf 93       	push	r28
    11e8:	df 93       	push	r29
    11ea:	cd b7       	in	r28, 0x3d	; 61
    11ec:	de b7       	in	r29, 0x3e	; 62
    11ee:	29 97       	sbiw	r28, 0x09	; 9
    11f0:	cd bf       	out	0x3d, r28	; 61
    11f2:	de bf       	out	0x3e, r29	; 62
    11f4:	8c 01       	movw	r16, r24
    11f6:	5b 01       	movw	r10, r22
    11f8:	2e 83       	std	Y+6, r18	; 0x06
    11fa:	3f 83       	std	Y+7, r19	; 0x07
    11fc:	48 87       	std	Y+8, r20	; 0x08
    11fe:	59 87       	std	Y+9, r21	; 0x09
    1200:	e1 2c       	mov	r14, r1
    1202:	6c 01       	movw	r12, r24
    1204:	83 e1       	ldi	r24, 0x13	; 19
    1206:	c8 0e       	add	r12, r24
    1208:	d1 1c       	adc	r13, r1
    120a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    120e:	ff 93       	push	r31
    1210:	f8 7f       	andi	r31, 0xF8	; 248
    1212:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1216:	f8 01       	movw	r30, r16
    1218:	f6 8c       	ldd	r15, Z+30	; 0x1e
    121a:	ff 20       	and	r15, r15
    121c:	b1 f0       	breq	.+44     	; 0x124a <xQueueReceive+0x74>
    121e:	b5 01       	movw	r22, r10
    1220:	c8 01       	movw	r24, r16
    1222:	0e 94 1e 07 	call	0xe3c	; 0xe3c <prvCopyDataFromQueue>
    1226:	fa 94       	dec	r15
    1228:	f8 01       	movw	r30, r16
    122a:	f6 8e       	std	Z+30, r15	; 0x1e
    122c:	80 85       	ldd	r24, Z+8	; 0x08
    122e:	88 23       	and	r24, r24
    1230:	39 f0       	breq	.+14     	; 0x1240 <xQueueReceive+0x6a>
    1232:	c8 01       	movw	r24, r16
    1234:	08 96       	adiw	r24, 0x08	; 8
    1236:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
    123a:	81 11       	cpse	r24, r1
    123c:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1240:	ff 91       	pop	r31
    1242:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	5e c0       	rjmp	.+188    	; 0x1306 <xQueueReceive+0x130>
    124a:	8e 81       	ldd	r24, Y+6	; 0x06
    124c:	9f 81       	ldd	r25, Y+7	; 0x07
    124e:	a8 85       	ldd	r26, Y+8	; 0x08
    1250:	b9 85       	ldd	r27, Y+9	; 0x09
    1252:	89 2b       	or	r24, r25
    1254:	8a 2b       	or	r24, r26
    1256:	8b 2b       	or	r24, r27
    1258:	29 f4       	brne	.+10     	; 0x1264 <xQueueReceive+0x8e>
    125a:	ff 91       	pop	r31
    125c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1260:	80 e0       	ldi	r24, 0x00	; 0
    1262:	51 c0       	rjmp	.+162    	; 0x1306 <xQueueReceive+0x130>
    1264:	e1 10       	cpse	r14, r1
    1266:	06 c0       	rjmp	.+12     	; 0x1274 <xQueueReceive+0x9e>
    1268:	ce 01       	movw	r24, r28
    126a:	01 96       	adiw	r24, 0x01	; 1
    126c:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskInternalSetTimeOutState>
    1270:	ee 24       	eor	r14, r14
    1272:	e3 94       	inc	r14
    1274:	ff 91       	pop	r31
    1276:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    127a:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    127e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1282:	ff 93       	push	r31
    1284:	f8 7f       	andi	r31, 0xF8	; 248
    1286:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    128a:	f8 01       	movw	r30, r16
    128c:	81 a1       	ldd	r24, Z+33	; 0x21
    128e:	8f 3f       	cpi	r24, 0xFF	; 255
    1290:	09 f4       	brne	.+2      	; 0x1294 <xQueueReceive+0xbe>
    1292:	11 a2       	std	Z+33, r1	; 0x21
    1294:	f8 01       	movw	r30, r16
    1296:	82 a1       	ldd	r24, Z+34	; 0x22
    1298:	8f 3f       	cpi	r24, 0xFF	; 255
    129a:	09 f4       	brne	.+2      	; 0x129e <xQueueReceive+0xc8>
    129c:	12 a2       	std	Z+34, r1	; 0x22
    129e:	ff 91       	pop	r31
    12a0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12a4:	be 01       	movw	r22, r28
    12a6:	6a 5f       	subi	r22, 0xFA	; 250
    12a8:	7f 4f       	sbci	r23, 0xFF	; 255
    12aa:	ce 01       	movw	r24, r28
    12ac:	01 96       	adiw	r24, 0x01	; 1
    12ae:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <xTaskCheckForTimeOut>
    12b2:	81 11       	cpse	r24, r1
    12b4:	1c c0       	rjmp	.+56     	; 0x12ee <xQueueReceive+0x118>
    12b6:	c8 01       	movw	r24, r16
    12b8:	0e 94 b3 06 	call	0xd66	; 0xd66 <prvIsQueueEmpty>
    12bc:	88 23       	and	r24, r24
    12be:	89 f0       	breq	.+34     	; 0x12e2 <xQueueReceive+0x10c>
    12c0:	4e 81       	ldd	r20, Y+6	; 0x06
    12c2:	5f 81       	ldd	r21, Y+7	; 0x07
    12c4:	68 85       	ldd	r22, Y+8	; 0x08
    12c6:	79 85       	ldd	r23, Y+9	; 0x09
    12c8:	c6 01       	movw	r24, r12
    12ca:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <vTaskPlaceOnEventList>
    12ce:	c8 01       	movw	r24, r16
    12d0:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    12d4:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    12d8:	81 11       	cpse	r24, r1
    12da:	97 cf       	rjmp	.-210    	; 0x120a <xQueueReceive+0x34>
    12dc:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    12e0:	94 cf       	rjmp	.-216    	; 0x120a <xQueueReceive+0x34>
    12e2:	c8 01       	movw	r24, r16
    12e4:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    12e8:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    12ec:	8e cf       	rjmp	.-228    	; 0x120a <xQueueReceive+0x34>
    12ee:	c8 01       	movw	r24, r16
    12f0:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    12f4:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    12f8:	c8 01       	movw	r24, r16
    12fa:	0e 94 b3 06 	call	0xd66	; 0xd66 <prvIsQueueEmpty>
    12fe:	88 23       	and	r24, r24
    1300:	09 f4       	brne	.+2      	; 0x1304 <xQueueReceive+0x12e>
    1302:	83 cf       	rjmp	.-250    	; 0x120a <xQueueReceive+0x34>
    1304:	80 e0       	ldi	r24, 0x00	; 0
    1306:	29 96       	adiw	r28, 0x09	; 9
    1308:	cd bf       	out	0x3d, r28	; 61
    130a:	de bf       	out	0x3e, r29	; 62
    130c:	df 91       	pop	r29
    130e:	cf 91       	pop	r28
    1310:	1f 91       	pop	r17
    1312:	0f 91       	pop	r16
    1314:	ff 90       	pop	r15
    1316:	ef 90       	pop	r14
    1318:	df 90       	pop	r13
    131a:	cf 90       	pop	r12
    131c:	bf 90       	pop	r11
    131e:	af 90       	pop	r10
    1320:	08 95       	ret

00001322 <uxQueueMessagesWaiting>:
    1322:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1326:	ff 93       	push	r31
    1328:	f8 7f       	andi	r31, 0xF8	; 248
    132a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    132e:	fc 01       	movw	r30, r24
    1330:	86 8d       	ldd	r24, Z+30	; 0x1e
    1332:	ff 91       	pop	r31
    1334:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1338:	08 95       	ret

0000133a <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1340:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1344:	ff 93       	push	r31
    1346:	f8 7f       	andi	r31, 0xF8	; 248
    1348:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    134c:	89 a1       	ldd	r24, Y+33	; 0x21
    134e:	8f 3f       	cpi	r24, 0xFF	; 255
    1350:	09 f4       	brne	.+2      	; 0x1354 <vQueueWaitForMessageRestricted+0x1a>
    1352:	19 a2       	std	Y+33, r1	; 0x21
    1354:	8a a1       	ldd	r24, Y+34	; 0x22
    1356:	8f 3f       	cpi	r24, 0xFF	; 255
    1358:	09 f4       	brne	.+2      	; 0x135c <vQueueWaitForMessageRestricted+0x22>
    135a:	1a a2       	std	Y+34, r1	; 0x22
    135c:	ff 91       	pop	r31
    135e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1362:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1364:	81 11       	cpse	r24, r1
    1366:	04 c0       	rjmp	.+8      	; 0x1370 <vQueueWaitForMessageRestricted+0x36>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1368:	ce 01       	movw	r24, r28
    136a:	43 96       	adiw	r24, 0x13	; 19
    136c:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1370:	ce 01       	movw	r24, r28
    1372:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
	}
    1376:	df 91       	pop	r29
    1378:	cf 91       	pop	r28
    137a:	08 95       	ret

0000137c <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
    137c:	e0 91 68 2c 	lds	r30, 0x2C68	; 0x802c68 <pxDelayedTaskList>
    1380:	f0 91 69 2c 	lds	r31, 0x2C69	; 0x802c69 <pxDelayedTaskList+0x1>
    1384:	80 81       	ld	r24, Z
    1386:	81 11       	cpse	r24, r1
    1388:	0c c0       	rjmp	.+24     	; 0x13a2 <prvResetNextTaskUnblockTime+0x26>
    138a:	8f ef       	ldi	r24, 0xFF	; 255
    138c:	9f ef       	ldi	r25, 0xFF	; 255
    138e:	dc 01       	movw	r26, r24
    1390:	80 93 41 2c 	sts	0x2C41, r24	; 0x802c41 <xNextTaskUnblockTime>
    1394:	90 93 42 2c 	sts	0x2C42, r25	; 0x802c42 <xNextTaskUnblockTime+0x1>
    1398:	a0 93 43 2c 	sts	0x2C43, r26	; 0x802c43 <xNextTaskUnblockTime+0x2>
    139c:	b0 93 44 2c 	sts	0x2C44, r27	; 0x802c44 <xNextTaskUnblockTime+0x3>
    13a0:	08 95       	ret
    13a2:	e0 91 68 2c 	lds	r30, 0x2C68	; 0x802c68 <pxDelayedTaskList>
    13a6:	f0 91 69 2c 	lds	r31, 0x2C69	; 0x802c69 <pxDelayedTaskList+0x1>
    13aa:	07 80       	ldd	r0, Z+7	; 0x07
    13ac:	f0 85       	ldd	r31, Z+8	; 0x08
    13ae:	e0 2d       	mov	r30, r0
    13b0:	00 84       	ldd	r0, Z+8	; 0x08
    13b2:	f1 85       	ldd	r31, Z+9	; 0x09
    13b4:	e0 2d       	mov	r30, r0
    13b6:	82 81       	ldd	r24, Z+2	; 0x02
    13b8:	93 81       	ldd	r25, Z+3	; 0x03
    13ba:	a4 81       	ldd	r26, Z+4	; 0x04
    13bc:	b5 81       	ldd	r27, Z+5	; 0x05
    13be:	80 93 41 2c 	sts	0x2C41, r24	; 0x802c41 <xNextTaskUnblockTime>
    13c2:	90 93 42 2c 	sts	0x2C42, r25	; 0x802c42 <xNextTaskUnblockTime+0x1>
    13c6:	a0 93 43 2c 	sts	0x2C43, r26	; 0x802c43 <xNextTaskUnblockTime+0x2>
    13ca:	b0 93 44 2c 	sts	0x2C44, r27	; 0x802c44 <xNextTaskUnblockTime+0x3>
    13ce:	08 95       	ret

000013d0 <prvAddCurrentTaskToDelayedList>:
    13d0:	8f 92       	push	r8
    13d2:	9f 92       	push	r9
    13d4:	af 92       	push	r10
    13d6:	bf 92       	push	r11
    13d8:	cf 92       	push	r12
    13da:	df 92       	push	r13
    13dc:	ef 92       	push	r14
    13de:	ff 92       	push	r15
    13e0:	cf 93       	push	r28
    13e2:	6b 01       	movw	r12, r22
    13e4:	7c 01       	movw	r14, r24
    13e6:	c4 2f       	mov	r28, r20
    13e8:	80 90 4b 2c 	lds	r8, 0x2C4B	; 0x802c4b <xTickCount>
    13ec:	90 90 4c 2c 	lds	r9, 0x2C4C	; 0x802c4c <xTickCount+0x1>
    13f0:	a0 90 4d 2c 	lds	r10, 0x2C4D	; 0x802c4d <xTickCount+0x2>
    13f4:	b0 90 4e 2c 	lds	r11, 0x2C4E	; 0x802c4e <xTickCount+0x3>
    13f8:	80 91 ac 2c 	lds	r24, 0x2CAC	; 0x802cac <pxCurrentTCB>
    13fc:	90 91 ad 2c 	lds	r25, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1400:	02 96       	adiw	r24, 0x02	; 2
    1402:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1406:	8f ef       	ldi	r24, 0xFF	; 255
    1408:	c8 16       	cp	r12, r24
    140a:	d8 06       	cpc	r13, r24
    140c:	e8 06       	cpc	r14, r24
    140e:	f8 06       	cpc	r15, r24
    1410:	69 f4       	brne	.+26     	; 0x142c <prvAddCurrentTaskToDelayedList+0x5c>
    1412:	cc 23       	and	r28, r28
    1414:	59 f0       	breq	.+22     	; 0x142c <prvAddCurrentTaskToDelayedList+0x5c>
    1416:	60 91 ac 2c 	lds	r22, 0x2CAC	; 0x802cac <pxCurrentTCB>
    141a:	70 91 ad 2c 	lds	r23, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    141e:	6e 5f       	subi	r22, 0xFE	; 254
    1420:	7f 4f       	sbci	r23, 0xFF	; 255
    1422:	80 e5       	ldi	r24, 0x50	; 80
    1424:	9c e2       	ldi	r25, 0x2C	; 44
    1426:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    142a:	3f c0       	rjmp	.+126    	; 0x14aa <prvAddCurrentTaskToDelayedList+0xda>
    142c:	c8 0c       	add	r12, r8
    142e:	d9 1c       	adc	r13, r9
    1430:	ea 1c       	adc	r14, r10
    1432:	fb 1c       	adc	r15, r11
    1434:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1438:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    143c:	c2 82       	std	Z+2, r12	; 0x02
    143e:	d3 82       	std	Z+3, r13	; 0x03
    1440:	e4 82       	std	Z+4, r14	; 0x04
    1442:	f5 82       	std	Z+5, r15	; 0x05
    1444:	c8 14       	cp	r12, r8
    1446:	d9 04       	cpc	r13, r9
    1448:	ea 04       	cpc	r14, r10
    144a:	fb 04       	cpc	r15, r11
    144c:	68 f4       	brcc	.+26     	; 0x1468 <prvAddCurrentTaskToDelayedList+0x98>
    144e:	60 91 ac 2c 	lds	r22, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1452:	70 91 ad 2c 	lds	r23, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1456:	80 91 66 2c 	lds	r24, 0x2C66	; 0x802c66 <pxOverflowDelayedTaskList>
    145a:	90 91 67 2c 	lds	r25, 0x2C67	; 0x802c67 <pxOverflowDelayedTaskList+0x1>
    145e:	6e 5f       	subi	r22, 0xFE	; 254
    1460:	7f 4f       	sbci	r23, 0xFF	; 255
    1462:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1466:	21 c0       	rjmp	.+66     	; 0x14aa <prvAddCurrentTaskToDelayedList+0xda>
    1468:	60 91 ac 2c 	lds	r22, 0x2CAC	; 0x802cac <pxCurrentTCB>
    146c:	70 91 ad 2c 	lds	r23, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1470:	80 91 68 2c 	lds	r24, 0x2C68	; 0x802c68 <pxDelayedTaskList>
    1474:	90 91 69 2c 	lds	r25, 0x2C69	; 0x802c69 <pxDelayedTaskList+0x1>
    1478:	6e 5f       	subi	r22, 0xFE	; 254
    147a:	7f 4f       	sbci	r23, 0xFF	; 255
    147c:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1480:	80 91 41 2c 	lds	r24, 0x2C41	; 0x802c41 <xNextTaskUnblockTime>
    1484:	90 91 42 2c 	lds	r25, 0x2C42	; 0x802c42 <xNextTaskUnblockTime+0x1>
    1488:	a0 91 43 2c 	lds	r26, 0x2C43	; 0x802c43 <xNextTaskUnblockTime+0x2>
    148c:	b0 91 44 2c 	lds	r27, 0x2C44	; 0x802c44 <xNextTaskUnblockTime+0x3>
    1490:	c8 16       	cp	r12, r24
    1492:	d9 06       	cpc	r13, r25
    1494:	ea 06       	cpc	r14, r26
    1496:	fb 06       	cpc	r15, r27
    1498:	40 f4       	brcc	.+16     	; 0x14aa <prvAddCurrentTaskToDelayedList+0xda>
    149a:	c0 92 41 2c 	sts	0x2C41, r12	; 0x802c41 <xNextTaskUnblockTime>
    149e:	d0 92 42 2c 	sts	0x2C42, r13	; 0x802c42 <xNextTaskUnblockTime+0x1>
    14a2:	e0 92 43 2c 	sts	0x2C43, r14	; 0x802c43 <xNextTaskUnblockTime+0x2>
    14a6:	f0 92 44 2c 	sts	0x2C44, r15	; 0x802c44 <xNextTaskUnblockTime+0x3>
    14aa:	cf 91       	pop	r28
    14ac:	ff 90       	pop	r15
    14ae:	ef 90       	pop	r14
    14b0:	df 90       	pop	r13
    14b2:	cf 90       	pop	r12
    14b4:	bf 90       	pop	r11
    14b6:	af 90       	pop	r10
    14b8:	9f 90       	pop	r9
    14ba:	8f 90       	pop	r8
    14bc:	08 95       	ret

000014be <prvIdleTask>:
    14be:	c0 e8       	ldi	r28, 0x80	; 128
    14c0:	dc e2       	ldi	r29, 0x2C	; 44
    14c2:	88 81       	ld	r24, Y
    14c4:	82 30       	cpi	r24, 0x02	; 2
    14c6:	10 f0       	brcs	.+4      	; 0x14cc <prvIdleTask+0xe>
    14c8:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    14cc:	0e 94 ca 13 	call	0x2794	; 0x2794 <vApplicationIdleHook>
    14d0:	f8 cf       	rjmp	.-16     	; 0x14c2 <prvIdleTask+0x4>

000014d2 <xTaskCreate>:
    14d2:	4f 92       	push	r4
    14d4:	5f 92       	push	r5
    14d6:	6f 92       	push	r6
    14d8:	7f 92       	push	r7
    14da:	8f 92       	push	r8
    14dc:	9f 92       	push	r9
    14de:	af 92       	push	r10
    14e0:	bf 92       	push	r11
    14e2:	cf 92       	push	r12
    14e4:	df 92       	push	r13
    14e6:	ef 92       	push	r14
    14e8:	ff 92       	push	r15
    14ea:	0f 93       	push	r16
    14ec:	cf 93       	push	r28
    14ee:	df 93       	push	r29
    14f0:	4c 01       	movw	r8, r24
    14f2:	6b 01       	movw	r12, r22
    14f4:	5a 01       	movw	r10, r20
    14f6:	29 01       	movw	r4, r18
    14f8:	ca 01       	movw	r24, r20
    14fa:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
    14fe:	3c 01       	movw	r6, r24
    1500:	89 2b       	or	r24, r25
    1502:	09 f4       	brne	.+2      	; 0x1506 <xTaskCreate+0x34>
    1504:	ea c0       	rjmp	.+468    	; 0x16da <xTaskCreate+0x208>
    1506:	8c e2       	ldi	r24, 0x2C	; 44
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
    150e:	ec 01       	movw	r28, r24
    1510:	89 2b       	or	r24, r25
    1512:	b1 f0       	breq	.+44     	; 0x1540 <xTaskCreate+0x6e>
    1514:	6b 8e       	std	Y+27, r6	; 0x1b
    1516:	7c 8e       	std	Y+28, r7	; 0x1c
    1518:	a5 01       	movw	r20, r10
    151a:	65 ea       	ldi	r22, 0xA5	; 165
    151c:	70 e0       	ldi	r23, 0x00	; 0
    151e:	c3 01       	movw	r24, r6
    1520:	0e 94 b5 1d 	call	0x3b6a	; 0x3b6a <memset>
    1524:	21 e0       	ldi	r18, 0x01	; 1
    1526:	a2 1a       	sub	r10, r18
    1528:	b1 08       	sbc	r11, r1
    152a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    152c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    152e:	a8 0e       	add	r10, r24
    1530:	b9 1e       	adc	r11, r25
    1532:	d6 01       	movw	r26, r12
    1534:	8c 91       	ld	r24, X
    1536:	8d 8f       	std	Y+29, r24	; 0x1d
    1538:	8c 91       	ld	r24, X
    153a:	81 11       	cpse	r24, r1
    153c:	05 c0       	rjmp	.+10     	; 0x1548 <xTaskCreate+0x76>
    153e:	18 c0       	rjmp	.+48     	; 0x1570 <xTaskCreate+0x9e>
    1540:	c3 01       	movw	r24, r6
    1542:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortFree>
    1546:	c9 c0       	rjmp	.+402    	; 0x16da <xTaskCreate+0x208>
    1548:	ae 01       	movw	r20, r28
    154a:	42 5e       	subi	r20, 0xE2	; 226
    154c:	5f 4f       	sbci	r21, 0xFF	; 255
    154e:	f6 01       	movw	r30, r12
    1550:	31 96       	adiw	r30, 0x01	; 1
    1552:	b8 e0       	ldi	r27, 0x08	; 8
    1554:	cb 0e       	add	r12, r27
    1556:	d1 1c       	adc	r13, r1
    1558:	cf 01       	movw	r24, r30
    155a:	21 91       	ld	r18, Z+
    155c:	da 01       	movw	r26, r20
    155e:	2d 93       	st	X+, r18
    1560:	ad 01       	movw	r20, r26
    1562:	dc 01       	movw	r26, r24
    1564:	8c 91       	ld	r24, X
    1566:	88 23       	and	r24, r24
    1568:	19 f0       	breq	.+6      	; 0x1570 <xTaskCreate+0x9e>
    156a:	ec 15       	cp	r30, r12
    156c:	fd 05       	cpc	r31, r13
    156e:	a1 f7       	brne	.-24     	; 0x1558 <xTaskCreate+0x86>
    1570:	1c a2       	std	Y+36, r1	; 0x24
    1572:	04 30       	cpi	r16, 0x04	; 4
    1574:	08 f0       	brcs	.+2      	; 0x1578 <xTaskCreate+0xa6>
    1576:	03 e0       	ldi	r16, 0x03	; 3
    1578:	0a 8f       	std	Y+26, r16	; 0x1a
    157a:	6e 01       	movw	r12, r28
    157c:	b2 e0       	ldi	r27, 0x02	; 2
    157e:	cb 0e       	add	r12, r27
    1580:	d1 1c       	adc	r13, r1
    1582:	c6 01       	movw	r24, r12
    1584:	0e 94 7d 04 	call	0x8fa	; 0x8fa <vListInitialiseItem>
    1588:	ce 01       	movw	r24, r28
    158a:	0e 96       	adiw	r24, 0x0e	; 14
    158c:	0e 94 7d 04 	call	0x8fa	; 0x8fa <vListInitialiseItem>
    1590:	ca 87       	std	Y+10, r28	; 0x0a
    1592:	db 87       	std	Y+11, r29	; 0x0b
    1594:	84 e0       	ldi	r24, 0x04	; 4
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	a0 e0       	ldi	r26, 0x00	; 0
    159a:	b0 e0       	ldi	r27, 0x00	; 0
    159c:	80 1b       	sub	r24, r16
    159e:	91 09       	sbc	r25, r1
    15a0:	a1 09       	sbc	r26, r1
    15a2:	b1 09       	sbc	r27, r1
    15a4:	8e 87       	std	Y+14, r24	; 0x0e
    15a6:	9f 87       	std	Y+15, r25	; 0x0f
    15a8:	a8 8b       	std	Y+16, r26	; 0x10
    15aa:	b9 8b       	std	Y+17, r27	; 0x11
    15ac:	ce 8b       	std	Y+22, r28	; 0x16
    15ae:	df 8b       	std	Y+23, r29	; 0x17
    15b0:	1f a2       	std	Y+39, r1	; 0x27
    15b2:	18 a6       	std	Y+40, r1	; 0x28
    15b4:	19 a6       	std	Y+41, r1	; 0x29
    15b6:	1a a6       	std	Y+42, r1	; 0x2a
    15b8:	1b a6       	std	Y+43, r1	; 0x2b
    15ba:	a2 01       	movw	r20, r4
    15bc:	b4 01       	movw	r22, r8
    15be:	c5 01       	movw	r24, r10
    15c0:	0e 94 0d 05 	call	0xa1a	; 0xa1a <pxPortInitialiseStack>
    15c4:	88 83       	st	Y, r24
    15c6:	99 83       	std	Y+1, r25	; 0x01
    15c8:	e1 14       	cp	r14, r1
    15ca:	f1 04       	cpc	r15, r1
    15cc:	19 f0       	breq	.+6      	; 0x15d4 <xTaskCreate+0x102>
    15ce:	f7 01       	movw	r30, r14
    15d0:	c0 83       	st	Z, r28
    15d2:	d1 83       	std	Z+1, r29	; 0x01
    15d4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15d8:	ff 93       	push	r31
    15da:	f8 7f       	andi	r31, 0xF8	; 248
    15dc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15e0:	80 91 4f 2c 	lds	r24, 0x2C4F	; 0x802c4f <uxCurrentNumberOfTasks>
    15e4:	8f 5f       	subi	r24, 0xFF	; 255
    15e6:	80 93 4f 2c 	sts	0x2C4F, r24	; 0x802c4f <uxCurrentNumberOfTasks>
    15ea:	80 91 ac 2c 	lds	r24, 0x2CAC	; 0x802cac <pxCurrentTCB>
    15ee:	90 91 ad 2c 	lds	r25, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    15f2:	89 2b       	or	r24, r25
    15f4:	a9 f5       	brne	.+106    	; 0x1660 <xTaskCreate+0x18e>
    15f6:	c0 93 ac 2c 	sts	0x2CAC, r28	; 0x802cac <pxCurrentTCB>
    15fa:	d0 93 ad 2c 	sts	0x2CAD, r29	; 0x802cad <pxCurrentTCB+0x1>
    15fe:	80 91 4f 2c 	lds	r24, 0x2C4F	; 0x802c4f <uxCurrentNumberOfTasks>
    1602:	81 30       	cpi	r24, 0x01	; 1
    1604:	e9 f5       	brne	.+122    	; 0x1680 <xTaskCreate+0x1ae>
    1606:	80 e8       	ldi	r24, 0x80	; 128
    1608:	9c e2       	ldi	r25, 0x2C	; 44
    160a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    160e:	8b e8       	ldi	r24, 0x8B	; 139
    1610:	9c e2       	ldi	r25, 0x2C	; 44
    1612:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1616:	86 e9       	ldi	r24, 0x96	; 150
    1618:	9c e2       	ldi	r25, 0x2C	; 44
    161a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    161e:	81 ea       	ldi	r24, 0xA1	; 161
    1620:	9c e2       	ldi	r25, 0x2C	; 44
    1622:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1626:	85 e7       	ldi	r24, 0x75	; 117
    1628:	9c e2       	ldi	r25, 0x2C	; 44
    162a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    162e:	8a e6       	ldi	r24, 0x6A	; 106
    1630:	9c e2       	ldi	r25, 0x2C	; 44
    1632:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1636:	8b e5       	ldi	r24, 0x5B	; 91
    1638:	9c e2       	ldi	r25, 0x2C	; 44
    163a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    163e:	80 e5       	ldi	r24, 0x50	; 80
    1640:	9c e2       	ldi	r25, 0x2C	; 44
    1642:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1646:	85 e7       	ldi	r24, 0x75	; 117
    1648:	9c e2       	ldi	r25, 0x2C	; 44
    164a:	80 93 68 2c 	sts	0x2C68, r24	; 0x802c68 <pxDelayedTaskList>
    164e:	90 93 69 2c 	sts	0x2C69, r25	; 0x802c69 <pxDelayedTaskList+0x1>
    1652:	8a e6       	ldi	r24, 0x6A	; 106
    1654:	9c e2       	ldi	r25, 0x2C	; 44
    1656:	80 93 66 2c 	sts	0x2C66, r24	; 0x802c66 <pxOverflowDelayedTaskList>
    165a:	90 93 67 2c 	sts	0x2C67, r25	; 0x802c67 <pxOverflowDelayedTaskList+0x1>
    165e:	10 c0       	rjmp	.+32     	; 0x1680 <xTaskCreate+0x1ae>
    1660:	80 91 49 2c 	lds	r24, 0x2C49	; 0x802c49 <xSchedulerRunning>
    1664:	81 11       	cpse	r24, r1
    1666:	0c c0       	rjmp	.+24     	; 0x1680 <xTaskCreate+0x1ae>
    1668:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    166c:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1670:	92 8d       	ldd	r25, Z+26	; 0x1a
    1672:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1674:	89 17       	cp	r24, r25
    1676:	20 f0       	brcs	.+8      	; 0x1680 <xTaskCreate+0x1ae>
    1678:	c0 93 ac 2c 	sts	0x2CAC, r28	; 0x802cac <pxCurrentTCB>
    167c:	d0 93 ad 2c 	sts	0x2CAD, r29	; 0x802cad <pxCurrentTCB+0x1>
    1680:	80 91 45 2c 	lds	r24, 0x2C45	; 0x802c45 <uxTaskNumber>
    1684:	8f 5f       	subi	r24, 0xFF	; 255
    1686:	80 93 45 2c 	sts	0x2C45, r24	; 0x802c45 <uxTaskNumber>
    168a:	8d a3       	std	Y+37, r24	; 0x25
    168c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    168e:	90 91 4a 2c 	lds	r25, 0x2C4A	; 0x802c4a <uxTopReadyPriority>
    1692:	98 17       	cp	r25, r24
    1694:	10 f4       	brcc	.+4      	; 0x169a <xTaskCreate+0x1c8>
    1696:	80 93 4a 2c 	sts	0x2C4A, r24	; 0x802c4a <uxTopReadyPriority>
    169a:	fb e0       	ldi	r31, 0x0B	; 11
    169c:	8f 9f       	mul	r24, r31
    169e:	c0 01       	movw	r24, r0
    16a0:	11 24       	eor	r1, r1
    16a2:	b6 01       	movw	r22, r12
    16a4:	80 58       	subi	r24, 0x80	; 128
    16a6:	93 4d       	sbci	r25, 0xD3	; 211
    16a8:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    16ac:	ff 91       	pop	r31
    16ae:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    16b2:	80 91 49 2c 	lds	r24, 0x2C49	; 0x802c49 <xSchedulerRunning>
    16b6:	88 23       	and	r24, r24
    16b8:	61 f0       	breq	.+24     	; 0x16d2 <xTaskCreate+0x200>
    16ba:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    16be:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    16c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    16c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16c6:	98 17       	cp	r25, r24
    16c8:	30 f4       	brcc	.+12     	; 0x16d6 <xTaskCreate+0x204>
    16ca:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    16ce:	81 e0       	ldi	r24, 0x01	; 1
    16d0:	05 c0       	rjmp	.+10     	; 0x16dc <xTaskCreate+0x20a>
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	03 c0       	rjmp	.+6      	; 0x16dc <xTaskCreate+0x20a>
    16d6:	81 e0       	ldi	r24, 0x01	; 1
    16d8:	01 c0       	rjmp	.+2      	; 0x16dc <xTaskCreate+0x20a>
    16da:	8f ef       	ldi	r24, 0xFF	; 255
    16dc:	df 91       	pop	r29
    16de:	cf 91       	pop	r28
    16e0:	0f 91       	pop	r16
    16e2:	ff 90       	pop	r15
    16e4:	ef 90       	pop	r14
    16e6:	df 90       	pop	r13
    16e8:	cf 90       	pop	r12
    16ea:	bf 90       	pop	r11
    16ec:	af 90       	pop	r10
    16ee:	9f 90       	pop	r9
    16f0:	8f 90       	pop	r8
    16f2:	7f 90       	pop	r7
    16f4:	6f 90       	pop	r6
    16f6:	5f 90       	pop	r5
    16f8:	4f 90       	pop	r4
    16fa:	08 95       	ret

000016fc <vTaskStartScheduler>:
    16fc:	ef 92       	push	r14
    16fe:	ff 92       	push	r15
    1700:	0f 93       	push	r16
    1702:	0f 2e       	mov	r0, r31
    1704:	ff e3       	ldi	r31, 0x3F	; 63
    1706:	ef 2e       	mov	r14, r31
    1708:	fc e2       	ldi	r31, 0x2C	; 44
    170a:	ff 2e       	mov	r15, r31
    170c:	f0 2d       	mov	r31, r0
    170e:	00 e0       	ldi	r16, 0x00	; 0
    1710:	20 e0       	ldi	r18, 0x00	; 0
    1712:	30 e0       	ldi	r19, 0x00	; 0
    1714:	48 ec       	ldi	r20, 0xC8	; 200
    1716:	50 e0       	ldi	r21, 0x00	; 0
    1718:	64 e0       	ldi	r22, 0x04	; 4
    171a:	70 e2       	ldi	r23, 0x20	; 32
    171c:	8f e5       	ldi	r24, 0x5F	; 95
    171e:	9a e0       	ldi	r25, 0x0A	; 10
    1720:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
    1724:	81 30       	cpi	r24, 0x01	; 1
    1726:	09 f5       	brne	.+66     	; 0x176a <vTaskStartScheduler+0x6e>
    1728:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <xTimerCreateTimerTask>
    172c:	81 30       	cpi	r24, 0x01	; 1
    172e:	e9 f4       	brne	.+58     	; 0x176a <vTaskStartScheduler+0x6e>
    1730:	e0 ea       	ldi	r30, 0xA0	; 160
    1732:	f0 e0       	ldi	r31, 0x00	; 0
    1734:	82 81       	ldd	r24, Z+2	; 0x02
    1736:	88 7f       	andi	r24, 0xF8	; 248
    1738:	82 83       	std	Z+2, r24	; 0x02
    173a:	8f ef       	ldi	r24, 0xFF	; 255
    173c:	9f ef       	ldi	r25, 0xFF	; 255
    173e:	dc 01       	movw	r26, r24
    1740:	80 93 41 2c 	sts	0x2C41, r24	; 0x802c41 <xNextTaskUnblockTime>
    1744:	90 93 42 2c 	sts	0x2C42, r25	; 0x802c42 <xNextTaskUnblockTime+0x1>
    1748:	a0 93 43 2c 	sts	0x2C43, r26	; 0x802c43 <xNextTaskUnblockTime+0x2>
    174c:	b0 93 44 2c 	sts	0x2C44, r27	; 0x802c44 <xNextTaskUnblockTime+0x3>
    1750:	81 e0       	ldi	r24, 0x01	; 1
    1752:	80 93 49 2c 	sts	0x2C49, r24	; 0x802c49 <xSchedulerRunning>
    1756:	10 92 4b 2c 	sts	0x2C4B, r1	; 0x802c4b <xTickCount>
    175a:	10 92 4c 2c 	sts	0x2C4C, r1	; 0x802c4c <xTickCount+0x1>
    175e:	10 92 4d 2c 	sts	0x2C4D, r1	; 0x802c4d <xTickCount+0x2>
    1762:	10 92 4e 2c 	sts	0x2C4E, r1	; 0x802c4e <xTickCount+0x3>
    1766:	0e 94 8a 05 	call	0xb14	; 0xb14 <xPortStartScheduler>
    176a:	0f 91       	pop	r16
    176c:	ff 90       	pop	r15
    176e:	ef 90       	pop	r14
    1770:	08 95       	ret

00001772 <vTaskSuspendAll>:
    1772:	80 91 3e 2c 	lds	r24, 0x2C3E	; 0x802c3e <uxSchedulerSuspended>
    1776:	8f 5f       	subi	r24, 0xFF	; 255
    1778:	80 93 3e 2c 	sts	0x2C3E, r24	; 0x802c3e <uxSchedulerSuspended>
    177c:	08 95       	ret

0000177e <xTaskGetTickCount>:
    177e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1782:	ff 93       	push	r31
    1784:	f8 7f       	andi	r31, 0xF8	; 248
    1786:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    178a:	60 91 4b 2c 	lds	r22, 0x2C4B	; 0x802c4b <xTickCount>
    178e:	70 91 4c 2c 	lds	r23, 0x2C4C	; 0x802c4c <xTickCount+0x1>
    1792:	80 91 4d 2c 	lds	r24, 0x2C4D	; 0x802c4d <xTickCount+0x2>
    1796:	90 91 4e 2c 	lds	r25, 0x2C4E	; 0x802c4e <xTickCount+0x3>
    179a:	ff 91       	pop	r31
    179c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    17a0:	08 95       	ret

000017a2 <xTaskIncrementTick>:
    17a2:	af 92       	push	r10
    17a4:	bf 92       	push	r11
    17a6:	cf 92       	push	r12
    17a8:	df 92       	push	r13
    17aa:	ef 92       	push	r14
    17ac:	ff 92       	push	r15
    17ae:	0f 93       	push	r16
    17b0:	1f 93       	push	r17
    17b2:	cf 93       	push	r28
    17b4:	df 93       	push	r29
    17b6:	80 91 3e 2c 	lds	r24, 0x2C3E	; 0x802c3e <uxSchedulerSuspended>
    17ba:	81 11       	cpse	r24, r1
    17bc:	ad c0       	rjmp	.+346    	; 0x1918 <xTaskIncrementTick+0x176>
    17be:	c0 90 4b 2c 	lds	r12, 0x2C4B	; 0x802c4b <xTickCount>
    17c2:	d0 90 4c 2c 	lds	r13, 0x2C4C	; 0x802c4c <xTickCount+0x1>
    17c6:	e0 90 4d 2c 	lds	r14, 0x2C4D	; 0x802c4d <xTickCount+0x2>
    17ca:	f0 90 4e 2c 	lds	r15, 0x2C4E	; 0x802c4e <xTickCount+0x3>
    17ce:	8f ef       	ldi	r24, 0xFF	; 255
    17d0:	c8 1a       	sub	r12, r24
    17d2:	d8 0a       	sbc	r13, r24
    17d4:	e8 0a       	sbc	r14, r24
    17d6:	f8 0a       	sbc	r15, r24
    17d8:	c0 92 4b 2c 	sts	0x2C4B, r12	; 0x802c4b <xTickCount>
    17dc:	d0 92 4c 2c 	sts	0x2C4C, r13	; 0x802c4c <xTickCount+0x1>
    17e0:	e0 92 4d 2c 	sts	0x2C4D, r14	; 0x802c4d <xTickCount+0x2>
    17e4:	f0 92 4e 2c 	sts	0x2C4E, r15	; 0x802c4e <xTickCount+0x3>
    17e8:	c1 14       	cp	r12, r1
    17ea:	d1 04       	cpc	r13, r1
    17ec:	e1 04       	cpc	r14, r1
    17ee:	f1 04       	cpc	r15, r1
    17f0:	b9 f4       	brne	.+46     	; 0x1820 <xTaskIncrementTick+0x7e>
    17f2:	80 91 68 2c 	lds	r24, 0x2C68	; 0x802c68 <pxDelayedTaskList>
    17f6:	90 91 69 2c 	lds	r25, 0x2C69	; 0x802c69 <pxDelayedTaskList+0x1>
    17fa:	20 91 66 2c 	lds	r18, 0x2C66	; 0x802c66 <pxOverflowDelayedTaskList>
    17fe:	30 91 67 2c 	lds	r19, 0x2C67	; 0x802c67 <pxOverflowDelayedTaskList+0x1>
    1802:	20 93 68 2c 	sts	0x2C68, r18	; 0x802c68 <pxDelayedTaskList>
    1806:	30 93 69 2c 	sts	0x2C69, r19	; 0x802c69 <pxDelayedTaskList+0x1>
    180a:	80 93 66 2c 	sts	0x2C66, r24	; 0x802c66 <pxOverflowDelayedTaskList>
    180e:	90 93 67 2c 	sts	0x2C67, r25	; 0x802c67 <pxOverflowDelayedTaskList+0x1>
    1812:	80 91 46 2c 	lds	r24, 0x2C46	; 0x802c46 <xNumOfOverflows>
    1816:	8f 5f       	subi	r24, 0xFF	; 255
    1818:	80 93 46 2c 	sts	0x2C46, r24	; 0x802c46 <xNumOfOverflows>
    181c:	0e 94 be 09 	call	0x137c	; 0x137c <prvResetNextTaskUnblockTime>
    1820:	80 91 41 2c 	lds	r24, 0x2C41	; 0x802c41 <xNextTaskUnblockTime>
    1824:	90 91 42 2c 	lds	r25, 0x2C42	; 0x802c42 <xNextTaskUnblockTime+0x1>
    1828:	a0 91 43 2c 	lds	r26, 0x2C43	; 0x802c43 <xNextTaskUnblockTime+0x2>
    182c:	b0 91 44 2c 	lds	r27, 0x2C44	; 0x802c44 <xNextTaskUnblockTime+0x3>
    1830:	c8 16       	cp	r12, r24
    1832:	d9 06       	cpc	r13, r25
    1834:	ea 06       	cpc	r14, r26
    1836:	fb 06       	cpc	r15, r27
    1838:	10 f4       	brcc	.+4      	; 0x183e <xTaskIncrementTick+0x9c>
    183a:	b1 2c       	mov	r11, r1
    183c:	5c c0       	rjmp	.+184    	; 0x18f6 <xTaskIncrementTick+0x154>
    183e:	b1 2c       	mov	r11, r1
    1840:	0f 2e       	mov	r0, r31
    1842:	fb e0       	ldi	r31, 0x0B	; 11
    1844:	af 2e       	mov	r10, r31
    1846:	f0 2d       	mov	r31, r0
    1848:	e0 91 68 2c 	lds	r30, 0x2C68	; 0x802c68 <pxDelayedTaskList>
    184c:	f0 91 69 2c 	lds	r31, 0x2C69	; 0x802c69 <pxDelayedTaskList+0x1>
    1850:	80 81       	ld	r24, Z
    1852:	81 11       	cpse	r24, r1
    1854:	0c c0       	rjmp	.+24     	; 0x186e <xTaskIncrementTick+0xcc>
    1856:	8f ef       	ldi	r24, 0xFF	; 255
    1858:	9f ef       	ldi	r25, 0xFF	; 255
    185a:	dc 01       	movw	r26, r24
    185c:	80 93 41 2c 	sts	0x2C41, r24	; 0x802c41 <xNextTaskUnblockTime>
    1860:	90 93 42 2c 	sts	0x2C42, r25	; 0x802c42 <xNextTaskUnblockTime+0x1>
    1864:	a0 93 43 2c 	sts	0x2C43, r26	; 0x802c43 <xNextTaskUnblockTime+0x2>
    1868:	b0 93 44 2c 	sts	0x2C44, r27	; 0x802c44 <xNextTaskUnblockTime+0x3>
    186c:	44 c0       	rjmp	.+136    	; 0x18f6 <xTaskIncrementTick+0x154>
    186e:	e0 91 68 2c 	lds	r30, 0x2C68	; 0x802c68 <pxDelayedTaskList>
    1872:	f0 91 69 2c 	lds	r31, 0x2C69	; 0x802c69 <pxDelayedTaskList+0x1>
    1876:	07 80       	ldd	r0, Z+7	; 0x07
    1878:	f0 85       	ldd	r31, Z+8	; 0x08
    187a:	e0 2d       	mov	r30, r0
    187c:	c0 85       	ldd	r28, Z+8	; 0x08
    187e:	d1 85       	ldd	r29, Z+9	; 0x09
    1880:	8a 81       	ldd	r24, Y+2	; 0x02
    1882:	9b 81       	ldd	r25, Y+3	; 0x03
    1884:	ac 81       	ldd	r26, Y+4	; 0x04
    1886:	bd 81       	ldd	r27, Y+5	; 0x05
    1888:	c8 16       	cp	r12, r24
    188a:	d9 06       	cpc	r13, r25
    188c:	ea 06       	cpc	r14, r26
    188e:	fb 06       	cpc	r15, r27
    1890:	48 f4       	brcc	.+18     	; 0x18a4 <xTaskIncrementTick+0x102>
    1892:	80 93 41 2c 	sts	0x2C41, r24	; 0x802c41 <xNextTaskUnblockTime>
    1896:	90 93 42 2c 	sts	0x2C42, r25	; 0x802c42 <xNextTaskUnblockTime+0x1>
    189a:	a0 93 43 2c 	sts	0x2C43, r26	; 0x802c43 <xNextTaskUnblockTime+0x2>
    189e:	b0 93 44 2c 	sts	0x2C44, r27	; 0x802c44 <xNextTaskUnblockTime+0x3>
    18a2:	29 c0       	rjmp	.+82     	; 0x18f6 <xTaskIncrementTick+0x154>
    18a4:	8e 01       	movw	r16, r28
    18a6:	0e 5f       	subi	r16, 0xFE	; 254
    18a8:	1f 4f       	sbci	r17, 0xFF	; 255
    18aa:	c8 01       	movw	r24, r16
    18ac:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    18b0:	88 8d       	ldd	r24, Y+24	; 0x18
    18b2:	99 8d       	ldd	r25, Y+25	; 0x19
    18b4:	89 2b       	or	r24, r25
    18b6:	21 f0       	breq	.+8      	; 0x18c0 <xTaskIncrementTick+0x11e>
    18b8:	ce 01       	movw	r24, r28
    18ba:	0e 96       	adiw	r24, 0x0e	; 14
    18bc:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    18c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    18c2:	90 91 4a 2c 	lds	r25, 0x2C4A	; 0x802c4a <uxTopReadyPriority>
    18c6:	98 17       	cp	r25, r24
    18c8:	10 f4       	brcc	.+4      	; 0x18ce <xTaskIncrementTick+0x12c>
    18ca:	80 93 4a 2c 	sts	0x2C4A, r24	; 0x802c4a <uxTopReadyPriority>
    18ce:	a8 9e       	mul	r10, r24
    18d0:	c0 01       	movw	r24, r0
    18d2:	11 24       	eor	r1, r1
    18d4:	b8 01       	movw	r22, r16
    18d6:	80 58       	subi	r24, 0x80	; 128
    18d8:	93 4d       	sbci	r25, 0xD3	; 211
    18da:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    18de:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    18e2:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    18e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    18ea:	98 17       	cp	r25, r24
    18ec:	08 f4       	brcc	.+2      	; 0x18f0 <xTaskIncrementTick+0x14e>
    18ee:	ac cf       	rjmp	.-168    	; 0x1848 <xTaskIncrementTick+0xa6>
    18f0:	bb 24       	eor	r11, r11
    18f2:	b3 94       	inc	r11
    18f4:	a9 cf       	rjmp	.-174    	; 0x1848 <xTaskIncrementTick+0xa6>
    18f6:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    18fa:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    18fe:	e2 8d       	ldd	r30, Z+26	; 0x1a
    1900:	8b e0       	ldi	r24, 0x0B	; 11
    1902:	e8 9f       	mul	r30, r24
    1904:	f0 01       	movw	r30, r0
    1906:	11 24       	eor	r1, r1
    1908:	e0 58       	subi	r30, 0x80	; 128
    190a:	f3 4d       	sbci	r31, 0xD3	; 211
    190c:	80 81       	ld	r24, Z
    190e:	82 30       	cpi	r24, 0x02	; 2
    1910:	48 f0       	brcs	.+18     	; 0x1924 <xTaskIncrementTick+0x182>
    1912:	bb 24       	eor	r11, r11
    1914:	b3 94       	inc	r11
    1916:	06 c0       	rjmp	.+12     	; 0x1924 <xTaskIncrementTick+0x182>
    1918:	80 91 48 2c 	lds	r24, 0x2C48	; 0x802c48 <uxPendedTicks>
    191c:	8f 5f       	subi	r24, 0xFF	; 255
    191e:	80 93 48 2c 	sts	0x2C48, r24	; 0x802c48 <uxPendedTicks>
    1922:	b1 2c       	mov	r11, r1
    1924:	80 91 47 2c 	lds	r24, 0x2C47	; 0x802c47 <xYieldPending>
    1928:	88 23       	and	r24, r24
    192a:	11 f0       	breq	.+4      	; 0x1930 <xTaskIncrementTick+0x18e>
    192c:	bb 24       	eor	r11, r11
    192e:	b3 94       	inc	r11
    1930:	8b 2d       	mov	r24, r11
    1932:	df 91       	pop	r29
    1934:	cf 91       	pop	r28
    1936:	1f 91       	pop	r17
    1938:	0f 91       	pop	r16
    193a:	ff 90       	pop	r15
    193c:	ef 90       	pop	r14
    193e:	df 90       	pop	r13
    1940:	cf 90       	pop	r12
    1942:	bf 90       	pop	r11
    1944:	af 90       	pop	r10
    1946:	08 95       	ret

00001948 <xTaskResumeAll>:
    1948:	cf 92       	push	r12
    194a:	df 92       	push	r13
    194c:	ef 92       	push	r14
    194e:	ff 92       	push	r15
    1950:	0f 93       	push	r16
    1952:	1f 93       	push	r17
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    195c:	ff 93       	push	r31
    195e:	f8 7f       	andi	r31, 0xF8	; 248
    1960:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1964:	80 91 3e 2c 	lds	r24, 0x2C3E	; 0x802c3e <uxSchedulerSuspended>
    1968:	81 50       	subi	r24, 0x01	; 1
    196a:	80 93 3e 2c 	sts	0x2C3E, r24	; 0x802c3e <uxSchedulerSuspended>
    196e:	80 91 3e 2c 	lds	r24, 0x2C3E	; 0x802c3e <uxSchedulerSuspended>
    1972:	81 11       	cpse	r24, r1
    1974:	5c c0       	rjmp	.+184    	; 0x1a2e <xTaskResumeAll+0xe6>
    1976:	80 91 4f 2c 	lds	r24, 0x2C4F	; 0x802c4f <uxCurrentNumberOfTasks>
    197a:	81 11       	cpse	r24, r1
    197c:	2c c0       	rjmp	.+88     	; 0x19d6 <xTaskResumeAll+0x8e>
    197e:	5a c0       	rjmp	.+180    	; 0x1a34 <xTaskResumeAll+0xec>
    1980:	d7 01       	movw	r26, r14
    1982:	17 96       	adiw	r26, 0x07	; 7
    1984:	ed 91       	ld	r30, X+
    1986:	fc 91       	ld	r31, X
    1988:	18 97       	sbiw	r26, 0x08	; 8
    198a:	c0 85       	ldd	r28, Z+8	; 0x08
    198c:	d1 85       	ldd	r29, Z+9	; 0x09
    198e:	ce 01       	movw	r24, r28
    1990:	0e 96       	adiw	r24, 0x0e	; 14
    1992:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1996:	8e 01       	movw	r16, r28
    1998:	0e 5f       	subi	r16, 0xFE	; 254
    199a:	1f 4f       	sbci	r17, 0xFF	; 255
    199c:	c8 01       	movw	r24, r16
    199e:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    19a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19a4:	90 91 4a 2c 	lds	r25, 0x2C4A	; 0x802c4a <uxTopReadyPriority>
    19a8:	98 17       	cp	r25, r24
    19aa:	10 f4       	brcc	.+4      	; 0x19b0 <xTaskResumeAll+0x68>
    19ac:	80 93 4a 2c 	sts	0x2C4A, r24	; 0x802c4a <uxTopReadyPriority>
    19b0:	d8 9e       	mul	r13, r24
    19b2:	c0 01       	movw	r24, r0
    19b4:	11 24       	eor	r1, r1
    19b6:	b8 01       	movw	r22, r16
    19b8:	80 58       	subi	r24, 0x80	; 128
    19ba:	93 4d       	sbci	r25, 0xD3	; 211
    19bc:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    19c0:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    19c4:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    19c8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    19cc:	98 17       	cp	r25, r24
    19ce:	88 f0       	brcs	.+34     	; 0x19f2 <xTaskResumeAll+0xaa>
    19d0:	c0 92 47 2c 	sts	0x2C47, r12	; 0x802c47 <xYieldPending>
    19d4:	0e c0       	rjmp	.+28     	; 0x19f2 <xTaskResumeAll+0xaa>
    19d6:	c0 e0       	ldi	r28, 0x00	; 0
    19d8:	d0 e0       	ldi	r29, 0x00	; 0
    19da:	0f 2e       	mov	r0, r31
    19dc:	fb e5       	ldi	r31, 0x5B	; 91
    19de:	ef 2e       	mov	r14, r31
    19e0:	fc e2       	ldi	r31, 0x2C	; 44
    19e2:	ff 2e       	mov	r15, r31
    19e4:	f0 2d       	mov	r31, r0
    19e6:	0f 2e       	mov	r0, r31
    19e8:	fb e0       	ldi	r31, 0x0B	; 11
    19ea:	df 2e       	mov	r13, r31
    19ec:	f0 2d       	mov	r31, r0
    19ee:	cc 24       	eor	r12, r12
    19f0:	c3 94       	inc	r12
    19f2:	f7 01       	movw	r30, r14
    19f4:	80 81       	ld	r24, Z
    19f6:	81 11       	cpse	r24, r1
    19f8:	c3 cf       	rjmp	.-122    	; 0x1980 <xTaskResumeAll+0x38>
    19fa:	cd 2b       	or	r28, r29
    19fc:	11 f0       	breq	.+4      	; 0x1a02 <xTaskResumeAll+0xba>
    19fe:	0e 94 be 09 	call	0x137c	; 0x137c <prvResetNextTaskUnblockTime>
    1a02:	c0 91 48 2c 	lds	r28, 0x2C48	; 0x802c48 <uxPendedTicks>
    1a06:	cc 23       	and	r28, r28
    1a08:	51 f0       	breq	.+20     	; 0x1a1e <xTaskResumeAll+0xd6>
    1a0a:	d1 e0       	ldi	r29, 0x01	; 1
    1a0c:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <xTaskIncrementTick>
    1a10:	81 11       	cpse	r24, r1
    1a12:	d0 93 47 2c 	sts	0x2C47, r29	; 0x802c47 <xYieldPending>
    1a16:	c1 50       	subi	r28, 0x01	; 1
    1a18:	c9 f7       	brne	.-14     	; 0x1a0c <xTaskResumeAll+0xc4>
    1a1a:	10 92 48 2c 	sts	0x2C48, r1	; 0x802c48 <uxPendedTicks>
    1a1e:	80 91 47 2c 	lds	r24, 0x2C47	; 0x802c47 <xYieldPending>
    1a22:	88 23       	and	r24, r24
    1a24:	31 f0       	breq	.+12     	; 0x1a32 <xTaskResumeAll+0xea>
    1a26:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1a2a:	81 e0       	ldi	r24, 0x01	; 1
    1a2c:	03 c0       	rjmp	.+6      	; 0x1a34 <xTaskResumeAll+0xec>
    1a2e:	80 e0       	ldi	r24, 0x00	; 0
    1a30:	01 c0       	rjmp	.+2      	; 0x1a34 <xTaskResumeAll+0xec>
    1a32:	80 e0       	ldi	r24, 0x00	; 0
    1a34:	ff 91       	pop	r31
    1a36:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1a3a:	df 91       	pop	r29
    1a3c:	cf 91       	pop	r28
    1a3e:	1f 91       	pop	r17
    1a40:	0f 91       	pop	r16
    1a42:	ff 90       	pop	r15
    1a44:	ef 90       	pop	r14
    1a46:	df 90       	pop	r13
    1a48:	cf 90       	pop	r12
    1a4a:	08 95       	ret

00001a4c <vTaskDelay>:
    1a4c:	cf 92       	push	r12
    1a4e:	df 92       	push	r13
    1a50:	ef 92       	push	r14
    1a52:	ff 92       	push	r15
    1a54:	6b 01       	movw	r12, r22
    1a56:	7c 01       	movw	r14, r24
    1a58:	67 2b       	or	r22, r23
    1a5a:	68 2b       	or	r22, r24
    1a5c:	69 2b       	or	r22, r25
    1a5e:	59 f0       	breq	.+22     	; 0x1a76 <vTaskDelay+0x2a>
    1a60:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    1a64:	40 e0       	ldi	r20, 0x00	; 0
    1a66:	c7 01       	movw	r24, r14
    1a68:	b6 01       	movw	r22, r12
    1a6a:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1a6e:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    1a72:	81 11       	cpse	r24, r1
    1a74:	02 c0       	rjmp	.+4      	; 0x1a7a <vTaskDelay+0x2e>
    1a76:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1a7a:	ff 90       	pop	r15
    1a7c:	ef 90       	pop	r14
    1a7e:	df 90       	pop	r13
    1a80:	cf 90       	pop	r12
    1a82:	08 95       	ret

00001a84 <vTaskSwitchContext>:
    1a84:	80 91 3e 2c 	lds	r24, 0x2C3E	; 0x802c3e <uxSchedulerSuspended>
    1a88:	88 23       	and	r24, r24
    1a8a:	21 f0       	breq	.+8      	; 0x1a94 <vTaskSwitchContext+0x10>
    1a8c:	81 e0       	ldi	r24, 0x01	; 1
    1a8e:	80 93 47 2c 	sts	0x2C47, r24	; 0x802c47 <xYieldPending>
    1a92:	08 95       	ret
    1a94:	10 92 47 2c 	sts	0x2C47, r1	; 0x802c47 <xYieldPending>
    1a98:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1a9c:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1aa0:	03 8c       	ldd	r0, Z+27	; 0x1b
    1aa2:	f4 8d       	ldd	r31, Z+28	; 0x1c
    1aa4:	e0 2d       	mov	r30, r0
    1aa6:	80 81       	ld	r24, Z
    1aa8:	91 81       	ldd	r25, Z+1	; 0x01
    1aaa:	a2 81       	ldd	r26, Z+2	; 0x02
    1aac:	b3 81       	ldd	r27, Z+3	; 0x03
    1aae:	85 3a       	cpi	r24, 0xA5	; 165
    1ab0:	95 4a       	sbci	r25, 0xA5	; 165
    1ab2:	a5 4a       	sbci	r26, 0xA5	; 165
    1ab4:	b5 4a       	sbci	r27, 0xA5	; 165
    1ab6:	d9 f4       	brne	.+54     	; 0x1aee <vTaskSwitchContext+0x6a>
    1ab8:	84 81       	ldd	r24, Z+4	; 0x04
    1aba:	95 81       	ldd	r25, Z+5	; 0x05
    1abc:	a6 81       	ldd	r26, Z+6	; 0x06
    1abe:	b7 81       	ldd	r27, Z+7	; 0x07
    1ac0:	85 3a       	cpi	r24, 0xA5	; 165
    1ac2:	95 4a       	sbci	r25, 0xA5	; 165
    1ac4:	a5 4a       	sbci	r26, 0xA5	; 165
    1ac6:	b5 4a       	sbci	r27, 0xA5	; 165
    1ac8:	91 f4       	brne	.+36     	; 0x1aee <vTaskSwitchContext+0x6a>
    1aca:	80 85       	ldd	r24, Z+8	; 0x08
    1acc:	91 85       	ldd	r25, Z+9	; 0x09
    1ace:	a2 85       	ldd	r26, Z+10	; 0x0a
    1ad0:	b3 85       	ldd	r27, Z+11	; 0x0b
    1ad2:	85 3a       	cpi	r24, 0xA5	; 165
    1ad4:	95 4a       	sbci	r25, 0xA5	; 165
    1ad6:	a5 4a       	sbci	r26, 0xA5	; 165
    1ad8:	b5 4a       	sbci	r27, 0xA5	; 165
    1ada:	49 f4       	brne	.+18     	; 0x1aee <vTaskSwitchContext+0x6a>
    1adc:	84 85       	ldd	r24, Z+12	; 0x0c
    1ade:	95 85       	ldd	r25, Z+13	; 0x0d
    1ae0:	a6 85       	ldd	r26, Z+14	; 0x0e
    1ae2:	b7 85       	ldd	r27, Z+15	; 0x0f
    1ae4:	85 3a       	cpi	r24, 0xA5	; 165
    1ae6:	95 4a       	sbci	r25, 0xA5	; 165
    1ae8:	a5 4a       	sbci	r26, 0xA5	; 165
    1aea:	b5 4a       	sbci	r27, 0xA5	; 165
    1aec:	61 f0       	breq	.+24     	; 0x1b06 <vTaskSwitchContext+0x82>
    1aee:	60 91 ac 2c 	lds	r22, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1af2:	70 91 ad 2c 	lds	r23, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1af6:	80 91 ac 2c 	lds	r24, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1afa:	90 91 ad 2c 	lds	r25, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1afe:	63 5e       	subi	r22, 0xE3	; 227
    1b00:	7f 4f       	sbci	r23, 0xFF	; 255
    1b02:	0e 94 a5 02 	call	0x54a	; 0x54a <vApplicationStackOverflowHook>
    1b06:	80 91 4a 2c 	lds	r24, 0x2C4A	; 0x802c4a <uxTopReadyPriority>
    1b0a:	28 2f       	mov	r18, r24
    1b0c:	30 e0       	ldi	r19, 0x00	; 0
    1b0e:	9b e0       	ldi	r25, 0x0B	; 11
    1b10:	89 9f       	mul	r24, r25
    1b12:	f0 01       	movw	r30, r0
    1b14:	11 24       	eor	r1, r1
    1b16:	e0 58       	subi	r30, 0x80	; 128
    1b18:	f3 4d       	sbci	r31, 0xD3	; 211
    1b1a:	90 81       	ld	r25, Z
    1b1c:	91 11       	cpse	r25, r1
    1b1e:	0e c0       	rjmp	.+28     	; 0x1b3c <vTaskSwitchContext+0xb8>
    1b20:	4b e0       	ldi	r20, 0x0B	; 11
    1b22:	81 50       	subi	r24, 0x01	; 1
    1b24:	28 2f       	mov	r18, r24
    1b26:	30 e0       	ldi	r19, 0x00	; 0
    1b28:	42 9f       	mul	r20, r18
    1b2a:	f0 01       	movw	r30, r0
    1b2c:	43 9f       	mul	r20, r19
    1b2e:	f0 0d       	add	r31, r0
    1b30:	11 24       	eor	r1, r1
    1b32:	e0 58       	subi	r30, 0x80	; 128
    1b34:	f3 4d       	sbci	r31, 0xD3	; 211
    1b36:	90 81       	ld	r25, Z
    1b38:	99 23       	and	r25, r25
    1b3a:	99 f3       	breq	.-26     	; 0x1b22 <vTaskSwitchContext+0x9e>
    1b3c:	9b e0       	ldi	r25, 0x0B	; 11
    1b3e:	92 9f       	mul	r25, r18
    1b40:	a0 01       	movw	r20, r0
    1b42:	93 9f       	mul	r25, r19
    1b44:	50 0d       	add	r21, r0
    1b46:	11 24       	eor	r1, r1
    1b48:	da 01       	movw	r26, r20
    1b4a:	a0 58       	subi	r26, 0x80	; 128
    1b4c:	b3 4d       	sbci	r27, 0xD3	; 211
    1b4e:	11 96       	adiw	r26, 0x01	; 1
    1b50:	ed 91       	ld	r30, X+
    1b52:	fc 91       	ld	r31, X
    1b54:	12 97       	sbiw	r26, 0x02	; 2
    1b56:	04 80       	ldd	r0, Z+4	; 0x04
    1b58:	f5 81       	ldd	r31, Z+5	; 0x05
    1b5a:	e0 2d       	mov	r30, r0
    1b5c:	11 96       	adiw	r26, 0x01	; 1
    1b5e:	ed 93       	st	X+, r30
    1b60:	fc 93       	st	X, r31
    1b62:	12 97       	sbiw	r26, 0x02	; 2
    1b64:	4d 57       	subi	r20, 0x7D	; 125
    1b66:	53 4d       	sbci	r21, 0xD3	; 211
    1b68:	e4 17       	cp	r30, r20
    1b6a:	f5 07       	cpc	r31, r21
    1b6c:	29 f4       	brne	.+10     	; 0x1b78 <vTaskSwitchContext+0xf4>
    1b6e:	44 81       	ldd	r20, Z+4	; 0x04
    1b70:	55 81       	ldd	r21, Z+5	; 0x05
    1b72:	fd 01       	movw	r30, r26
    1b74:	41 83       	std	Z+1, r20	; 0x01
    1b76:	52 83       	std	Z+2, r21	; 0x02
    1b78:	9b e0       	ldi	r25, 0x0B	; 11
    1b7a:	92 9f       	mul	r25, r18
    1b7c:	f0 01       	movw	r30, r0
    1b7e:	93 9f       	mul	r25, r19
    1b80:	f0 0d       	add	r31, r0
    1b82:	11 24       	eor	r1, r1
    1b84:	e0 58       	subi	r30, 0x80	; 128
    1b86:	f3 4d       	sbci	r31, 0xD3	; 211
    1b88:	01 80       	ldd	r0, Z+1	; 0x01
    1b8a:	f2 81       	ldd	r31, Z+2	; 0x02
    1b8c:	e0 2d       	mov	r30, r0
    1b8e:	20 85       	ldd	r18, Z+8	; 0x08
    1b90:	31 85       	ldd	r19, Z+9	; 0x09
    1b92:	20 93 ac 2c 	sts	0x2CAC, r18	; 0x802cac <pxCurrentTCB>
    1b96:	30 93 ad 2c 	sts	0x2CAD, r19	; 0x802cad <pxCurrentTCB+0x1>
    1b9a:	80 93 4a 2c 	sts	0x2C4A, r24	; 0x802c4a <uxTopReadyPriority>
    1b9e:	08 95       	ret

00001ba0 <vTaskPlaceOnEventList>:
    1ba0:	cf 92       	push	r12
    1ba2:	df 92       	push	r13
    1ba4:	ef 92       	push	r14
    1ba6:	ff 92       	push	r15
    1ba8:	6a 01       	movw	r12, r20
    1baa:	7b 01       	movw	r14, r22
    1bac:	60 91 ac 2c 	lds	r22, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1bb0:	70 91 ad 2c 	lds	r23, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1bb4:	62 5f       	subi	r22, 0xF2	; 242
    1bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb8:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1bbc:	41 e0       	ldi	r20, 0x01	; 1
    1bbe:	c7 01       	movw	r24, r14
    1bc0:	b6 01       	movw	r22, r12
    1bc2:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1bc6:	ff 90       	pop	r15
    1bc8:	ef 90       	pop	r14
    1bca:	df 90       	pop	r13
    1bcc:	cf 90       	pop	r12
    1bce:	08 95       	ret

00001bd0 <vTaskPlaceOnUnorderedEventList>:
    1bd0:	cf 92       	push	r12
    1bd2:	df 92       	push	r13
    1bd4:	ef 92       	push	r14
    1bd6:	ff 92       	push	r15
    1bd8:	0f 93       	push	r16
    1bda:	1f 93       	push	r17
    1bdc:	68 01       	movw	r12, r16
    1bde:	79 01       	movw	r14, r18
    1be0:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1be4:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1be8:	70 68       	ori	r23, 0x80	; 128
    1bea:	46 87       	std	Z+14, r20	; 0x0e
    1bec:	57 87       	std	Z+15, r21	; 0x0f
    1bee:	60 8b       	std	Z+16, r22	; 0x10
    1bf0:	71 8b       	std	Z+17, r23	; 0x11
    1bf2:	60 91 ac 2c 	lds	r22, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1bf6:	70 91 ad 2c 	lds	r23, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1bfa:	62 5f       	subi	r22, 0xF2	; 242
    1bfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bfe:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1c02:	41 e0       	ldi	r20, 0x01	; 1
    1c04:	c7 01       	movw	r24, r14
    1c06:	b6 01       	movw	r22, r12
    1c08:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1c0c:	1f 91       	pop	r17
    1c0e:	0f 91       	pop	r16
    1c10:	ff 90       	pop	r15
    1c12:	ef 90       	pop	r14
    1c14:	df 90       	pop	r13
    1c16:	cf 90       	pop	r12
    1c18:	08 95       	ret

00001c1a <vTaskPlaceOnEventListRestricted>:
    1c1a:	cf 92       	push	r12
    1c1c:	df 92       	push	r13
    1c1e:	ef 92       	push	r14
    1c20:	ff 92       	push	r15
    1c22:	cf 93       	push	r28
    1c24:	6a 01       	movw	r12, r20
    1c26:	7b 01       	movw	r14, r22
    1c28:	c2 2f       	mov	r28, r18
    1c2a:	60 91 ac 2c 	lds	r22, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1c2e:	70 91 ad 2c 	lds	r23, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1c32:	62 5f       	subi	r22, 0xF2	; 242
    1c34:	7f 4f       	sbci	r23, 0xFF	; 255
    1c36:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1c3a:	cc 23       	and	r28, r28
    1c3c:	21 f0       	breq	.+8      	; 0x1c46 <vTaskPlaceOnEventListRestricted+0x2c>
    1c3e:	cc 24       	eor	r12, r12
    1c40:	ca 94       	dec	r12
    1c42:	dc 2c       	mov	r13, r12
    1c44:	76 01       	movw	r14, r12
    1c46:	4c 2f       	mov	r20, r28
    1c48:	c7 01       	movw	r24, r14
    1c4a:	b6 01       	movw	r22, r12
    1c4c:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1c50:	cf 91       	pop	r28
    1c52:	ff 90       	pop	r15
    1c54:	ef 90       	pop	r14
    1c56:	df 90       	pop	r13
    1c58:	cf 90       	pop	r12
    1c5a:	08 95       	ret

00001c5c <xTaskRemoveFromEventList>:
    1c5c:	0f 93       	push	r16
    1c5e:	1f 93       	push	r17
    1c60:	cf 93       	push	r28
    1c62:	df 93       	push	r29
    1c64:	dc 01       	movw	r26, r24
    1c66:	17 96       	adiw	r26, 0x07	; 7
    1c68:	ed 91       	ld	r30, X+
    1c6a:	fc 91       	ld	r31, X
    1c6c:	18 97       	sbiw	r26, 0x08	; 8
    1c6e:	c0 85       	ldd	r28, Z+8	; 0x08
    1c70:	d1 85       	ldd	r29, Z+9	; 0x09
    1c72:	8e 01       	movw	r16, r28
    1c74:	02 5f       	subi	r16, 0xF2	; 242
    1c76:	1f 4f       	sbci	r17, 0xFF	; 255
    1c78:	c8 01       	movw	r24, r16
    1c7a:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1c7e:	80 91 3e 2c 	lds	r24, 0x2C3E	; 0x802c3e <uxSchedulerSuspended>
    1c82:	81 11       	cpse	r24, r1
    1c84:	16 c0       	rjmp	.+44     	; 0x1cb2 <xTaskRemoveFromEventList+0x56>
    1c86:	0c 50       	subi	r16, 0x0C	; 12
    1c88:	11 09       	sbc	r17, r1
    1c8a:	c8 01       	movw	r24, r16
    1c8c:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1c90:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c92:	90 91 4a 2c 	lds	r25, 0x2C4A	; 0x802c4a <uxTopReadyPriority>
    1c96:	98 17       	cp	r25, r24
    1c98:	10 f4       	brcc	.+4      	; 0x1c9e <xTaskRemoveFromEventList+0x42>
    1c9a:	80 93 4a 2c 	sts	0x2C4A, r24	; 0x802c4a <uxTopReadyPriority>
    1c9e:	bb e0       	ldi	r27, 0x0B	; 11
    1ca0:	8b 9f       	mul	r24, r27
    1ca2:	c0 01       	movw	r24, r0
    1ca4:	11 24       	eor	r1, r1
    1ca6:	b8 01       	movw	r22, r16
    1ca8:	80 58       	subi	r24, 0x80	; 128
    1caa:	93 4d       	sbci	r25, 0xD3	; 211
    1cac:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1cb0:	05 c0       	rjmp	.+10     	; 0x1cbc <xTaskRemoveFromEventList+0x60>
    1cb2:	b8 01       	movw	r22, r16
    1cb4:	8b e5       	ldi	r24, 0x5B	; 91
    1cb6:	9c e2       	ldi	r25, 0x2C	; 44
    1cb8:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1cbc:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1cc0:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1cc4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1cc6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cc8:	89 17       	cp	r24, r25
    1cca:	20 f4       	brcc	.+8      	; 0x1cd4 <xTaskRemoveFromEventList+0x78>
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	80 93 47 2c 	sts	0x2C47, r24	; 0x802c47 <xYieldPending>
    1cd2:	01 c0       	rjmp	.+2      	; 0x1cd6 <xTaskRemoveFromEventList+0x7a>
    1cd4:	80 e0       	ldi	r24, 0x00	; 0
    1cd6:	df 91       	pop	r29
    1cd8:	cf 91       	pop	r28
    1cda:	1f 91       	pop	r17
    1cdc:	0f 91       	pop	r16
    1cde:	08 95       	ret

00001ce0 <vTaskRemoveFromUnorderedEventList>:
    1ce0:	0f 93       	push	r16
    1ce2:	1f 93       	push	r17
    1ce4:	cf 93       	push	r28
    1ce6:	df 93       	push	r29
    1ce8:	70 68       	ori	r23, 0x80	; 128
    1cea:	fc 01       	movw	r30, r24
    1cec:	40 83       	st	Z, r20
    1cee:	51 83       	std	Z+1, r21	; 0x01
    1cf0:	62 83       	std	Z+2, r22	; 0x02
    1cf2:	73 83       	std	Z+3, r23	; 0x03
    1cf4:	c0 85       	ldd	r28, Z+8	; 0x08
    1cf6:	d1 85       	ldd	r29, Z+9	; 0x09
    1cf8:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1cfc:	8e 01       	movw	r16, r28
    1cfe:	0e 5f       	subi	r16, 0xFE	; 254
    1d00:	1f 4f       	sbci	r17, 0xFF	; 255
    1d02:	c8 01       	movw	r24, r16
    1d04:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1d08:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d0a:	90 91 4a 2c 	lds	r25, 0x2C4A	; 0x802c4a <uxTopReadyPriority>
    1d0e:	98 17       	cp	r25, r24
    1d10:	10 f4       	brcc	.+4      	; 0x1d16 <vTaskRemoveFromUnorderedEventList+0x36>
    1d12:	80 93 4a 2c 	sts	0x2C4A, r24	; 0x802c4a <uxTopReadyPriority>
    1d16:	fb e0       	ldi	r31, 0x0B	; 11
    1d18:	8f 9f       	mul	r24, r31
    1d1a:	c0 01       	movw	r24, r0
    1d1c:	11 24       	eor	r1, r1
    1d1e:	b8 01       	movw	r22, r16
    1d20:	80 58       	subi	r24, 0x80	; 128
    1d22:	93 4d       	sbci	r25, 0xD3	; 211
    1d24:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1d28:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1d2c:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1d30:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d32:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d34:	89 17       	cp	r24, r25
    1d36:	18 f4       	brcc	.+6      	; 0x1d3e <vTaskRemoveFromUnorderedEventList+0x5e>
    1d38:	81 e0       	ldi	r24, 0x01	; 1
    1d3a:	80 93 47 2c 	sts	0x2C47, r24	; 0x802c47 <xYieldPending>
    1d3e:	df 91       	pop	r29
    1d40:	cf 91       	pop	r28
    1d42:	1f 91       	pop	r17
    1d44:	0f 91       	pop	r16
    1d46:	08 95       	ret

00001d48 <vTaskInternalSetTimeOutState>:
    1d48:	20 91 46 2c 	lds	r18, 0x2C46	; 0x802c46 <xNumOfOverflows>
    1d4c:	fc 01       	movw	r30, r24
    1d4e:	20 83       	st	Z, r18
    1d50:	40 91 4b 2c 	lds	r20, 0x2C4B	; 0x802c4b <xTickCount>
    1d54:	50 91 4c 2c 	lds	r21, 0x2C4C	; 0x802c4c <xTickCount+0x1>
    1d58:	60 91 4d 2c 	lds	r22, 0x2C4D	; 0x802c4d <xTickCount+0x2>
    1d5c:	70 91 4e 2c 	lds	r23, 0x2C4E	; 0x802c4e <xTickCount+0x3>
    1d60:	41 83       	std	Z+1, r20	; 0x01
    1d62:	52 83       	std	Z+2, r21	; 0x02
    1d64:	63 83       	std	Z+3, r22	; 0x03
    1d66:	74 83       	std	Z+4, r23	; 0x04
    1d68:	08 95       	ret

00001d6a <xTaskCheckForTimeOut>:
    1d6a:	cf 92       	push	r12
    1d6c:	df 92       	push	r13
    1d6e:	ef 92       	push	r14
    1d70:	ff 92       	push	r15
    1d72:	0f 93       	push	r16
    1d74:	1f 93       	push	r17
    1d76:	cf 93       	push	r28
    1d78:	df 93       	push	r29
    1d7a:	db 01       	movw	r26, r22
    1d7c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d80:	ff 93       	push	r31
    1d82:	f8 7f       	andi	r31, 0xF8	; 248
    1d84:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d88:	40 91 4b 2c 	lds	r20, 0x2C4B	; 0x802c4b <xTickCount>
    1d8c:	50 91 4c 2c 	lds	r21, 0x2C4C	; 0x802c4c <xTickCount+0x1>
    1d90:	60 91 4d 2c 	lds	r22, 0x2C4D	; 0x802c4d <xTickCount+0x2>
    1d94:	70 91 4e 2c 	lds	r23, 0x2C4E	; 0x802c4e <xTickCount+0x3>
    1d98:	0d 91       	ld	r16, X+
    1d9a:	1d 91       	ld	r17, X+
    1d9c:	2d 91       	ld	r18, X+
    1d9e:	3c 91       	ld	r19, X
    1da0:	13 97       	sbiw	r26, 0x03	; 3
    1da2:	0f 3f       	cpi	r16, 0xFF	; 255
    1da4:	cf ef       	ldi	r28, 0xFF	; 255
    1da6:	1c 07       	cpc	r17, r28
    1da8:	2c 07       	cpc	r18, r28
    1daa:	3c 07       	cpc	r19, r28
    1dac:	69 f1       	breq	.+90     	; 0x1e08 <xTaskCheckForTimeOut+0x9e>
    1dae:	fc 01       	movw	r30, r24
    1db0:	c1 80       	ldd	r12, Z+1	; 0x01
    1db2:	d2 80       	ldd	r13, Z+2	; 0x02
    1db4:	e3 80       	ldd	r14, Z+3	; 0x03
    1db6:	f4 80       	ldd	r15, Z+4	; 0x04
    1db8:	e0 91 46 2c 	lds	r30, 0x2C46	; 0x802c46 <xNumOfOverflows>
    1dbc:	ec 01       	movw	r28, r24
    1dbe:	f8 81       	ld	r31, Y
    1dc0:	fe 17       	cp	r31, r30
    1dc2:	29 f0       	breq	.+10     	; 0x1dce <xTaskCheckForTimeOut+0x64>
    1dc4:	4c 15       	cp	r20, r12
    1dc6:	5d 05       	cpc	r21, r13
    1dc8:	6e 05       	cpc	r22, r14
    1dca:	7f 05       	cpc	r23, r15
    1dcc:	f8 f4       	brcc	.+62     	; 0x1e0c <xTaskCheckForTimeOut+0xa2>
    1dce:	4c 19       	sub	r20, r12
    1dd0:	5d 09       	sbc	r21, r13
    1dd2:	6e 09       	sbc	r22, r14
    1dd4:	7f 09       	sbc	r23, r15
    1dd6:	40 17       	cp	r20, r16
    1dd8:	51 07       	cpc	r21, r17
    1dda:	62 07       	cpc	r22, r18
    1ddc:	73 07       	cpc	r23, r19
    1dde:	68 f4       	brcc	.+26     	; 0x1dfa <xTaskCheckForTimeOut+0x90>
    1de0:	fd 01       	movw	r30, r26
    1de2:	04 1b       	sub	r16, r20
    1de4:	15 0b       	sbc	r17, r21
    1de6:	26 0b       	sbc	r18, r22
    1de8:	37 0b       	sbc	r19, r23
    1dea:	00 83       	st	Z, r16
    1dec:	11 83       	std	Z+1, r17	; 0x01
    1dee:	22 83       	std	Z+2, r18	; 0x02
    1df0:	33 83       	std	Z+3, r19	; 0x03
    1df2:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskInternalSetTimeOutState>
    1df6:	80 e0       	ldi	r24, 0x00	; 0
    1df8:	0a c0       	rjmp	.+20     	; 0x1e0e <xTaskCheckForTimeOut+0xa4>
    1dfa:	1d 92       	st	X+, r1
    1dfc:	1d 92       	st	X+, r1
    1dfe:	1d 92       	st	X+, r1
    1e00:	1c 92       	st	X, r1
    1e02:	13 97       	sbiw	r26, 0x03	; 3
    1e04:	81 e0       	ldi	r24, 0x01	; 1
    1e06:	03 c0       	rjmp	.+6      	; 0x1e0e <xTaskCheckForTimeOut+0xa4>
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	01 c0       	rjmp	.+2      	; 0x1e0e <xTaskCheckForTimeOut+0xa4>
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	ff 91       	pop	r31
    1e10:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1e14:	df 91       	pop	r29
    1e16:	cf 91       	pop	r28
    1e18:	1f 91       	pop	r17
    1e1a:	0f 91       	pop	r16
    1e1c:	ff 90       	pop	r15
    1e1e:	ef 90       	pop	r14
    1e20:	df 90       	pop	r13
    1e22:	cf 90       	pop	r12
    1e24:	08 95       	ret

00001e26 <vTaskMissedYield>:
    1e26:	81 e0       	ldi	r24, 0x01	; 1
    1e28:	80 93 47 2c 	sts	0x2C47, r24	; 0x802c47 <xYieldPending>
    1e2c:	08 95       	ret

00001e2e <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    1e2e:	80 91 49 2c 	lds	r24, 0x2C49	; 0x802c49 <xSchedulerRunning>
    1e32:	88 23       	and	r24, r24
    1e34:	31 f0       	breq	.+12     	; 0x1e42 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1e36:	80 91 3e 2c 	lds	r24, 0x2C3E	; 0x802c3e <uxSchedulerSuspended>
    1e3a:	88 23       	and	r24, r24
    1e3c:	21 f0       	breq	.+8      	; 0x1e46 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1e3e:	80 e0       	ldi	r24, 0x00	; 0
    1e40:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1e42:	81 e0       	ldi	r24, 0x01	; 1
    1e44:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    1e46:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    1e48:	08 95       	ret

00001e4a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    1e4a:	cf 92       	push	r12
    1e4c:	df 92       	push	r13
    1e4e:	ef 92       	push	r14
    1e50:	ff 92       	push	r15
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1e52:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1e56:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1e5a:	66 85       	ldd	r22, Z+14	; 0x0e
    1e5c:	77 85       	ldd	r23, Z+15	; 0x0f
    1e5e:	80 89       	ldd	r24, Z+16	; 0x10
    1e60:	91 89       	ldd	r25, Z+17	; 0x11

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e62:	e0 91 ac 2c 	lds	r30, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1e66:	f0 91 ad 2c 	lds	r31, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1e6a:	a0 91 ac 2c 	lds	r26, 0x2CAC	; 0x802cac <pxCurrentTCB>
    1e6e:	b0 91 ad 2c 	lds	r27, 0x2CAD	; 0x802cad <pxCurrentTCB+0x1>
    1e72:	5a 96       	adiw	r26, 0x1a	; 26
    1e74:	2c 91       	ld	r18, X
    1e76:	c1 2c       	mov	r12, r1
    1e78:	d1 2c       	mov	r13, r1
    1e7a:	76 01       	movw	r14, r12
    1e7c:	68 94       	set
    1e7e:	c2 f8       	bld	r12, 2
    1e80:	c2 1a       	sub	r12, r18
    1e82:	d1 08       	sbc	r13, r1
    1e84:	e1 08       	sbc	r14, r1
    1e86:	f1 08       	sbc	r15, r1
    1e88:	c6 86       	std	Z+14, r12	; 0x0e
    1e8a:	d7 86       	std	Z+15, r13	; 0x0f
    1e8c:	e0 8a       	std	Z+16, r14	; 0x10
    1e8e:	f1 8a       	std	Z+17, r15	; 0x11

	return uxReturn;
}
    1e90:	ff 90       	pop	r15
    1e92:	ef 90       	pop	r14
    1e94:	df 90       	pop	r13
    1e96:	cf 90       	pop	r12
    1e98:	08 95       	ret

00001e9a <prvInsertTimerInActiveList>:

	taskENTER_CRITICAL();
	{
		pxTimer->pvTimerID = pvNewID;
	}
	taskEXIT_CRITICAL();
    1e9a:	cf 92       	push	r12
    1e9c:	df 92       	push	r13
    1e9e:	ef 92       	push	r14
    1ea0:	ff 92       	push	r15
    1ea2:	0f 93       	push	r16
    1ea4:	1f 93       	push	r17
    1ea6:	fc 01       	movw	r30, r24
    1ea8:	42 83       	std	Z+2, r20	; 0x02
    1eaa:	53 83       	std	Z+3, r21	; 0x03
    1eac:	64 83       	std	Z+4, r22	; 0x04
    1eae:	75 83       	std	Z+5, r23	; 0x05
    1eb0:	82 87       	std	Z+10, r24	; 0x0a
    1eb2:	93 87       	std	Z+11, r25	; 0x0b
    1eb4:	04 17       	cp	r16, r20
    1eb6:	15 07       	cpc	r17, r21
    1eb8:	26 07       	cpc	r18, r22
    1eba:	37 07       	cpc	r19, r23
    1ebc:	c0 f0       	brcs	.+48     	; 0x1eee <prvInsertTimerInActiveList+0x54>
    1ebe:	0c 19       	sub	r16, r12
    1ec0:	1d 09       	sbc	r17, r13
    1ec2:	2e 09       	sbc	r18, r14
    1ec4:	3f 09       	sbc	r19, r15
    1ec6:	86 85       	ldd	r24, Z+14	; 0x0e
    1ec8:	97 85       	ldd	r25, Z+15	; 0x0f
    1eca:	a0 89       	ldd	r26, Z+16	; 0x10
    1ecc:	b1 89       	ldd	r27, Z+17	; 0x11
    1ece:	08 17       	cp	r16, r24
    1ed0:	19 07       	cpc	r17, r25
    1ed2:	2a 07       	cpc	r18, r26
    1ed4:	3b 07       	cpc	r19, r27
    1ed6:	00 f5       	brcc	.+64     	; 0x1f18 <prvInsertTimerInActiveList+0x7e>
    1ed8:	bf 01       	movw	r22, r30
    1eda:	6e 5f       	subi	r22, 0xFE	; 254
    1edc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ede:	80 91 b6 2c 	lds	r24, 0x2CB6	; 0x802cb6 <pxOverflowTimerList>
    1ee2:	90 91 b7 2c 	lds	r25, 0x2CB7	; 0x802cb7 <pxOverflowTimerList+0x1>
    1ee6:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1eea:	80 e0       	ldi	r24, 0x00	; 0
    1eec:	18 c0       	rjmp	.+48     	; 0x1f1e <prvInsertTimerInActiveList+0x84>
    1eee:	0c 15       	cp	r16, r12
    1ef0:	1d 05       	cpc	r17, r13
    1ef2:	2e 05       	cpc	r18, r14
    1ef4:	3f 05       	cpc	r19, r15
    1ef6:	28 f4       	brcc	.+10     	; 0x1f02 <prvInsertTimerInActiveList+0x68>
    1ef8:	4c 15       	cp	r20, r12
    1efa:	5d 05       	cpc	r21, r13
    1efc:	6e 05       	cpc	r22, r14
    1efe:	7f 05       	cpc	r23, r15
    1f00:	68 f4       	brcc	.+26     	; 0x1f1c <prvInsertTimerInActiveList+0x82>
    1f02:	bf 01       	movw	r22, r30
    1f04:	6e 5f       	subi	r22, 0xFE	; 254
    1f06:	7f 4f       	sbci	r23, 0xFF	; 255
    1f08:	80 91 b8 2c 	lds	r24, 0x2CB8	; 0x802cb8 <pxCurrentTimerList>
    1f0c:	90 91 b9 2c 	lds	r25, 0x2CB9	; 0x802cb9 <pxCurrentTimerList+0x1>
    1f10:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1f14:	80 e0       	ldi	r24, 0x00	; 0
    1f16:	03 c0       	rjmp	.+6      	; 0x1f1e <prvInsertTimerInActiveList+0x84>
    1f18:	81 e0       	ldi	r24, 0x01	; 1
    1f1a:	01 c0       	rjmp	.+2      	; 0x1f1e <prvInsertTimerInActiveList+0x84>
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	1f 91       	pop	r17
    1f20:	0f 91       	pop	r16
    1f22:	ff 90       	pop	r15
    1f24:	ef 90       	pop	r14
    1f26:	df 90       	pop	r13
    1f28:	cf 90       	pop	r12
    1f2a:	08 95       	ret

00001f2c <prvCheckForValidListAndQueue>:
    1f2c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f30:	ff 93       	push	r31
    1f32:	f8 7f       	andi	r31, 0xF8	; 248
    1f34:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f38:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <xTimerQueue>
    1f3c:	90 91 b5 2c 	lds	r25, 0x2CB5	; 0x802cb5 <xTimerQueue+0x1>
    1f40:	89 2b       	or	r24, r25
    1f42:	e9 f4       	brne	.+58     	; 0x1f7e <prvCheckForValidListAndQueue+0x52>
    1f44:	85 ec       	ldi	r24, 0xC5	; 197
    1f46:	9c e2       	ldi	r25, 0x2C	; 44
    1f48:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1f4c:	8a eb       	ldi	r24, 0xBA	; 186
    1f4e:	9c e2       	ldi	r25, 0x2C	; 44
    1f50:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1f54:	85 ec       	ldi	r24, 0xC5	; 197
    1f56:	9c e2       	ldi	r25, 0x2C	; 44
    1f58:	80 93 b8 2c 	sts	0x2CB8, r24	; 0x802cb8 <pxCurrentTimerList>
    1f5c:	90 93 b9 2c 	sts	0x2CB9, r25	; 0x802cb9 <pxCurrentTimerList+0x1>
    1f60:	8a eb       	ldi	r24, 0xBA	; 186
    1f62:	9c e2       	ldi	r25, 0x2C	; 44
    1f64:	80 93 b6 2c 	sts	0x2CB6, r24	; 0x802cb6 <pxOverflowTimerList>
    1f68:	90 93 b7 2c 	sts	0x2CB7, r25	; 0x802cb7 <pxOverflowTimerList+0x1>
    1f6c:	40 e0       	ldi	r20, 0x00	; 0
    1f6e:	69 e0       	ldi	r22, 0x09	; 9
    1f70:	85 e0       	ldi	r24, 0x05	; 5
    1f72:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericCreate>
    1f76:	80 93 b4 2c 	sts	0x2CB4, r24	; 0x802cb4 <xTimerQueue>
    1f7a:	90 93 b5 2c 	sts	0x2CB5, r25	; 0x802cb5 <xTimerQueue+0x1>
    1f7e:	ff 91       	pop	r31
    1f80:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f84:	08 95       	ret

00001f86 <xTimerCreateTimerTask>:
    1f86:	ef 92       	push	r14
    1f88:	ff 92       	push	r15
    1f8a:	0f 93       	push	r16
    1f8c:	0e 94 96 0f 	call	0x1f2c	; 0x1f2c <prvCheckForValidListAndQueue>
    1f90:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <xTimerQueue>
    1f94:	90 91 b5 2c 	lds	r25, 0x2CB5	; 0x802cb5 <xTimerQueue+0x1>
    1f98:	89 2b       	or	r24, r25
    1f9a:	91 f0       	breq	.+36     	; 0x1fc0 <xTimerCreateTimerTask+0x3a>
    1f9c:	0f 2e       	mov	r0, r31
    1f9e:	f2 eb       	ldi	r31, 0xB2	; 178
    1fa0:	ef 2e       	mov	r14, r31
    1fa2:	fc e2       	ldi	r31, 0x2C	; 44
    1fa4:	ff 2e       	mov	r15, r31
    1fa6:	f0 2d       	mov	r31, r0
    1fa8:	03 e0       	ldi	r16, 0x03	; 3
    1faa:	20 e0       	ldi	r18, 0x00	; 0
    1fac:	30 e0       	ldi	r19, 0x00	; 0
    1fae:	48 ec       	ldi	r20, 0xC8	; 200
    1fb0:	50 e0       	ldi	r21, 0x00	; 0
    1fb2:	69 e0       	ldi	r22, 0x09	; 9
    1fb4:	70 e2       	ldi	r23, 0x20	; 32
    1fb6:	86 ed       	ldi	r24, 0xD6	; 214
    1fb8:	90 e1       	ldi	r25, 0x10	; 16
    1fba:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
    1fbe:	01 c0       	rjmp	.+2      	; 0x1fc2 <xTimerCreateTimerTask+0x3c>
    1fc0:	80 e0       	ldi	r24, 0x00	; 0
    1fc2:	0f 91       	pop	r16
    1fc4:	ff 90       	pop	r15
    1fc6:	ef 90       	pop	r14
    1fc8:	08 95       	ret

00001fca <xTimerGenericCommand>:
    1fca:	8f 92       	push	r8
    1fcc:	9f 92       	push	r9
    1fce:	af 92       	push	r10
    1fd0:	bf 92       	push	r11
    1fd2:	cf 92       	push	r12
    1fd4:	df 92       	push	r13
    1fd6:	ef 92       	push	r14
    1fd8:	ff 92       	push	r15
    1fda:	0f 93       	push	r16
    1fdc:	1f 93       	push	r17
    1fde:	cf 93       	push	r28
    1fe0:	df 93       	push	r29
    1fe2:	cd b7       	in	r28, 0x3d	; 61
    1fe4:	de b7       	in	r29, 0x3e	; 62
    1fe6:	29 97       	sbiw	r28, 0x09	; 9
    1fe8:	cd bf       	out	0x3d, r28	; 61
    1fea:	de bf       	out	0x3e, r29	; 62
    1fec:	e0 91 b4 2c 	lds	r30, 0x2CB4	; 0x802cb4 <xTimerQueue>
    1ff0:	f0 91 b5 2c 	lds	r31, 0x2CB5	; 0x802cb5 <xTimerQueue+0x1>
    1ff4:	30 97       	sbiw	r30, 0x00	; 0
    1ff6:	89 f1       	breq	.+98     	; 0x205a <xTimerGenericCommand+0x90>
    1ff8:	69 83       	std	Y+1, r22	; 0x01
    1ffa:	2a 83       	std	Y+2, r18	; 0x02
    1ffc:	3b 83       	std	Y+3, r19	; 0x03
    1ffe:	4c 83       	std	Y+4, r20	; 0x04
    2000:	5d 83       	std	Y+5, r21	; 0x05
    2002:	8e 83       	std	Y+6, r24	; 0x06
    2004:	9f 83       	std	Y+7, r25	; 0x07
    2006:	66 30       	cpi	r22, 0x06	; 6
    2008:	fc f4       	brge	.+62     	; 0x2048 <xTimerGenericCommand+0x7e>
    200a:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <xTaskGetSchedulerState>
    200e:	82 30       	cpi	r24, 0x02	; 2
    2010:	69 f4       	brne	.+26     	; 0x202c <xTimerGenericCommand+0x62>
    2012:	00 e0       	ldi	r16, 0x00	; 0
    2014:	a7 01       	movw	r20, r14
    2016:	96 01       	movw	r18, r12
    2018:	be 01       	movw	r22, r28
    201a:	6f 5f       	subi	r22, 0xFF	; 255
    201c:	7f 4f       	sbci	r23, 0xFF	; 255
    201e:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <xTimerQueue>
    2022:	90 91 b5 2c 	lds	r25, 0x2CB5	; 0x802cb5 <xTimerQueue+0x1>
    2026:	0e 94 00 08 	call	0x1000	; 0x1000 <xQueueGenericSend>
    202a:	18 c0       	rjmp	.+48     	; 0x205c <xTimerGenericCommand+0x92>
    202c:	00 e0       	ldi	r16, 0x00	; 0
    202e:	20 e0       	ldi	r18, 0x00	; 0
    2030:	30 e0       	ldi	r19, 0x00	; 0
    2032:	a9 01       	movw	r20, r18
    2034:	be 01       	movw	r22, r28
    2036:	6f 5f       	subi	r22, 0xFF	; 255
    2038:	7f 4f       	sbci	r23, 0xFF	; 255
    203a:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <xTimerQueue>
    203e:	90 91 b5 2c 	lds	r25, 0x2CB5	; 0x802cb5 <xTimerQueue+0x1>
    2042:	0e 94 00 08 	call	0x1000	; 0x1000 <xQueueGenericSend>
    2046:	0a c0       	rjmp	.+20     	; 0x205c <xTimerGenericCommand+0x92>
    2048:	20 e0       	ldi	r18, 0x00	; 0
    204a:	a8 01       	movw	r20, r16
    204c:	be 01       	movw	r22, r28
    204e:	6f 5f       	subi	r22, 0xFF	; 255
    2050:	7f 4f       	sbci	r23, 0xFF	; 255
    2052:	cf 01       	movw	r24, r30
    2054:	0e 94 a6 08 	call	0x114c	; 0x114c <xQueueGenericSendFromISR>
    2058:	01 c0       	rjmp	.+2      	; 0x205c <xTimerGenericCommand+0x92>
    205a:	80 e0       	ldi	r24, 0x00	; 0
    205c:	29 96       	adiw	r28, 0x09	; 9
    205e:	cd bf       	out	0x3d, r28	; 61
    2060:	de bf       	out	0x3e, r29	; 62
    2062:	df 91       	pop	r29
    2064:	cf 91       	pop	r28
    2066:	1f 91       	pop	r17
    2068:	0f 91       	pop	r16
    206a:	ff 90       	pop	r15
    206c:	ef 90       	pop	r14
    206e:	df 90       	pop	r13
    2070:	cf 90       	pop	r12
    2072:	bf 90       	pop	r11
    2074:	af 90       	pop	r10
    2076:	9f 90       	pop	r9
    2078:	8f 90       	pop	r8
    207a:	08 95       	ret

0000207c <prvSampleTimeNow>:
    207c:	2f 92       	push	r2
    207e:	3f 92       	push	r3
    2080:	4f 92       	push	r4
    2082:	5f 92       	push	r5
    2084:	6f 92       	push	r6
    2086:	7f 92       	push	r7
    2088:	8f 92       	push	r8
    208a:	9f 92       	push	r9
    208c:	af 92       	push	r10
    208e:	bf 92       	push	r11
    2090:	cf 92       	push	r12
    2092:	df 92       	push	r13
    2094:	ef 92       	push	r14
    2096:	ff 92       	push	r15
    2098:	0f 93       	push	r16
    209a:	1f 93       	push	r17
    209c:	cf 93       	push	r28
    209e:	df 93       	push	r29
    20a0:	1c 01       	movw	r2, r24
    20a2:	0e 94 bf 0b 	call	0x177e	; 0x177e <xTaskGetTickCount>
    20a6:	2b 01       	movw	r4, r22
    20a8:	3c 01       	movw	r6, r24
    20aa:	80 91 ae 2c 	lds	r24, 0x2CAE	; 0x802cae <xLastTime.4745>
    20ae:	90 91 af 2c 	lds	r25, 0x2CAF	; 0x802caf <xLastTime.4745+0x1>
    20b2:	a0 91 b0 2c 	lds	r26, 0x2CB0	; 0x802cb0 <xLastTime.4745+0x2>
    20b6:	b0 91 b1 2c 	lds	r27, 0x2CB1	; 0x802cb1 <xLastTime.4745+0x3>
    20ba:	48 16       	cp	r4, r24
    20bc:	59 06       	cpc	r5, r25
    20be:	6a 06       	cpc	r6, r26
    20c0:	7b 06       	cpc	r7, r27
    20c2:	08 f0       	brcs	.+2      	; 0x20c6 <prvSampleTimeNow+0x4a>
    20c4:	54 c0       	rjmp	.+168    	; 0x216e <prvSampleTimeNow+0xf2>
    20c6:	3c c0       	rjmp	.+120    	; 0x2140 <prvSampleTimeNow+0xc4>
    20c8:	07 80       	ldd	r0, Z+7	; 0x07
    20ca:	f0 85       	ldd	r31, Z+8	; 0x08
    20cc:	e0 2d       	mov	r30, r0
    20ce:	80 80       	ld	r8, Z
    20d0:	91 80       	ldd	r9, Z+1	; 0x01
    20d2:	a2 80       	ldd	r10, Z+2	; 0x02
    20d4:	b3 80       	ldd	r11, Z+3	; 0x03
    20d6:	c0 85       	ldd	r28, Z+8	; 0x08
    20d8:	d1 85       	ldd	r29, Z+9	; 0x09
    20da:	8e 01       	movw	r16, r28
    20dc:	0e 5f       	subi	r16, 0xFE	; 254
    20de:	1f 4f       	sbci	r17, 0xFF	; 255
    20e0:	c8 01       	movw	r24, r16
    20e2:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    20e6:	ed 89       	ldd	r30, Y+21	; 0x15
    20e8:	fe 89       	ldd	r31, Y+22	; 0x16
    20ea:	ce 01       	movw	r24, r28
    20ec:	19 95       	eicall
    20ee:	8a 89       	ldd	r24, Y+18	; 0x12
    20f0:	81 30       	cpi	r24, 0x01	; 1
    20f2:	31 f5       	brne	.+76     	; 0x2140 <prvSampleTimeNow+0xc4>
    20f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    20f6:	9f 85       	ldd	r25, Y+15	; 0x0f
    20f8:	a8 89       	ldd	r26, Y+16	; 0x10
    20fa:	b9 89       	ldd	r27, Y+17	; 0x11
    20fc:	88 0d       	add	r24, r8
    20fe:	99 1d       	adc	r25, r9
    2100:	aa 1d       	adc	r26, r10
    2102:	bb 1d       	adc	r27, r11
    2104:	88 16       	cp	r8, r24
    2106:	99 06       	cpc	r9, r25
    2108:	aa 06       	cpc	r10, r26
    210a:	bb 06       	cpc	r11, r27
    210c:	70 f4       	brcc	.+28     	; 0x212a <prvSampleTimeNow+0xae>
    210e:	8a 83       	std	Y+2, r24	; 0x02
    2110:	9b 83       	std	Y+3, r25	; 0x03
    2112:	ac 83       	std	Y+4, r26	; 0x04
    2114:	bd 83       	std	Y+5, r27	; 0x05
    2116:	ca 87       	std	Y+10, r28	; 0x0a
    2118:	db 87       	std	Y+11, r29	; 0x0b
    211a:	b8 01       	movw	r22, r16
    211c:	80 91 b8 2c 	lds	r24, 0x2CB8	; 0x802cb8 <pxCurrentTimerList>
    2120:	90 91 b9 2c 	lds	r25, 0x2CB9	; 0x802cb9 <pxCurrentTimerList+0x1>
    2124:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    2128:	0b c0       	rjmp	.+22     	; 0x2140 <prvSampleTimeNow+0xc4>
    212a:	c1 2c       	mov	r12, r1
    212c:	d1 2c       	mov	r13, r1
    212e:	76 01       	movw	r14, r12
    2130:	00 e0       	ldi	r16, 0x00	; 0
    2132:	10 e0       	ldi	r17, 0x00	; 0
    2134:	a5 01       	movw	r20, r10
    2136:	94 01       	movw	r18, r8
    2138:	60 e0       	ldi	r22, 0x00	; 0
    213a:	ce 01       	movw	r24, r28
    213c:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <xTimerGenericCommand>
    2140:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTimerList>
    2144:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTimerList+0x1>
    2148:	80 81       	ld	r24, Z
    214a:	81 11       	cpse	r24, r1
    214c:	bd cf       	rjmp	.-134    	; 0x20c8 <prvSampleTimeNow+0x4c>
    214e:	80 91 b6 2c 	lds	r24, 0x2CB6	; 0x802cb6 <pxOverflowTimerList>
    2152:	90 91 b7 2c 	lds	r25, 0x2CB7	; 0x802cb7 <pxOverflowTimerList+0x1>
    2156:	80 93 b8 2c 	sts	0x2CB8, r24	; 0x802cb8 <pxCurrentTimerList>
    215a:	90 93 b9 2c 	sts	0x2CB9, r25	; 0x802cb9 <pxCurrentTimerList+0x1>
    215e:	e0 93 b6 2c 	sts	0x2CB6, r30	; 0x802cb6 <pxOverflowTimerList>
    2162:	f0 93 b7 2c 	sts	0x2CB7, r31	; 0x802cb7 <pxOverflowTimerList+0x1>
    2166:	81 e0       	ldi	r24, 0x01	; 1
    2168:	f1 01       	movw	r30, r2
    216a:	80 83       	st	Z, r24
    216c:	02 c0       	rjmp	.+4      	; 0x2172 <prvSampleTimeNow+0xf6>
    216e:	f1 01       	movw	r30, r2
    2170:	10 82       	st	Z, r1
    2172:	40 92 ae 2c 	sts	0x2CAE, r4	; 0x802cae <xLastTime.4745>
    2176:	50 92 af 2c 	sts	0x2CAF, r5	; 0x802caf <xLastTime.4745+0x1>
    217a:	60 92 b0 2c 	sts	0x2CB0, r6	; 0x802cb0 <xLastTime.4745+0x2>
    217e:	70 92 b1 2c 	sts	0x2CB1, r7	; 0x802cb1 <xLastTime.4745+0x3>
    2182:	c3 01       	movw	r24, r6
    2184:	b2 01       	movw	r22, r4
    2186:	df 91       	pop	r29
    2188:	cf 91       	pop	r28
    218a:	1f 91       	pop	r17
    218c:	0f 91       	pop	r16
    218e:	ff 90       	pop	r15
    2190:	ef 90       	pop	r14
    2192:	df 90       	pop	r13
    2194:	cf 90       	pop	r12
    2196:	bf 90       	pop	r11
    2198:	af 90       	pop	r10
    219a:	9f 90       	pop	r9
    219c:	8f 90       	pop	r8
    219e:	7f 90       	pop	r7
    21a0:	6f 90       	pop	r6
    21a2:	5f 90       	pop	r5
    21a4:	4f 90       	pop	r4
    21a6:	3f 90       	pop	r3
    21a8:	2f 90       	pop	r2
    21aa:	08 95       	ret

000021ac <prvTimerTask>:
    21ac:	cf 93       	push	r28
    21ae:	df 93       	push	r29
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
    21b4:	2e 97       	sbiw	r28, 0x0e	; 14
    21b6:	cd bf       	out	0x3d, r28	; 61
    21b8:	de bf       	out	0x3e, r29	; 62
    21ba:	ce 01       	movw	r24, r28
    21bc:	01 96       	adiw	r24, 0x01	; 1
    21be:	1c 01       	movw	r2, r24
    21c0:	a8 2e       	mov	r10, r24
    21c2:	b3 2c       	mov	r11, r3
    21c4:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTimerList>
    21c8:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTimerList+0x1>
    21cc:	80 81       	ld	r24, Z
    21ce:	88 23       	and	r24, r24
    21d0:	09 f4       	brne	.+2      	; 0x21d4 <prvTimerTask+0x28>
    21d2:	03 c1       	rjmp	.+518    	; 0x23da <prvTimerTask+0x22e>
    21d4:	07 80       	ldd	r0, Z+7	; 0x07
    21d6:	f0 85       	ldd	r31, Z+8	; 0x08
    21d8:	e0 2d       	mov	r30, r0
    21da:	40 80       	ld	r4, Z
    21dc:	51 80       	ldd	r5, Z+1	; 0x01
    21de:	62 80       	ldd	r6, Z+2	; 0x02
    21e0:	73 80       	ldd	r7, Z+3	; 0x03
    21e2:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    21e6:	c1 01       	movw	r24, r2
    21e8:	0e 94 3e 10 	call	0x207c	; 0x207c <prvSampleTimeNow>
    21ec:	6b 87       	std	Y+11, r22	; 0x0b
    21ee:	7c 87       	std	Y+12, r23	; 0x0c
    21f0:	8d 87       	std	Y+13, r24	; 0x0d
    21f2:	9e 87       	std	Y+14, r25	; 0x0e
    21f4:	89 81       	ldd	r24, Y+1	; 0x01
    21f6:	81 11       	cpse	r24, r1
    21f8:	5e c0       	rjmp	.+188    	; 0x22b6 <prvTimerTask+0x10a>
    21fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    21fc:	9c 85       	ldd	r25, Y+12	; 0x0c
    21fe:	ad 85       	ldd	r26, Y+13	; 0x0d
    2200:	be 85       	ldd	r27, Y+14	; 0x0e
    2202:	84 15       	cp	r24, r4
    2204:	95 05       	cpc	r25, r5
    2206:	a6 05       	cpc	r26, r6
    2208:	b7 05       	cpc	r27, r7
    220a:	e8 f1       	brcs	.+122    	; 0x2286 <prvTimerTask+0xda>
    220c:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    2210:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTimerList>
    2214:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTimerList+0x1>
    2218:	07 80       	ldd	r0, Z+7	; 0x07
    221a:	f0 85       	ldd	r31, Z+8	; 0x08
    221c:	e0 2d       	mov	r30, r0
    221e:	80 84       	ldd	r8, Z+8	; 0x08
    2220:	91 84       	ldd	r9, Z+9	; 0x09
    2222:	c4 01       	movw	r24, r8
    2224:	02 96       	adiw	r24, 0x02	; 2
    2226:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    222a:	d4 01       	movw	r26, r8
    222c:	52 96       	adiw	r26, 0x12	; 18
    222e:	8c 91       	ld	r24, X
    2230:	52 97       	sbiw	r26, 0x12	; 18
    2232:	81 30       	cpi	r24, 0x01	; 1
    2234:	01 f5       	brne	.+64     	; 0x2276 <prvTimerTask+0xca>
    2236:	1e 96       	adiw	r26, 0x0e	; 14
    2238:	4d 91       	ld	r20, X+
    223a:	5d 91       	ld	r21, X+
    223c:	6d 91       	ld	r22, X+
    223e:	7c 91       	ld	r23, X
    2240:	51 97       	sbiw	r26, 0x11	; 17
    2242:	44 0d       	add	r20, r4
    2244:	55 1d       	adc	r21, r5
    2246:	66 1d       	adc	r22, r6
    2248:	77 1d       	adc	r23, r7
    224a:	73 01       	movw	r14, r6
    224c:	62 01       	movw	r12, r4
    224e:	0b 85       	ldd	r16, Y+11	; 0x0b
    2250:	1c 85       	ldd	r17, Y+12	; 0x0c
    2252:	2d 85       	ldd	r18, Y+13	; 0x0d
    2254:	3e 85       	ldd	r19, Y+14	; 0x0e
    2256:	c4 01       	movw	r24, r8
    2258:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <prvInsertTimerInActiveList>
    225c:	88 23       	and	r24, r24
    225e:	59 f0       	breq	.+22     	; 0x2276 <prvTimerTask+0xca>
    2260:	c1 2c       	mov	r12, r1
    2262:	d1 2c       	mov	r13, r1
    2264:	76 01       	movw	r14, r12
    2266:	00 e0       	ldi	r16, 0x00	; 0
    2268:	10 e0       	ldi	r17, 0x00	; 0
    226a:	a3 01       	movw	r20, r6
    226c:	92 01       	movw	r18, r4
    226e:	60 e0       	ldi	r22, 0x00	; 0
    2270:	c4 01       	movw	r24, r8
    2272:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <xTimerGenericCommand>
    2276:	d4 01       	movw	r26, r8
    2278:	55 96       	adiw	r26, 0x15	; 21
    227a:	ed 91       	ld	r30, X+
    227c:	fc 91       	ld	r31, X
    227e:	56 97       	sbiw	r26, 0x16	; 22
    2280:	c4 01       	movw	r24, r8
    2282:	19 95       	eicall
    2284:	9c c0       	rjmp	.+312    	; 0x23be <prvTimerTask+0x212>
    2286:	20 e0       	ldi	r18, 0x00	; 0
    2288:	b3 01       	movw	r22, r6
    228a:	a2 01       	movw	r20, r4
    228c:	8b 85       	ldd	r24, Y+11	; 0x0b
    228e:	9c 85       	ldd	r25, Y+12	; 0x0c
    2290:	ad 85       	ldd	r26, Y+13	; 0x0d
    2292:	be 85       	ldd	r27, Y+14	; 0x0e
    2294:	48 1b       	sub	r20, r24
    2296:	59 0b       	sbc	r21, r25
    2298:	6a 0b       	sbc	r22, r26
    229a:	7b 0b       	sbc	r23, r27
    229c:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <xTimerQueue>
    22a0:	90 91 b5 2c 	lds	r25, 0x2CB5	; 0x802cb5 <xTimerQueue+0x1>
    22a4:	0e 94 9d 09 	call	0x133a	; 0x133a <vQueueWaitForMessageRestricted>
    22a8:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    22ac:	81 11       	cpse	r24, r1
    22ae:	87 c0       	rjmp	.+270    	; 0x23be <prvTimerTask+0x212>
    22b0:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    22b4:	84 c0       	rjmp	.+264    	; 0x23be <prvTimerTask+0x212>
    22b6:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    22ba:	81 c0       	rjmp	.+258    	; 0x23be <prvTimerTask+0x212>
    22bc:	89 81       	ldd	r24, Y+1	; 0x01
    22be:	88 23       	and	r24, r24
    22c0:	6c f4       	brge	.+26     	; 0x22dc <prvTimerTask+0x130>
    22c2:	4e 81       	ldd	r20, Y+6	; 0x06
    22c4:	5f 81       	ldd	r21, Y+7	; 0x07
    22c6:	68 85       	ldd	r22, Y+8	; 0x08
    22c8:	79 85       	ldd	r23, Y+9	; 0x09
    22ca:	ea 81       	ldd	r30, Y+2	; 0x02
    22cc:	fb 81       	ldd	r31, Y+3	; 0x03
    22ce:	8c 81       	ldd	r24, Y+4	; 0x04
    22d0:	9d 81       	ldd	r25, Y+5	; 0x05
    22d2:	19 95       	eicall
    22d4:	89 81       	ldd	r24, Y+1	; 0x01
    22d6:	88 23       	and	r24, r24
    22d8:	0c f4       	brge	.+2      	; 0x22dc <prvTimerTask+0x130>
    22da:	71 c0       	rjmp	.+226    	; 0x23be <prvTimerTask+0x212>
    22dc:	8e 80       	ldd	r8, Y+6	; 0x06
    22de:	9f 80       	ldd	r9, Y+7	; 0x07
    22e0:	d4 01       	movw	r26, r8
    22e2:	1c 96       	adiw	r26, 0x0c	; 12
    22e4:	8d 91       	ld	r24, X+
    22e6:	9c 91       	ld	r25, X
    22e8:	1d 97       	sbiw	r26, 0x0d	; 13
    22ea:	89 2b       	or	r24, r25
    22ec:	21 f0       	breq	.+8      	; 0x22f6 <prvTimerTask+0x14a>
    22ee:	c4 01       	movw	r24, r8
    22f0:	02 96       	adiw	r24, 0x02	; 2
    22f2:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    22f6:	ce 01       	movw	r24, r28
    22f8:	0a 96       	adiw	r24, 0x0a	; 10
    22fa:	0e 94 3e 10 	call	0x207c	; 0x207c <prvSampleTimeNow>
    22fe:	8b 01       	movw	r16, r22
    2300:	9c 01       	movw	r18, r24
    2302:	89 81       	ldd	r24, Y+1	; 0x01
    2304:	08 2e       	mov	r0, r24
    2306:	00 0c       	add	r0, r0
    2308:	99 0b       	sbc	r25, r25
    230a:	aa 0b       	sbc	r26, r26
    230c:	bb 0b       	sbc	r27, r27
    230e:	8a 30       	cpi	r24, 0x0A	; 10
    2310:	91 05       	cpc	r25, r1
    2312:	08 f0       	brcs	.+2      	; 0x2316 <prvTimerTask+0x16a>
    2314:	54 c0       	rjmp	.+168    	; 0x23be <prvTimerTask+0x212>
    2316:	fc 01       	movw	r30, r24
    2318:	88 27       	eor	r24, r24
    231a:	e2 50       	subi	r30, 0x02	; 2
    231c:	ff 4f       	sbci	r31, 0xFF	; 255
    231e:	8f 4f       	sbci	r24, 0xFF	; 255
    2320:	0c 94 a4 1d 	jmp	0x3b48	; 0x3b48 <__tablejump2__>
    2324:	ca 80       	ldd	r12, Y+2	; 0x02
    2326:	db 80       	ldd	r13, Y+3	; 0x03
    2328:	ec 80       	ldd	r14, Y+4	; 0x04
    232a:	fd 80       	ldd	r15, Y+5	; 0x05
    232c:	f4 01       	movw	r30, r8
    232e:	46 85       	ldd	r20, Z+14	; 0x0e
    2330:	57 85       	ldd	r21, Z+15	; 0x0f
    2332:	60 89       	ldd	r22, Z+16	; 0x10
    2334:	71 89       	ldd	r23, Z+17	; 0x11
    2336:	4c 0d       	add	r20, r12
    2338:	5d 1d       	adc	r21, r13
    233a:	6e 1d       	adc	r22, r14
    233c:	7f 1d       	adc	r23, r15
    233e:	c4 01       	movw	r24, r8
    2340:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <prvInsertTimerInActiveList>
    2344:	88 23       	and	r24, r24
    2346:	d9 f1       	breq	.+118    	; 0x23be <prvTimerTask+0x212>
    2348:	d4 01       	movw	r26, r8
    234a:	55 96       	adiw	r26, 0x15	; 21
    234c:	ed 91       	ld	r30, X+
    234e:	fc 91       	ld	r31, X
    2350:	56 97       	sbiw	r26, 0x16	; 22
    2352:	c4 01       	movw	r24, r8
    2354:	19 95       	eicall
    2356:	f4 01       	movw	r30, r8
    2358:	82 89       	ldd	r24, Z+18	; 0x12
    235a:	81 30       	cpi	r24, 0x01	; 1
    235c:	81 f5       	brne	.+96     	; 0x23be <prvTimerTask+0x212>
    235e:	4a 81       	ldd	r20, Y+2	; 0x02
    2360:	5b 81       	ldd	r21, Y+3	; 0x03
    2362:	6c 81       	ldd	r22, Y+4	; 0x04
    2364:	7d 81       	ldd	r23, Y+5	; 0x05
    2366:	86 85       	ldd	r24, Z+14	; 0x0e
    2368:	97 85       	ldd	r25, Z+15	; 0x0f
    236a:	a0 89       	ldd	r26, Z+16	; 0x10
    236c:	b1 89       	ldd	r27, Z+17	; 0x11
    236e:	9a 01       	movw	r18, r20
    2370:	ab 01       	movw	r20, r22
    2372:	28 0f       	add	r18, r24
    2374:	39 1f       	adc	r19, r25
    2376:	4a 1f       	adc	r20, r26
    2378:	5b 1f       	adc	r21, r27
    237a:	c1 2c       	mov	r12, r1
    237c:	d1 2c       	mov	r13, r1
    237e:	76 01       	movw	r14, r12
    2380:	00 e0       	ldi	r16, 0x00	; 0
    2382:	10 e0       	ldi	r17, 0x00	; 0
    2384:	60 e0       	ldi	r22, 0x00	; 0
    2386:	c4 01       	movw	r24, r8
    2388:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <xTimerGenericCommand>
    238c:	18 c0       	rjmp	.+48     	; 0x23be <prvTimerTask+0x212>
    238e:	4a 81       	ldd	r20, Y+2	; 0x02
    2390:	5b 81       	ldd	r21, Y+3	; 0x03
    2392:	6c 81       	ldd	r22, Y+4	; 0x04
    2394:	7d 81       	ldd	r23, Y+5	; 0x05
    2396:	d4 01       	movw	r26, r8
    2398:	1e 96       	adiw	r26, 0x0e	; 14
    239a:	4d 93       	st	X+, r20
    239c:	5d 93       	st	X+, r21
    239e:	6d 93       	st	X+, r22
    23a0:	7c 93       	st	X, r23
    23a2:	51 97       	sbiw	r26, 0x11	; 17
    23a4:	40 0f       	add	r20, r16
    23a6:	51 1f       	adc	r21, r17
    23a8:	62 1f       	adc	r22, r18
    23aa:	73 1f       	adc	r23, r19
    23ac:	68 01       	movw	r12, r16
    23ae:	79 01       	movw	r14, r18
    23b0:	c4 01       	movw	r24, r8
    23b2:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <prvInsertTimerInActiveList>
    23b6:	03 c0       	rjmp	.+6      	; 0x23be <prvTimerTask+0x212>
    23b8:	c4 01       	movw	r24, r8
    23ba:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortFree>
    23be:	20 e0       	ldi	r18, 0x00	; 0
    23c0:	30 e0       	ldi	r19, 0x00	; 0
    23c2:	a9 01       	movw	r20, r18
    23c4:	6a 2d       	mov	r22, r10
    23c6:	7b 2d       	mov	r23, r11
    23c8:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <xTimerQueue>
    23cc:	90 91 b5 2c 	lds	r25, 0x2CB5	; 0x802cb5 <xTimerQueue+0x1>
    23d0:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <xQueueReceive>
    23d4:	81 11       	cpse	r24, r1
    23d6:	72 cf       	rjmp	.-284    	; 0x22bc <prvTimerTask+0x110>
    23d8:	f5 ce       	rjmp	.-534    	; 0x21c4 <prvTimerTask+0x18>
    23da:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    23de:	c1 01       	movw	r24, r2
    23e0:	0e 94 3e 10 	call	0x207c	; 0x207c <prvSampleTimeNow>
    23e4:	6b 87       	std	Y+11, r22	; 0x0b
    23e6:	7c 87       	std	Y+12, r23	; 0x0c
    23e8:	8d 87       	std	Y+13, r24	; 0x0d
    23ea:	9e 87       	std	Y+14, r25	; 0x0e
    23ec:	89 81       	ldd	r24, Y+1	; 0x01
    23ee:	81 11       	cpse	r24, r1
    23f0:	62 cf       	rjmp	.-316    	; 0x22b6 <prvTimerTask+0x10a>
    23f2:	e0 91 b6 2c 	lds	r30, 0x2CB6	; 0x802cb6 <pxOverflowTimerList>
    23f6:	f0 91 b7 2c 	lds	r31, 0x2CB7	; 0x802cb7 <pxOverflowTimerList+0x1>
    23fa:	80 81       	ld	r24, Z
    23fc:	21 e0       	ldi	r18, 0x01	; 1
    23fe:	81 11       	cpse	r24, r1
    2400:	20 e0       	ldi	r18, 0x00	; 0
    2402:	41 2c       	mov	r4, r1
    2404:	51 2c       	mov	r5, r1
    2406:	32 01       	movw	r6, r4
    2408:	3f cf       	rjmp	.-386    	; 0x2288 <prvTimerTask+0xdc>

0000240a <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
    240a:	0f 93       	push	r16
    240c:	1f 93       	push	r17
    240e:	cf 93       	push	r28
    2410:	df 93       	push	r29
    2412:	cd b7       	in	r28, 0x3d	; 61
    2414:	de b7       	in	r29, 0x3e	; 62
    2416:	29 97       	sbiw	r28, 0x09	; 9
    2418:	cd bf       	out	0x3d, r28	; 61
    241a:	de bf       	out	0x3e, r29	; 62
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    241c:	ee ef       	ldi	r30, 0xFE	; 254
    241e:	e9 83       	std	Y+1, r30	; 0x01
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    2420:	8a 83       	std	Y+2, r24	; 0x02
    2422:	9b 83       	std	Y+3, r25	; 0x03
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    2424:	6c 83       	std	Y+4, r22	; 0x04
    2426:	7d 83       	std	Y+5, r23	; 0x05
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    2428:	2e 83       	std	Y+6, r18	; 0x06
    242a:	3f 83       	std	Y+7, r19	; 0x07
    242c:	48 87       	std	Y+8, r20	; 0x08
    242e:	59 87       	std	Y+9, r21	; 0x09

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2430:	20 e0       	ldi	r18, 0x00	; 0
    2432:	a8 01       	movw	r20, r16
    2434:	be 01       	movw	r22, r28
    2436:	6f 5f       	subi	r22, 0xFF	; 255
    2438:	7f 4f       	sbci	r23, 0xFF	; 255
    243a:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <xTimerQueue>
    243e:	90 91 b5 2c 	lds	r25, 0x2CB5	; 0x802cb5 <xTimerQueue+0x1>
    2442:	0e 94 a6 08 	call	0x114c	; 0x114c <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
    2446:	29 96       	adiw	r28, 0x09	; 9
    2448:	cd bf       	out	0x3d, r28	; 61
    244a:	de bf       	out	0x3e, r29	; 62
    244c:	df 91       	pop	r29
    244e:	cf 91       	pop	r28
    2450:	1f 91       	pop	r17
    2452:	0f 91       	pop	r16
    2454:	08 95       	ret

00002456 <vInitClock>:
#include "clksys_driver.h"


void vInitClock(void)
{
	CLKSYS_Enable( OSC_RC2MEN_bm );
    2456:	e0 e5       	ldi	r30, 0x50	; 80
    2458:	f0 e0       	ldi	r31, 0x00	; 0
    245a:	80 81       	ld	r24, Z
    245c:	81 60       	ori	r24, 0x01	; 1
    245e:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC2MRDY_bm ) == 0 );
    2460:	81 81       	ldd	r24, Z+1	; 0x01
    2462:	80 ff       	sbrs	r24, 0
    2464:	fd cf       	rjmp	.-6      	; 0x2460 <vInitClock+0xa>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC2M_gc );
    2466:	80 e0       	ldi	r24, 0x00	; 0
    2468:	0e 94 77 02 	call	0x4ee	; 0x4ee <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
    246c:	8e e1       	ldi	r24, 0x1E	; 30
    246e:	0e 94 67 02 	call	0x4ce	; 0x4ce <CLKSYS_Disable>
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    2472:	60 e0       	ldi	r22, 0x00	; 0
    2474:	80 e0       	ldi	r24, 0x00	; 0
    2476:	0e 94 71 02 	call	0x4e2	; 0x4e2 <CLKSYS_Prescalers_Config>
	CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,false,OSC_XOSCSEL_XTAL_256CLK_gc );
    247a:	43 e0       	ldi	r20, 0x03	; 3
    247c:	60 e0       	ldi	r22, 0x00	; 0
    247e:	80 e4       	ldi	r24, 0x40	; 64
    2480:	0e 94 58 02 	call	0x4b0	; 0x4b0 <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
    2484:	e0 e5       	ldi	r30, 0x50	; 80
    2486:	f0 e0       	ldi	r31, 0x00	; 0
    2488:	80 81       	ld	r24, Z
    248a:	88 60       	ori	r24, 0x08	; 8
    248c:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    248e:	81 81       	ldd	r24, Z+1	; 0x01
    2490:	83 ff       	sbrs	r24, 3
    2492:	fd cf       	rjmp	.-6      	; 0x248e <vInitClock+0x38>
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 4 );
    2494:	64 e0       	ldi	r22, 0x04	; 4
    2496:	80 ec       	ldi	r24, 0xC0	; 192
    2498:	0e 94 62 02 	call	0x4c4	; 0x4c4 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    249c:	e0 e5       	ldi	r30, 0x50	; 80
    249e:	f0 e0       	ldi	r31, 0x00	; 0
    24a0:	80 81       	ld	r24, Z
    24a2:	80 61       	ori	r24, 0x10	; 16
    24a4:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    24a6:	60 e0       	ldi	r22, 0x00	; 0
    24a8:	80 e0       	ldi	r24, 0x00	; 0
    24aa:	0e 94 71 02 	call	0x4e2	; 0x4e2 <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    24ae:	e0 e5       	ldi	r30, 0x50	; 80
    24b0:	f0 e0       	ldi	r31, 0x00	; 0
    24b2:	81 81       	ldd	r24, Z+1	; 0x01
    24b4:	84 ff       	sbrs	r24, 4
    24b6:	fd cf       	rjmp	.-6      	; 0x24b2 <vInitClock+0x5c>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    24b8:	84 e0       	ldi	r24, 0x04	; 4
    24ba:	0e 94 77 02 	call	0x4ee	; 0x4ee <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm);
    24be:	87 e0       	ldi	r24, 0x07	; 7
    24c0:	0e 94 67 02 	call	0x4ce	; 0x4ce <CLKSYS_Disable>
    24c4:	08 95       	ret

000024c6 <vLedBlink>:
	return 0;
}

void vLedBlink(void *pvParameters) {
	(void) pvParameters;
	PORTF.DIRSET = PIN0_bm; /*LED1*/
    24c6:	e0 ea       	ldi	r30, 0xA0	; 160
    24c8:	f6 e0       	ldi	r31, 0x06	; 6
    24ca:	81 e0       	ldi	r24, 0x01	; 1
    24cc:	81 83       	std	Z+1, r24	; 0x01
	PORTF.OUT = 0x01;
    24ce:	84 83       	std	Z+4, r24	; 0x04
	for(;;) {
		//PORTF.OUTTGL = 0x01;				
		vTaskDelay(100 / portTICK_RATE_MS);
    24d0:	64 e6       	ldi	r22, 0x64	; 100
    24d2:	70 e0       	ldi	r23, 0x00	; 0
    24d4:	80 e0       	ldi	r24, 0x00	; 0
    24d6:	90 e0       	ldi	r25, 0x00	; 0
    24d8:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
    24dc:	f9 cf       	rjmp	.-14     	; 0x24d0 <vLedBlink+0xa>

000024de <vWrite_Display>:
void vWrite_Display(void *pvParameters){
	EventBits_t uxBits;
	for (;;)
	{
			vDisplayClear();
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    24de:	0f 2e       	mov	r0, r31
    24e0:	f1 e1       	ldi	r31, 0x11	; 17
    24e2:	ef 2e       	mov	r14, r31
    24e4:	f0 e2       	ldi	r31, 0x20	; 32
    24e6:	ff 2e       	mov	r15, r31
    24e8:	f0 2d       	mov	r31, r0
			vDisplayWriteStringAtPos(1,0,"a: %d b: %d",buffer_a[1],buffer_b[1]);
    24ea:	0f 2e       	mov	r0, r31
    24ec:	f4 ef       	ldi	r31, 0xF4	; 244
    24ee:	af 2e       	mov	r10, r31
    24f0:	fe e2       	ldi	r31, 0x2E	; 46
    24f2:	bf 2e       	mov	r11, r31
    24f4:	f0 2d       	mov	r31, r0
    24f6:	0f 2e       	mov	r0, r31
    24f8:	f6 ef       	ldi	r31, 0xF6	; 246
    24fa:	cf 2e       	mov	r12, r31
    24fc:	f6 e3       	ldi	r31, 0x36	; 54
    24fe:	df 2e       	mov	r13, r31
    2500:	f0 2d       	mov	r31, r0
    2502:	01 e2       	ldi	r16, 0x21	; 33
    2504:	10 e2       	ldi	r17, 0x20	; 32
    2506:	55 24       	eor	r5, r5
    2508:	53 94       	inc	r5
			vDisplayWriteStringAtPos(2,0,"H: %d L: %d ",high_peak, low_peak);
    250a:	cd e2       	ldi	r28, 0x2D	; 45
    250c:	d0 e2       	ldi	r29, 0x20	; 32
    250e:	68 94       	set
    2510:	66 24       	eor	r6, r6
    2512:	61 f8       	bld	r6, 1
			vDisplayWriteStringAtPos(3,0,"Hoi");
    2514:	0f 2e       	mov	r0, r31
    2516:	fa e3       	ldi	r31, 0x3A	; 58
    2518:	8f 2e       	mov	r8, r31
    251a:	f0 e2       	ldi	r31, 0x20	; 32
    251c:	9f 2e       	mov	r9, r31
    251e:	f0 2d       	mov	r31, r0
    2520:	0f 2e       	mov	r0, r31
    2522:	f3 e0       	ldi	r31, 0x03	; 3
    2524:	7f 2e       	mov	r7, r31
    2526:	f0 2d       	mov	r31, r0
}
void vWrite_Display(void *pvParameters){
	EventBits_t uxBits;
	for (;;)
	{
			vDisplayClear();
    2528:	0e 94 d9 16 	call	0x2db2	; 0x2db2 <vDisplayClear>
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    252c:	ff 92       	push	r15
    252e:	ef 92       	push	r14
    2530:	1f 92       	push	r1
    2532:	1f 92       	push	r1
    2534:	1f 92       	push	r1
    2536:	1f 92       	push	r1
    2538:	0e 94 e4 16 	call	0x2dc8	; 0x2dc8 <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(1,0,"a: %d b: %d",buffer_a[1],buffer_b[1]);
    253c:	f5 01       	movw	r30, r10
    253e:	91 81       	ldd	r25, Z+1	; 0x01
    2540:	f6 01       	movw	r30, r12
    2542:	81 81       	ldd	r24, Z+1	; 0x01
    2544:	1f 92       	push	r1
    2546:	9f 93       	push	r25
    2548:	1f 92       	push	r1
    254a:	8f 93       	push	r24
    254c:	1f 93       	push	r17
    254e:	0f 93       	push	r16
    2550:	1f 92       	push	r1
    2552:	1f 92       	push	r1
    2554:	1f 92       	push	r1
    2556:	5f 92       	push	r5
    2558:	0e 94 e4 16 	call	0x2dc8	; 0x2dc8 <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(2,0,"H: %d L: %d ",high_peak, low_peak);
    255c:	80 91 01 20 	lds	r24, 0x2001	; 0x802001 <__data_start+0x1>
    2560:	8f 93       	push	r24
    2562:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    2566:	8f 93       	push	r24
    2568:	80 91 03 20 	lds	r24, 0x2003	; 0x802003 <high_peak+0x1>
    256c:	8f 93       	push	r24
    256e:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <high_peak>
    2572:	8f 93       	push	r24
    2574:	df 93       	push	r29
    2576:	cf 93       	push	r28
    2578:	1f 92       	push	r1
    257a:	1f 92       	push	r1
    257c:	1f 92       	push	r1
    257e:	6f 92       	push	r6
    2580:	0e 94 e4 16 	call	0x2dc8	; 0x2dc8 <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(3,0,"Hoi");
    2584:	9f 92       	push	r9
    2586:	8f 92       	push	r8
    2588:	1f 92       	push	r1
    258a:	1f 92       	push	r1
    258c:	1f 92       	push	r1
    258e:	7f 92       	push	r7
    2590:	0e 94 e4 16 	call	0x2dc8	; 0x2dc8 <vDisplayWriteStringAtPos>
			vTaskStartScheduler();
    2594:	ed b7       	in	r30, 0x3d	; 61
    2596:	fe b7       	in	r31, 0x3e	; 62
    2598:	b0 96       	adiw	r30, 0x20	; 32
    259a:	ed bf       	out	0x3d, r30	; 61
    259c:	fe bf       	out	0x3e, r31	; 62
    259e:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <vTaskStartScheduler>
			vTaskDelay(100 / portTICK_RATE_MS);
    25a2:	64 e6       	ldi	r22, 0x64	; 100
    25a4:	70 e0       	ldi	r23, 0x00	; 0
    25a6:	80 e0       	ldi	r24, 0x00	; 0
    25a8:	90 e0       	ldi	r25, 0x00	; 0
    25aa:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
    25ae:	bc cf       	rjmp	.-136    	; 0x2528 <vWrite_Display+0x4a>

000025b0 <vRead_DMA>:
						if (buffer_b[i] > 100)
						{
							neg_peak_array[count_array_position_L] = low_peak;
							position_array_L[count_array_position_L] = position_low_peak_b;
							count_array_position_L++;
							low_peak = 127;
    25b0:	df e7       	ldi	r29, 0x7F	; 127
    25b2:	c0 e0       	ldi	r28, 0x00	; 0
	int i = 0;
	int pos_peak_array[2048], neg_peak_array[2048], position_array_H[2048], position_array_L[2048];
	EventBits_t uxBits;
	for (;;)
	{			
		uxBits = xEventGroupWaitBits(
    25b4:	cc 24       	eor	r12, r12
    25b6:	ca 94       	dec	r12
    25b8:	dc 2c       	mov	r13, r12
    25ba:	76 01       	movw	r14, r12
    25bc:	00 e0       	ldi	r16, 0x00	; 0
    25be:	21 e0       	ldi	r18, 0x01	; 1
    25c0:	43 e0       	ldi	r20, 0x03	; 3
    25c2:	50 e0       	ldi	r21, 0x00	; 0
    25c4:	60 e0       	ldi	r22, 0x00	; 0
    25c6:	70 e0       	ldi	r23, 0x00	; 0
    25c8:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <xSignalProcessEventGroup>
    25cc:	90 91 f7 2d 	lds	r25, 0x2DF7	; 0x802df7 <xSignalProcessEventGroup+0x1>
    25d0:	0e 94 bd 02 	call	0x57a	; 0x57a <xEventGroupWaitBits>
								Process_Signal_BufferA | Process_Signal_BufferB, /* The bits within the event group to wait for. */
								pdTRUE,        /* Bits should be cleared before returning. */
								pdFALSE,       /* Don't wait for both bits, either bit will do. */
								portMAX_DELAY );/* Wait a maximum for either bit to be set. */								
		//process signal values
		if (uxBits & Process_Signal_BufferA) // if "BufferA" bit is set, read out bufferA
    25d4:	60 ff       	sbrs	r22, 0
    25d6:	6b c0       	rjmp	.+214    	; 0x26ae <vRead_DMA+0xfe>
    25d8:	60 91 02 20 	lds	r22, 0x2002	; 0x802002 <high_peak>
    25dc:	70 91 03 20 	lds	r23, 0x2003	; 0x802003 <high_peak+0x1>
    25e0:	00 91 f7 3e 	lds	r16, 0x3EF7	; 0x803ef7 <position_high_peak_a>
    25e4:	10 91 f8 3e 	lds	r17, 0x3EF8	; 0x803ef8 <position_high_peak_a+0x1>
    25e8:	40 91 00 20 	lds	r20, 0x2000	; 0x802000 <__data_start>
    25ec:	50 91 01 20 	lds	r21, 0x2001	; 0x802001 <__data_start+0x1>
    25f0:	b0 91 ff 3e 	lds	r27, 0x3EFF	; 0x803eff <position_low_peak_a>
    25f4:	a0 91 00 3f 	lds	r26, 0x3F00	; 0x803f00 <position_low_peak_a+0x1>
    25f8:	80 e0       	ldi	r24, 0x00	; 0
    25fa:	90 e0       	ldi	r25, 0x00	; 0
		{
			i = 0;
			for(i=0;i<3;i++)
			{
				// HIGH PEAK A
				if (buffer_a[i] > 127)
    25fc:	fc 01       	movw	r30, r24
    25fe:	ea 50       	subi	r30, 0x0A	; 10
    2600:	f9 4c       	sbci	r31, 0xC9	; 201
    2602:	20 81       	ld	r18, Z
    2604:	22 23       	and	r18, r18
    2606:	fc f4       	brge	.+62     	; 0x2646 <vRead_DMA+0x96>
				{
					if (buffer_a[i] > high_peak)	//if buffer bigger than current high_peak
    2608:	fc 01       	movw	r30, r24
    260a:	ea 50       	subi	r30, 0x0A	; 10
    260c:	f9 4c       	sbci	r31, 0xC9	; 201
    260e:	20 81       	ld	r18, Z
    2610:	30 e0       	ldi	r19, 0x00	; 0
    2612:	62 17       	cp	r22, r18
    2614:	73 07       	cpc	r23, r19
    2616:	74 f4       	brge	.+28     	; 0x2634 <vRead_DMA+0x84>
					{
						if (buffer_a[i] > 220)
    2618:	fc 01       	movw	r30, r24
    261a:	ea 50       	subi	r30, 0x0A	; 10
    261c:	f9 4c       	sbci	r31, 0xC9	; 201
    261e:	20 81       	ld	r18, Z
    2620:	2d 3d       	cpi	r18, 0xDD	; 221
    2622:	78 f1       	brcs	.+94     	; 0x2682 <vRead_DMA+0xd2>
						{
							high_peak = buffer_a[i];	// store new peak
    2624:	fc 01       	movw	r30, r24
    2626:	ea 50       	subi	r30, 0x0A	; 10
    2628:	f9 4c       	sbci	r31, 0xC9	; 201
    262a:	60 81       	ld	r22, Z
    262c:	70 e0       	ldi	r23, 0x00	; 0
							position_high_peak_a = i;	// store array position of new peak
    262e:	08 2f       	mov	r16, r24
    2630:	19 2f       	mov	r17, r25
    2632:	27 c0       	rjmp	.+78     	; 0x2682 <vRead_DMA+0xd2>
						}
					}	
					else 
					{
						if(buffer_a[i] < 160)
    2634:	fc 01       	movw	r30, r24
    2636:	ea 50       	subi	r30, 0x0A	; 10
    2638:	f9 4c       	sbci	r31, 0xC9	; 201
    263a:	20 81       	ld	r18, Z
    263c:	20 3a       	cpi	r18, 0xA0	; 160
    263e:	08 f5       	brcc	.+66     	; 0x2682 <vRead_DMA+0xd2>
						{
							pos_peak_array[count_array_position_H] = high_peak;	//
							position_array_H[count_array_position_H] = position_high_peak_a;
							count_array_position_H++;
							high_peak = 127;
    2640:	6d 2f       	mov	r22, r29
    2642:	7c 2f       	mov	r23, r28
    2644:	1e c0       	rjmp	.+60     	; 0x2682 <vRead_DMA+0xd2>
					}
				}
				// LOW PEAK	A
				else 
				{
					if (buffer_a[i] < low_peak)		//if buffer bigger than current high_peak
    2646:	fc 01       	movw	r30, r24
    2648:	ea 50       	subi	r30, 0x0A	; 10
    264a:	f9 4c       	sbci	r31, 0xC9	; 201
    264c:	20 81       	ld	r18, Z
    264e:	30 e0       	ldi	r19, 0x00	; 0
    2650:	24 17       	cp	r18, r20
    2652:	35 07       	cpc	r19, r21
    2654:	74 f4       	brge	.+28     	; 0x2672 <vRead_DMA+0xc2>
					{
						if (buffer_a[i] < 35)
    2656:	fc 01       	movw	r30, r24
    2658:	ea 50       	subi	r30, 0x0A	; 10
    265a:	f9 4c       	sbci	r31, 0xC9	; 201
    265c:	20 81       	ld	r18, Z
    265e:	23 32       	cpi	r18, 0x23	; 35
    2660:	80 f4       	brcc	.+32     	; 0x2682 <vRead_DMA+0xd2>
						{
							low_peak = buffer_a[i];	// store new peak
    2662:	fc 01       	movw	r30, r24
    2664:	ea 50       	subi	r30, 0x0A	; 10
    2666:	f9 4c       	sbci	r31, 0xC9	; 201
    2668:	40 81       	ld	r20, Z
    266a:	50 e0       	ldi	r21, 0x00	; 0
							position_low_peak_a = i;	// store array position of new peak
    266c:	b8 2f       	mov	r27, r24
    266e:	a9 2f       	mov	r26, r25
    2670:	08 c0       	rjmp	.+16     	; 0x2682 <vRead_DMA+0xd2>
						}
					}
					else
					{
						if (buffer_a[i] > 100)
    2672:	fc 01       	movw	r30, r24
    2674:	ea 50       	subi	r30, 0x0A	; 10
    2676:	f9 4c       	sbci	r31, 0xC9	; 201
    2678:	20 81       	ld	r18, Z
    267a:	25 36       	cpi	r18, 0x65	; 101
    267c:	10 f0       	brcs	.+4      	; 0x2682 <vRead_DMA+0xd2>
						{
							neg_peak_array[count_array_position_L] = low_peak;
							position_array_L[count_array_position_L] = position_low_peak_a;
							count_array_position_L++;
							low_peak = 127;
    267e:	4d 2f       	mov	r20, r29
    2680:	5c 2f       	mov	r21, r28
								portMAX_DELAY );/* Wait a maximum for either bit to be set. */								
		//process signal values
		if (uxBits & Process_Signal_BufferA) // if "BufferA" bit is set, read out bufferA
		{
			i = 0;
			for(i=0;i<3;i++)
    2682:	01 96       	adiw	r24, 0x01	; 1
    2684:	83 30       	cpi	r24, 0x03	; 3
    2686:	91 05       	cpc	r25, r1
    2688:	09 f0       	breq	.+2      	; 0x268c <vRead_DMA+0xdc>
    268a:	b8 cf       	rjmp	.-144    	; 0x25fc <vRead_DMA+0x4c>
    268c:	40 93 00 20 	sts	0x2000, r20	; 0x802000 <__data_start>
    2690:	50 93 01 20 	sts	0x2001, r21	; 0x802001 <__data_start+0x1>
    2694:	60 93 02 20 	sts	0x2002, r22	; 0x802002 <high_peak>
    2698:	70 93 03 20 	sts	0x2003, r23	; 0x802003 <high_peak+0x1>
    269c:	00 93 f7 3e 	sts	0x3EF7, r16	; 0x803ef7 <position_high_peak_a>
    26a0:	10 93 f8 3e 	sts	0x3EF8, r17	; 0x803ef8 <position_high_peak_a+0x1>
    26a4:	b0 93 ff 3e 	sts	0x3EFF, r27	; 0x803eff <position_low_peak_a>
    26a8:	a0 93 00 3f 	sts	0x3F00, r26	; 0x803f00 <position_low_peak_a+0x1>
    26ac:	6c c0       	rjmp	.+216    	; 0x2786 <vRead_DMA+0x1d6>
						}
					}	
				}	
			}
		}
		else if (uxBits & Process_Signal_BufferB)
    26ae:	61 ff       	sbrs	r22, 1
    26b0:	6a c0       	rjmp	.+212    	; 0x2786 <vRead_DMA+0x1d6>
    26b2:	60 91 02 20 	lds	r22, 0x2002	; 0x802002 <high_peak>
    26b6:	70 91 03 20 	lds	r23, 0x2003	; 0x802003 <high_peak+0x1>
    26ba:	00 91 05 3f 	lds	r16, 0x3F05	; 0x803f05 <position_high_peak_b>
    26be:	10 91 06 3f 	lds	r17, 0x3F06	; 0x803f06 <position_high_peak_b+0x1>
    26c2:	40 91 00 20 	lds	r20, 0x2000	; 0x802000 <__data_start>
    26c6:	50 91 01 20 	lds	r21, 0x2001	; 0x802001 <__data_start+0x1>
    26ca:	b0 91 fb 3e 	lds	r27, 0x3EFB	; 0x803efb <position_low_peak_b>
    26ce:	a0 91 fc 3e 	lds	r26, 0x3EFC	; 0x803efc <position_low_peak_b+0x1>
    26d2:	80 e0       	ldi	r24, 0x00	; 0
    26d4:	90 e0       	ldi	r25, 0x00	; 0
		{
			for (i=0;i<3;i++)
			{
				// HIGH PEAK B
				if (buffer_b[i] > 127)
    26d6:	fc 01       	movw	r30, r24
    26d8:	ec 50       	subi	r30, 0x0C	; 12
    26da:	f1 4d       	sbci	r31, 0xD1	; 209
    26dc:	20 81       	ld	r18, Z
    26de:	22 23       	and	r18, r18
    26e0:	fc f4       	brge	.+62     	; 0x2720 <vRead_DMA+0x170>
				{
					if (buffer_b[i] > high_peak)	//if buffer bigger than current high_peak
    26e2:	fc 01       	movw	r30, r24
    26e4:	ec 50       	subi	r30, 0x0C	; 12
    26e6:	f1 4d       	sbci	r31, 0xD1	; 209
    26e8:	20 81       	ld	r18, Z
    26ea:	30 e0       	ldi	r19, 0x00	; 0
    26ec:	62 17       	cp	r22, r18
    26ee:	73 07       	cpc	r23, r19
    26f0:	74 f4       	brge	.+28     	; 0x270e <vRead_DMA+0x15e>
					{
						if (buffer_b[i] > 220)
    26f2:	fc 01       	movw	r30, r24
    26f4:	ec 50       	subi	r30, 0x0C	; 12
    26f6:	f1 4d       	sbci	r31, 0xD1	; 209
    26f8:	20 81       	ld	r18, Z
    26fa:	2d 3d       	cpi	r18, 0xDD	; 221
    26fc:	78 f1       	brcs	.+94     	; 0x275c <vRead_DMA+0x1ac>
						{
							high_peak = buffer_b[i];	// store new peak
    26fe:	fc 01       	movw	r30, r24
    2700:	ec 50       	subi	r30, 0x0C	; 12
    2702:	f1 4d       	sbci	r31, 0xD1	; 209
    2704:	60 81       	ld	r22, Z
    2706:	70 e0       	ldi	r23, 0x00	; 0
							position_high_peak_b = i;	// store array position of new peak
    2708:	08 2f       	mov	r16, r24
    270a:	19 2f       	mov	r17, r25
    270c:	27 c0       	rjmp	.+78     	; 0x275c <vRead_DMA+0x1ac>
						}
					}
					else
					{
						if(buffer_b[i] < 160)
    270e:	fc 01       	movw	r30, r24
    2710:	ec 50       	subi	r30, 0x0C	; 12
    2712:	f1 4d       	sbci	r31, 0xD1	; 209
    2714:	20 81       	ld	r18, Z
    2716:	20 3a       	cpi	r18, 0xA0	; 160
    2718:	08 f5       	brcc	.+66     	; 0x275c <vRead_DMA+0x1ac>
						{
							pos_peak_array[count_array_position_H] = high_peak;	//
							position_array_H[count_array_position_H] = position_high_peak_b;
							count_array_position_H++;
							high_peak = 127;
    271a:	6d 2f       	mov	r22, r29
    271c:	7c 2f       	mov	r23, r28
    271e:	1e c0       	rjmp	.+60     	; 0x275c <vRead_DMA+0x1ac>
					}
				}
				// LOW PEAK	B				
				else
				{
					if (buffer_b[i] < low_peak)		//if buffer bigger than current high_peak
    2720:	fc 01       	movw	r30, r24
    2722:	ec 50       	subi	r30, 0x0C	; 12
    2724:	f1 4d       	sbci	r31, 0xD1	; 209
    2726:	20 81       	ld	r18, Z
    2728:	30 e0       	ldi	r19, 0x00	; 0
    272a:	24 17       	cp	r18, r20
    272c:	35 07       	cpc	r19, r21
    272e:	74 f4       	brge	.+28     	; 0x274c <vRead_DMA+0x19c>
					{
						if (buffer_b[i] < 35)
    2730:	fc 01       	movw	r30, r24
    2732:	ec 50       	subi	r30, 0x0C	; 12
    2734:	f1 4d       	sbci	r31, 0xD1	; 209
    2736:	20 81       	ld	r18, Z
    2738:	23 32       	cpi	r18, 0x23	; 35
    273a:	80 f4       	brcc	.+32     	; 0x275c <vRead_DMA+0x1ac>
						{
							low_peak = buffer_b[i];	// store new peak
    273c:	fc 01       	movw	r30, r24
    273e:	ec 50       	subi	r30, 0x0C	; 12
    2740:	f1 4d       	sbci	r31, 0xD1	; 209
    2742:	40 81       	ld	r20, Z
    2744:	50 e0       	ldi	r21, 0x00	; 0
							position_low_peak_b = i;	// store array position of new peak
    2746:	b8 2f       	mov	r27, r24
    2748:	a9 2f       	mov	r26, r25
    274a:	08 c0       	rjmp	.+16     	; 0x275c <vRead_DMA+0x1ac>
						}
					}
					else
					{
						if (buffer_b[i] > 100)
    274c:	fc 01       	movw	r30, r24
    274e:	ec 50       	subi	r30, 0x0C	; 12
    2750:	f1 4d       	sbci	r31, 0xD1	; 209
    2752:	20 81       	ld	r18, Z
    2754:	25 36       	cpi	r18, 0x65	; 101
    2756:	10 f0       	brcs	.+4      	; 0x275c <vRead_DMA+0x1ac>
						{
							neg_peak_array[count_array_position_L] = low_peak;
							position_array_L[count_array_position_L] = position_low_peak_b;
							count_array_position_L++;
							low_peak = 127;
    2758:	4d 2f       	mov	r20, r29
    275a:	5c 2f       	mov	r21, r28
				}	
			}
		}
		else if (uxBits & Process_Signal_BufferB)
		{
			for (i=0;i<3;i++)
    275c:	01 96       	adiw	r24, 0x01	; 1
    275e:	83 30       	cpi	r24, 0x03	; 3
    2760:	91 05       	cpc	r25, r1
    2762:	09 f0       	breq	.+2      	; 0x2766 <vRead_DMA+0x1b6>
    2764:	b8 cf       	rjmp	.-144    	; 0x26d6 <vRead_DMA+0x126>
    2766:	40 93 00 20 	sts	0x2000, r20	; 0x802000 <__data_start>
    276a:	50 93 01 20 	sts	0x2001, r21	; 0x802001 <__data_start+0x1>
    276e:	60 93 02 20 	sts	0x2002, r22	; 0x802002 <high_peak>
    2772:	70 93 03 20 	sts	0x2003, r23	; 0x802003 <high_peak+0x1>
    2776:	b0 93 fb 3e 	sts	0x3EFB, r27	; 0x803efb <position_low_peak_b>
    277a:	a0 93 fc 3e 	sts	0x3EFC, r26	; 0x803efc <position_low_peak_b+0x1>
    277e:	00 93 05 3f 	sts	0x3F05, r16	; 0x803f05 <position_high_peak_b>
    2782:	10 93 06 3f 	sts	0x3F06, r17	; 0x803f06 <position_high_peak_b+0x1>
						}
					}
				}
			}
		}
		vTaskDelay(100 / portTICK_RATE_MS);
    2786:	64 e6       	ldi	r22, 0x64	; 100
    2788:	70 e0       	ldi	r23, 0x00	; 0
    278a:	80 e0       	ldi	r24, 0x00	; 0
    278c:	90 e0       	ldi	r25, 0x00	; 0
    278e:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
	}
    2792:	10 cf       	rjmp	.-480    	; 0x25b4 <vRead_DMA+0x4>

00002794 <vApplicationIdleHook>:
int count_after_high_peak, count_after_low_peak;
int sinus_status;		// 0 = rising up; 1 = rising down


void vApplicationIdleHook( void )
{	
    2794:	08 95       	ret

00002796 <main>:
	
}

int main(void)
{
    2796:	ef 92       	push	r14
    2798:	ff 92       	push	r15
    279a:	0f 93       	push	r16
    279c:	cf 93       	push	r28
    resetReason_t reason = getResetReason();
    279e:	0e 94 40 1b 	call	0x3680	; 0x3680 <getResetReason>
    27a2:	c8 2f       	mov	r28, r24

	vInitClock();
    27a4:	0e 94 2b 12 	call	0x2456	; 0x2456 <vInitClock>
	vInitDisplay();
    27a8:	0e 94 5d 15 	call	0x2aba	; 0x2aba <vInitDisplay>
	
	xTaskCreate( vLedBlink, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+10, NULL, 1, &ledTask);
    27ac:	0f 2e       	mov	r0, r31
    27ae:	f9 ef       	ldi	r31, 0xF9	; 249
    27b0:	ef 2e       	mov	r14, r31
    27b2:	fe e3       	ldi	r31, 0x3E	; 62
    27b4:	ff 2e       	mov	r15, r31
    27b6:	f0 2d       	mov	r31, r0
    27b8:	01 e0       	ldi	r16, 0x01	; 1
    27ba:	20 e0       	ldi	r18, 0x00	; 0
    27bc:	30 e0       	ldi	r19, 0x00	; 0
    27be:	42 ed       	ldi	r20, 0xD2	; 210
    27c0:	50 e0       	ldi	r21, 0x00	; 0
    27c2:	6e e3       	ldi	r22, 0x3E	; 62
    27c4:	70 e2       	ldi	r23, 0x20	; 32
    27c6:	83 e6       	ldi	r24, 0x63	; 99
    27c8:	92 e1       	ldi	r25, 0x12	; 18
    27ca:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xTaskCreate( vRead_DMA, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+500, NULL, 1, &my_read_DMA);
    27ce:	0f 2e       	mov	r0, r31
    27d0:	fd ef       	ldi	r31, 0xFD	; 253
    27d2:	ef 2e       	mov	r14, r31
    27d4:	fe e3       	ldi	r31, 0x3E	; 62
    27d6:	ff 2e       	mov	r15, r31
    27d8:	f0 2d       	mov	r31, r0
    27da:	20 e0       	ldi	r18, 0x00	; 0
    27dc:	30 e0       	ldi	r19, 0x00	; 0
    27de:	4c eb       	ldi	r20, 0xBC	; 188
    27e0:	52 e0       	ldi	r21, 0x02	; 2
    27e2:	6e e3       	ldi	r22, 0x3E	; 62
    27e4:	70 e2       	ldi	r23, 0x20	; 32
    27e6:	88 ed       	ldi	r24, 0xD8	; 216
    27e8:	92 e1       	ldi	r25, 0x12	; 18
    27ea:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xTaskCreate( vWrite_Display, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+10, NULL, 1, &my_Display);
    27ee:	0f 2e       	mov	r0, r31
    27f0:	f9 e0       	ldi	r31, 0x09	; 9
    27f2:	ef 2e       	mov	r14, r31
    27f4:	ff e3       	ldi	r31, 0x3F	; 63
    27f6:	ff 2e       	mov	r15, r31
    27f8:	f0 2d       	mov	r31, r0
    27fa:	20 e0       	ldi	r18, 0x00	; 0
    27fc:	30 e0       	ldi	r19, 0x00	; 0
    27fe:	42 ed       	ldi	r20, 0xD2	; 210
    2800:	50 e0       	ldi	r21, 0x00	; 0
    2802:	6e e3       	ldi	r22, 0x3E	; 62
    2804:	70 e2       	ldi	r23, 0x20	; 32
    2806:	8f e6       	ldi	r24, 0x6F	; 111
    2808:	92 e1       	ldi	r25, 0x12	; 18
    280a:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xTaskCreate( vTask_DMAHandler, (const char *) "dmaHandler", configMINIMAL_STACK_SIZE + 100, NULL, 1, &TaskDMAHandler);		
    280e:	0f 2e       	mov	r0, r31
    2810:	fb e0       	ldi	r31, 0x0B	; 11
    2812:	ef 2e       	mov	r14, r31
    2814:	ff e3       	ldi	r31, 0x3F	; 63
    2816:	ff 2e       	mov	r15, r31
    2818:	f0 2d       	mov	r31, r0
    281a:	20 e0       	ldi	r18, 0x00	; 0
    281c:	30 e0       	ldi	r19, 0x00	; 0
    281e:	4c e2       	ldi	r20, 0x2C	; 44
    2820:	51 e0       	ldi	r21, 0x01	; 1
    2822:	67 e4       	ldi	r22, 0x47	; 71
    2824:	70 e2       	ldi	r23, 0x20	; 32
    2826:	87 e8       	ldi	r24, 0x87	; 135
    2828:	9a e1       	ldi	r25, 0x1A	; 26
    282a:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xSignalProcessEventGroup = xEventGroupCreate();
    282e:	0e 94 a8 02 	call	0x550	; 0x550 <xEventGroupCreate>
    2832:	80 93 f6 2d 	sts	0x2DF6, r24	; 0x802df6 <xSignalProcessEventGroup>
    2836:	90 93 f7 2d 	sts	0x2DF7, r25	; 0x802df7 <xSignalProcessEventGroup+0x1>
	vInitDMA();			
    283a:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <vInitDMA>

	vDisplayClear();
    283e:	0e 94 d9 16 	call	0x2db2	; 0x2db2 <vDisplayClear>
	vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    2842:	81 e1       	ldi	r24, 0x11	; 17
    2844:	90 e2       	ldi	r25, 0x20	; 32
    2846:	9f 93       	push	r25
    2848:	8f 93       	push	r24
    284a:	1f 92       	push	r1
    284c:	1f 92       	push	r1
    284e:	1f 92       	push	r1
    2850:	1f 92       	push	r1
    2852:	0e 94 e4 16 	call	0x2dc8	; 0x2dc8 <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(1,0,"EDUBoard 1.0");
    2856:	82 e5       	ldi	r24, 0x52	; 82
    2858:	90 e2       	ldi	r25, 0x20	; 32
    285a:	9f 93       	push	r25
    285c:	8f 93       	push	r24
    285e:	1f 92       	push	r1
    2860:	1f 92       	push	r1
    2862:	1f 92       	push	r1
    2864:	81 e0       	ldi	r24, 0x01	; 1
    2866:	8f 93       	push	r24
    2868:	0e 94 e4 16 	call	0x2dc8	; 0x2dc8 <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(2,0,"Template");
    286c:	8f e5       	ldi	r24, 0x5F	; 95
    286e:	90 e2       	ldi	r25, 0x20	; 32
    2870:	9f 93       	push	r25
    2872:	8f 93       	push	r24
    2874:	1f 92       	push	r1
    2876:	1f 92       	push	r1
    2878:	1f 92       	push	r1
    287a:	82 e0       	ldi	r24, 0x02	; 2
    287c:	8f 93       	push	r24
    287e:	0e 94 e4 16 	call	0x2dc8	; 0x2dc8 <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(3,0,"ResetReason: %d", reason);
    2882:	1f 92       	push	r1
    2884:	cf 93       	push	r28
    2886:	88 e6       	ldi	r24, 0x68	; 104
    2888:	90 e2       	ldi	r25, 0x20	; 32
    288a:	9f 93       	push	r25
    288c:	8f 93       	push	r24
    288e:	1f 92       	push	r1
    2890:	1f 92       	push	r1
    2892:	1f 92       	push	r1
    2894:	83 e0       	ldi	r24, 0x03	; 3
    2896:	8f 93       	push	r24
    2898:	0e 94 e4 16 	call	0x2dc8	; 0x2dc8 <vDisplayWriteStringAtPos>
	vTaskStartScheduler();
    289c:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <vTaskStartScheduler>
    28a0:	8d b7       	in	r24, 0x3d	; 61
    28a2:	9e b7       	in	r25, 0x3e	; 62
    28a4:	4a 96       	adiw	r24, 0x1a	; 26
    28a6:	8d bf       	out	0x3d, r24	; 61
    28a8:	9e bf       	out	0x3e, r25	; 62
	return 0;
}
    28aa:	80 e0       	ldi	r24, 0x00	; 0
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	cf 91       	pop	r28
    28b0:	0f 91       	pop	r16
    28b2:	ff 90       	pop	r15
    28b4:	ef 90       	pop	r14
    28b6:	08 95       	ret

000028b8 <__vector_108>:
 void displayHome() {
	 command(0x02);
 }
 void _displayClear() {
	 command(0x01);
	 delayUS(2000);
    28b8:	1f 92       	push	r1
    28ba:	0f 92       	push	r0
    28bc:	0f b6       	in	r0, 0x3f	; 63
    28be:	0f 92       	push	r0
    28c0:	11 24       	eor	r1, r1
    28c2:	0b b6       	in	r0, 0x3b	; 59
    28c4:	0f 92       	push	r0
    28c6:	2f 93       	push	r18
    28c8:	3f 93       	push	r19
    28ca:	4f 93       	push	r20
    28cc:	5f 93       	push	r21
    28ce:	6f 93       	push	r22
    28d0:	7f 93       	push	r23
    28d2:	8f 93       	push	r24
    28d4:	9f 93       	push	r25
    28d6:	af 93       	push	r26
    28d8:	bf 93       	push	r27
    28da:	ef 93       	push	r30
    28dc:	ff 93       	push	r31
    28de:	cf 93       	push	r28
    28e0:	df 93       	push	r29
    28e2:	1f 92       	push	r1
    28e4:	cd b7       	in	r28, 0x3d	; 61
    28e6:	de b7       	in	r29, 0x3e	; 62
    28e8:	19 82       	std	Y+1, r1	; 0x01
    28ea:	9e 01       	movw	r18, r28
    28ec:	2f 5f       	subi	r18, 0xFF	; 255
    28ee:	3f 4f       	sbci	r19, 0xFF	; 255
    28f0:	41 e0       	ldi	r20, 0x01	; 1
    28f2:	50 e0       	ldi	r21, 0x00	; 0
    28f4:	60 e0       	ldi	r22, 0x00	; 0
    28f6:	70 e0       	ldi	r23, 0x00	; 0
    28f8:	80 91 0f 3f 	lds	r24, 0x3F0F	; 0x803f0f <egDisplayTiming>
    28fc:	90 91 10 3f 	lds	r25, 0x3F10	; 0x803f10 <egDisplayTiming+0x1>
    2900:	0e 94 38 04 	call	0x870	; 0x870 <xEventGroupSetBitsFromISR>
    2904:	60 e0       	ldi	r22, 0x00	; 0
    2906:	80 e0       	ldi	r24, 0x00	; 0
    2908:	9b e0       	ldi	r25, 0x0B	; 11
    290a:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
    290e:	10 92 06 0b 	sts	0x0B06, r1	; 0x800b06 <__TEXT_REGION_LENGTH__+0x700b06>
    2912:	0f 90       	pop	r0
    2914:	df 91       	pop	r29
    2916:	cf 91       	pop	r28
    2918:	ff 91       	pop	r31
    291a:	ef 91       	pop	r30
    291c:	bf 91       	pop	r27
    291e:	af 91       	pop	r26
    2920:	9f 91       	pop	r25
    2922:	8f 91       	pop	r24
    2924:	7f 91       	pop	r23
    2926:	6f 91       	pop	r22
    2928:	5f 91       	pop	r21
    292a:	4f 91       	pop	r20
    292c:	3f 91       	pop	r19
    292e:	2f 91       	pop	r18
    2930:	0f 90       	pop	r0
    2932:	0b be       	out	0x3b, r0	; 59
    2934:	0f 90       	pop	r0
    2936:	0f be       	out	0x3f, r0	; 63
    2938:	0f 90       	pop	r0
    293a:	1f 90       	pop	r1
    293c:	18 95       	reti

0000293e <delayUS>:
    293e:	cf 92       	push	r12
    2940:	df 92       	push	r13
    2942:	ef 92       	push	r14
    2944:	ff 92       	push	r15
    2946:	0f 93       	push	r16
    2948:	6b 01       	movw	r12, r22
    294a:	7c 01       	movw	r14, r24
    294c:	82 e0       	ldi	r24, 0x02	; 2
    294e:	c8 16       	cp	r12, r24
    2950:	d1 04       	cpc	r13, r1
    2952:	e1 04       	cpc	r14, r1
    2954:	f1 04       	cpc	r15, r1
    2956:	08 f4       	brcc	.+2      	; 0x295a <delayUS+0x1c>
    2958:	4e c0       	rjmp	.+156    	; 0x29f6 <delayUS+0xb8>
    295a:	e0 e0       	ldi	r30, 0x00	; 0
    295c:	fb e0       	ldi	r31, 0x0B	; 11
    295e:	81 e0       	ldi	r24, 0x01	; 1
    2960:	86 83       	std	Z+6, r24	; 0x06
    2962:	10 a2       	std	Z+32, r1	; 0x20
    2964:	11 a2       	std	Z+33, r1	; 0x21
    2966:	60 e0       	ldi	r22, 0x00	; 0
    2968:	80 e0       	ldi	r24, 0x00	; 0
    296a:	9b e0       	ldi	r25, 0x0B	; 11
    296c:	0e 94 92 02 	call	0x524	; 0x524 <TC0_ConfigWGM>
    2970:	8e ef       	ldi	r24, 0xFE	; 254
    2972:	c8 16       	cp	r12, r24
    2974:	8f ef       	ldi	r24, 0xFF	; 255
    2976:	d8 06       	cpc	r13, r24
    2978:	e1 04       	cpc	r14, r1
    297a:	f1 04       	cpc	r15, r1
    297c:	70 f4       	brcc	.+28     	; 0x299a <delayUS+0x5c>
    297e:	f6 94       	lsr	r15
    2980:	e7 94       	ror	r14
    2982:	d7 94       	ror	r13
    2984:	c7 94       	ror	r12
    2986:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    298a:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    298e:	65 e0       	ldi	r22, 0x05	; 5
    2990:	80 e0       	ldi	r24, 0x00	; 0
    2992:	9b e0       	ldi	r25, 0x0B	; 11
    2994:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
    2998:	19 c0       	rjmp	.+50     	; 0x29cc <delayUS+0x8e>
    299a:	80 e4       	ldi	r24, 0x40	; 64
    299c:	c8 16       	cp	r12, r24
    299e:	82 e4       	ldi	r24, 0x42	; 66
    29a0:	d8 06       	cpc	r13, r24
    29a2:	8f e0       	ldi	r24, 0x0F	; 15
    29a4:	e8 06       	cpc	r14, r24
    29a6:	f1 04       	cpc	r15, r1
    29a8:	88 f4       	brcc	.+34     	; 0x29cc <delayUS+0x8e>
    29aa:	68 94       	set
    29ac:	14 f8       	bld	r1, 4
    29ae:	f6 94       	lsr	r15
    29b0:	e7 94       	ror	r14
    29b2:	d7 94       	ror	r13
    29b4:	c7 94       	ror	r12
    29b6:	16 94       	lsr	r1
    29b8:	d1 f7       	brne	.-12     	; 0x29ae <delayUS+0x70>
    29ba:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    29be:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    29c2:	67 e0       	ldi	r22, 0x07	; 7
    29c4:	80 e0       	ldi	r24, 0x00	; 0
    29c6:	9b e0       	ldi	r25, 0x0B	; 11
    29c8:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
    29cc:	0f 2e       	mov	r0, r31
    29ce:	f4 ef       	ldi	r31, 0xF4	; 244
    29d0:	cf 2e       	mov	r12, r31
    29d2:	dd 24       	eor	r13, r13
    29d4:	d3 94       	inc	r13
    29d6:	e1 2c       	mov	r14, r1
    29d8:	f1 2c       	mov	r15, r1
    29da:	f0 2d       	mov	r31, r0
    29dc:	00 e0       	ldi	r16, 0x00	; 0
    29de:	21 e0       	ldi	r18, 0x01	; 1
    29e0:	41 e0       	ldi	r20, 0x01	; 1
    29e2:	50 e0       	ldi	r21, 0x00	; 0
    29e4:	60 e0       	ldi	r22, 0x00	; 0
    29e6:	70 e0       	ldi	r23, 0x00	; 0
    29e8:	80 91 0f 3f 	lds	r24, 0x3F0F	; 0x803f0f <egDisplayTiming>
    29ec:	90 91 10 3f 	lds	r25, 0x3F10	; 0x803f10 <egDisplayTiming+0x1>
    29f0:	0e 94 bd 02 	call	0x57a	; 0x57a <xEventGroupWaitBits>
    29f4:	11 c0       	rjmp	.+34     	; 0x2a18 <delayUS+0xda>
    29f6:	e0 e0       	ldi	r30, 0x00	; 0
    29f8:	fb e0       	ldi	r31, 0x0B	; 11
    29fa:	81 e0       	ldi	r24, 0x01	; 1
    29fc:	86 83       	std	Z+6, r24	; 0x06
    29fe:	10 a2       	std	Z+32, r1	; 0x20
    2a00:	11 a2       	std	Z+33, r1	; 0x21
    2a02:	60 e0       	ldi	r22, 0x00	; 0
    2a04:	80 e0       	ldi	r24, 0x00	; 0
    2a06:	9b e0       	ldi	r25, 0x0B	; 11
    2a08:	0e 94 92 02 	call	0x524	; 0x524 <TC0_ConfigWGM>
    2a0c:	c1 2c       	mov	r12, r1
    2a0e:	d1 2c       	mov	r13, r1
    2a10:	76 01       	movw	r14, r12
    2a12:	68 94       	set
    2a14:	c1 f8       	bld	r12, 1
    2a16:	b3 cf       	rjmp	.-154    	; 0x297e <delayUS+0x40>
    2a18:	0f 91       	pop	r16
    2a1a:	ff 90       	pop	r15
    2a1c:	ef 90       	pop	r14
    2a1e:	df 90       	pop	r13
    2a20:	cf 90       	pop	r12
    2a22:	08 95       	ret

00002a24 <setPort>:
    2a24:	82 95       	swap	r24
    2a26:	80 7f       	andi	r24, 0xF0	; 240
    2a28:	e0 e0       	ldi	r30, 0x00	; 0
    2a2a:	f6 e0       	ldi	r31, 0x06	; 6
    2a2c:	94 81       	ldd	r25, Z+4	; 0x04
    2a2e:	28 2f       	mov	r18, r24
    2a30:	2f 60       	ori	r18, 0x0F	; 15
    2a32:	92 23       	and	r25, r18
    2a34:	94 83       	std	Z+4, r25	; 0x04
    2a36:	94 81       	ldd	r25, Z+4	; 0x04
    2a38:	89 2b       	or	r24, r25
    2a3a:	84 83       	std	Z+4, r24	; 0x04
    2a3c:	08 95       	ret

00002a3e <Nybble>:
    2a3e:	1f 93       	push	r17
    2a40:	cf 93       	push	r28
    2a42:	df 93       	push	r29
    2a44:	c0 e6       	ldi	r28, 0x60	; 96
    2a46:	d6 e0       	ldi	r29, 0x06	; 6
    2a48:	14 e0       	ldi	r17, 0x04	; 4
    2a4a:	1d 83       	std	Y+5, r17	; 0x05
    2a4c:	61 e0       	ldi	r22, 0x01	; 1
    2a4e:	70 e0       	ldi	r23, 0x00	; 0
    2a50:	80 e0       	ldi	r24, 0x00	; 0
    2a52:	90 e0       	ldi	r25, 0x00	; 0
    2a54:	0e 94 9f 14 	call	0x293e	; 0x293e <delayUS>
    2a58:	1e 83       	std	Y+6, r17	; 0x06
    2a5a:	df 91       	pop	r29
    2a5c:	cf 91       	pop	r28
    2a5e:	1f 91       	pop	r17
    2a60:	08 95       	ret

00002a62 <command>:
    2a62:	cf 93       	push	r28
    2a64:	c8 2f       	mov	r28, r24
    2a66:	82 95       	swap	r24
    2a68:	8f 70       	andi	r24, 0x0F	; 15
    2a6a:	0e 94 12 15 	call	0x2a24	; 0x2a24 <setPort>
    2a6e:	e0 e6       	ldi	r30, 0x60	; 96
    2a70:	f6 e0       	ldi	r31, 0x06	; 6
    2a72:	81 e0       	ldi	r24, 0x01	; 1
    2a74:	86 83       	std	Z+6, r24	; 0x06
    2a76:	82 e0       	ldi	r24, 0x02	; 2
    2a78:	86 83       	std	Z+6, r24	; 0x06
    2a7a:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <Nybble>
    2a7e:	8c 2f       	mov	r24, r28
    2a80:	8f 70       	andi	r24, 0x0F	; 15
    2a82:	0e 94 12 15 	call	0x2a24	; 0x2a24 <setPort>
    2a86:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <Nybble>
    2a8a:	cf 91       	pop	r28
    2a8c:	08 95       	ret

00002a8e <write>:
    2a8e:	cf 93       	push	r28
    2a90:	c8 2f       	mov	r28, r24
    2a92:	82 95       	swap	r24
    2a94:	8f 70       	andi	r24, 0x0F	; 15
    2a96:	0e 94 12 15 	call	0x2a24	; 0x2a24 <setPort>
    2a9a:	e0 e6       	ldi	r30, 0x60	; 96
    2a9c:	f6 e0       	ldi	r31, 0x06	; 6
    2a9e:	81 e0       	ldi	r24, 0x01	; 1
    2aa0:	85 83       	std	Z+5, r24	; 0x05
    2aa2:	82 e0       	ldi	r24, 0x02	; 2
    2aa4:	86 83       	std	Z+6, r24	; 0x06
    2aa6:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <Nybble>
    2aaa:	8c 2f       	mov	r24, r28
    2aac:	8f 70       	andi	r24, 0x0F	; 15
    2aae:	0e 94 12 15 	call	0x2a24	; 0x2a24 <setPort>
    2ab2:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <Nybble>
    2ab6:	cf 91       	pop	r28
    2ab8:	08 95       	ret

00002aba <vInitDisplay>:
 }
 
 void vInitDisplay() {
    2aba:	ef 92       	push	r14
    2abc:	ff 92       	push	r15
    2abe:	0f 93       	push	r16
	PORTA.DIRSET = PIN4_bm;
    2ac0:	e0 e0       	ldi	r30, 0x00	; 0
    2ac2:	f6 e0       	ldi	r31, 0x06	; 6
    2ac4:	80 e1       	ldi	r24, 0x10	; 16
    2ac6:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN5_bm;
    2ac8:	80 e2       	ldi	r24, 0x20	; 32
    2aca:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN6_bm;
    2acc:	80 e4       	ldi	r24, 0x40	; 64
    2ace:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN7_bm;
    2ad0:	80 e8       	ldi	r24, 0x80	; 128
    2ad2:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN0_bm;
    2ad4:	a0 e6       	ldi	r26, 0x60	; 96
    2ad6:	b6 e0       	ldi	r27, 0x06	; 6
    2ad8:	81 e0       	ldi	r24, 0x01	; 1
    2ada:	11 96       	adiw	r26, 0x01	; 1
    2adc:	8c 93       	st	X, r24
    2ade:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN1_bm;
    2ae0:	82 e0       	ldi	r24, 0x02	; 2
    2ae2:	11 96       	adiw	r26, 0x01	; 1
    2ae4:	8c 93       	st	X, r24
    2ae6:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN2_bm;
    2ae8:	84 e0       	ldi	r24, 0x04	; 4
    2aea:	11 96       	adiw	r26, 0x01	; 1
    2aec:	8c 93       	st	X, r24
    2aee:	11 97       	sbiw	r26, 0x01	; 1
	PORTA.OUT &= 0x0F;
    2af0:	84 81       	ldd	r24, Z+4	; 0x04
    2af2:	8f 70       	andi	r24, 0x0F	; 15
    2af4:	84 83       	std	Z+4, r24	; 0x04
	PORTD.OUT &= 0xF8;
    2af6:	14 96       	adiw	r26, 0x04	; 4
    2af8:	8c 91       	ld	r24, X
    2afa:	14 97       	sbiw	r26, 0x04	; 4
    2afc:	88 7f       	andi	r24, 0xF8	; 248
    2afe:	14 96       	adiw	r26, 0x04	; 4
    2b00:	8c 93       	st	X, r24

	if((displayLineQueue = xQueueCreate(DISPLAY_QUEUE_DEPTH, sizeof(displayLine_t))) == NULL)
    2b02:	40 e0       	ldi	r20, 0x00	; 0
    2b04:	66 e1       	ldi	r22, 0x16	; 22
    2b06:	88 e0       	ldi	r24, 0x08	; 8
    2b08:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericCreate>
    2b0c:	80 93 0d 3f 	sts	0x3F0D, r24	; 0x803f0d <displayLineQueue>
    2b10:	90 93 0e 3f 	sts	0x3F0E, r25	; 0x803f0e <displayLineQueue+0x1>
	{
		//error(ERR_QUEUE_CREATE_HANDLE_NULL);
	}
	
	egDisplayTiming = xEventGroupCreate();
    2b14:	0e 94 a8 02 	call	0x550	; 0x550 <xEventGroupCreate>
    2b18:	80 93 0f 3f 	sts	0x3F0F, r24	; 0x803f0f <egDisplayTiming>
    2b1c:	90 93 10 3f 	sts	0x3F10, r25	; 0x803f10 <egDisplayTiming+0x1>
	

	xTaskCreate(vDisplayUpdateTask, (const char*) "dispUpdate", configMINIMAL_STACK_SIZE+150, NULL, 1, NULL);	
    2b20:	e1 2c       	mov	r14, r1
    2b22:	f1 2c       	mov	r15, r1
    2b24:	01 e0       	ldi	r16, 0x01	; 1
    2b26:	20 e0       	ldi	r18, 0x00	; 0
    2b28:	30 e0       	ldi	r19, 0x00	; 0
    2b2a:	4e e5       	ldi	r20, 0x5E	; 94
    2b2c:	51 e0       	ldi	r21, 0x01	; 1
    2b2e:	68 e7       	ldi	r22, 0x78	; 120
    2b30:	70 e2       	ldi	r23, 0x20	; 32
    2b32:	8b ef       	ldi	r24, 0xFB	; 251
    2b34:	95 e1       	ldi	r25, 0x15	; 21
    2b36:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
 }
    2b3a:	0f 91       	pop	r16
    2b3c:	ff 90       	pop	r15
    2b3e:	ef 90       	pop	r14
    2b40:	08 95       	ret

00002b42 <_displaySetPos>:
 
 void _displaySetPos(int line, int pos) {
	 switch(line) {
    2b42:	81 30       	cpi	r24, 0x01	; 1
    2b44:	91 05       	cpc	r25, r1
    2b46:	79 f0       	breq	.+30     	; 0x2b66 <_displaySetPos+0x24>
    2b48:	1c f4       	brge	.+6      	; 0x2b50 <_displaySetPos+0xe>
    2b4a:	89 2b       	or	r24, r25
    2b4c:	39 f0       	breq	.+14     	; 0x2b5c <_displaySetPos+0x1a>
    2b4e:	19 c0       	rjmp	.+50     	; 0x2b82 <_displaySetPos+0x40>
    2b50:	82 30       	cpi	r24, 0x02	; 2
    2b52:	91 05       	cpc	r25, r1
    2b54:	69 f0       	breq	.+26     	; 0x2b70 <_displaySetPos+0x2e>
    2b56:	03 97       	sbiw	r24, 0x03	; 3
    2b58:	81 f0       	breq	.+32     	; 0x2b7a <_displaySetPos+0x38>
    2b5a:	13 c0       	rjmp	.+38     	; 0x2b82 <_displaySetPos+0x40>
		 case 0:
		 command(0x80 + 0x00 + pos);
    2b5c:	80 e8       	ldi	r24, 0x80	; 128
    2b5e:	86 0f       	add	r24, r22
    2b60:	0e 94 31 15 	call	0x2a62	; 0x2a62 <command>
		 break;
    2b64:	0e c0       	rjmp	.+28     	; 0x2b82 <_displaySetPos+0x40>
		 case 1:
		 command(0x80 + 0x40 + pos);
    2b66:	80 ec       	ldi	r24, 0xC0	; 192
    2b68:	86 0f       	add	r24, r22
    2b6a:	0e 94 31 15 	call	0x2a62	; 0x2a62 <command>
		 break;
    2b6e:	09 c0       	rjmp	.+18     	; 0x2b82 <_displaySetPos+0x40>
		 case 2:
		 command(0x80 + 0x14 + pos);
    2b70:	84 e9       	ldi	r24, 0x94	; 148
    2b72:	86 0f       	add	r24, r22
    2b74:	0e 94 31 15 	call	0x2a62	; 0x2a62 <command>
		 break;
    2b78:	04 c0       	rjmp	.+8      	; 0x2b82 <_displaySetPos+0x40>
		 case 3:
		 command(0x80 + 0x54 + pos);
    2b7a:	84 ed       	ldi	r24, 0xD4	; 212
    2b7c:	86 0f       	add	r24, r22
    2b7e:	0e 94 31 15 	call	0x2a62	; 0x2a62 <command>
		 break;
	 }
	 delayUS(39);
    2b82:	67 e2       	ldi	r22, 0x27	; 39
    2b84:	70 e0       	ldi	r23, 0x00	; 0
    2b86:	80 e0       	ldi	r24, 0x00	; 0
    2b88:	90 e0       	ldi	r25, 0x00	; 0
    2b8a:	0e 94 9f 14 	call	0x293e	; 0x293e <delayUS>
    2b8e:	08 95       	ret

00002b90 <_displayWriteChar>:
 }

 void _displayWriteChar(char c) {
	 write(c);
    2b90:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <write>
	 delayUS(43);
    2b94:	6b e2       	ldi	r22, 0x2B	; 43
    2b96:	70 e0       	ldi	r23, 0x00	; 0
    2b98:	80 e0       	ldi	r24, 0x00	; 0
    2b9a:	90 e0       	ldi	r25, 0x00	; 0
    2b9c:	0e 94 9f 14 	call	0x293e	; 0x293e <delayUS>
    2ba0:	08 95       	ret

00002ba2 <_displayWriteString>:
 }
 
 void _displayWriteString(char* s) {
    2ba2:	0f 93       	push	r16
    2ba4:	1f 93       	push	r17
    2ba6:	cf 93       	push	r28
    2ba8:	df 93       	push	r29
    2baa:	fc 01       	movw	r30, r24
	 for(int i = 0; i < 20; i++) {
		 if(s[i] == '\0') {
    2bac:	80 81       	ld	r24, Z
    2bae:	81 11       	cpse	r24, r1
    2bb0:	0a c0       	rjmp	.+20     	; 0x2bc6 <_displayWriteString+0x24>
    2bb2:	11 c0       	rjmp	.+34     	; 0x2bd6 <_displayWriteString+0x34>
    2bb4:	89 91       	ld	r24, Y+
    2bb6:	88 23       	and	r24, r24
    2bb8:	71 f0       	breq	.+28     	; 0x2bd6 <_displayWriteString+0x34>
			 break;
		 }
		 _displayWriteChar(s[i]);
    2bba:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <_displayWriteChar>
	 write(c);
	 delayUS(43);
 }
 
 void _displayWriteString(char* s) {
	 for(int i = 0; i < 20; i++) {
    2bbe:	0c 17       	cp	r16, r28
    2bc0:	1d 07       	cpc	r17, r29
    2bc2:	c1 f7       	brne	.-16     	; 0x2bb4 <_displayWriteString+0x12>
    2bc4:	08 c0       	rjmp	.+16     	; 0x2bd6 <_displayWriteString+0x34>
    2bc6:	8f 01       	movw	r16, r30
		 if(s[i] == '\0') {
			 break;
		 }
		 _displayWriteChar(s[i]);
    2bc8:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <_displayWriteChar>
    2bcc:	e8 01       	movw	r28, r16
    2bce:	21 96       	adiw	r28, 0x01	; 1
    2bd0:	0c 5e       	subi	r16, 0xEC	; 236
    2bd2:	1f 4f       	sbci	r17, 0xFF	; 255
    2bd4:	ef cf       	rjmp	.-34     	; 0x2bb4 <_displayWriteString+0x12>
	 }
 }
    2bd6:	df 91       	pop	r29
    2bd8:	cf 91       	pop	r28
    2bda:	1f 91       	pop	r17
    2bdc:	0f 91       	pop	r16
    2bde:	08 95       	ret

00002be0 <_displayWriteStringAtPos>:

 void _displayWriteStringAtPos(int line, int pos, char* s) {
    2be0:	cf 93       	push	r28
    2be2:	df 93       	push	r29
    2be4:	ea 01       	movw	r28, r20
	 _displaySetPos(line, pos);
    2be6:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <_displaySetPos>
	 _displayWriteString(s);
    2bea:	ce 01       	movw	r24, r28
    2bec:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <_displayWriteString>
 }
    2bf0:	df 91       	pop	r29
    2bf2:	cf 91       	pop	r28
    2bf4:	08 95       	ret

00002bf6 <vDisplayUpdateTask>:

 void vDisplayUpdateTask(void *pvParameters) {
    2bf6:	cf 93       	push	r28
    2bf8:	df 93       	push	r29
    2bfa:	cd b7       	in	r28, 0x3d	; 61
    2bfc:	de b7       	in	r29, 0x3e	; 62
    2bfe:	c6 56       	subi	r28, 0x66	; 102
    2c00:	d1 09       	sbc	r29, r1
    2c02:	cd bf       	out	0x3d, r28	; 61
    2c04:	de bf       	out	0x3e, r29	; 62
    2c06:	5e 01       	movw	r10, r28
    2c08:	41 e5       	ldi	r20, 0x51	; 81
    2c0a:	a4 0e       	add	r10, r20
    2c0c:	b1 1c       	adc	r11, r1
    2c0e:	fe 01       	movw	r30, r28
    2c10:	31 96       	adiw	r30, 0x01	; 1
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
			displayLines[i][j] = 0x20;
    2c12:	20 e2       	ldi	r18, 0x20	; 32
    2c14:	08 c0       	rjmp	.+16     	; 0x2c26 <vDisplayUpdateTask+0x30>
    2c16:	21 93       	st	Z+, r18
 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
    2c18:	e8 17       	cp	r30, r24
    2c1a:	f9 07       	cpc	r31, r25
    2c1c:	e1 f7       	brne	.-8      	; 0x2c16 <vDisplayUpdateTask+0x20>
    2c1e:	fc 01       	movw	r30, r24

 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
    2c20:	a8 16       	cp	r10, r24
    2c22:	b9 06       	cpc	r11, r25
    2c24:	19 f0       	breq	.+6      	; 0x2c2c <vDisplayUpdateTask+0x36>
    2c26:	cf 01       	movw	r24, r30
    2c28:	44 96       	adiw	r24, 0x14	; 20
    2c2a:	f5 cf       	rjmp	.-22     	; 0x2c16 <vDisplayUpdateTask+0x20>
			displayLines[i][j] = 0x20;
		}
	 }
	 displayLine_t newLine;

	 delayUS(40000);
    2c2c:	60 e4       	ldi	r22, 0x40	; 64
    2c2e:	7c e9       	ldi	r23, 0x9C	; 156
    2c30:	80 e0       	ldi	r24, 0x00	; 0
    2c32:	90 e0       	ldi	r25, 0x00	; 0
    2c34:	0e 94 9f 14 	call	0x293e	; 0x293e <delayUS>
	 setPort(0x03);
    2c38:	83 e0       	ldi	r24, 0x03	; 3
    2c3a:	0e 94 12 15 	call	0x2a24	; 0x2a24 <setPort>
	 delayUS(5000);
    2c3e:	68 e8       	ldi	r22, 0x88	; 136
    2c40:	73 e1       	ldi	r23, 0x13	; 19
    2c42:	80 e0       	ldi	r24, 0x00	; 0
    2c44:	90 e0       	ldi	r25, 0x00	; 0
    2c46:	0e 94 9f 14 	call	0x293e	; 0x293e <delayUS>
	 Nybble();
    2c4a:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <Nybble>
	 delayUS(160);
    2c4e:	60 ea       	ldi	r22, 0xA0	; 160
    2c50:	70 e0       	ldi	r23, 0x00	; 0
    2c52:	80 e0       	ldi	r24, 0x00	; 0
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	0e 94 9f 14 	call	0x293e	; 0x293e <delayUS>
	 Nybble();
    2c5a:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <Nybble>
	 delayUS(160);
    2c5e:	60 ea       	ldi	r22, 0xA0	; 160
    2c60:	70 e0       	ldi	r23, 0x00	; 0
    2c62:	80 e0       	ldi	r24, 0x00	; 0
    2c64:	90 e0       	ldi	r25, 0x00	; 0
    2c66:	0e 94 9f 14 	call	0x293e	; 0x293e <delayUS>
	 Nybble();
    2c6a:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <Nybble>
	 delayUS(160);
    2c6e:	60 ea       	ldi	r22, 0xA0	; 160
    2c70:	70 e0       	ldi	r23, 0x00	; 0
    2c72:	80 e0       	ldi	r24, 0x00	; 0
    2c74:	90 e0       	ldi	r25, 0x00	; 0
    2c76:	0e 94 9f 14 	call	0x293e	; 0x293e <delayUS>
	 setPort(0x02);
    2c7a:	82 e0       	ldi	r24, 0x02	; 2
    2c7c:	0e 94 12 15 	call	0x2a24	; 0x2a24 <setPort>
	 Nybble();
    2c80:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <Nybble>
	 command(0x28);
    2c84:	88 e2       	ldi	r24, 0x28	; 40
    2c86:	0e 94 31 15 	call	0x2a62	; 0x2a62 <command>
	 command(0x10);
    2c8a:	80 e1       	ldi	r24, 0x10	; 16
    2c8c:	0e 94 31 15 	call	0x2a62	; 0x2a62 <command>
	 command(0x0C); //Cursor and Blinking off
    2c90:	8c e0       	ldi	r24, 0x0C	; 12
    2c92:	0e 94 31 15 	call	0x2a62	; 0x2a62 <command>
	 command(0x06);
    2c96:	86 e0       	ldi	r24, 0x06	; 6
    2c98:	0e 94 31 15 	call	0x2a62	; 0x2a62 <command>
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2c9c:	10 e2       	ldi	r17, 0x20	; 32
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2c9e:	6e 01       	movw	r12, r28
    2ca0:	51 e5       	ldi	r21, 0x51	; 81
    2ca2:	c5 0e       	add	r12, r21
    2ca4:	d1 1c       	adc	r13, r1
    2ca6:	0f 2e       	mov	r0, r31
    2ca8:	f4 e1       	ldi	r31, 0x14	; 20
    2caa:	4f 2e       	mov	r4, r31
    2cac:	f0 2d       	mov	r31, r0
    2cae:	0f 2e       	mov	r0, r31
    2cb0:	f6 e1       	ldi	r31, 0x16	; 22
    2cb2:	8f 2e       	mov	r8, r31
    2cb4:	91 2c       	mov	r9, r1
    2cb6:	f0 2d       	mov	r31, r0
    2cb8:	5c 2c       	mov	r5, r12
    2cba:	0d 2d       	mov	r16, r13
	 command(0x10);
	 command(0x0C); //Cursor and Blinking off
	 command(0x06);
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
    2cbc:	68 ec       	ldi	r22, 0xC8	; 200
    2cbe:	70 e0       	ldi	r23, 0x00	; 0
    2cc0:	80 e0       	ldi	r24, 0x00	; 0
    2cc2:	90 e0       	ldi	r25, 0x00	; 0
    2cc4:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
    2cc8:	40 e0       	ldi	r20, 0x00	; 0
    2cca:	50 e0       	ldi	r21, 0x00	; 0
    2ccc:	ba 01       	movw	r22, r20
    2cce:	80 91 0f 3f 	lds	r24, 0x3F0F	; 0x803f0f <egDisplayTiming>
    2cd2:	90 91 10 3f 	lds	r25, 0x3F10	; 0x803f10 <egDisplayTiming+0x1>
    2cd6:	0e 94 82 03 	call	0x704	; 0x704 <xEventGroupClearBits>
    2cda:	67 2b       	or	r22, r23
    2cdc:	68 2b       	or	r22, r24
    2cde:	69 2b       	or	r22, r25
    2ce0:	09 f4       	brne	.+2      	; 0x2ce4 <vDisplayUpdateTask+0xee>
    2ce2:	49 c0       	rjmp	.+146    	; 0x2d76 <vDisplayUpdateTask+0x180>
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2ce4:	42 e0       	ldi	r20, 0x02	; 2
    2ce6:	50 e0       	ldi	r21, 0x00	; 0
    2ce8:	60 e0       	ldi	r22, 0x00	; 0
    2cea:	70 e0       	ldi	r23, 0x00	; 0
    2cec:	80 91 0f 3f 	lds	r24, 0x3F0F	; 0x803f0f <egDisplayTiming>
    2cf0:	90 91 10 3f 	lds	r25, 0x3F10	; 0x803f10 <egDisplayTiming+0x1>
    2cf4:	0e 94 82 03 	call	0x704	; 0x704 <xEventGroupClearBits>
    2cf8:	fe 01       	movw	r30, r28
    2cfa:	31 96       	adiw	r30, 0x01	; 1
    2cfc:	08 c0       	rjmp	.+16     	; 0x2d0e <vDisplayUpdateTask+0x118>
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2cfe:	11 93       	st	Z+, r17
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
    2d00:	e8 17       	cp	r30, r24
    2d02:	f9 07       	cpc	r31, r25
    2d04:	e1 f7       	brne	.-8      	; 0x2cfe <vDisplayUpdateTask+0x108>
    2d06:	fc 01       	movw	r30, r24
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
    2d08:	8a 15       	cp	r24, r10
    2d0a:	9b 05       	cpc	r25, r11
    2d0c:	a1 f1       	breq	.+104    	; 0x2d76 <vDisplayUpdateTask+0x180>
    2d0e:	cf 01       	movw	r24, r30
    2d10:	44 96       	adiw	r24, 0x14	; 20
    2d12:	f5 cf       	rjmp	.-22     	; 0x2cfe <vDisplayUpdateTask+0x108>
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2d14:	2f ef       	ldi	r18, 0xFF	; 255
    2d16:	3f ef       	ldi	r19, 0xFF	; 255
    2d18:	a9 01       	movw	r20, r18
    2d1a:	65 2d       	mov	r22, r5
    2d1c:	70 2f       	mov	r23, r16
    2d1e:	80 91 0d 3f 	lds	r24, 0x3F0D	; 0x803f0d <displayLineQueue>
    2d22:	90 91 0e 3f 	lds	r25, 0x3F0E	; 0x803f0e <displayLineQueue+0x1>
    2d26:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <xQueueReceive>
    2d2a:	88 23       	and	r24, r24
    2d2c:	21 f1       	breq	.+72     	; 0x2d76 <vDisplayUpdateTask+0x180>
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2d2e:	f6 01       	movw	r30, r12
    2d30:	21 81       	ldd	r18, Z+1	; 0x01
    2d32:	82 2f       	mov	r24, r18
    2d34:	90 e0       	ldi	r25, 0x00	; 0
    2d36:	44 97       	sbiw	r24, 0x14	; 20
    2d38:	f4 f4       	brge	.+60     	; 0x2d76 <vDisplayUpdateTask+0x180>
    2d3a:	82 81       	ldd	r24, Z+2	; 0x02
    2d3c:	88 23       	and	r24, r24
    2d3e:	d9 f0       	breq	.+54     	; 0x2d76 <vDisplayUpdateTask+0x180>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
    2d40:	90 81       	ld	r25, Z
    2d42:	30 e0       	ldi	r19, 0x00	; 0
    2d44:	d9 01       	movw	r26, r18
    2d46:	49 9e       	mul	r4, r25
    2d48:	a0 0d       	add	r26, r0
    2d4a:	b1 1d       	adc	r27, r1
    2d4c:	11 24       	eor	r1, r1
    2d4e:	41 e0       	ldi	r20, 0x01	; 1
    2d50:	50 e0       	ldi	r21, 0x00	; 0
    2d52:	4c 0f       	add	r20, r28
    2d54:	5d 1f       	adc	r21, r29
    2d56:	a4 0f       	add	r26, r20
    2d58:	b5 1f       	adc	r27, r21
    2d5a:	33 96       	adiw	r30, 0x03	; 3
    2d5c:	a4 01       	movw	r20, r8
    2d5e:	42 1b       	sub	r20, r18
    2d60:	53 0b       	sbc	r21, r19
    2d62:	9a 01       	movw	r18, r20
    2d64:	2c 0d       	add	r18, r12
    2d66:	3d 1d       	adc	r19, r13
    2d68:	8d 93       	st	X+, r24
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2d6a:	e2 17       	cp	r30, r18
    2d6c:	f3 07       	cpc	r31, r19
    2d6e:	19 f0       	breq	.+6      	; 0x2d76 <vDisplayUpdateTask+0x180>
    2d70:	81 91       	ld	r24, Z+
    2d72:	81 11       	cpse	r24, r1
    2d74:	f9 cf       	rjmp	.-14     	; 0x2d68 <vDisplayUpdateTask+0x172>
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
    2d76:	80 91 0d 3f 	lds	r24, 0x3F0D	; 0x803f0d <displayLineQueue>
    2d7a:	90 91 0e 3f 	lds	r25, 0x3F0E	; 0x803f0e <displayLineQueue+0x1>
    2d7e:	0e 94 91 09 	call	0x1322	; 0x1322 <uxQueueMessagesWaiting>
    2d82:	81 11       	cpse	r24, r1
    2d84:	c7 cf       	rjmp	.-114    	; 0x2d14 <vDisplayUpdateTask+0x11e>
    2d86:	ce 01       	movw	r24, r28
    2d88:	01 96       	adiw	r24, 0x01	; 1
    2d8a:	7c 01       	movw	r14, r24
    2d8c:	61 2c       	mov	r6, r1
    2d8e:	71 2c       	mov	r7, r1
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
			 _displayWriteStringAtPos(i,0,&displayLines[i][0]);
    2d90:	a7 01       	movw	r20, r14
    2d92:	60 e0       	ldi	r22, 0x00	; 0
    2d94:	70 e0       	ldi	r23, 0x00	; 0
    2d96:	c3 01       	movw	r24, r6
    2d98:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <_displayWriteStringAtPos>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
    2d9c:	9f ef       	ldi	r25, 0xFF	; 255
    2d9e:	69 1a       	sub	r6, r25
    2da0:	79 0a       	sbc	r7, r25
    2da2:	e4 e1       	ldi	r30, 0x14	; 20
    2da4:	ee 0e       	add	r14, r30
    2da6:	f1 1c       	adc	r15, r1
    2da8:	f4 e0       	ldi	r31, 0x04	; 4
    2daa:	6f 16       	cp	r6, r31
    2dac:	71 04       	cpc	r7, r1
    2dae:	81 f7       	brne	.-32     	; 0x2d90 <vDisplayUpdateTask+0x19a>
    2db0:	85 cf       	rjmp	.-246    	; 0x2cbc <vDisplayUpdateTask+0xc6>

00002db2 <vDisplayClear>:
	 }
 }
 

void vDisplayClear() {
	xEventGroupSetBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2db2:	42 e0       	ldi	r20, 0x02	; 2
    2db4:	50 e0       	ldi	r21, 0x00	; 0
    2db6:	60 e0       	ldi	r22, 0x00	; 0
    2db8:	70 e0       	ldi	r23, 0x00	; 0
    2dba:	80 91 0f 3f 	lds	r24, 0x3F0F	; 0x803f0f <egDisplayTiming>
    2dbe:	90 91 10 3f 	lds	r25, 0x3F10	; 0x803f10 <egDisplayTiming+0x1>
    2dc2:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
    2dc6:	08 95       	ret

00002dc8 <vDisplayWriteStringAtPos>:
}

void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
    2dc8:	2f 92       	push	r2
    2dca:	3f 92       	push	r3
    2dcc:	4f 92       	push	r4
    2dce:	5f 92       	push	r5
    2dd0:	6f 92       	push	r6
    2dd2:	7f 92       	push	r7
    2dd4:	8f 92       	push	r8
    2dd6:	9f 92       	push	r9
    2dd8:	af 92       	push	r10
    2dda:	bf 92       	push	r11
    2ddc:	cf 92       	push	r12
    2dde:	df 92       	push	r13
    2de0:	ef 92       	push	r14
    2de2:	ff 92       	push	r15
    2de4:	0f 93       	push	r16
    2de6:	1f 93       	push	r17
    2de8:	cf 93       	push	r28
    2dea:	df 93       	push	r29
    2dec:	cd b7       	in	r28, 0x3d	; 61
    2dee:	de b7       	in	r29, 0x3e	; 62
    2df0:	6d 97       	sbiw	r28, 0x1d	; 29
    2df2:	cd bf       	out	0x3d, r28	; 61
    2df4:	de bf       	out	0x3e, r29	; 62
    2df6:	2b a9       	ldd	r18, Y+51	; 0x33
    2df8:	2b 8f       	std	Y+27, r18	; 0x1b
    2dfa:	af a9       	ldd	r26, Y+55	; 0x37
    2dfc:	b8 ad       	ldd	r27, Y+56	; 0x38
	va_list arg;	
	va_start(arg, fmt);
    2dfe:	7e 01       	movw	r14, r28
    2e00:	39 e3       	ldi	r19, 0x39	; 57
    2e02:	e3 0e       	add	r14, r19
    2e04:	f1 1c       	adc	r15, r1
    2e06:	28 ef       	ldi	r18, 0xF8	; 248
    2e08:	3c e2       	ldi	r19, 0x2C	; 44
	display_vprintf(line, pos, fmt, arg);
    2e0a:	e4 ee       	ldi	r30, 0xE4	; 228
    2e0c:	fc e2       	ldi	r31, 0x2C	; 44
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
    2e0e:	11 92       	st	Z+, r1
	char ch;
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
    2e10:	e2 17       	cp	r30, r18
    2e12:	f3 07       	cpc	r31, r19
    2e14:	e1 f7       	brne	.-8      	; 0x2e0e <vDisplayWriteStringAtPos+0x46>
    2e16:	0f 2e       	mov	r0, r31
    2e18:	f0 ed       	ldi	r31, 0xD0	; 208
    2e1a:	af 2e       	mov	r10, r31
    2e1c:	fc e2       	ldi	r31, 0x2C	; 44
    2e1e:	bf 2e       	mov	r11, r31
    2e20:	f0 2d       	mov	r31, r0
    2e22:	24 ee       	ldi	r18, 0xE4	; 228
    2e24:	3c e2       	ldi	r19, 0x2C	; 44
    2e26:	f5 01       	movw	r30, r10
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
    2e28:	11 92       	st	Z+, r1
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    2e2a:	e2 17       	cp	r30, r18
    2e2c:	f3 07       	cpc	r31, r19
    2e2e:	e1 f7       	brne	.-8      	; 0x2e28 <vDisplayWriteStringAtPos+0x60>
    2e30:	81 2c       	mov	r8, r1
    2e32:	91 2c       	mov	r9, r1
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    2e34:	0f 2e       	mov	r0, r31
    2e36:	f4 ee       	ldi	r31, 0xE4	; 228
    2e38:	cf 2e       	mov	r12, r31
    2e3a:	fc e2       	ldi	r31, 0x2C	; 44
    2e3c:	df 2e       	mov	r13, r31
    2e3e:	f0 2d       	mov	r31, r0
    2e40:	fc c2       	rjmp	.+1528   	; 0x343a <vDisplayWriteStringAtPos+0x672>
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
    2e42:	85 32       	cpi	r24, 0x25	; 37
    2e44:	09 f0       	breq	.+2      	; 0x2e48 <vDisplayWriteStringAtPos+0x80>
    2e46:	e8 c2       	rjmp	.+1488   	; 0x3418 <vDisplayWriteStringAtPos+0x650>
			switch (ch = *fmt++) {
    2e48:	2d 01       	movw	r4, r26
    2e4a:	82 e0       	ldi	r24, 0x02	; 2
    2e4c:	48 0e       	add	r4, r24
    2e4e:	51 1c       	adc	r5, r1
    2e50:	11 96       	adiw	r26, 0x01	; 1
    2e52:	8c 91       	ld	r24, X
    2e54:	85 36       	cpi	r24, 0x65	; 101
    2e56:	09 f4       	brne	.+2      	; 0x2e5a <vDisplayWriteStringAtPos+0x92>
    2e58:	db c1       	rjmp	.+950    	; 0x3210 <vDisplayWriteStringAtPos+0x448>
    2e5a:	38 f4       	brcc	.+14     	; 0x2e6a <vDisplayWriteStringAtPos+0xa2>
    2e5c:	83 36       	cpi	r24, 0x63	; 99
    2e5e:	c1 f0       	breq	.+48     	; 0x2e90 <vDisplayWriteStringAtPos+0xc8>
    2e60:	08 f0       	brcs	.+2      	; 0x2e64 <vDisplayWriteStringAtPos+0x9c>
    2e62:	48 c0       	rjmp	.+144    	; 0x2ef4 <vDisplayWriteStringAtPos+0x12c>
    2e64:	85 32       	cpi	r24, 0x25	; 37
    2e66:	51 f0       	breq	.+20     	; 0x2e7c <vDisplayWriteStringAtPos+0xb4>
    2e68:	e7 c2       	rjmp	.+1486   	; 0x3438 <vDisplayWriteStringAtPos+0x670>
    2e6a:	83 37       	cpi	r24, 0x73	; 115
    2e6c:	f9 f0       	breq	.+62     	; 0x2eac <vDisplayWriteStringAtPos+0xe4>
    2e6e:	88 37       	cpi	r24, 0x78	; 120
    2e70:	09 f4       	brne	.+2      	; 0x2e74 <vDisplayWriteStringAtPos+0xac>
    2e72:	68 c0       	rjmp	.+208    	; 0x2f44 <vDisplayWriteStringAtPos+0x17c>
    2e74:	86 36       	cpi	r24, 0x66	; 102
    2e76:	09 f0       	breq	.+2      	; 0x2e7a <vDisplayWriteStringAtPos+0xb2>
    2e78:	df c2       	rjmp	.+1470   	; 0x3438 <vDisplayWriteStringAtPos+0x670>
    2e7a:	8c c0       	rjmp	.+280    	; 0x2f94 <vDisplayWriteStringAtPos+0x1cc>
				/* %% - print out a single %    */
				case '%':
				str[length] = '%';
    2e7c:	f4 01       	movw	r30, r8
    2e7e:	e0 53       	subi	r30, 0x30	; 48
    2e80:	f3 4d       	sbci	r31, 0xD3	; 211
    2e82:	95 e2       	ldi	r25, 0x25	; 37
    2e84:	90 83       	st	Z, r25
				length++;
    2e86:	af ef       	ldi	r26, 0xFF	; 255
    2e88:	8a 1a       	sub	r8, r26
    2e8a:	9a 0a       	sbc	r9, r26
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2e8c:	d2 01       	movw	r26, r4
    2e8e:	d5 c2       	rjmp	.+1450   	; 0x343a <vDisplayWriteStringAtPos+0x672>
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
				str[length] = char_temp;
    2e90:	f4 01       	movw	r30, r8
    2e92:	e0 53       	subi	r30, 0x30	; 48
    2e94:	f3 4d       	sbci	r31, 0xD3	; 211
    2e96:	d7 01       	movw	r26, r14
    2e98:	8c 91       	ld	r24, X
    2e9a:	80 83       	st	Z, r24
				length++;
    2e9c:	bf ef       	ldi	r27, 0xFF	; 255
    2e9e:	8b 1a       	sub	r8, r27
    2ea0:	9b 0a       	sbc	r9, r27
				length++;
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
    2ea2:	f7 01       	movw	r30, r14
    2ea4:	32 96       	adiw	r30, 0x02	; 2
    2ea6:	7f 01       	movw	r14, r30
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2ea8:	d2 01       	movw	r26, r4
    2eaa:	c7 c2       	rjmp	.+1422   	; 0x343a <vDisplayWriteStringAtPos+0x672>
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2eac:	a7 01       	movw	r20, r14
    2eae:	4e 5f       	subi	r20, 0xFE	; 254
    2eb0:	5f 4f       	sbci	r21, 0xFF	; 255
    2eb2:	d7 01       	movw	r26, r14
    2eb4:	8d 91       	ld	r24, X+
    2eb6:	9c 91       	ld	r25, X
    2eb8:	9c 01       	movw	r18, r24
    2eba:	b4 01       	movw	r22, r8
    2ebc:	f4 01       	movw	r30, r8
    2ebe:	e0 53       	subi	r30, 0x30	; 48
    2ec0:	f3 4d       	sbci	r31, 0xD3	; 211
				for(int i = 0; i < strlen(string_temp);i++) {
    2ec2:	00 e0       	ldi	r16, 0x00	; 0
    2ec4:	10 e0       	ldi	r17, 0x00	; 0
    2ec6:	06 c0       	rjmp	.+12     	; 0x2ed4 <vDisplayWriteStringAtPos+0x10c>
					str[length+i] = string_temp[i];
    2ec8:	d9 01       	movw	r26, r18
    2eca:	fd 90       	ld	r15, X+
    2ecc:	9d 01       	movw	r18, r26
    2ece:	f1 92       	st	Z+, r15
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
				for(int i = 0; i < strlen(string_temp);i++) {
    2ed0:	0f 5f       	subi	r16, 0xFF	; 255
    2ed2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ed4:	dc 01       	movw	r26, r24
    2ed6:	0d 90       	ld	r0, X+
    2ed8:	00 20       	and	r0, r0
    2eda:	e9 f7       	brne	.-6      	; 0x2ed6 <vDisplayWriteStringAtPos+0x10e>
    2edc:	11 97       	sbiw	r26, 0x01	; 1
    2ede:	a8 1b       	sub	r26, r24
    2ee0:	b9 0b       	sbc	r27, r25
    2ee2:	0a 17       	cp	r16, r26
    2ee4:	1b 07       	cpc	r17, r27
    2ee6:	80 f3       	brcs	.-32     	; 0x2ec8 <vDisplayWriteStringAtPos+0x100>
					str[length+i] = string_temp[i];
				}
				length += strlen(string_temp);
    2ee8:	4d 01       	movw	r8, r26
    2eea:	86 0e       	add	r8, r22
    2eec:	97 1e       	adc	r9, r23
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2eee:	7a 01       	movw	r14, r20
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2ef0:	d2 01       	movw	r26, r4
    2ef2:	a3 c2       	rjmp	.+1350   	; 0x343a <vDisplayWriteStringAtPos+0x672>
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    2ef4:	87 01       	movw	r16, r14
    2ef6:	0e 5f       	subi	r16, 0xFE	; 254
    2ef8:	1f 4f       	sbci	r17, 0xFF	; 255
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    2efa:	4a e0       	ldi	r20, 0x0A	; 10
    2efc:	b6 01       	movw	r22, r12
    2efe:	f7 01       	movw	r30, r14
    2f00:	80 81       	ld	r24, Z
    2f02:	91 81       	ldd	r25, Z+1	; 0x01
    2f04:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <__itoa_ncheck>
    2f08:	94 01       	movw	r18, r8
    2f0a:	d4 01       	movw	r26, r8
    2f0c:	a0 53       	subi	r26, 0x30	; 48
    2f0e:	b3 4d       	sbci	r27, 0xD3	; 211
    2f10:	44 ee       	ldi	r20, 0xE4	; 228
    2f12:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    2f14:	80 e0       	ldi	r24, 0x00	; 0
    2f16:	90 e0       	ldi	r25, 0x00	; 0
    2f18:	05 c0       	rjmp	.+10     	; 0x2f24 <vDisplayWriteStringAtPos+0x15c>
					str[length+i] = buffer[i];
    2f1a:	fa 01       	movw	r30, r20
    2f1c:	61 91       	ld	r22, Z+
    2f1e:	af 01       	movw	r20, r30
    2f20:	6d 93       	st	X+, r22

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    2f22:	01 96       	adiw	r24, 0x01	; 1
    2f24:	f6 01       	movw	r30, r12
    2f26:	01 90       	ld	r0, Z+
    2f28:	00 20       	and	r0, r0
    2f2a:	e9 f7       	brne	.-6      	; 0x2f26 <vDisplayWriteStringAtPos+0x15e>
    2f2c:	31 97       	sbiw	r30, 0x01	; 1
    2f2e:	e4 5e       	subi	r30, 0xE4	; 228
    2f30:	fc 42       	sbci	r31, 0x2C	; 44
    2f32:	8e 17       	cp	r24, r30
    2f34:	9f 07       	cpc	r25, r31
    2f36:	88 f3       	brcs	.-30     	; 0x2f1a <vDisplayWriteStringAtPos+0x152>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    2f38:	4f 01       	movw	r8, r30
    2f3a:	82 0e       	add	r8, r18
    2f3c:	93 1e       	adc	r9, r19
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    2f3e:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2f40:	d2 01       	movw	r26, r4
    2f42:	7b c2       	rjmp	.+1270   	; 0x343a <vDisplayWriteStringAtPos+0x672>
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    2f44:	87 01       	movw	r16, r14
    2f46:	0e 5f       	subi	r16, 0xFE	; 254
    2f48:	1f 4f       	sbci	r17, 0xFF	; 255
    2f4a:	40 e1       	ldi	r20, 0x10	; 16
    2f4c:	b6 01       	movw	r22, r12
    2f4e:	d7 01       	movw	r26, r14
    2f50:	8d 91       	ld	r24, X+
    2f52:	9c 91       	ld	r25, X
    2f54:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <__itoa_ncheck>
    2f58:	94 01       	movw	r18, r8
    2f5a:	f4 01       	movw	r30, r8
    2f5c:	e0 53       	subi	r30, 0x30	; 48
    2f5e:	f3 4d       	sbci	r31, 0xD3	; 211
    2f60:	44 ee       	ldi	r20, 0xE4	; 228
    2f62:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    2f64:	80 e0       	ldi	r24, 0x00	; 0
    2f66:	90 e0       	ldi	r25, 0x00	; 0
    2f68:	05 c0       	rjmp	.+10     	; 0x2f74 <vDisplayWriteStringAtPos+0x1ac>
					str[length+i] = buffer[i];
    2f6a:	da 01       	movw	r26, r20
    2f6c:	6d 91       	ld	r22, X+
    2f6e:	ad 01       	movw	r20, r26
    2f70:	61 93       	st	Z+, r22

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    2f72:	01 96       	adiw	r24, 0x01	; 1
    2f74:	d6 01       	movw	r26, r12
    2f76:	0d 90       	ld	r0, X+
    2f78:	00 20       	and	r0, r0
    2f7a:	e9 f7       	brne	.-6      	; 0x2f76 <vDisplayWriteStringAtPos+0x1ae>
    2f7c:	11 97       	sbiw	r26, 0x01	; 1
    2f7e:	a4 5e       	subi	r26, 0xE4	; 228
    2f80:	bc 42       	sbci	r27, 0x2C	; 44
    2f82:	8a 17       	cp	r24, r26
    2f84:	9b 07       	cpc	r25, r27
    2f86:	88 f3       	brcs	.-30     	; 0x2f6a <vDisplayWriteStringAtPos+0x1a2>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    2f88:	4d 01       	movw	r8, r26
    2f8a:	82 0e       	add	r8, r18
    2f8c:	93 1e       	adc	r9, r19
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    2f8e:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2f90:	d2 01       	movw	r26, r4
    2f92:	53 c2       	rjmp	.+1190   	; 0x343a <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    2f94:	17 01       	movw	r2, r14
    2f96:	b4 e0       	ldi	r27, 0x04	; 4
    2f98:	2b 0e       	add	r2, r27
    2f9a:	31 1c       	adc	r3, r1
    2f9c:	d7 01       	movw	r26, r14
    2f9e:	8d 91       	ld	r24, X+
    2fa0:	9d 91       	ld	r25, X+
    2fa2:	0d 90       	ld	r0, X+
    2fa4:	bc 91       	ld	r27, X
    2fa6:	a0 2d       	mov	r26, r0
    2fa8:	8f 8b       	std	Y+23, r24	; 0x17
    2faa:	98 8f       	std	Y+24, r25	; 0x18
    2fac:	a9 8f       	std	Y+25, r26	; 0x19
    2fae:	ba 8f       	std	Y+26, r27	; 0x1a

    int exponent = 0;
    int places = 0;
    static const int width = 4;

    if (value == 0.0) {
    2fb0:	20 e0       	ldi	r18, 0x00	; 0
    2fb2:	30 e0       	ldi	r19, 0x00	; 0
    2fb4:	a9 01       	movw	r20, r18
    2fb6:	bc 01       	movw	r22, r24
    2fb8:	cd 01       	movw	r24, r26
    2fba:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <__cmpsf2>
    2fbe:	81 11       	cpse	r24, r1
    2fc0:	05 c0       	rjmp	.+10     	; 0x2fcc <vDisplayWriteStringAtPos+0x204>
        buffer[0] = '0';
    2fc2:	20 e3       	ldi	r18, 0x30	; 48
    2fc4:	f6 01       	movw	r30, r12
    2fc6:	20 83       	st	Z, r18
        buffer[1] = '\0';
    2fc8:	11 82       	std	Z+1, r1	; 0x01
    2fca:	04 c1       	rjmp	.+520    	; 0x31d4 <vDisplayWriteStringAtPos+0x40c>
        return;
    }         

    if (value < 0.0) {
    2fcc:	20 e0       	ldi	r18, 0x00	; 0
    2fce:	30 e0       	ldi	r19, 0x00	; 0
    2fd0:	a9 01       	movw	r20, r18
    2fd2:	6f 89       	ldd	r22, Y+23	; 0x17
    2fd4:	78 8d       	ldd	r23, Y+24	; 0x18
    2fd6:	89 8d       	ldd	r24, Y+25	; 0x19
    2fd8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2fda:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <__cmpsf2>
    2fde:	88 23       	and	r24, r24
    2fe0:	9c f4       	brge	.+38     	; 0x3008 <vDisplayWriteStringAtPos+0x240>
        *buffer++ = '-';
    2fe2:	ed e2       	ldi	r30, 0x2D	; 45
    2fe4:	d6 01       	movw	r26, r12
    2fe6:	ec 93       	st	X, r30
        value = -value;
    2fe8:	8f 89       	ldd	r24, Y+23	; 0x17
    2fea:	98 8d       	ldd	r25, Y+24	; 0x18
    2fec:	a9 8d       	ldd	r26, Y+25	; 0x19
    2fee:	ba 8d       	ldd	r27, Y+26	; 0x1a
    2ff0:	b0 58       	subi	r27, 0x80	; 128
    2ff2:	8f 8b       	std	Y+23, r24	; 0x17
    2ff4:	98 8f       	std	Y+24, r25	; 0x18
    2ff6:	a9 8f       	std	Y+25, r26	; 0x19
    2ff8:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
        *buffer++ = '-';
    2ffa:	0f 2e       	mov	r0, r31
    2ffc:	f5 ee       	ldi	r31, 0xE5	; 229
    2ffe:	6f 2e       	mov	r6, r31
    3000:	fc e2       	ldi	r31, 0x2C	; 44
    3002:	7f 2e       	mov	r7, r31
    3004:	f0 2d       	mov	r31, r0
    3006:	01 c0       	rjmp	.+2      	; 0x300a <vDisplayWriteStringAtPos+0x242>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
    3008:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    300a:	20 e0       	ldi	r18, 0x00	; 0
    300c:	30 e0       	ldi	r19, 0x00	; 0
    300e:	40 e8       	ldi	r20, 0x80	; 128
    3010:	5f e3       	ldi	r21, 0x3F	; 63
    3012:	6f 89       	ldd	r22, Y+23	; 0x17
    3014:	78 8d       	ldd	r23, Y+24	; 0x18
    3016:	89 8d       	ldd	r24, Y+25	; 0x19
    3018:	9a 8d       	ldd	r25, Y+26	; 0x1a
    301a:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <__gesf2>
    301e:	88 23       	and	r24, r24
    3020:	0c f4       	brge	.+2      	; 0x3024 <vDisplayWriteStringAtPos+0x25c>
    3022:	44 c2       	rjmp	.+1160   	; 0x34ac <vDisplayWriteStringAtPos+0x6e4>
    3024:	00 e0       	ldi	r16, 0x00	; 0
    3026:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    3028:	20 e0       	ldi	r18, 0x00	; 0
    302a:	30 e0       	ldi	r19, 0x00	; 0
    302c:	40 e2       	ldi	r20, 0x20	; 32
    302e:	51 e4       	ldi	r21, 0x41	; 65
    3030:	6f 89       	ldd	r22, Y+23	; 0x17
    3032:	78 8d       	ldd	r23, Y+24	; 0x18
    3034:	89 8d       	ldd	r24, Y+25	; 0x19
    3036:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3038:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__divsf3>
    303c:	6f 8b       	std	Y+23, r22	; 0x17
    303e:	78 8f       	std	Y+24, r23	; 0x18
    3040:	89 8f       	std	Y+25, r24	; 0x19
    3042:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    3044:	0f 5f       	subi	r16, 0xFF	; 255
    3046:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3048:	20 e0       	ldi	r18, 0x00	; 0
    304a:	30 e0       	ldi	r19, 0x00	; 0
    304c:	40 e8       	ldi	r20, 0x80	; 128
    304e:	5f e3       	ldi	r21, 0x3F	; 63
    3050:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <__gesf2>
    3054:	88 23       	and	r24, r24
    3056:	44 f7       	brge	.-48     	; 0x3028 <vDisplayWriteStringAtPos+0x260>
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3058:	2d ec       	ldi	r18, 0xCD	; 205
    305a:	3c ec       	ldi	r19, 0xCC	; 204
    305c:	4c ec       	ldi	r20, 0xCC	; 204
    305e:	5d e3       	ldi	r21, 0x3D	; 61
    3060:	6f 89       	ldd	r22, Y+23	; 0x17
    3062:	78 8d       	ldd	r23, Y+24	; 0x18
    3064:	89 8d       	ldd	r24, Y+25	; 0x19
    3066:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3068:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <__cmpsf2>
    306c:	88 23       	and	r24, r24
    306e:	1c f0       	brlt	.+6      	; 0x3076 <vDisplayWriteStringAtPos+0x2ae>
    3070:	1a c0       	rjmp	.+52     	; 0x30a6 <vDisplayWriteStringAtPos+0x2de>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    3072:	00 e0       	ldi	r16, 0x00	; 0
    3074:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
        value *= 10.0;
    3076:	20 e0       	ldi	r18, 0x00	; 0
    3078:	30 e0       	ldi	r19, 0x00	; 0
    307a:	40 e2       	ldi	r20, 0x20	; 32
    307c:	51 e4       	ldi	r21, 0x41	; 65
    307e:	6f 89       	ldd	r22, Y+23	; 0x17
    3080:	78 8d       	ldd	r23, Y+24	; 0x18
    3082:	89 8d       	ldd	r24, Y+25	; 0x19
    3084:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3086:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <__mulsf3>
    308a:	6f 8b       	std	Y+23, r22	; 0x17
    308c:	78 8f       	std	Y+24, r23	; 0x18
    308e:	89 8f       	std	Y+25, r24	; 0x19
    3090:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    3092:	01 50       	subi	r16, 0x01	; 1
    3094:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3096:	2d ec       	ldi	r18, 0xCD	; 205
    3098:	3c ec       	ldi	r19, 0xCC	; 204
    309a:	4c ec       	ldi	r20, 0xCC	; 204
    309c:	5d e3       	ldi	r21, 0x3D	; 61
    309e:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <__cmpsf2>
    30a2:	88 23       	and	r24, r24
    30a4:	44 f3       	brlt	.-48     	; 0x3076 <vDisplayWriteStringAtPos+0x2ae>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    30a6:	10 16       	cp	r1, r16
    30a8:	11 06       	cpc	r1, r17
    30aa:	ac f5       	brge	.+106    	; 0x3116 <vDisplayWriteStringAtPos+0x34e>
    30ac:	73 01       	movw	r14, r6
    30ae:	d3 01       	movw	r26, r6
    30b0:	a0 0f       	add	r26, r16
    30b2:	b1 1f       	adc	r27, r17
    30b4:	ac 8f       	std	Y+28, r26	; 0x1c
    30b6:	bd 8f       	std	Y+29, r27	; 0x1d
    30b8:	3d 01       	movw	r6, r26
    30ba:	6f 89       	ldd	r22, Y+23	; 0x17
    30bc:	78 8d       	ldd	r23, Y+24	; 0x18
    30be:	89 8d       	ldd	r24, Y+25	; 0x19
    30c0:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10;
    30c2:	20 e0       	ldi	r18, 0x00	; 0
    30c4:	30 e0       	ldi	r19, 0x00	; 0
    30c6:	40 e2       	ldi	r20, 0x20	; 32
    30c8:	51 e4       	ldi	r21, 0x41	; 65
    30ca:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <__mulsf3>
    30ce:	6f 8b       	std	Y+23, r22	; 0x17
    30d0:	78 8f       	std	Y+24, r23	; 0x18
    30d2:	89 8f       	std	Y+25, r24	; 0x19
    30d4:	9a 8f       	std	Y+26, r25	; 0x1a
    30d6:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__fixsfsi>
        *buffer++ = digit + '0';
    30da:	20 e3       	ldi	r18, 0x30	; 48
    30dc:	26 0f       	add	r18, r22
    30de:	f7 01       	movw	r30, r14
    30e0:	21 93       	st	Z+, r18
    30e2:	7f 01       	movw	r14, r30
        value = value * 10 - digit;
    30e4:	07 2e       	mov	r0, r23
    30e6:	00 0c       	add	r0, r0
    30e8:	88 0b       	sbc	r24, r24
    30ea:	99 0b       	sbc	r25, r25
    30ec:	0e 94 82 1c 	call	0x3904	; 0x3904 <__floatsisf>
    30f0:	9b 01       	movw	r18, r22
    30f2:	ac 01       	movw	r20, r24
    30f4:	6f 89       	ldd	r22, Y+23	; 0x17
    30f6:	78 8d       	ldd	r23, Y+24	; 0x18
    30f8:	89 8d       	ldd	r24, Y+25	; 0x19
    30fa:	9a 8d       	ldd	r25, Y+26	; 0x1a
    30fc:	0e 94 66 1b 	call	0x36cc	; 0x36cc <__subsf3>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    3100:	e6 14       	cp	r14, r6
    3102:	f7 04       	cpc	r15, r7
    3104:	f1 f6       	brne	.-68     	; 0x30c2 <vDisplayWriteStringAtPos+0x2fa>
    3106:	6f 8b       	std	Y+23, r22	; 0x17
    3108:	78 8f       	std	Y+24, r23	; 0x18
    310a:	89 8f       	std	Y+25, r24	; 0x19
    310c:	9a 8f       	std	Y+26, r25	; 0x1a
        value = value * 10 - digit;
        ++places;
        --exponent;
    }

    if (places == 0)
    310e:	01 15       	cp	r16, r1
    3110:	11 05       	cpc	r17, r1
    3112:	89 f4       	brne	.+34     	; 0x3136 <vDisplayWriteStringAtPos+0x36e>
    3114:	db c1       	rjmp	.+950    	; 0x34cc <vDisplayWriteStringAtPos+0x704>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    3116:	c8 01       	movw	r24, r16
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    3118:	e0 e3       	ldi	r30, 0x30	; 48
    311a:	d3 01       	movw	r26, r6
    311c:	ec 93       	st	X, r30

    *buffer++ = '.';
    311e:	73 01       	movw	r14, r6
    3120:	f2 e0       	ldi	r31, 0x02	; 2
    3122:	ef 0e       	add	r14, r31
    3124:	f1 1c       	adc	r15, r1
    3126:	2e e2       	ldi	r18, 0x2E	; 46
    3128:	11 96       	adiw	r26, 0x01	; 1
    312a:	2c 93       	st	X, r18

    while (exponent < 0 && places < width) {
    312c:	99 23       	and	r25, r25
    312e:	6c f0       	brlt	.+26     	; 0x314a <vDisplayWriteStringAtPos+0x382>
    3130:	00 e0       	ldi	r16, 0x00	; 0
    3132:	10 e0       	ldi	r17, 0x00	; 0
    3134:	1f c0       	rjmp	.+62     	; 0x3174 <vDisplayWriteStringAtPos+0x3ac>
    }

    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';
    3136:	ec 8c       	ldd	r14, Y+28	; 0x1c
    3138:	fd 8c       	ldd	r15, Y+29	; 0x1d
    313a:	3f ef       	ldi	r19, 0xFF	; 255
    313c:	e3 1a       	sub	r14, r19
    313e:	f3 0a       	sbc	r15, r19
    3140:	ee e2       	ldi	r30, 0x2E	; 46
    3142:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3144:	bd 8d       	ldd	r27, Y+29	; 0x1d
    3146:	ec 93       	st	X, r30
    3148:	12 c0       	rjmp	.+36     	; 0x316e <vDisplayWriteStringAtPos+0x3a6>

    while (exponent < 0 && places < width) {
    314a:	00 e0       	ldi	r16, 0x00	; 0
    314c:	10 e0       	ldi	r17, 0x00	; 0
        *buffer++ = '0';
    314e:	ff ef       	ldi	r31, 0xFF	; 255
    3150:	ef 1a       	sub	r14, r31
    3152:	ff 0a       	sbc	r15, r31
    3154:	f7 01       	movw	r30, r14
    3156:	31 97       	sbiw	r30, 0x01	; 1
    3158:	20 e3       	ldi	r18, 0x30	; 48
    315a:	20 83       	st	Z, r18
        --exponent;
    315c:	01 97       	sbiw	r24, 0x01	; 1
        ++places;
    315e:	0f 5f       	subi	r16, 0xFF	; 255
    3160:	1f 4f       	sbci	r17, 0xFF	; 255
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    3162:	99 23       	and	r25, r25
    3164:	24 f4       	brge	.+8      	; 0x316e <vDisplayWriteStringAtPos+0x3a6>
    3166:	04 30       	cpi	r16, 0x04	; 4
    3168:	11 05       	cpc	r17, r1
    316a:	8c f3       	brlt	.-30     	; 0x314e <vDisplayWriteStringAtPos+0x386>
    316c:	31 c0       	rjmp	.+98     	; 0x31d0 <vDisplayWriteStringAtPos+0x408>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    316e:	04 30       	cpi	r16, 0x04	; 4
    3170:	11 05       	cpc	r17, r1
    3172:	74 f5       	brge	.+92     	; 0x31d0 <vDisplayWriteStringAtPos+0x408>
    3174:	37 01       	movw	r6, r14
    3176:	84 e0       	ldi	r24, 0x04	; 4
    3178:	90 e0       	ldi	r25, 0x00	; 0
    317a:	80 1b       	sub	r24, r16
    317c:	91 0b       	sbc	r25, r17
    317e:	e8 0e       	add	r14, r24
    3180:	f9 1e       	adc	r15, r25
    3182:	87 01       	movw	r16, r14
    3184:	6f 89       	ldd	r22, Y+23	; 0x17
    3186:	78 8d       	ldd	r23, Y+24	; 0x18
    3188:	89 8d       	ldd	r24, Y+25	; 0x19
    318a:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10.0;
    318c:	20 e0       	ldi	r18, 0x00	; 0
    318e:	30 e0       	ldi	r19, 0x00	; 0
    3190:	40 e2       	ldi	r20, 0x20	; 32
    3192:	51 e4       	ldi	r21, 0x41	; 65
    3194:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <__mulsf3>
    3198:	6f 8b       	std	Y+23, r22	; 0x17
    319a:	78 8f       	std	Y+24, r23	; 0x18
    319c:	89 8f       	std	Y+25, r24	; 0x19
    319e:	9a 8f       	std	Y+26, r25	; 0x1a
    31a0:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__fixsfsi>
        *buffer++ = digit + '0';
    31a4:	20 e3       	ldi	r18, 0x30	; 48
    31a6:	26 0f       	add	r18, r22
    31a8:	d3 01       	movw	r26, r6
    31aa:	2d 93       	st	X+, r18
    31ac:	3d 01       	movw	r6, r26
        value = value * 10.0 - digit;
    31ae:	07 2e       	mov	r0, r23
    31b0:	00 0c       	add	r0, r0
    31b2:	88 0b       	sbc	r24, r24
    31b4:	99 0b       	sbc	r25, r25
    31b6:	0e 94 82 1c 	call	0x3904	; 0x3904 <__floatsisf>
    31ba:	9b 01       	movw	r18, r22
    31bc:	ac 01       	movw	r20, r24
    31be:	6f 89       	ldd	r22, Y+23	; 0x17
    31c0:	78 8d       	ldd	r23, Y+24	; 0x18
    31c2:	89 8d       	ldd	r24, Y+25	; 0x19
    31c4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31c6:	0e 94 66 1b 	call	0x36cc	; 0x36cc <__subsf3>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    31ca:	60 16       	cp	r6, r16
    31cc:	71 06       	cpc	r7, r17
    31ce:	f1 f6       	brne	.-68     	; 0x318c <vDisplayWriteStringAtPos+0x3c4>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
        ++places;
    }
    *buffer = '\0';
    31d0:	f7 01       	movw	r30, r14
    31d2:	10 82       	st	Z, r1
    31d4:	94 01       	movw	r18, r8
    31d6:	f4 01       	movw	r30, r8
    31d8:	e0 53       	subi	r30, 0x30	; 48
    31da:	f3 4d       	sbci	r31, 0xD3	; 211
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    31dc:	44 ee       	ldi	r20, 0xE4	; 228
    31de:	5c e2       	ldi	r21, 0x2C	; 44
    31e0:	80 e0       	ldi	r24, 0x00	; 0
    31e2:	90 e0       	ldi	r25, 0x00	; 0
    31e4:	05 c0       	rjmp	.+10     	; 0x31f0 <vDisplayWriteStringAtPos+0x428>

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    31e6:	da 01       	movw	r26, r20
    31e8:	6d 91       	ld	r22, X+
    31ea:	ad 01       	movw	r20, r26
    31ec:	61 93       	st	Z+, r22
				break;

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    31ee:	01 96       	adiw	r24, 0x01	; 1
    31f0:	d6 01       	movw	r26, r12
    31f2:	0d 90       	ld	r0, X+
    31f4:	00 20       	and	r0, r0
    31f6:	e9 f7       	brne	.-6      	; 0x31f2 <vDisplayWriteStringAtPos+0x42a>
    31f8:	11 97       	sbiw	r26, 0x01	; 1
    31fa:	a4 5e       	subi	r26, 0xE4	; 228
    31fc:	bc 42       	sbci	r27, 0x2C	; 44
    31fe:	8a 17       	cp	r24, r26
    3200:	9b 07       	cpc	r25, r27
    3202:	88 f3       	brcs	.-30     	; 0x31e6 <vDisplayWriteStringAtPos+0x41e>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    3204:	4d 01       	movw	r8, r26
    3206:	82 0e       	add	r8, r18
    3208:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    320a:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    320c:	d2 01       	movw	r26, r4
    320e:	15 c1       	rjmp	.+554    	; 0x343a <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    3210:	17 01       	movw	r2, r14
    3212:	b4 e0       	ldi	r27, 0x04	; 4
    3214:	2b 0e       	add	r2, r27
    3216:	31 1c       	adc	r3, r1
    3218:	d7 01       	movw	r26, r14
    321a:	8d 91       	ld	r24, X+
    321c:	9d 91       	ld	r25, X+
    321e:	0d 90       	ld	r0, X+
    3220:	bc 91       	ld	r27, X
    3222:	a0 2d       	mov	r26, r0
    3224:	8f 8b       	std	Y+23, r24	; 0x17
    3226:	98 8f       	std	Y+24, r25	; 0x18
    3228:	a9 8f       	std	Y+25, r26	; 0x19
    322a:	ba 8f       	std	Y+26, r27	; 0x1a

void ftoa_sci(char *buffer, double value) {
    int exponent = 0;    
    static const int width = 4;

    if (value == 0.0) {
    322c:	20 e0       	ldi	r18, 0x00	; 0
    322e:	30 e0       	ldi	r19, 0x00	; 0
    3230:	a9 01       	movw	r20, r18
    3232:	bc 01       	movw	r22, r24
    3234:	cd 01       	movw	r24, r26
    3236:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <__cmpsf2>
    323a:	81 11       	cpse	r24, r1
    323c:	05 c0       	rjmp	.+10     	; 0x3248 <vDisplayWriteStringAtPos+0x480>
        buffer[0] = '0';
    323e:	20 e3       	ldi	r18, 0x30	; 48
    3240:	f6 01       	movw	r30, r12
    3242:	20 83       	st	Z, r18
        buffer[1] = '\0';
    3244:	11 82       	std	Z+1, r1	; 0x01
    3246:	ca c0       	rjmp	.+404    	; 0x33dc <vDisplayWriteStringAtPos+0x614>
        return;
    }

    if (value < 0.0) {
    3248:	20 e0       	ldi	r18, 0x00	; 0
    324a:	30 e0       	ldi	r19, 0x00	; 0
    324c:	a9 01       	movw	r20, r18
    324e:	6f 89       	ldd	r22, Y+23	; 0x17
    3250:	78 8d       	ldd	r23, Y+24	; 0x18
    3252:	89 8d       	ldd	r24, Y+25	; 0x19
    3254:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3256:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <__cmpsf2>
    325a:	88 23       	and	r24, r24
    325c:	9c f4       	brge	.+38     	; 0x3284 <vDisplayWriteStringAtPos+0x4bc>
        *buffer++ = '-';
    325e:	ed e2       	ldi	r30, 0x2D	; 45
    3260:	d6 01       	movw	r26, r12
    3262:	ec 93       	st	X, r30
        value = -value;
    3264:	8f 89       	ldd	r24, Y+23	; 0x17
    3266:	98 8d       	ldd	r25, Y+24	; 0x18
    3268:	a9 8d       	ldd	r26, Y+25	; 0x19
    326a:	ba 8d       	ldd	r27, Y+26	; 0x1a
    326c:	b0 58       	subi	r27, 0x80	; 128
    326e:	8f 8b       	std	Y+23, r24	; 0x17
    3270:	98 8f       	std	Y+24, r25	; 0x18
    3272:	a9 8f       	std	Y+25, r26	; 0x19
    3274:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
        *buffer++ = '-';
    3276:	0f 2e       	mov	r0, r31
    3278:	f5 ee       	ldi	r31, 0xE5	; 229
    327a:	6f 2e       	mov	r6, r31
    327c:	fc e2       	ldi	r31, 0x2C	; 44
    327e:	7f 2e       	mov	r7, r31
    3280:	f0 2d       	mov	r31, r0
    3282:	01 c0       	rjmp	.+2      	; 0x3286 <vDisplayWriteStringAtPos+0x4be>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
    3284:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3286:	20 e0       	ldi	r18, 0x00	; 0
    3288:	30 e0       	ldi	r19, 0x00	; 0
    328a:	40 e8       	ldi	r20, 0x80	; 128
    328c:	5f e3       	ldi	r21, 0x3F	; 63
    328e:	6f 89       	ldd	r22, Y+23	; 0x17
    3290:	78 8d       	ldd	r23, Y+24	; 0x18
    3292:	89 8d       	ldd	r24, Y+25	; 0x19
    3294:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3296:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <__gesf2>
    329a:	88 23       	and	r24, r24
    329c:	dc f0       	brlt	.+54     	; 0x32d4 <vDisplayWriteStringAtPos+0x50c>
    329e:	00 e0       	ldi	r16, 0x00	; 0
    32a0:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    32a2:	20 e0       	ldi	r18, 0x00	; 0
    32a4:	30 e0       	ldi	r19, 0x00	; 0
    32a6:	40 e2       	ldi	r20, 0x20	; 32
    32a8:	51 e4       	ldi	r21, 0x41	; 65
    32aa:	6f 89       	ldd	r22, Y+23	; 0x17
    32ac:	78 8d       	ldd	r23, Y+24	; 0x18
    32ae:	89 8d       	ldd	r24, Y+25	; 0x19
    32b0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    32b2:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__divsf3>
    32b6:	6f 8b       	std	Y+23, r22	; 0x17
    32b8:	78 8f       	std	Y+24, r23	; 0x18
    32ba:	89 8f       	std	Y+25, r24	; 0x19
    32bc:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    32be:	0f 5f       	subi	r16, 0xFF	; 255
    32c0:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    32c2:	20 e0       	ldi	r18, 0x00	; 0
    32c4:	30 e0       	ldi	r19, 0x00	; 0
    32c6:	40 e8       	ldi	r20, 0x80	; 128
    32c8:	5f e3       	ldi	r21, 0x3F	; 63
    32ca:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <__gesf2>
    32ce:	88 23       	and	r24, r24
    32d0:	44 f7       	brge	.-48     	; 0x32a2 <vDisplayWriteStringAtPos+0x4da>
    32d2:	02 c0       	rjmp	.+4      	; 0x32d8 <vDisplayWriteStringAtPos+0x510>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    32d4:	00 e0       	ldi	r16, 0x00	; 0
    32d6:	10 e0       	ldi	r17, 0x00	; 0
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    32d8:	2d ec       	ldi	r18, 0xCD	; 205
    32da:	3c ec       	ldi	r19, 0xCC	; 204
    32dc:	4c ec       	ldi	r20, 0xCC	; 204
    32de:	5d e3       	ldi	r21, 0x3D	; 61
    32e0:	6f 89       	ldd	r22, Y+23	; 0x17
    32e2:	78 8d       	ldd	r23, Y+24	; 0x18
    32e4:	89 8d       	ldd	r24, Y+25	; 0x19
    32e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    32e8:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <__cmpsf2>
    32ec:	88 23       	and	r24, r24
    32ee:	c4 f4       	brge	.+48     	; 0x3320 <vDisplayWriteStringAtPos+0x558>
        value *= 10.0;
    32f0:	20 e0       	ldi	r18, 0x00	; 0
    32f2:	30 e0       	ldi	r19, 0x00	; 0
    32f4:	40 e2       	ldi	r20, 0x20	; 32
    32f6:	51 e4       	ldi	r21, 0x41	; 65
    32f8:	6f 89       	ldd	r22, Y+23	; 0x17
    32fa:	78 8d       	ldd	r23, Y+24	; 0x18
    32fc:	89 8d       	ldd	r24, Y+25	; 0x19
    32fe:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3300:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <__mulsf3>
    3304:	6f 8b       	std	Y+23, r22	; 0x17
    3306:	78 8f       	std	Y+24, r23	; 0x18
    3308:	89 8f       	std	Y+25, r24	; 0x19
    330a:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    330c:	01 50       	subi	r16, 0x01	; 1
    330e:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3310:	2d ec       	ldi	r18, 0xCD	; 205
    3312:	3c ec       	ldi	r19, 0xCC	; 204
    3314:	4c ec       	ldi	r20, 0xCC	; 204
    3316:	5d e3       	ldi	r21, 0x3D	; 61
    3318:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <__cmpsf2>
    331c:	88 23       	and	r24, r24
    331e:	44 f3       	brlt	.-48     	; 0x32f0 <vDisplayWriteStringAtPos+0x528>
        value = -value;
    }

    exponent = normalize(&value);

    int digit = value * 10.0;
    3320:	20 e0       	ldi	r18, 0x00	; 0
    3322:	30 e0       	ldi	r19, 0x00	; 0
    3324:	40 e2       	ldi	r20, 0x20	; 32
    3326:	51 e4       	ldi	r21, 0x41	; 65
    3328:	6f 89       	ldd	r22, Y+23	; 0x17
    332a:	78 8d       	ldd	r23, Y+24	; 0x18
    332c:	89 8d       	ldd	r24, Y+25	; 0x19
    332e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3330:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <__mulsf3>
    3334:	6f 8b       	std	Y+23, r22	; 0x17
    3336:	78 8f       	std	Y+24, r23	; 0x18
    3338:	89 8f       	std	Y+25, r24	; 0x19
    333a:	9a 8f       	std	Y+26, r25	; 0x1a
    333c:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__fixsfsi>
    *buffer++ = digit + '0';
    3340:	20 e3       	ldi	r18, 0x30	; 48
    3342:	26 0f       	add	r18, r22
    3344:	d3 01       	movw	r26, r6
    3346:	2c 93       	st	X, r18
    value = value * 10.0 - digit;
    3348:	07 2e       	mov	r0, r23
    334a:	00 0c       	add	r0, r0
    334c:	88 0b       	sbc	r24, r24
    334e:	99 0b       	sbc	r25, r25
    3350:	0e 94 82 1c 	call	0x3904	; 0x3904 <__floatsisf>
    3354:	9b 01       	movw	r18, r22
    3356:	ac 01       	movw	r20, r24
    3358:	6f 89       	ldd	r22, Y+23	; 0x17
    335a:	78 8d       	ldd	r23, Y+24	; 0x18
    335c:	89 8d       	ldd	r24, Y+25	; 0x19
    335e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3360:	0e 94 66 1b 	call	0x36cc	; 0x36cc <__subsf3>
    --exponent;
    3364:	f8 01       	movw	r30, r16
    3366:	31 97       	sbiw	r30, 0x01	; 1
    3368:	ec 8f       	std	Y+28, r30	; 0x1c
    336a:	fd 8f       	std	Y+29, r31	; 0x1d

    *buffer++ = '.';
    336c:	ee e2       	ldi	r30, 0x2E	; 46
    336e:	d3 01       	movw	r26, r6
    3370:	11 96       	adiw	r26, 0x01	; 1
    3372:	ec 93       	st	X, r30
    3374:	83 01       	movw	r16, r6
    3376:	0e 5f       	subi	r16, 0xFE	; 254
    3378:	1f 4f       	sbci	r17, 0xFF	; 255
    337a:	73 01       	movw	r14, r6
    337c:	f6 e0       	ldi	r31, 0x06	; 6
    337e:	ef 0e       	add	r14, r31
    3380:	f1 1c       	adc	r15, r1

    for (int i = 0; i < width; i++) {
        int digit = value * 10.0;
    3382:	20 e0       	ldi	r18, 0x00	; 0
    3384:	30 e0       	ldi	r19, 0x00	; 0
    3386:	40 e2       	ldi	r20, 0x20	; 32
    3388:	51 e4       	ldi	r21, 0x41	; 65
    338a:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <__mulsf3>
    338e:	6f 8b       	std	Y+23, r22	; 0x17
    3390:	78 8f       	std	Y+24, r23	; 0x18
    3392:	89 8f       	std	Y+25, r24	; 0x19
    3394:	9a 8f       	std	Y+26, r25	; 0x1a
    3396:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__fixsfsi>
        *buffer++ = digit + '0';
    339a:	20 e3       	ldi	r18, 0x30	; 48
    339c:	26 0f       	add	r18, r22
    339e:	d8 01       	movw	r26, r16
    33a0:	2d 93       	st	X+, r18
    33a2:	8d 01       	movw	r16, r26
        value = value * 10.0 - digit;
    33a4:	07 2e       	mov	r0, r23
    33a6:	00 0c       	add	r0, r0
    33a8:	88 0b       	sbc	r24, r24
    33aa:	99 0b       	sbc	r25, r25
    33ac:	0e 94 82 1c 	call	0x3904	; 0x3904 <__floatsisf>
    33b0:	9b 01       	movw	r18, r22
    33b2:	ac 01       	movw	r20, r24
    33b4:	6f 89       	ldd	r22, Y+23	; 0x17
    33b6:	78 8d       	ldd	r23, Y+24	; 0x18
    33b8:	89 8d       	ldd	r24, Y+25	; 0x19
    33ba:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33bc:	0e 94 66 1b 	call	0x36cc	; 0x36cc <__subsf3>
    value = value * 10.0 - digit;
    --exponent;

    *buffer++ = '.';

    for (int i = 0; i < width; i++) {
    33c0:	0e 15       	cp	r16, r14
    33c2:	1f 05       	cpc	r17, r15
    33c4:	f1 f6       	brne	.-68     	; 0x3382 <vDisplayWriteStringAtPos+0x5ba>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
    }

    *buffer++ = 'e';
    33c6:	25 e6       	ldi	r18, 0x65	; 101
    33c8:	f3 01       	movw	r30, r6
    33ca:	26 83       	std	Z+6, r18	; 0x06
    33cc:	b3 01       	movw	r22, r6
    33ce:	69 5f       	subi	r22, 0xF9	; 249
    33d0:	7f 4f       	sbci	r23, 0xFF	; 255
    33d2:	4a e0       	ldi	r20, 0x0A	; 10
    33d4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    33d6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    33d8:	0e 94 bc 1d 	call	0x3b78	; 0x3b78 <__itoa_ncheck>
    33dc:	94 01       	movw	r18, r8
    33de:	f4 01       	movw	r30, r8
    33e0:	e0 53       	subi	r30, 0x30	; 48
    33e2:	f3 4d       	sbci	r31, 0xD3	; 211
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    33e4:	44 ee       	ldi	r20, 0xE4	; 228
    33e6:	5c e2       	ldi	r21, 0x2C	; 44
    33e8:	80 e0       	ldi	r24, 0x00	; 0
    33ea:	90 e0       	ldi	r25, 0x00	; 0
    33ec:	05 c0       	rjmp	.+10     	; 0x33f8 <vDisplayWriteStringAtPos+0x630>

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    33ee:	da 01       	movw	r26, r20
    33f0:	6d 91       	ld	r22, X+
    33f2:	ad 01       	movw	r20, r26
    33f4:	61 93       	st	Z+, r22
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    33f6:	01 96       	adiw	r24, 0x01	; 1
    33f8:	d6 01       	movw	r26, r12
    33fa:	0d 90       	ld	r0, X+
    33fc:	00 20       	and	r0, r0
    33fe:	e9 f7       	brne	.-6      	; 0x33fa <vDisplayWriteStringAtPos+0x632>
    3400:	11 97       	sbiw	r26, 0x01	; 1
    3402:	a4 5e       	subi	r26, 0xE4	; 228
    3404:	bc 42       	sbci	r27, 0x2C	; 44
    3406:	8a 17       	cp	r24, r26
    3408:	9b 07       	cpc	r25, r27
    340a:	88 f3       	brcs	.-30     	; 0x33ee <vDisplayWriteStringAtPos+0x626>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    340c:	4d 01       	movw	r8, r26
    340e:	82 0e       	add	r8, r18
    3410:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    3412:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3414:	d2 01       	movw	r26, r4
    3416:	11 c0       	rjmp	.+34     	; 0x343a <vDisplayWriteStringAtPos+0x672>
				break;
			}
		}
		else {
			str[length] = ch;
			if(str[length] == '\n') {
    3418:	8a 30       	cpi	r24, 0x0A	; 10
    341a:	29 f0       	breq	.+10     	; 0x3426 <vDisplayWriteStringAtPos+0x65e>
				length += strlen(buffer);
				break;
			}
		}
		else {
			str[length] = ch;
    341c:	f4 01       	movw	r30, r8
    341e:	e0 53       	subi	r30, 0x30	; 48
    3420:	f3 4d       	sbci	r31, 0xD3	; 211
    3422:	80 83       	st	Z, r24
    3424:	04 c0       	rjmp	.+8      	; 0x342e <vDisplayWriteStringAtPos+0x666>
			if(str[length] == '\n') {
				str[length] = '\0';				
    3426:	f4 01       	movw	r30, r8
    3428:	e0 53       	subi	r30, 0x30	; 48
    342a:	f3 4d       	sbci	r31, 0xD3	; 211
    342c:	10 82       	st	Z, r1
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    342e:	11 96       	adiw	r26, 0x01	; 1
		else {
			str[length] = ch;
			if(str[length] == '\n') {
				str[length] = '\0';				
			}
			length++;
    3430:	ef ef       	ldi	r30, 0xFF	; 255
    3432:	8e 1a       	sub	r8, r30
    3434:	9e 0a       	sbc	r9, r30
    3436:	01 c0       	rjmp	.+2      	; 0x343a <vDisplayWriteStringAtPos+0x672>
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3438:	d2 01       	movw	r26, r4
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    343a:	8c 91       	ld	r24, X
    343c:	81 11       	cpse	r24, r1
    343e:	01 cd       	rjmp	.-1534   	; 0x2e42 <vDisplayWriteStringAtPos+0x7a>
				str[length] = '\0';				
			}
			length++;
		}
	}
	if(length + pos >= 20) {
    3440:	8d a9       	ldd	r24, Y+53	; 0x35
    3442:	9e a9       	ldd	r25, Y+54	; 0x36
    3444:	88 0d       	add	r24, r8
    3446:	99 1d       	adc	r25, r9
    3448:	44 97       	sbiw	r24, 0x14	; 20
    344a:	3c f0       	brlt	.+14     	; 0x345a <vDisplayWriteStringAtPos+0x692>
		length = 20-pos;
    344c:	84 e1       	ldi	r24, 0x14	; 20
    344e:	90 e0       	ldi	r25, 0x00	; 0
    3450:	4c 01       	movw	r8, r24
    3452:	2d a9       	ldd	r18, Y+53	; 0x35
    3454:	3e a9       	ldd	r19, Y+54	; 0x36
    3456:	82 1a       	sub	r8, r18
    3458:	93 0a       	sbc	r9, r19
    345a:	fe 01       	movw	r30, r28
    345c:	33 96       	adiw	r30, 0x03	; 3
    345e:	ce 01       	movw	r24, r28
    3460:	47 96       	adiw	r24, 0x17	; 23
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    3462:	df 01       	movw	r26, r30
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
    3464:	1d 92       	st	X+, r1
	}
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
    3466:	a8 17       	cp	r26, r24
    3468:	b9 07       	cpc	r27, r25
    346a:	e1 f7       	brne	.-8      	; 0x3464 <vDisplayWriteStringAtPos+0x69c>
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
    346c:	3b 8d       	ldd	r19, Y+27	; 0x1b
    346e:	39 83       	std	Y+1, r19	; 0x01
	newLine.displayPos = pos;
    3470:	8d a9       	ldd	r24, Y+53	; 0x35
    3472:	8a 83       	std	Y+2, r24	; 0x02
	for(int i = 0; i < length;i++) {
    3474:	18 14       	cp	r1, r8
    3476:	19 04       	cpc	r1, r9
    3478:	5c f4       	brge	.+22     	; 0x3490 <vDisplayWriteStringAtPos+0x6c8>
    347a:	ce 01       	movw	r24, r28
    347c:	88 0d       	add	r24, r8
    347e:	99 1d       	adc	r25, r9
    3480:	03 96       	adiw	r24, 0x03	; 3
		newLine.displayBuffer[i] = str[i];
    3482:	d5 01       	movw	r26, r10
    3484:	2d 91       	ld	r18, X+
    3486:	5d 01       	movw	r10, r26
    3488:	21 93       	st	Z+, r18
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
	newLine.displayPos = pos;
	for(int i = 0; i < length;i++) {
    348a:	8e 17       	cp	r24, r30
    348c:	9f 07       	cpc	r25, r31
    348e:	c9 f7       	brne	.-14     	; 0x3482 <vDisplayWriteStringAtPos+0x6ba>
		newLine.displayBuffer[i] = str[i];
	}	
	xQueueSend(displayLineQueue, (void *) &newLine, portMAX_DELAY);
    3490:	00 e0       	ldi	r16, 0x00	; 0
    3492:	2f ef       	ldi	r18, 0xFF	; 255
    3494:	3f ef       	ldi	r19, 0xFF	; 255
    3496:	a9 01       	movw	r20, r18
    3498:	be 01       	movw	r22, r28
    349a:	6f 5f       	subi	r22, 0xFF	; 255
    349c:	7f 4f       	sbci	r23, 0xFF	; 255
    349e:	80 91 0d 3f 	lds	r24, 0x3F0D	; 0x803f0d <displayLineQueue>
    34a2:	90 91 0e 3f 	lds	r25, 0x3F0E	; 0x803f0e <displayLineQueue+0x1>
    34a6:	0e 94 00 08 	call	0x1000	; 0x1000 <xQueueGenericSend>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    34aa:	1b c0       	rjmp	.+54     	; 0x34e2 <vDisplayWriteStringAtPos+0x71a>
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    34ac:	2d ec       	ldi	r18, 0xCD	; 205
    34ae:	3c ec       	ldi	r19, 0xCC	; 204
    34b0:	4c ec       	ldi	r20, 0xCC	; 204
    34b2:	5d e3       	ldi	r21, 0x3D	; 61
    34b4:	6f 89       	ldd	r22, Y+23	; 0x17
    34b6:	78 8d       	ldd	r23, Y+24	; 0x18
    34b8:	89 8d       	ldd	r24, Y+25	; 0x19
    34ba:	9a 8d       	ldd	r25, Y+26	; 0x1a
    34bc:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <__cmpsf2>
    34c0:	88 23       	and	r24, r24
    34c2:	0c f4       	brge	.+2      	; 0x34c6 <vDisplayWriteStringAtPos+0x6fe>
    34c4:	d6 cd       	rjmp	.-1108   	; 0x3072 <vDisplayWriteStringAtPos+0x2aa>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    34c6:	80 e0       	ldi	r24, 0x00	; 0
    34c8:	90 e0       	ldi	r25, 0x00	; 0
    34ca:	26 ce       	rjmp	.-948    	; 0x3118 <vDisplayWriteStringAtPos+0x350>
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    34cc:	20 e3       	ldi	r18, 0x30	; 48
    34ce:	ec 8d       	ldd	r30, Y+28	; 0x1c
    34d0:	fd 8d       	ldd	r31, Y+29	; 0x1d
    34d2:	20 83       	st	Z, r18

    *buffer++ = '.';
    34d4:	7f 01       	movw	r14, r30
    34d6:	32 e0       	ldi	r19, 0x02	; 2
    34d8:	e3 0e       	add	r14, r19
    34da:	f1 1c       	adc	r15, r1
    34dc:	8e e2       	ldi	r24, 0x2E	; 46
    34de:	81 83       	std	Z+1, r24	; 0x01
    34e0:	46 ce       	rjmp	.-884    	; 0x316e <vDisplayWriteStringAtPos+0x3a6>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    34e2:	6d 96       	adiw	r28, 0x1d	; 29
    34e4:	cd bf       	out	0x3d, r28	; 61
    34e6:	de bf       	out	0x3e, r29	; 62
    34e8:	df 91       	pop	r29
    34ea:	cf 91       	pop	r28
    34ec:	1f 91       	pop	r17
    34ee:	0f 91       	pop	r16
    34f0:	ff 90       	pop	r15
    34f2:	ef 90       	pop	r14
    34f4:	df 90       	pop	r13
    34f6:	cf 90       	pop	r12
    34f8:	bf 90       	pop	r11
    34fa:	af 90       	pop	r10
    34fc:	9f 90       	pop	r9
    34fe:	8f 90       	pop	r8
    3500:	7f 90       	pop	r7
    3502:	6f 90       	pop	r6
    3504:	5f 90       	pop	r5
    3506:	4f 90       	pop	r4
    3508:	3f 90       	pop	r3
    350a:	2f 90       	pop	r2
    350c:	08 95       	ret

0000350e <vTask_DMAHandler>:
EventGroupHandle_t xSignalProcessEventGroup;

void vTask_DMAHandler(void *pvParameters) 
{
	//Do things and Stuff with DMA!
	xDMAProcessEventGroup = xEventGroupCreate();
    350e:	0e 94 a8 02 	call	0x550	; 0x550 <xEventGroupCreate>
    3512:	80 93 fa 2c 	sts	0x2CFA, r24	; 0x802cfa <xDMAProcessEventGroup>
    3516:	90 93 fb 2c 	sts	0x2CFB, r25	; 0x802cfb <xDMAProcessEventGroup+0x1>
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,count_after_peak = 0;
	PORTF.DIRSET = PIN1_bm; /*LED1*/
    351a:	e0 ea       	ldi	r30, 0xA0	; 160
    351c:	f6 e0       	ldi	r31, 0x06	; 6
    351e:	82 e0       	ldi	r24, 0x02	; 2
    3520:	81 83       	std	Z+1, r24	; 0x01
	PORTF.DIRSET = PIN2_bm; /*LED2*/
    3522:	94 e0       	ldi	r25, 0x04	; 4
    3524:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN0_bm;
    3526:	e0 e8       	ldi	r30, 0x80	; 128
    3528:	f6 e0       	ldi	r31, 0x06	; 6
    352a:	91 e0       	ldi	r25, 0x01	; 1
    352c:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN1_bm;
    352e:	81 83       	std	Z+1, r24	; 0x01
{
	//Do things and Stuff with DMA!
	xDMAProcessEventGroup = xEventGroupCreate();
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,count_after_peak = 0;
    3530:	a1 2c       	mov	r10, r1
    3532:	b1 2c       	mov	r11, r1
						}
				}
			}
			count_buffer_b++;
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x04));
    3534:	0f 2e       	mov	r0, r31
    3536:	f0 ea       	ldi	r31, 0xA0	; 160
    3538:	8f 2e       	mov	r8, r31
    353a:	f6 e0       	ldi	r31, 0x06	; 6
    353c:	9f 2e       	mov	r9, r31
    353e:	f0 2d       	mov	r31, r0
	PORTE.DIRSET = PIN0_bm;
	PORTE.DIRSET = PIN1_bm;
	
	while(1)
	{
		uxBits = xEventGroupWaitBits(
    3540:	cc 24       	eor	r12, r12
    3542:	ca 94       	dec	r12
    3544:	dc 2c       	mov	r13, r12
    3546:	76 01       	movw	r14, r12
    3548:	00 e0       	ldi	r16, 0x00	; 0
    354a:	21 e0       	ldi	r18, 0x01	; 1
    354c:	43 e0       	ldi	r20, 0x03	; 3
    354e:	50 e0       	ldi	r21, 0x00	; 0
    3550:	60 e0       	ldi	r22, 0x00	; 0
    3552:	70 e0       	ldi	r23, 0x00	; 0
    3554:	80 91 fa 2c 	lds	r24, 0x2CFA	; 0x802cfa <xDMAProcessEventGroup>
    3558:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <xDMAProcessEventGroup+0x1>
    355c:	0e 94 bd 02 	call	0x57a	; 0x57a <xEventGroupWaitBits>
		pdTRUE,        /* Bits should be cleared before returning. */
		pdFALSE,       /* Don't wait for both bits, either bit will do. */
		portMAX_DELAY );/* Wait a maximum for either bit to be set. */
			
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
    3560:	60 ff       	sbrs	r22, 0
    3562:	43 c0       	rjmp	.+134    	; 0x35ea <vTask_DMAHandler+0xdc>
		{
			//Do stuff with BufferA
			//buffer_a ....
			count_array_a++; // test number of write cycles
    3564:	80 91 f4 36 	lds	r24, 0x36F4	; 0x8036f4 <count_array_a>
    3568:	90 91 f5 36 	lds	r25, 0x36F5	; 0x8036f5 <count_array_a+0x1>
    356c:	01 96       	adiw	r24, 0x01	; 1
    356e:	80 93 f4 36 	sts	0x36F4, r24	; 0x8036f4 <count_array_a>
    3572:	90 93 f5 36 	sts	0x36F5, r25	; 0x8036f5 <count_array_a+0x1>
			for (i=0;i<2048;i++)//Detect signal 
    3576:	c0 e0       	ldi	r28, 0x00	; 0
    3578:	d0 e0       	ldi	r29, 0x00	; 0
			{
				if (buffer_a[i] >= 20)
    357a:	fe 01       	movw	r30, r28
    357c:	ea 50       	subi	r30, 0x0A	; 10
    357e:	f9 4c       	sbci	r31, 0xC9	; 201
    3580:	80 81       	ld	r24, Z
    3582:	84 31       	cpi	r24, 0x14	; 20
    3584:	70 f0       	brcs	.+28     	; 0x35a2 <vTask_DMAHandler+0x94>
				{
					xResult = xEventGroupSetBits(
    3586:	42 e0       	ldi	r20, 0x02	; 2
    3588:	50 e0       	ldi	r21, 0x00	; 0
    358a:	60 e0       	ldi	r22, 0x00	; 0
    358c:	70 e0       	ldi	r23, 0x00	; 0
    358e:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <xSignalProcessEventGroup>
    3592:	90 91 f7 2d 	lds	r25, 0x2DF7	; 0x802df7 <xSignalProcessEventGroup+0x1>
    3596:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
    359a:	16 2f       	mov	r17, r22
								);
					if( xResult & Process_Signal_BufferB )		//test if Eventgroup bit is set
					{
						//count_array_a++;
					}
					count_after_peak = 0;
    359c:	a1 2c       	mov	r10, r1
    359e:	b1 2c       	mov	r11, r1
    35a0:	12 c0       	rjmp	.+36     	; 0x35c6 <vTask_DMAHandler+0xb8>
				}
				
				else											// if value is under threshold, it shall stop calculating the signal
				{
					count_after_peak++;							// wait 100 counts to make sure that signal has stopped
    35a2:	8f ef       	ldi	r24, 0xFF	; 255
    35a4:	a8 1a       	sub	r10, r24
    35a6:	b8 0a       	sbc	r11, r24
					if (count_after_peak >=100)					// no signal stop calculating -> set event bits to 0
    35a8:	e4 e6       	ldi	r30, 0x64	; 100
    35aa:	ae 16       	cp	r10, r30
    35ac:	b1 04       	cpc	r11, r1
    35ae:	5c f0       	brlt	.+22     	; 0x35c6 <vTask_DMAHandler+0xb8>
					{											// no signal stop calculating -> set event bits to 0
						xResult = xEventGroupClearBits(			// clear event bits
    35b0:	43 e0       	ldi	r20, 0x03	; 3
    35b2:	50 e0       	ldi	r21, 0x00	; 0
    35b4:	60 e0       	ldi	r22, 0x00	; 0
    35b6:	70 e0       	ldi	r23, 0x00	; 0
    35b8:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <xSignalProcessEventGroup>
    35bc:	90 91 f7 2d 	lds	r25, 0x2DF7	; 0x802df7 <xSignalProcessEventGroup+0x1>
    35c0:	0e 94 82 03 	call	0x704	; 0x704 <xEventGroupClearBits>
    35c4:	16 2f       	mov	r17, r22
		if(uxBits & DMA_EVT_GRP_BufferA)
		{
			//Do stuff with BufferA
			//buffer_a ....
			count_array_a++; // test number of write cycles
			for (i=0;i<2048;i++)//Detect signal 
    35c6:	21 96       	adiw	r28, 0x01	; 1
    35c8:	c1 15       	cp	r28, r1
    35ca:	f8 e0       	ldi	r31, 0x08	; 8
    35cc:	df 07       	cpc	r29, r31
    35ce:	a9 f6       	brne	.-86     	; 0x357a <vTask_DMAHandler+0x6c>
											Process_Signal_BufferA|Process_Signal_BufferB
											);												
					}
				}
			}
			count_buffer_a++;
    35d0:	80 91 f9 2c 	lds	r24, 0x2CF9	; 0x802cf9 <count_buffer_a>
    35d4:	8f 5f       	subi	r24, 0xFF	; 255
    35d6:	80 93 f9 2c 	sts	0x2CF9, r24	; 0x802cf9 <count_buffer_a>
			
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x02));
    35da:	f4 01       	movw	r30, r8
    35dc:	84 81       	ldd	r24, Z+4	; 0x04
    35de:	8d 7f       	andi	r24, 0xFD	; 253
    35e0:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x04;	
    35e2:	84 81       	ldd	r24, Z+4	; 0x04
    35e4:	84 60       	ori	r24, 0x04	; 4
    35e6:	84 83       	std	Z+4, r24	; 0x04
    35e8:	44 c0       	rjmp	.+136    	; 0x3672 <vTask_DMAHandler+0x164>
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			count_array_b++; // test number of write cycles
    35ea:	80 91 f2 2e 	lds	r24, 0x2EF2	; 0x802ef2 <count_array_b>
    35ee:	90 91 f3 2e 	lds	r25, 0x2EF3	; 0x802ef3 <count_array_b+0x1>
    35f2:	01 96       	adiw	r24, 0x01	; 1
    35f4:	80 93 f2 2e 	sts	0x2EF2, r24	; 0x802ef2 <count_array_b>
    35f8:	90 93 f3 2e 	sts	0x2EF3, r25	; 0x802ef3 <count_array_b+0x1>
			for (i=0;i<2048;i++)
    35fc:	c0 e0       	ldi	r28, 0x00	; 0
    35fe:	d0 e0       	ldi	r29, 0x00	; 0
			{				
				if (buffer_b[i] >= 20)
    3600:	fe 01       	movw	r30, r28
    3602:	ec 50       	subi	r30, 0x0C	; 12
    3604:	f1 4d       	sbci	r31, 0xD1	; 209
    3606:	80 81       	ld	r24, Z
    3608:	84 31       	cpi	r24, 0x14	; 20
    360a:	58 f0       	brcs	.+22     	; 0x3622 <vTask_DMAHandler+0x114>
				{
				xResult = xEventGroupSetBits(
    360c:	41 e0       	ldi	r20, 0x01	; 1
    360e:	50 e0       	ldi	r21, 0x00	; 0
    3610:	60 e0       	ldi	r22, 0x00	; 0
    3612:	70 e0       	ldi	r23, 0x00	; 0
    3614:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <xSignalProcessEventGroup>
    3618:	90 91 f7 2d 	lds	r25, 0x2DF7	; 0x802df7 <xSignalProcessEventGroup+0x1>
    361c:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
    3620:	16 2f       	mov	r17, r22
									xSignalProcessEventGroup,   /* The event group being updated. */
									Process_Signal_BufferA		/* The bits being set. */
									);	
				}
				if(xResult & Process_Signal_BufferA)			//test if Eventgroup bit is set
    3622:	10 ff       	sbrs	r17, 0
    3624:	03 c0       	rjmp	.+6      	; 0x362c <vTask_DMAHandler+0x11e>
				{
					{
						//count_array_b++;
					}
					count_buffer_a = 0;
    3626:	10 92 f9 2c 	sts	0x2CF9, r1	; 0x802cf9 <count_buffer_a>
    362a:	12 c0       	rjmp	.+36     	; 0x3650 <vTask_DMAHandler+0x142>
				}
				else											// if value is under threshold, it shall stop calculating the signal
				{
					count_after_peak++;					
    362c:	ff ef       	ldi	r31, 0xFF	; 255
    362e:	af 1a       	sub	r10, r31
    3630:	bf 0a       	sbc	r11, r31
					if (count_after_peak >=100)					// wait 100 counts to make sure that signal has stopped
    3632:	84 e6       	ldi	r24, 0x64	; 100
    3634:	a8 16       	cp	r10, r24
    3636:	b1 04       	cpc	r11, r1
    3638:	5c f0       	brlt	.+22     	; 0x3650 <vTask_DMAHandler+0x142>
					{									
						xResult = xEventGroupClearBits(			// clear event bits
    363a:	43 e0       	ldi	r20, 0x03	; 3
    363c:	50 e0       	ldi	r21, 0x00	; 0
    363e:	60 e0       	ldi	r22, 0x00	; 0
    3640:	70 e0       	ldi	r23, 0x00	; 0
    3642:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <xSignalProcessEventGroup>
    3646:	90 91 f7 2d 	lds	r25, 0x2DF7	; 0x802df7 <xSignalProcessEventGroup+0x1>
    364a:	0e 94 82 03 	call	0x704	; 0x704 <xEventGroupClearBits>
    364e:	16 2f       	mov	r17, r22
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			count_array_b++; // test number of write cycles
			for (i=0;i<2048;i++)
    3650:	21 96       	adiw	r28, 0x01	; 1
    3652:	c1 15       	cp	r28, r1
    3654:	e8 e0       	ldi	r30, 0x08	; 8
    3656:	de 07       	cpc	r29, r30
    3658:	99 f6       	brne	.-90     	; 0x3600 <vTask_DMAHandler+0xf2>
												Process_Signal_BufferA|Process_Signal_BufferB
												);										// no signal stop calculating -> set event bits to 0
						}
				}
			}
			count_buffer_b++;
    365a:	80 91 f8 2c 	lds	r24, 0x2CF8	; 0x802cf8 <count_buffer_b>
    365e:	8f 5f       	subi	r24, 0xFF	; 255
    3660:	80 93 f8 2c 	sts	0x2CF8, r24	; 0x802cf8 <count_buffer_b>
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x04));
    3664:	f4 01       	movw	r30, r8
    3666:	84 81       	ldd	r24, Z+4	; 0x04
    3668:	8b 7f       	andi	r24, 0xFB	; 251
    366a:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x02;
    366c:	84 81       	ldd	r24, Z+4	; 0x04
    366e:	82 60       	ori	r24, 0x02	; 2
    3670:	84 83       	std	Z+4, r24	; 0x04
		}
	vTaskDelay(100 / portTICK_RATE_MS);
    3672:	64 e6       	ldi	r22, 0x64	; 100
    3674:	70 e0       	ldi	r23, 0x00	; 0
    3676:	80 e0       	ldi	r24, 0x00	; 0
    3678:	90 e0       	ldi	r25, 0x00	; 0
    367a:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
	}
    367e:	60 cf       	rjmp	.-320    	; 0x3540 <vTask_DMAHandler+0x32>

00003680 <getResetReason>:
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
	 // software reset ?
	 if( RST.STATUS & RST_SRF_bm )
    3680:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3684:	85 ff       	sbrs	r24, 5
    3686:	05 c0       	rjmp	.+10     	; 0x3692 <getResetReason+0x12>
	 {
		 // reset this bit
		 RST.STATUS = RST_SRF_bm;
    3688:	80 e2       	ldi	r24, 0x20	; 32
    368a:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_SOFTWARERESET;
    368e:	81 e0       	ldi	r24, 0x01	; 1
    3690:	08 95       	ret
	 }
	 // power on reset ?
	 else if( RST.STATUS & RST_PORF_bm)
    3692:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3696:	80 ff       	sbrs	r24, 0
    3698:	05 c0       	rjmp	.+10     	; 0x36a4 <getResetReason+0x24>
	 {
		 // reset this bit
		 RST.STATUS = RST_PORF_bm;
    369a:	81 e0       	ldi	r24, 0x01	; 1
    369c:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_POWERONRESET;
    36a0:	82 e0       	ldi	r24, 0x02	; 2
    36a2:	08 95       	ret
	 }
	 // debugger reset ?
	 else if( RST.STATUS & RST_PDIRF_bm)
    36a4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    36a8:	84 ff       	sbrs	r24, 4
    36aa:	05 c0       	rjmp	.+10     	; 0x36b6 <getResetReason+0x36>
	 {
		 // reset this bit
		 RST.STATUS = RST_PDIRF_bm;
    36ac:	80 e1       	ldi	r24, 0x10	; 16
    36ae:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_DEBUGGERRESET;
    36b2:	83 e0       	ldi	r24, 0x03	; 3
    36b4:	08 95       	ret
	 }
	 // external reset ?
	 else if( RST.STATUS & RST_EXTRF_bm)
    36b6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    36ba:	81 ff       	sbrs	r24, 1
    36bc:	05 c0       	rjmp	.+10     	; 0x36c8 <getResetReason+0x48>
	 {
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
    36be:	82 e0       	ldi	r24, 0x02	; 2
    36c0:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_EXTERNALRESET;
    36c4:	84 e0       	ldi	r24, 0x04	; 4
    36c6:	08 95       	ret
 */ 
 #include "avr_compiler.h"
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
    36c8:	82 e0       	ldi	r24, 0x02	; 2
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
		 returnValue = RESETREASON_EXTERNALRESET;
	 }
	 return returnValue;
    36ca:	08 95       	ret

000036cc <__subsf3>:
    36cc:	50 58       	subi	r21, 0x80	; 128

000036ce <__addsf3>:
    36ce:	bb 27       	eor	r27, r27
    36d0:	aa 27       	eor	r26, r26
    36d2:	0e 94 7e 1b 	call	0x36fc	; 0x36fc <__addsf3x>
    36d6:	0c 94 f8 1c 	jmp	0x39f0	; 0x39f0 <__fp_round>
    36da:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <__fp_pscA>
    36de:	38 f0       	brcs	.+14     	; 0x36ee <__addsf3+0x20>
    36e0:	0e 94 f1 1c 	call	0x39e2	; 0x39e2 <__fp_pscB>
    36e4:	20 f0       	brcs	.+8      	; 0x36ee <__addsf3+0x20>
    36e6:	39 f4       	brne	.+14     	; 0x36f6 <__addsf3+0x28>
    36e8:	9f 3f       	cpi	r25, 0xFF	; 255
    36ea:	19 f4       	brne	.+6      	; 0x36f2 <__addsf3+0x24>
    36ec:	26 f4       	brtc	.+8      	; 0x36f6 <__addsf3+0x28>
    36ee:	0c 94 e7 1c 	jmp	0x39ce	; 0x39ce <__fp_nan>
    36f2:	0e f4       	brtc	.+2      	; 0x36f6 <__addsf3+0x28>
    36f4:	e0 95       	com	r30
    36f6:	e7 fb       	bst	r30, 7
    36f8:	0c 94 e1 1c 	jmp	0x39c2	; 0x39c2 <__fp_inf>

000036fc <__addsf3x>:
    36fc:	e9 2f       	mov	r30, r25
    36fe:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <__fp_split3>
    3702:	58 f3       	brcs	.-42     	; 0x36da <__addsf3+0xc>
    3704:	ba 17       	cp	r27, r26
    3706:	62 07       	cpc	r22, r18
    3708:	73 07       	cpc	r23, r19
    370a:	84 07       	cpc	r24, r20
    370c:	95 07       	cpc	r25, r21
    370e:	20 f0       	brcs	.+8      	; 0x3718 <__addsf3x+0x1c>
    3710:	79 f4       	brne	.+30     	; 0x3730 <__addsf3x+0x34>
    3712:	a6 f5       	brtc	.+104    	; 0x377c <__addsf3x+0x80>
    3714:	0c 94 2b 1d 	jmp	0x3a56	; 0x3a56 <__fp_zero>
    3718:	0e f4       	brtc	.+2      	; 0x371c <__addsf3x+0x20>
    371a:	e0 95       	com	r30
    371c:	0b 2e       	mov	r0, r27
    371e:	ba 2f       	mov	r27, r26
    3720:	a0 2d       	mov	r26, r0
    3722:	0b 01       	movw	r0, r22
    3724:	b9 01       	movw	r22, r18
    3726:	90 01       	movw	r18, r0
    3728:	0c 01       	movw	r0, r24
    372a:	ca 01       	movw	r24, r20
    372c:	a0 01       	movw	r20, r0
    372e:	11 24       	eor	r1, r1
    3730:	ff 27       	eor	r31, r31
    3732:	59 1b       	sub	r21, r25
    3734:	99 f0       	breq	.+38     	; 0x375c <__addsf3x+0x60>
    3736:	59 3f       	cpi	r21, 0xF9	; 249
    3738:	50 f4       	brcc	.+20     	; 0x374e <__addsf3x+0x52>
    373a:	50 3e       	cpi	r21, 0xE0	; 224
    373c:	68 f1       	brcs	.+90     	; 0x3798 <__addsf3x+0x9c>
    373e:	1a 16       	cp	r1, r26
    3740:	f0 40       	sbci	r31, 0x00	; 0
    3742:	a2 2f       	mov	r26, r18
    3744:	23 2f       	mov	r18, r19
    3746:	34 2f       	mov	r19, r20
    3748:	44 27       	eor	r20, r20
    374a:	58 5f       	subi	r21, 0xF8	; 248
    374c:	f3 cf       	rjmp	.-26     	; 0x3734 <__addsf3x+0x38>
    374e:	46 95       	lsr	r20
    3750:	37 95       	ror	r19
    3752:	27 95       	ror	r18
    3754:	a7 95       	ror	r26
    3756:	f0 40       	sbci	r31, 0x00	; 0
    3758:	53 95       	inc	r21
    375a:	c9 f7       	brne	.-14     	; 0x374e <__addsf3x+0x52>
    375c:	7e f4       	brtc	.+30     	; 0x377c <__addsf3x+0x80>
    375e:	1f 16       	cp	r1, r31
    3760:	ba 0b       	sbc	r27, r26
    3762:	62 0b       	sbc	r22, r18
    3764:	73 0b       	sbc	r23, r19
    3766:	84 0b       	sbc	r24, r20
    3768:	ba f0       	brmi	.+46     	; 0x3798 <__addsf3x+0x9c>
    376a:	91 50       	subi	r25, 0x01	; 1
    376c:	a1 f0       	breq	.+40     	; 0x3796 <__addsf3x+0x9a>
    376e:	ff 0f       	add	r31, r31
    3770:	bb 1f       	adc	r27, r27
    3772:	66 1f       	adc	r22, r22
    3774:	77 1f       	adc	r23, r23
    3776:	88 1f       	adc	r24, r24
    3778:	c2 f7       	brpl	.-16     	; 0x376a <__addsf3x+0x6e>
    377a:	0e c0       	rjmp	.+28     	; 0x3798 <__addsf3x+0x9c>
    377c:	ba 0f       	add	r27, r26
    377e:	62 1f       	adc	r22, r18
    3780:	73 1f       	adc	r23, r19
    3782:	84 1f       	adc	r24, r20
    3784:	48 f4       	brcc	.+18     	; 0x3798 <__addsf3x+0x9c>
    3786:	87 95       	ror	r24
    3788:	77 95       	ror	r23
    378a:	67 95       	ror	r22
    378c:	b7 95       	ror	r27
    378e:	f7 95       	ror	r31
    3790:	9e 3f       	cpi	r25, 0xFE	; 254
    3792:	08 f0       	brcs	.+2      	; 0x3796 <__addsf3x+0x9a>
    3794:	b0 cf       	rjmp	.-160    	; 0x36f6 <__addsf3+0x28>
    3796:	93 95       	inc	r25
    3798:	88 0f       	add	r24, r24
    379a:	08 f0       	brcs	.+2      	; 0x379e <__addsf3x+0xa2>
    379c:	99 27       	eor	r25, r25
    379e:	ee 0f       	add	r30, r30
    37a0:	97 95       	ror	r25
    37a2:	87 95       	ror	r24
    37a4:	08 95       	ret

000037a6 <__cmpsf2>:
    37a6:	0e 94 bd 1c 	call	0x397a	; 0x397a <__fp_cmp>
    37aa:	08 f4       	brcc	.+2      	; 0x37ae <__cmpsf2+0x8>
    37ac:	81 e0       	ldi	r24, 0x01	; 1
    37ae:	08 95       	ret

000037b0 <__divsf3>:
    37b0:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <__divsf3x>
    37b4:	0c 94 f8 1c 	jmp	0x39f0	; 0x39f0 <__fp_round>
    37b8:	0e 94 f1 1c 	call	0x39e2	; 0x39e2 <__fp_pscB>
    37bc:	58 f0       	brcs	.+22     	; 0x37d4 <__divsf3+0x24>
    37be:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <__fp_pscA>
    37c2:	40 f0       	brcs	.+16     	; 0x37d4 <__divsf3+0x24>
    37c4:	29 f4       	brne	.+10     	; 0x37d0 <__divsf3+0x20>
    37c6:	5f 3f       	cpi	r21, 0xFF	; 255
    37c8:	29 f0       	breq	.+10     	; 0x37d4 <__divsf3+0x24>
    37ca:	0c 94 e1 1c 	jmp	0x39c2	; 0x39c2 <__fp_inf>
    37ce:	51 11       	cpse	r21, r1
    37d0:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__fp_szero>
    37d4:	0c 94 e7 1c 	jmp	0x39ce	; 0x39ce <__fp_nan>

000037d8 <__divsf3x>:
    37d8:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <__fp_split3>
    37dc:	68 f3       	brcs	.-38     	; 0x37b8 <__divsf3+0x8>

000037de <__divsf3_pse>:
    37de:	99 23       	and	r25, r25
    37e0:	b1 f3       	breq	.-20     	; 0x37ce <__divsf3+0x1e>
    37e2:	55 23       	and	r21, r21
    37e4:	91 f3       	breq	.-28     	; 0x37ca <__divsf3+0x1a>
    37e6:	95 1b       	sub	r25, r21
    37e8:	55 0b       	sbc	r21, r21
    37ea:	bb 27       	eor	r27, r27
    37ec:	aa 27       	eor	r26, r26
    37ee:	62 17       	cp	r22, r18
    37f0:	73 07       	cpc	r23, r19
    37f2:	84 07       	cpc	r24, r20
    37f4:	38 f0       	brcs	.+14     	; 0x3804 <__divsf3_pse+0x26>
    37f6:	9f 5f       	subi	r25, 0xFF	; 255
    37f8:	5f 4f       	sbci	r21, 0xFF	; 255
    37fa:	22 0f       	add	r18, r18
    37fc:	33 1f       	adc	r19, r19
    37fe:	44 1f       	adc	r20, r20
    3800:	aa 1f       	adc	r26, r26
    3802:	a9 f3       	breq	.-22     	; 0x37ee <__divsf3_pse+0x10>
    3804:	35 d0       	rcall	.+106    	; 0x3870 <__divsf3_pse+0x92>
    3806:	0e 2e       	mov	r0, r30
    3808:	3a f0       	brmi	.+14     	; 0x3818 <__divsf3_pse+0x3a>
    380a:	e0 e8       	ldi	r30, 0x80	; 128
    380c:	32 d0       	rcall	.+100    	; 0x3872 <__divsf3_pse+0x94>
    380e:	91 50       	subi	r25, 0x01	; 1
    3810:	50 40       	sbci	r21, 0x00	; 0
    3812:	e6 95       	lsr	r30
    3814:	00 1c       	adc	r0, r0
    3816:	ca f7       	brpl	.-14     	; 0x380a <__divsf3_pse+0x2c>
    3818:	2b d0       	rcall	.+86     	; 0x3870 <__divsf3_pse+0x92>
    381a:	fe 2f       	mov	r31, r30
    381c:	29 d0       	rcall	.+82     	; 0x3870 <__divsf3_pse+0x92>
    381e:	66 0f       	add	r22, r22
    3820:	77 1f       	adc	r23, r23
    3822:	88 1f       	adc	r24, r24
    3824:	bb 1f       	adc	r27, r27
    3826:	26 17       	cp	r18, r22
    3828:	37 07       	cpc	r19, r23
    382a:	48 07       	cpc	r20, r24
    382c:	ab 07       	cpc	r26, r27
    382e:	b0 e8       	ldi	r27, 0x80	; 128
    3830:	09 f0       	breq	.+2      	; 0x3834 <__divsf3_pse+0x56>
    3832:	bb 0b       	sbc	r27, r27
    3834:	80 2d       	mov	r24, r0
    3836:	bf 01       	movw	r22, r30
    3838:	ff 27       	eor	r31, r31
    383a:	93 58       	subi	r25, 0x83	; 131
    383c:	5f 4f       	sbci	r21, 0xFF	; 255
    383e:	3a f0       	brmi	.+14     	; 0x384e <__divsf3_pse+0x70>
    3840:	9e 3f       	cpi	r25, 0xFE	; 254
    3842:	51 05       	cpc	r21, r1
    3844:	78 f0       	brcs	.+30     	; 0x3864 <__divsf3_pse+0x86>
    3846:	0c 94 e1 1c 	jmp	0x39c2	; 0x39c2 <__fp_inf>
    384a:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__fp_szero>
    384e:	5f 3f       	cpi	r21, 0xFF	; 255
    3850:	e4 f3       	brlt	.-8      	; 0x384a <__divsf3_pse+0x6c>
    3852:	98 3e       	cpi	r25, 0xE8	; 232
    3854:	d4 f3       	brlt	.-12     	; 0x384a <__divsf3_pse+0x6c>
    3856:	86 95       	lsr	r24
    3858:	77 95       	ror	r23
    385a:	67 95       	ror	r22
    385c:	b7 95       	ror	r27
    385e:	f7 95       	ror	r31
    3860:	9f 5f       	subi	r25, 0xFF	; 255
    3862:	c9 f7       	brne	.-14     	; 0x3856 <__divsf3_pse+0x78>
    3864:	88 0f       	add	r24, r24
    3866:	91 1d       	adc	r25, r1
    3868:	96 95       	lsr	r25
    386a:	87 95       	ror	r24
    386c:	97 f9       	bld	r25, 7
    386e:	08 95       	ret
    3870:	e1 e0       	ldi	r30, 0x01	; 1
    3872:	66 0f       	add	r22, r22
    3874:	77 1f       	adc	r23, r23
    3876:	88 1f       	adc	r24, r24
    3878:	bb 1f       	adc	r27, r27
    387a:	62 17       	cp	r22, r18
    387c:	73 07       	cpc	r23, r19
    387e:	84 07       	cpc	r24, r20
    3880:	ba 07       	cpc	r27, r26
    3882:	20 f0       	brcs	.+8      	; 0x388c <__divsf3_pse+0xae>
    3884:	62 1b       	sub	r22, r18
    3886:	73 0b       	sbc	r23, r19
    3888:	84 0b       	sbc	r24, r20
    388a:	ba 0b       	sbc	r27, r26
    388c:	ee 1f       	adc	r30, r30
    388e:	88 f7       	brcc	.-30     	; 0x3872 <__divsf3_pse+0x94>
    3890:	e0 95       	com	r30
    3892:	08 95       	ret

00003894 <__fixsfsi>:
    3894:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <__fixunssfsi>
    3898:	68 94       	set
    389a:	b1 11       	cpse	r27, r1
    389c:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__fp_szero>
    38a0:	08 95       	ret

000038a2 <__fixunssfsi>:
    38a2:	0e 94 11 1d 	call	0x3a22	; 0x3a22 <__fp_splitA>
    38a6:	88 f0       	brcs	.+34     	; 0x38ca <__fixunssfsi+0x28>
    38a8:	9f 57       	subi	r25, 0x7F	; 127
    38aa:	98 f0       	brcs	.+38     	; 0x38d2 <__fixunssfsi+0x30>
    38ac:	b9 2f       	mov	r27, r25
    38ae:	99 27       	eor	r25, r25
    38b0:	b7 51       	subi	r27, 0x17	; 23
    38b2:	b0 f0       	brcs	.+44     	; 0x38e0 <__fixunssfsi+0x3e>
    38b4:	e1 f0       	breq	.+56     	; 0x38ee <__fixunssfsi+0x4c>
    38b6:	66 0f       	add	r22, r22
    38b8:	77 1f       	adc	r23, r23
    38ba:	88 1f       	adc	r24, r24
    38bc:	99 1f       	adc	r25, r25
    38be:	1a f0       	brmi	.+6      	; 0x38c6 <__fixunssfsi+0x24>
    38c0:	ba 95       	dec	r27
    38c2:	c9 f7       	brne	.-14     	; 0x38b6 <__fixunssfsi+0x14>
    38c4:	14 c0       	rjmp	.+40     	; 0x38ee <__fixunssfsi+0x4c>
    38c6:	b1 30       	cpi	r27, 0x01	; 1
    38c8:	91 f0       	breq	.+36     	; 0x38ee <__fixunssfsi+0x4c>
    38ca:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <__fp_zero>
    38ce:	b1 e0       	ldi	r27, 0x01	; 1
    38d0:	08 95       	ret
    38d2:	0c 94 2b 1d 	jmp	0x3a56	; 0x3a56 <__fp_zero>
    38d6:	67 2f       	mov	r22, r23
    38d8:	78 2f       	mov	r23, r24
    38da:	88 27       	eor	r24, r24
    38dc:	b8 5f       	subi	r27, 0xF8	; 248
    38de:	39 f0       	breq	.+14     	; 0x38ee <__fixunssfsi+0x4c>
    38e0:	b9 3f       	cpi	r27, 0xF9	; 249
    38e2:	cc f3       	brlt	.-14     	; 0x38d6 <__fixunssfsi+0x34>
    38e4:	86 95       	lsr	r24
    38e6:	77 95       	ror	r23
    38e8:	67 95       	ror	r22
    38ea:	b3 95       	inc	r27
    38ec:	d9 f7       	brne	.-10     	; 0x38e4 <__fixunssfsi+0x42>
    38ee:	3e f4       	brtc	.+14     	; 0x38fe <__fixunssfsi+0x5c>
    38f0:	90 95       	com	r25
    38f2:	80 95       	com	r24
    38f4:	70 95       	com	r23
    38f6:	61 95       	neg	r22
    38f8:	7f 4f       	sbci	r23, 0xFF	; 255
    38fa:	8f 4f       	sbci	r24, 0xFF	; 255
    38fc:	9f 4f       	sbci	r25, 0xFF	; 255
    38fe:	08 95       	ret

00003900 <__floatunsisf>:
    3900:	e8 94       	clt
    3902:	09 c0       	rjmp	.+18     	; 0x3916 <__floatsisf+0x12>

00003904 <__floatsisf>:
    3904:	97 fb       	bst	r25, 7
    3906:	3e f4       	brtc	.+14     	; 0x3916 <__floatsisf+0x12>
    3908:	90 95       	com	r25
    390a:	80 95       	com	r24
    390c:	70 95       	com	r23
    390e:	61 95       	neg	r22
    3910:	7f 4f       	sbci	r23, 0xFF	; 255
    3912:	8f 4f       	sbci	r24, 0xFF	; 255
    3914:	9f 4f       	sbci	r25, 0xFF	; 255
    3916:	99 23       	and	r25, r25
    3918:	a9 f0       	breq	.+42     	; 0x3944 <__floatsisf+0x40>
    391a:	f9 2f       	mov	r31, r25
    391c:	96 e9       	ldi	r25, 0x96	; 150
    391e:	bb 27       	eor	r27, r27
    3920:	93 95       	inc	r25
    3922:	f6 95       	lsr	r31
    3924:	87 95       	ror	r24
    3926:	77 95       	ror	r23
    3928:	67 95       	ror	r22
    392a:	b7 95       	ror	r27
    392c:	f1 11       	cpse	r31, r1
    392e:	f8 cf       	rjmp	.-16     	; 0x3920 <__floatsisf+0x1c>
    3930:	fa f4       	brpl	.+62     	; 0x3970 <__floatsisf+0x6c>
    3932:	bb 0f       	add	r27, r27
    3934:	11 f4       	brne	.+4      	; 0x393a <__floatsisf+0x36>
    3936:	60 ff       	sbrs	r22, 0
    3938:	1b c0       	rjmp	.+54     	; 0x3970 <__floatsisf+0x6c>
    393a:	6f 5f       	subi	r22, 0xFF	; 255
    393c:	7f 4f       	sbci	r23, 0xFF	; 255
    393e:	8f 4f       	sbci	r24, 0xFF	; 255
    3940:	9f 4f       	sbci	r25, 0xFF	; 255
    3942:	16 c0       	rjmp	.+44     	; 0x3970 <__floatsisf+0x6c>
    3944:	88 23       	and	r24, r24
    3946:	11 f0       	breq	.+4      	; 0x394c <__floatsisf+0x48>
    3948:	96 e9       	ldi	r25, 0x96	; 150
    394a:	11 c0       	rjmp	.+34     	; 0x396e <__floatsisf+0x6a>
    394c:	77 23       	and	r23, r23
    394e:	21 f0       	breq	.+8      	; 0x3958 <__floatsisf+0x54>
    3950:	9e e8       	ldi	r25, 0x8E	; 142
    3952:	87 2f       	mov	r24, r23
    3954:	76 2f       	mov	r23, r22
    3956:	05 c0       	rjmp	.+10     	; 0x3962 <__floatsisf+0x5e>
    3958:	66 23       	and	r22, r22
    395a:	71 f0       	breq	.+28     	; 0x3978 <__floatsisf+0x74>
    395c:	96 e8       	ldi	r25, 0x86	; 134
    395e:	86 2f       	mov	r24, r22
    3960:	70 e0       	ldi	r23, 0x00	; 0
    3962:	60 e0       	ldi	r22, 0x00	; 0
    3964:	2a f0       	brmi	.+10     	; 0x3970 <__floatsisf+0x6c>
    3966:	9a 95       	dec	r25
    3968:	66 0f       	add	r22, r22
    396a:	77 1f       	adc	r23, r23
    396c:	88 1f       	adc	r24, r24
    396e:	da f7       	brpl	.-10     	; 0x3966 <__floatsisf+0x62>
    3970:	88 0f       	add	r24, r24
    3972:	96 95       	lsr	r25
    3974:	87 95       	ror	r24
    3976:	97 f9       	bld	r25, 7
    3978:	08 95       	ret

0000397a <__fp_cmp>:
    397a:	99 0f       	add	r25, r25
    397c:	00 08       	sbc	r0, r0
    397e:	55 0f       	add	r21, r21
    3980:	aa 0b       	sbc	r26, r26
    3982:	e0 e8       	ldi	r30, 0x80	; 128
    3984:	fe ef       	ldi	r31, 0xFE	; 254
    3986:	16 16       	cp	r1, r22
    3988:	17 06       	cpc	r1, r23
    398a:	e8 07       	cpc	r30, r24
    398c:	f9 07       	cpc	r31, r25
    398e:	c0 f0       	brcs	.+48     	; 0x39c0 <__fp_cmp+0x46>
    3990:	12 16       	cp	r1, r18
    3992:	13 06       	cpc	r1, r19
    3994:	e4 07       	cpc	r30, r20
    3996:	f5 07       	cpc	r31, r21
    3998:	98 f0       	brcs	.+38     	; 0x39c0 <__fp_cmp+0x46>
    399a:	62 1b       	sub	r22, r18
    399c:	73 0b       	sbc	r23, r19
    399e:	84 0b       	sbc	r24, r20
    39a0:	95 0b       	sbc	r25, r21
    39a2:	39 f4       	brne	.+14     	; 0x39b2 <__fp_cmp+0x38>
    39a4:	0a 26       	eor	r0, r26
    39a6:	61 f0       	breq	.+24     	; 0x39c0 <__fp_cmp+0x46>
    39a8:	23 2b       	or	r18, r19
    39aa:	24 2b       	or	r18, r20
    39ac:	25 2b       	or	r18, r21
    39ae:	21 f4       	brne	.+8      	; 0x39b8 <__fp_cmp+0x3e>
    39b0:	08 95       	ret
    39b2:	0a 26       	eor	r0, r26
    39b4:	09 f4       	brne	.+2      	; 0x39b8 <__fp_cmp+0x3e>
    39b6:	a1 40       	sbci	r26, 0x01	; 1
    39b8:	a6 95       	lsr	r26
    39ba:	8f ef       	ldi	r24, 0xFF	; 255
    39bc:	81 1d       	adc	r24, r1
    39be:	81 1d       	adc	r24, r1
    39c0:	08 95       	ret

000039c2 <__fp_inf>:
    39c2:	97 f9       	bld	r25, 7
    39c4:	9f 67       	ori	r25, 0x7F	; 127
    39c6:	80 e8       	ldi	r24, 0x80	; 128
    39c8:	70 e0       	ldi	r23, 0x00	; 0
    39ca:	60 e0       	ldi	r22, 0x00	; 0
    39cc:	08 95       	ret

000039ce <__fp_nan>:
    39ce:	9f ef       	ldi	r25, 0xFF	; 255
    39d0:	80 ec       	ldi	r24, 0xC0	; 192
    39d2:	08 95       	ret

000039d4 <__fp_pscA>:
    39d4:	00 24       	eor	r0, r0
    39d6:	0a 94       	dec	r0
    39d8:	16 16       	cp	r1, r22
    39da:	17 06       	cpc	r1, r23
    39dc:	18 06       	cpc	r1, r24
    39de:	09 06       	cpc	r0, r25
    39e0:	08 95       	ret

000039e2 <__fp_pscB>:
    39e2:	00 24       	eor	r0, r0
    39e4:	0a 94       	dec	r0
    39e6:	12 16       	cp	r1, r18
    39e8:	13 06       	cpc	r1, r19
    39ea:	14 06       	cpc	r1, r20
    39ec:	05 06       	cpc	r0, r21
    39ee:	08 95       	ret

000039f0 <__fp_round>:
    39f0:	09 2e       	mov	r0, r25
    39f2:	03 94       	inc	r0
    39f4:	00 0c       	add	r0, r0
    39f6:	11 f4       	brne	.+4      	; 0x39fc <__fp_round+0xc>
    39f8:	88 23       	and	r24, r24
    39fa:	52 f0       	brmi	.+20     	; 0x3a10 <__fp_round+0x20>
    39fc:	bb 0f       	add	r27, r27
    39fe:	40 f4       	brcc	.+16     	; 0x3a10 <__fp_round+0x20>
    3a00:	bf 2b       	or	r27, r31
    3a02:	11 f4       	brne	.+4      	; 0x3a08 <__fp_round+0x18>
    3a04:	60 ff       	sbrs	r22, 0
    3a06:	04 c0       	rjmp	.+8      	; 0x3a10 <__fp_round+0x20>
    3a08:	6f 5f       	subi	r22, 0xFF	; 255
    3a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    3a0c:	8f 4f       	sbci	r24, 0xFF	; 255
    3a0e:	9f 4f       	sbci	r25, 0xFF	; 255
    3a10:	08 95       	ret

00003a12 <__fp_split3>:
    3a12:	57 fd       	sbrc	r21, 7
    3a14:	90 58       	subi	r25, 0x80	; 128
    3a16:	44 0f       	add	r20, r20
    3a18:	55 1f       	adc	r21, r21
    3a1a:	59 f0       	breq	.+22     	; 0x3a32 <__fp_splitA+0x10>
    3a1c:	5f 3f       	cpi	r21, 0xFF	; 255
    3a1e:	71 f0       	breq	.+28     	; 0x3a3c <__fp_splitA+0x1a>
    3a20:	47 95       	ror	r20

00003a22 <__fp_splitA>:
    3a22:	88 0f       	add	r24, r24
    3a24:	97 fb       	bst	r25, 7
    3a26:	99 1f       	adc	r25, r25
    3a28:	61 f0       	breq	.+24     	; 0x3a42 <__fp_splitA+0x20>
    3a2a:	9f 3f       	cpi	r25, 0xFF	; 255
    3a2c:	79 f0       	breq	.+30     	; 0x3a4c <__fp_splitA+0x2a>
    3a2e:	87 95       	ror	r24
    3a30:	08 95       	ret
    3a32:	12 16       	cp	r1, r18
    3a34:	13 06       	cpc	r1, r19
    3a36:	14 06       	cpc	r1, r20
    3a38:	55 1f       	adc	r21, r21
    3a3a:	f2 cf       	rjmp	.-28     	; 0x3a20 <__fp_split3+0xe>
    3a3c:	46 95       	lsr	r20
    3a3e:	f1 df       	rcall	.-30     	; 0x3a22 <__fp_splitA>
    3a40:	08 c0       	rjmp	.+16     	; 0x3a52 <__fp_splitA+0x30>
    3a42:	16 16       	cp	r1, r22
    3a44:	17 06       	cpc	r1, r23
    3a46:	18 06       	cpc	r1, r24
    3a48:	99 1f       	adc	r25, r25
    3a4a:	f1 cf       	rjmp	.-30     	; 0x3a2e <__fp_splitA+0xc>
    3a4c:	86 95       	lsr	r24
    3a4e:	71 05       	cpc	r23, r1
    3a50:	61 05       	cpc	r22, r1
    3a52:	08 94       	sec
    3a54:	08 95       	ret

00003a56 <__fp_zero>:
    3a56:	e8 94       	clt

00003a58 <__fp_szero>:
    3a58:	bb 27       	eor	r27, r27
    3a5a:	66 27       	eor	r22, r22
    3a5c:	77 27       	eor	r23, r23
    3a5e:	cb 01       	movw	r24, r22
    3a60:	97 f9       	bld	r25, 7
    3a62:	08 95       	ret

00003a64 <__gesf2>:
    3a64:	0e 94 bd 1c 	call	0x397a	; 0x397a <__fp_cmp>
    3a68:	08 f4       	brcc	.+2      	; 0x3a6c <__gesf2+0x8>
    3a6a:	8f ef       	ldi	r24, 0xFF	; 255
    3a6c:	08 95       	ret

00003a6e <__mulsf3>:
    3a6e:	0e 94 4a 1d 	call	0x3a94	; 0x3a94 <__mulsf3x>
    3a72:	0c 94 f8 1c 	jmp	0x39f0	; 0x39f0 <__fp_round>
    3a76:	0e 94 ea 1c 	call	0x39d4	; 0x39d4 <__fp_pscA>
    3a7a:	38 f0       	brcs	.+14     	; 0x3a8a <__mulsf3+0x1c>
    3a7c:	0e 94 f1 1c 	call	0x39e2	; 0x39e2 <__fp_pscB>
    3a80:	20 f0       	brcs	.+8      	; 0x3a8a <__mulsf3+0x1c>
    3a82:	95 23       	and	r25, r21
    3a84:	11 f0       	breq	.+4      	; 0x3a8a <__mulsf3+0x1c>
    3a86:	0c 94 e1 1c 	jmp	0x39c2	; 0x39c2 <__fp_inf>
    3a8a:	0c 94 e7 1c 	jmp	0x39ce	; 0x39ce <__fp_nan>
    3a8e:	11 24       	eor	r1, r1
    3a90:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__fp_szero>

00003a94 <__mulsf3x>:
    3a94:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <__fp_split3>
    3a98:	70 f3       	brcs	.-36     	; 0x3a76 <__mulsf3+0x8>

00003a9a <__mulsf3_pse>:
    3a9a:	95 9f       	mul	r25, r21
    3a9c:	c1 f3       	breq	.-16     	; 0x3a8e <__mulsf3+0x20>
    3a9e:	95 0f       	add	r25, r21
    3aa0:	50 e0       	ldi	r21, 0x00	; 0
    3aa2:	55 1f       	adc	r21, r21
    3aa4:	62 9f       	mul	r22, r18
    3aa6:	f0 01       	movw	r30, r0
    3aa8:	72 9f       	mul	r23, r18
    3aaa:	bb 27       	eor	r27, r27
    3aac:	f0 0d       	add	r31, r0
    3aae:	b1 1d       	adc	r27, r1
    3ab0:	63 9f       	mul	r22, r19
    3ab2:	aa 27       	eor	r26, r26
    3ab4:	f0 0d       	add	r31, r0
    3ab6:	b1 1d       	adc	r27, r1
    3ab8:	aa 1f       	adc	r26, r26
    3aba:	64 9f       	mul	r22, r20
    3abc:	66 27       	eor	r22, r22
    3abe:	b0 0d       	add	r27, r0
    3ac0:	a1 1d       	adc	r26, r1
    3ac2:	66 1f       	adc	r22, r22
    3ac4:	82 9f       	mul	r24, r18
    3ac6:	22 27       	eor	r18, r18
    3ac8:	b0 0d       	add	r27, r0
    3aca:	a1 1d       	adc	r26, r1
    3acc:	62 1f       	adc	r22, r18
    3ace:	73 9f       	mul	r23, r19
    3ad0:	b0 0d       	add	r27, r0
    3ad2:	a1 1d       	adc	r26, r1
    3ad4:	62 1f       	adc	r22, r18
    3ad6:	83 9f       	mul	r24, r19
    3ad8:	a0 0d       	add	r26, r0
    3ada:	61 1d       	adc	r22, r1
    3adc:	22 1f       	adc	r18, r18
    3ade:	74 9f       	mul	r23, r20
    3ae0:	33 27       	eor	r19, r19
    3ae2:	a0 0d       	add	r26, r0
    3ae4:	61 1d       	adc	r22, r1
    3ae6:	23 1f       	adc	r18, r19
    3ae8:	84 9f       	mul	r24, r20
    3aea:	60 0d       	add	r22, r0
    3aec:	21 1d       	adc	r18, r1
    3aee:	82 2f       	mov	r24, r18
    3af0:	76 2f       	mov	r23, r22
    3af2:	6a 2f       	mov	r22, r26
    3af4:	11 24       	eor	r1, r1
    3af6:	9f 57       	subi	r25, 0x7F	; 127
    3af8:	50 40       	sbci	r21, 0x00	; 0
    3afa:	9a f0       	brmi	.+38     	; 0x3b22 <__mulsf3_pse+0x88>
    3afc:	f1 f0       	breq	.+60     	; 0x3b3a <__mulsf3_pse+0xa0>
    3afe:	88 23       	and	r24, r24
    3b00:	4a f0       	brmi	.+18     	; 0x3b14 <__mulsf3_pse+0x7a>
    3b02:	ee 0f       	add	r30, r30
    3b04:	ff 1f       	adc	r31, r31
    3b06:	bb 1f       	adc	r27, r27
    3b08:	66 1f       	adc	r22, r22
    3b0a:	77 1f       	adc	r23, r23
    3b0c:	88 1f       	adc	r24, r24
    3b0e:	91 50       	subi	r25, 0x01	; 1
    3b10:	50 40       	sbci	r21, 0x00	; 0
    3b12:	a9 f7       	brne	.-22     	; 0x3afe <__mulsf3_pse+0x64>
    3b14:	9e 3f       	cpi	r25, 0xFE	; 254
    3b16:	51 05       	cpc	r21, r1
    3b18:	80 f0       	brcs	.+32     	; 0x3b3a <__mulsf3_pse+0xa0>
    3b1a:	0c 94 e1 1c 	jmp	0x39c2	; 0x39c2 <__fp_inf>
    3b1e:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__fp_szero>
    3b22:	5f 3f       	cpi	r21, 0xFF	; 255
    3b24:	e4 f3       	brlt	.-8      	; 0x3b1e <__mulsf3_pse+0x84>
    3b26:	98 3e       	cpi	r25, 0xE8	; 232
    3b28:	d4 f3       	brlt	.-12     	; 0x3b1e <__mulsf3_pse+0x84>
    3b2a:	86 95       	lsr	r24
    3b2c:	77 95       	ror	r23
    3b2e:	67 95       	ror	r22
    3b30:	b7 95       	ror	r27
    3b32:	f7 95       	ror	r31
    3b34:	e7 95       	ror	r30
    3b36:	9f 5f       	subi	r25, 0xFF	; 255
    3b38:	c1 f7       	brne	.-16     	; 0x3b2a <__mulsf3_pse+0x90>
    3b3a:	fe 2b       	or	r31, r30
    3b3c:	88 0f       	add	r24, r24
    3b3e:	91 1d       	adc	r25, r1
    3b40:	96 95       	lsr	r25
    3b42:	87 95       	ror	r24
    3b44:	97 f9       	bld	r25, 7
    3b46:	08 95       	ret

00003b48 <__tablejump2__>:
    3b48:	ee 0f       	add	r30, r30
    3b4a:	ff 1f       	adc	r31, r31
    3b4c:	88 1f       	adc	r24, r24
    3b4e:	8b bf       	out	0x3b, r24	; 59
    3b50:	07 90       	elpm	r0, Z+
    3b52:	f6 91       	elpm	r31, Z
    3b54:	e0 2d       	mov	r30, r0
    3b56:	19 94       	eijmp

00003b58 <memcpy>:
    3b58:	fb 01       	movw	r30, r22
    3b5a:	dc 01       	movw	r26, r24
    3b5c:	02 c0       	rjmp	.+4      	; 0x3b62 <memcpy+0xa>
    3b5e:	01 90       	ld	r0, Z+
    3b60:	0d 92       	st	X+, r0
    3b62:	41 50       	subi	r20, 0x01	; 1
    3b64:	50 40       	sbci	r21, 0x00	; 0
    3b66:	d8 f7       	brcc	.-10     	; 0x3b5e <memcpy+0x6>
    3b68:	08 95       	ret

00003b6a <memset>:
    3b6a:	dc 01       	movw	r26, r24
    3b6c:	01 c0       	rjmp	.+2      	; 0x3b70 <memset+0x6>
    3b6e:	6d 93       	st	X+, r22
    3b70:	41 50       	subi	r20, 0x01	; 1
    3b72:	50 40       	sbci	r21, 0x00	; 0
    3b74:	e0 f7       	brcc	.-8      	; 0x3b6e <memset+0x4>
    3b76:	08 95       	ret

00003b78 <__itoa_ncheck>:
    3b78:	bb 27       	eor	r27, r27
    3b7a:	4a 30       	cpi	r20, 0x0A	; 10
    3b7c:	31 f4       	brne	.+12     	; 0x3b8a <__itoa_ncheck+0x12>
    3b7e:	99 23       	and	r25, r25
    3b80:	22 f4       	brpl	.+8      	; 0x3b8a <__itoa_ncheck+0x12>
    3b82:	bd e2       	ldi	r27, 0x2D	; 45
    3b84:	90 95       	com	r25
    3b86:	81 95       	neg	r24
    3b88:	9f 4f       	sbci	r25, 0xFF	; 255
    3b8a:	0c 94 c8 1d 	jmp	0x3b90	; 0x3b90 <__utoa_common>

00003b8e <__utoa_ncheck>:
    3b8e:	bb 27       	eor	r27, r27

00003b90 <__utoa_common>:
    3b90:	fb 01       	movw	r30, r22
    3b92:	55 27       	eor	r21, r21
    3b94:	aa 27       	eor	r26, r26
    3b96:	88 0f       	add	r24, r24
    3b98:	99 1f       	adc	r25, r25
    3b9a:	aa 1f       	adc	r26, r26
    3b9c:	a4 17       	cp	r26, r20
    3b9e:	10 f0       	brcs	.+4      	; 0x3ba4 <__utoa_common+0x14>
    3ba0:	a4 1b       	sub	r26, r20
    3ba2:	83 95       	inc	r24
    3ba4:	50 51       	subi	r21, 0x10	; 16
    3ba6:	b9 f7       	brne	.-18     	; 0x3b96 <__utoa_common+0x6>
    3ba8:	a0 5d       	subi	r26, 0xD0	; 208
    3baa:	aa 33       	cpi	r26, 0x3A	; 58
    3bac:	08 f0       	brcs	.+2      	; 0x3bb0 <__utoa_common+0x20>
    3bae:	a9 5d       	subi	r26, 0xD9	; 217
    3bb0:	a1 93       	st	Z+, r26
    3bb2:	00 97       	sbiw	r24, 0x00	; 0
    3bb4:	79 f7       	brne	.-34     	; 0x3b94 <__utoa_common+0x4>
    3bb6:	b1 11       	cpse	r27, r1
    3bb8:	b1 93       	st	Z+, r27
    3bba:	11 92       	st	Z+, r1
    3bbc:	cb 01       	movw	r24, r22
    3bbe:	0c 94 e1 1d 	jmp	0x3bc2	; 0x3bc2 <strrev>

00003bc2 <strrev>:
    3bc2:	dc 01       	movw	r26, r24
    3bc4:	fc 01       	movw	r30, r24
    3bc6:	67 2f       	mov	r22, r23
    3bc8:	71 91       	ld	r23, Z+
    3bca:	77 23       	and	r23, r23
    3bcc:	e1 f7       	brne	.-8      	; 0x3bc6 <strrev+0x4>
    3bce:	32 97       	sbiw	r30, 0x02	; 2
    3bd0:	04 c0       	rjmp	.+8      	; 0x3bda <strrev+0x18>
    3bd2:	7c 91       	ld	r23, X
    3bd4:	6d 93       	st	X+, r22
    3bd6:	70 83       	st	Z, r23
    3bd8:	62 91       	ld	r22, -Z
    3bda:	ae 17       	cp	r26, r30
    3bdc:	bf 07       	cpc	r27, r31
    3bde:	c8 f3       	brcs	.-14     	; 0x3bd2 <strrev+0x10>
    3be0:	08 95       	ret

00003be2 <_exit>:
    3be2:	f8 94       	cli

00003be4 <__stop_program>:
    3be4:	ff cf       	rjmp	.-2      	; 0x3be4 <__stop_program>
