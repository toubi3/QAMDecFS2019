
QAMDecFS2019.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003c6c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000090  00802000  00003c6c  00003d00  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00001e95  00802090  00802090  00003d90  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003d90  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003dc0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000790  00000000  00000000  00003e00  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010070  00000000  00000000  00004590  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000051c4  00000000  00000000  00014600  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000050fe  00000000  00000000  000197c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001914  00000000  00000000  0001e8c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000075d6  00000000  00000000  000201d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000091c4  00000000  00000000  000277ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000820  00000000  00000000  00030972  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 20 01 	jmp	0x240	; 0x240 <__ctors_end>
       4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
       8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
       c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      10:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      14:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      18:	0c 94 b7 01 	jmp	0x36e	; 0x36e <__vector_6>
      1c:	0c 94 fd 01 	jmp	0x3fa	; 0x3fa <__vector_7>
      20:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      24:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      28:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      2c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      30:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      34:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      38:	0c 94 4a 06 	jmp	0xc94	; 0xc94 <__vector_14>
      3c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      40:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      44:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      48:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      4c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      50:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      54:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      58:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      5c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      60:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      64:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      68:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      6c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      70:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      74:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      78:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      7c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      80:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      84:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      88:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      8c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      90:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      94:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      98:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      9c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      ac:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      bc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      cc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      dc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      ec:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      fc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     100:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     104:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     108:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     10c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     110:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     114:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     118:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     11c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     120:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     124:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     128:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     12c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     130:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     134:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     138:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     13c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     140:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     144:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     148:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     14c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     150:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     154:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     158:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     15c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     160:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     164:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     168:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     16c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     170:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     174:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     178:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     17c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     180:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     184:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     188:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     18c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     190:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     194:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     198:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     19c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1ac:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1b0:	0c 94 9f 14 	jmp	0x293e	; 0x293e <__vector_108>
     1b4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1b8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1bc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1cc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1dc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1ec:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1fc:	92 11       	cpse	r25, r2
     1fe:	92 11       	cpse	r25, r2
     200:	92 11       	cpse	r25, r2
     202:	df 11       	cpse	r29, r15
     204:	c7 11       	cpse	r28, r7
     206:	dc 11       	cpse	r29, r12
     208:	92 11       	cpse	r25, r2
     20a:	92 11       	cpse	r25, r2
     20c:	df 11       	cpse	r29, r15
     20e:	c7 11       	cpse	r28, r7

00000210 <__trampolines_start>:
     210:	0c 94 df 11 	jmp	0x23be	; 0x23be <prvTimerTask+0x212>
     214:	0c 94 63 12 	jmp	0x24c6	; 0x24c6 <vLedBlink>
     218:	0c 94 de 12 	jmp	0x25bc	; 0x25bc <vRead_DMA>
     21c:	0c 94 35 04 	jmp	0x86a	; 0x86a <vEventGroupSetBitsCallback>
     220:	0c 94 5f 0a 	jmp	0x14be	; 0x14be <prvIdleTask>
     224:	0c 94 92 11 	jmp	0x2324	; 0x2324 <prvTimerTask+0x178>
     228:	0c 94 d6 10 	jmp	0x21ac	; 0x21ac <prvTimerTask>
     22c:	0c 94 dc 11 	jmp	0x23b8	; 0x23b8 <prvTimerTask+0x20c>
     230:	0c 94 ca 1a 	jmp	0x3594	; 0x3594 <vTask_DMAHandler>
     234:	0c 94 c7 11 	jmp	0x238e	; 0x238e <prvTimerTask+0x1e2>
     238:	0c 94 6f 12 	jmp	0x24de	; 0x24de <vWrite_Display>
     23c:	0c 94 3e 16 	jmp	0x2c7c	; 0x2c7c <vDisplayUpdateTask>

00000240 <__ctors_end>:
     240:	11 24       	eor	r1, r1
     242:	1f be       	out	0x3f, r1	; 63
     244:	cf ef       	ldi	r28, 0xFF	; 255
     246:	cd bf       	out	0x3d, r28	; 61
     248:	df e3       	ldi	r29, 0x3F	; 63
     24a:	de bf       	out	0x3e, r29	; 62
     24c:	00 e0       	ldi	r16, 0x00	; 0
     24e:	0c bf       	out	0x3c, r16	; 60

00000250 <init_mem>:
// !!! Never call this function, it is part of .init-Code
void __attribute__ ((naked, section(".init3"))) init_mem (void);
void init_mem (void)
{
   //  Use inline assembler so it works even with optimization turned off
   __asm volatile (
     250:	e5 e2       	ldi	r30, 0x25	; 37
     252:	ff e3       	ldi	r31, 0x3F	; 63
     254:	8a ea       	ldi	r24, 0xAA	; 170
     256:	90 e4       	ldi	r25, 0x40	; 64
     258:	81 93       	st	Z+, r24
     25a:	e0 30       	cpi	r30, 0x00	; 0
     25c:	f9 07       	cpc	r31, r25
     25e:	e0 f3       	brcs	.-8      	; 0x258 <init_mem+0x8>

00000260 <__do_copy_data>:
     260:	10 e2       	ldi	r17, 0x20	; 32
     262:	a0 e0       	ldi	r26, 0x00	; 0
     264:	b0 e2       	ldi	r27, 0x20	; 32
     266:	ec e6       	ldi	r30, 0x6C	; 108
     268:	fc e3       	ldi	r31, 0x3C	; 60
     26a:	00 e0       	ldi	r16, 0x00	; 0
     26c:	0b bf       	out	0x3b, r16	; 59
     26e:	02 c0       	rjmp	.+4      	; 0x274 <__do_copy_data+0x14>
     270:	07 90       	elpm	r0, Z+
     272:	0d 92       	st	X+, r0
     274:	a0 39       	cpi	r26, 0x90	; 144
     276:	b1 07       	cpc	r27, r17
     278:	d9 f7       	brne	.-10     	; 0x270 <__do_copy_data+0x10>

0000027a <__do_clear_bss>:
     27a:	2f e3       	ldi	r18, 0x3F	; 63
     27c:	a0 e9       	ldi	r26, 0x90	; 144
     27e:	b0 e2       	ldi	r27, 0x20	; 32
     280:	01 c0       	rjmp	.+2      	; 0x284 <.do_clear_bss_start>

00000282 <.do_clear_bss_loop>:
     282:	1d 92       	st	X+, r1

00000284 <.do_clear_bss_start>:
     284:	a5 32       	cpi	r26, 0x25	; 37
     286:	b2 07       	cpc	r27, r18
     288:	e1 f7       	brne	.-8      	; 0x282 <.do_clear_bss_loop>
     28a:	0e 94 0e 14 	call	0x281c	; 0x281c <main>
     28e:	0c 94 34 1e 	jmp	0x3c68	; 0x3c68 <_exit>

00000292 <__bad_interrupt>:
     292:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000296 <sys_InitADC>:
void sys_InitADC(void)
{
	
	// Free Running mode: On
	// Conversion mode: Unsigned, 8Bit
	ADCB.CTRLB=(ADCB.CTRLB & (~(ADC_CONMODE_bm | ADC_FREERUN_bm | ADC_RESOLUTION_gm))) | ADC_RESOLUTION_8BIT_gc | ADC_FREERUN_bm;
     296:	e0 e4       	ldi	r30, 0x40	; 64
     298:	f2 e0       	ldi	r31, 0x02	; 2
     29a:	81 81       	ldd	r24, Z+1	; 0x01
     29c:	81 7e       	andi	r24, 0xE1	; 225
     29e:	8c 60       	ori	r24, 0x0C	; 12
     2a0:	81 83       	std	Z+1, r24	; 0x01
	// Reference 1V and configuration of prescaler to 256
	ADCB.PRESCALER=(ADCB.PRESCALER & (~ADC_PRESCALER_gm)) | ADC_PRESCALER_DIV256_gc; //?????
     2a2:	84 81       	ldd	r24, Z+4	; 0x04
     2a4:	88 7f       	andi	r24, 0xF8	; 248
     2a6:	86 60       	ori	r24, 0x06	; 6
     2a8:	84 83       	std	Z+4, r24	; 0x04
	ADCB.REFCTRL = ADC_REFSEL_INT1V_gc | ADC_TEMPREF_bm;;			//internal 1V
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	82 83       	std	Z+2, r24	; 0x02

	// Read and save the ADC offset using channel 0
	ADCB.CH0.CTRL=(ADCB.CH0.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2ae:	80 a1       	ldd	r24, Z+32	; 0x20
     2b0:	80 76       	andi	r24, 0x60	; 96
     2b2:	81 60       	ori	r24, 0x01	; 1
     2b4:	80 a3       	std	Z+32, r24	; 0x20
	ADCB.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN0_gc ;	// PORTB:0
     2b6:	11 a2       	std	Z+33, r1	; 0x21
	
	ADCB.CH1.CTRL=(ADCB.CH1.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2b8:	80 a5       	ldd	r24, Z+40	; 0x28
     2ba:	80 76       	andi	r24, 0x60	; 96
     2bc:	81 60       	ori	r24, 0x01	; 1
     2be:	80 a7       	std	Z+40, r24	; 0x28
	ADCB.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc ;	// PORTB:1	
     2c0:	88 e0       	ldi	r24, 0x08	; 8
     2c2:	81 a7       	std	Z+41, r24	; 0x29
	
	ADCB.CH2.CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_INTERNAL_gc;
     2c4:	10 aa       	std	Z+48, r1	; 0x30
	ADCB.CH2.MUXCTRL = ADC_CH_MUXINT_TEMP_gc;  //Temp Mux
     2c6:	11 aa       	std	Z+49, r1	; 0x31
	
	ADCB.EVCTRL = ADC_SWEEP_012_gc;
     2c8:	80 e8       	ldi	r24, 0x80	; 128
     2ca:	83 83       	std	Z+3, r24	; 0x03
	
	// Enable the ADC in order to read the offset
	ADCB.CTRLA|=ADC_ENABLE_bm;
     2cc:	80 81       	ld	r24, Z
     2ce:	81 60       	ori	r24, 0x01	; 1
     2d0:	80 83       	st	Z, r24
     2d2:	08 95       	ret

000002d4 <vInitDMA>:
void vInitDMA()
{
	uint8_t i = 0;
	
	//ADC8 PB0 Input
	PORTB.DIRCLR = PIN0_bm;
     2d4:	e0 e2       	ldi	r30, 0x20	; 32
     2d6:	f6 e0       	ldi	r31, 0x06	; 6
     2d8:	81 e0       	ldi	r24, 0x01	; 1
     2da:	82 83       	std	Z+2, r24	; 0x02
	PORTB.DIRCLR = PIN1_bm;
     2dc:	82 e0       	ldi	r24, 0x02	; 2
     2de:	82 83       	std	Z+2, r24	; 0x02
	
	sys_InitADC();
     2e0:	0e 94 4b 01 	call	0x296	; 0x296 <sys_InitADC>

	// set TCC1 to 11024Hz overflow, actually 11019.2838Hz (-0.052% error)
	TCC1.CTRLA = 0; // stop if running
     2e4:	e0 e4       	ldi	r30, 0x40	; 64
     2e6:	f8 e0       	ldi	r31, 0x08	; 8
     2e8:	10 82       	st	Z, r1
	TCC1.CNT = 0;
     2ea:	10 a2       	std	Z+32, r1	; 0x20
     2ec:	11 a2       	std	Z+33, r1	; 0x21
	TCC1.PER = 0x0FFF;
     2ee:	8f ef       	ldi	r24, 0xFF	; 255
     2f0:	9f e0       	ldi	r25, 0x0F	; 15
     2f2:	86 a3       	std	Z+38, r24	; 0x26
     2f4:	97 a3       	std	Z+39, r25	; 0x27

	EVSYS.CH0MUX = EVSYS_CHMUX_TCC1_OVF_gc; // trigger on timer overflow
     2f6:	88 ec       	ldi	r24, 0xC8	; 200
     2f8:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>


	// reset DMA controller
	DMA.CTRL = 0;
     2fc:	e0 e0       	ldi	r30, 0x00	; 0
     2fe:	f1 e0       	ldi	r31, 0x01	; 1
     300:	10 82       	st	Z, r1
	DMA.CTRL = DMA_RESET_bm;
     302:	80 e4       	ldi	r24, 0x40	; 64
     304:	80 83       	st	Z, r24
	while ((DMA.CTRL & DMA_RESET_bm) != 0);
     306:	80 81       	ld	r24, Z
     308:	86 fd       	sbrc	r24, 6
     30a:	fd cf       	rjmp	.-6      	; 0x306 <vInitDMA+0x32>
	
	DMA.CTRL			= DMA_CH_ENABLE_bm | DMA_DBUFMODE_CH01_gc; // double buffered with channels 0 and 1
     30c:	e0 e0       	ldi	r30, 0x00	; 0
     30e:	f1 e0       	ldi	r31, 0x01	; 1
     310:	84 e8       	ldi	r24, 0x84	; 132
     312:	80 83       	st	Z, r24
	//Bei Double Buffering wird automatisch aus Channel 0 und 1 ein "Pair" gebildet. 
	//Siehe dazu AVR1304.P8
	
	// channel 0
	// **** TODO: reset dma channels
	DMA.CH0.REPCNT		= 0;
     314:	16 8a       	std	Z+22, r1	; 0x16
	DMA.CH0.CTRLA		=  DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 1 byte (8 bit word)
     316:	74 e2       	ldi	r23, 0x24	; 36
     318:	70 8b       	std	Z+16, r23	; 0x10
	DMA.CH0.CTRLB		= 0x1;
     31a:	61 e0       	ldi	r22, 0x01	; 1
     31c:	61 8b       	std	Z+17, r22	; 0x11
	DMA.CH0.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     31e:	5d e9       	ldi	r21, 0x9D	; 157
     320:	52 8b       	std	Z+18, r21	; 0x12
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH0.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc;	//DMA0 gets synched by TCC1
     322:	46 e4       	ldi	r20, 0x46	; 70
     324:	43 8b       	std	Z+19, r20	; 0x13
	DMA.CH0.TRFCNT		= 2048; // always the number of bytes, even if burst length > 1
     326:	20 e0       	ldi	r18, 0x00	; 0
     328:	38 e0       	ldi	r19, 0x08	; 8
     32a:	24 8b       	std	Z+20, r18	; 0x14
     32c:	35 8b       	std	Z+21, r19	; 0x15
	DMA.CH0.DESTADDR0	= (( (uint16_t) buffer_a) >> 0) & 0xFF;
     32e:	82 e0       	ldi	r24, 0x02	; 2
     330:	97 e3       	ldi	r25, 0x37	; 55
     332:	84 8f       	std	Z+28, r24	; 0x1c
	DMA.CH0.DESTADDR1	= (( (uint16_t) buffer_a) >> 8) & 0xFF;
     334:	95 8f       	std	Z+29, r25	; 0x1d
	DMA.CH0.DESTADDR2	= 0;
     336:	16 8e       	std	Z+30, r1	; 0x1e
	DMA.CH0.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     338:	9c e6       	ldi	r25, 0x6C	; 108
     33a:	90 8f       	std	Z+24, r25	; 0x18
	DMA.CH0.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     33c:	82 e0       	ldi	r24, 0x02	; 2
     33e:	81 8f       	std	Z+25, r24	; 0x19
	DMA.CH0.SRCADDR2	= 0;
     340:	12 8e       	std	Z+26, r1	; 0x1a

	// channel 1
	DMA.CH1.REPCNT		= 0;
     342:	16 a2       	std	Z+38, r1	; 0x26
	DMA.CH1.CTRLA		= DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 1 byte (8 bit word)
     344:	70 a3       	std	Z+32, r23	; 0x20
	DMA.CH1.CTRLB		= 0x1;
     346:	61 a3       	std	Z+33, r22	; 0x21
	DMA.CH1.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     348:	52 a3       	std	Z+34, r21	; 0x22
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH1.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc; //DMA1 gets synched by TCC1
     34a:	43 a3       	std	Z+35, r20	; 0x23
	DMA.CH1.TRFCNT		= 2048;
     34c:	24 a3       	std	Z+36, r18	; 0x24
     34e:	35 a3       	std	Z+37, r19	; 0x25
	DMA.CH1.DESTADDR0	= (( (uint16_t) buffer_b) >> 0) & 0xFF;
     350:	20 e0       	ldi	r18, 0x00	; 0
     352:	3f e2       	ldi	r19, 0x2F	; 47
     354:	24 a7       	std	Z+44, r18	; 0x2c
	DMA.CH1.DESTADDR1	= (( (uint16_t) buffer_b) >> 8) & 0xFF;
     356:	35 a7       	std	Z+45, r19	; 0x2d
	DMA.CH1.DESTADDR2	= 0;
     358:	16 a6       	std	Z+46, r1	; 0x2e
	DMA.CH1.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     35a:	90 a7       	std	Z+40, r25	; 0x28
	DMA.CH1.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     35c:	81 a7       	std	Z+41, r24	; 0x29
	DMA.CH1.SRCADDR2	= 0;
     35e:	12 a6       	std	Z+42, r1	; 0x2a

	DMA.CH0.CTRLA		|= DMA_CH_ENABLE_bm;
     360:	80 89       	ldd	r24, Z+16	; 0x10
     362:	80 68       	ori	r24, 0x80	; 128
     364:	80 8b       	std	Z+16, r24	; 0x10
	TCC1.CTRLA			= TC_CLKSEL_DIV1024_gc; // start timer, and in turn ADC
     366:	87 e0       	ldi	r24, 0x07	; 7
     368:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
     36c:	08 95       	ret

0000036e <__vector_6>:
// 		DMA.INTFLAGS = DMA_CH0TRNIF_bm;

}

ISR(DMA_CH0_vect)
{
     36e:	1f 92       	push	r1
     370:	0f 92       	push	r0
     372:	0f b6       	in	r0, 0x3f	; 63
     374:	0f 92       	push	r0
     376:	11 24       	eor	r1, r1
     378:	0b b6       	in	r0, 0x3b	; 59
     37a:	0f 92       	push	r0
     37c:	2f 93       	push	r18
     37e:	3f 93       	push	r19
     380:	4f 93       	push	r20
     382:	5f 93       	push	r21
     384:	6f 93       	push	r22
     386:	7f 93       	push	r23
     388:	8f 93       	push	r24
     38a:	9f 93       	push	r25
     38c:	af 93       	push	r26
     38e:	bf 93       	push	r27
     390:	ef 93       	push	r30
     392:	ff 93       	push	r31
     394:	cf 93       	push	r28
     396:	df 93       	push	r29
     398:	1f 92       	push	r1
     39a:	cd b7       	in	r28, 0x3d	; 61
     39c:	de b7       	in	r29, 0x3e	; 62
	
	//Interrupt quittieren
	DMA.CH0.CTRLB |= 0x10;
     39e:	e0 e0       	ldi	r30, 0x00	; 0
     3a0:	f1 e0       	ldi	r31, 0x01	; 1
     3a2:	81 89       	ldd	r24, Z+17	; 0x11
     3a4:	80 61       	ori	r24, 0x10	; 16
     3a6:	81 8b       	std	Z+17, r24	; 0x11
	TCC1.INTFLAGS |= 0x01;
     3a8:	e0 e4       	ldi	r30, 0x40	; 64
     3aa:	f8 e0       	ldi	r31, 0x08	; 8
     3ac:	84 85       	ldd	r24, Z+12	; 0x0c
     3ae:	81 60       	ori	r24, 0x01	; 1
     3b0:	84 87       	std	Z+12, r24	; 0x0c
	//PORTF.OUTTGL = 0x01;
		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     3b2:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     3b4:	9e 01       	movw	r18, r28
     3b6:	2f 5f       	subi	r18, 0xFF	; 255
     3b8:	3f 4f       	sbci	r19, 0xFF	; 255
     3ba:	41 e0       	ldi	r20, 0x01	; 1
     3bc:	50 e0       	ldi	r21, 0x00	; 0
     3be:	60 e0       	ldi	r22, 0x00	; 0
     3c0:	70 e0       	ldi	r23, 0x00	; 0
     3c2:	80 91 06 2d 	lds	r24, 0x2D06	; 0x802d06 <xDMAProcessEventGroup>
     3c6:	90 91 07 2d 	lds	r25, 0x2D07	; 0x802d07 <xDMAProcessEventGroup+0x1>
     3ca:	0e 94 38 04 	call	0x870	; 0x870 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     3ce:	0f 90       	pop	r0
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	ff 91       	pop	r31
     3d6:	ef 91       	pop	r30
     3d8:	bf 91       	pop	r27
     3da:	af 91       	pop	r26
     3dc:	9f 91       	pop	r25
     3de:	8f 91       	pop	r24
     3e0:	7f 91       	pop	r23
     3e2:	6f 91       	pop	r22
     3e4:	5f 91       	pop	r21
     3e6:	4f 91       	pop	r20
     3e8:	3f 91       	pop	r19
     3ea:	2f 91       	pop	r18
     3ec:	0f 90       	pop	r0
     3ee:	0b be       	out	0x3b, r0	; 59
     3f0:	0f 90       	pop	r0
     3f2:	0f be       	out	0x3f, r0	; 63
     3f4:	0f 90       	pop	r0
     3f6:	1f 90       	pop	r1
     3f8:	18 95       	reti

000003fa <__vector_7>:

ISR(DMA_CH1_vect)
{
     3fa:	1f 92       	push	r1
     3fc:	0f 92       	push	r0
     3fe:	0f b6       	in	r0, 0x3f	; 63
     400:	0f 92       	push	r0
     402:	11 24       	eor	r1, r1
     404:	0b b6       	in	r0, 0x3b	; 59
     406:	0f 92       	push	r0
     408:	2f 93       	push	r18
     40a:	3f 93       	push	r19
     40c:	4f 93       	push	r20
     40e:	5f 93       	push	r21
     410:	6f 93       	push	r22
     412:	7f 93       	push	r23
     414:	8f 93       	push	r24
     416:	9f 93       	push	r25
     418:	af 93       	push	r26
     41a:	bf 93       	push	r27
     41c:	ef 93       	push	r30
     41e:	ff 93       	push	r31
     420:	cf 93       	push	r28
     422:	df 93       	push	r29
     424:	1f 92       	push	r1
     426:	cd b7       	in	r28, 0x3d	; 61
     428:	de b7       	in	r29, 0x3e	; 62
	//Interrupt quittieren
	DMA.CH1.CTRLB |= 0x10;
     42a:	e0 e0       	ldi	r30, 0x00	; 0
     42c:	f1 e0       	ldi	r31, 0x01	; 1
     42e:	81 a1       	ldd	r24, Z+33	; 0x21
     430:	80 61       	ori	r24, 0x10	; 16
     432:	81 a3       	std	Z+33, r24	; 0x21
	TCC1.INTFLAGS |= 0x01;
     434:	e0 e4       	ldi	r30, 0x40	; 64
     436:	f8 e0       	ldi	r31, 0x08	; 8
     438:	84 85       	ldd	r24, Z+12	; 0x0c
     43a:	81 60       	ori	r24, 0x01	; 1
     43c:	84 87       	std	Z+12, r24	; 0x0c

		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     43e:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     440:	9e 01       	movw	r18, r28
     442:	2f 5f       	subi	r18, 0xFF	; 255
     444:	3f 4f       	sbci	r19, 0xFF	; 255
     446:	42 e0       	ldi	r20, 0x02	; 2
     448:	50 e0       	ldi	r21, 0x00	; 0
     44a:	60 e0       	ldi	r22, 0x00	; 0
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	80 91 06 2d 	lds	r24, 0x2D06	; 0x802d06 <xDMAProcessEventGroup>
     452:	90 91 07 2d 	lds	r25, 0x2D07	; 0x802d07 <xDMAProcessEventGroup+0x1>
     456:	0e 94 38 04 	call	0x870	; 0x870 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     45a:	0f 90       	pop	r0
     45c:	df 91       	pop	r29
     45e:	cf 91       	pop	r28
     460:	ff 91       	pop	r31
     462:	ef 91       	pop	r30
     464:	bf 91       	pop	r27
     466:	af 91       	pop	r26
     468:	9f 91       	pop	r25
     46a:	8f 91       	pop	r24
     46c:	7f 91       	pop	r23
     46e:	6f 91       	pop	r22
     470:	5f 91       	pop	r21
     472:	4f 91       	pop	r20
     474:	3f 91       	pop	r19
     476:	2f 91       	pop	r18
     478:	0f 90       	pop	r0
     47a:	0b be       	out	0x3b, r0	; 59
     47c:	0f 90       	pop	r0
     47e:	0f be       	out	0x3f, r0	; 63
     480:	0f 90       	pop	r0
     482:	1f 90       	pop	r1
     484:	18 95       	reti

00000486 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     486:	0f 93       	push	r16
     488:	cf 93       	push	r28
     48a:	df 93       	push	r29
     48c:	1f 92       	push	r1
     48e:	cd b7       	in	r28, 0x3d	; 61
     490:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     492:	2f b7       	in	r18, 0x3f	; 63
     494:	29 83       	std	Y+1, r18	; 0x01
     496:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     498:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     49a:	fc 01       	movw	r30, r24
     49c:	08 ed       	ldi	r16, 0xD8	; 216
     49e:	04 bf       	out	0x34, r16	; 52
     4a0:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     4a2:	89 81       	ldd	r24, Y+1	; 0x01
     4a4:	8f bf       	out	0x3f, r24	; 63
#endif
}
     4a6:	0f 90       	pop	r0
     4a8:	df 91       	pop	r29
     4aa:	cf 91       	pop	r28
     4ac:	0f 91       	pop	r16
     4ae:	08 95       	ret

000004b0 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     4b0:	61 11       	cpse	r22, r1
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <CLKSYS_XOSC_Config+0x8>
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	01 c0       	rjmp	.+2      	; 0x4ba <CLKSYS_XOSC_Config+0xa>
     4b8:	90 e2       	ldi	r25, 0x20	; 32
     4ba:	84 2b       	or	r24, r20
     4bc:	89 2b       	or	r24, r25
     4be:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
     4c2:	08 95       	ret

000004c4 <CLKSYS_PLL_Config>:
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     4c4:	6f 71       	andi	r22, 0x1F	; 31
     4c6:	86 2b       	or	r24, r22
     4c8:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
     4cc:	08 95       	ret

000004ce <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     4ce:	e0 e5       	ldi	r30, 0x50	; 80
     4d0:	f0 e0       	ldi	r31, 0x00	; 0
     4d2:	90 81       	ld	r25, Z
     4d4:	28 2f       	mov	r18, r24
     4d6:	20 95       	com	r18
     4d8:	92 23       	and	r25, r18
     4da:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     4dc:	90 81       	ld	r25, Z
	return clkEnabled;
}
     4de:	89 23       	and	r24, r25
     4e0:	08 95       	ret

000004e2 <CLKSYS_Prescalers_Config>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
     4e2:	68 2b       	or	r22, r24
     4e4:	81 e4       	ldi	r24, 0x41	; 65
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	0e 94 43 02 	call	0x486	; 0x486 <CCPWrite>
     4ec:	08 95       	ret

000004ee <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     4ee:	0f 93       	push	r16
     4f0:	1f 93       	push	r17
     4f2:	cf 93       	push	r28
     4f4:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     4f6:	00 e4       	ldi	r16, 0x40	; 64
     4f8:	10 e0       	ldi	r17, 0x00	; 0
     4fa:	f8 01       	movw	r30, r16
     4fc:	60 81       	ld	r22, Z
	CCPWrite( &CLK.CTRL, clkCtrl );
     4fe:	68 7f       	andi	r22, 0xF8	; 248
     500:	68 2b       	or	r22, r24
     502:	80 e4       	ldi	r24, 0x40	; 64
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	0e 94 43 02 	call	0x486	; 0x486 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     50a:	f8 01       	movw	r30, r16
     50c:	80 81       	ld	r24, Z
	return clkCtrl;
}
     50e:	8c 23       	and	r24, r28
     510:	cf 91       	pop	r28
     512:	1f 91       	pop	r17
     514:	0f 91       	pop	r16
     516:	08 95       	ret

00000518 <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
     518:	fc 01       	movw	r30, r24
     51a:	90 81       	ld	r25, Z
     51c:	90 7f       	andi	r25, 0xF0	; 240
     51e:	69 2b       	or	r22, r25
     520:	60 83       	st	Z, r22
     522:	08 95       	ret

00000524 <TC0_ConfigWGM>:
     524:	fc 01       	movw	r30, r24
     526:	91 81       	ldd	r25, Z+1	; 0x01
     528:	98 7f       	andi	r25, 0xF8	; 248
     52a:	69 2b       	or	r22, r25
     52c:	61 83       	std	Z+1, r22	; 0x01
     52e:	08 95       	ret

00000530 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
     530:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     532:	96 81       	ldd	r25, Z+6	; 0x06
     534:	9c 7f       	andi	r25, 0xFC	; 252
     536:	69 2b       	or	r22, r25
     538:	66 83       	std	Z+6, r22	; 0x06
     53a:	08 95       	ret

0000053c <software_reset>:
	 // TODO from here:
	 //
	 // - log the occurance of any error in flash mem (inc counter)
	 // - print a message

	 software_reset();
     53c:	00 00       	nop
     53e:	88 ed       	ldi	r24, 0xD8	; 216
     540:	84 bf       	out	0x34, r24	; 52
     542:	81 e0       	ldi	r24, 0x01	; 1
     544:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     548:	08 95       	ret

0000054a <vApplicationStackOverflowHook>:
     54a:	0e 94 9e 02 	call	0x53c	; 0x53c <software_reset>
     54e:	08 95       	ret

00000550 <xEventGroupCreate>:
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
}
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	80 e1       	ldi	r24, 0x10	; 16
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
     55c:	ec 01       	movw	r28, r24
     55e:	00 97       	sbiw	r24, 0x00	; 0
     560:	41 f0       	breq	.+16     	; 0x572 <xEventGroupCreate+0x22>
     562:	fc 01       	movw	r30, r24
     564:	11 92       	st	Z+, r1
     566:	11 92       	st	Z+, r1
     568:	11 92       	st	Z+, r1
     56a:	11 92       	st	Z+, r1
     56c:	cf 01       	movw	r24, r30
     56e:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
     572:	ce 01       	movw	r24, r28
     574:	df 91       	pop	r29
     576:	cf 91       	pop	r28
     578:	08 95       	ret

0000057a <xEventGroupWaitBits>:
     57a:	2f 92       	push	r2
     57c:	3f 92       	push	r3
     57e:	4f 92       	push	r4
     580:	5f 92       	push	r5
     582:	6f 92       	push	r6
     584:	7f 92       	push	r7
     586:	8f 92       	push	r8
     588:	9f 92       	push	r9
     58a:	af 92       	push	r10
     58c:	bf 92       	push	r11
     58e:	cf 92       	push	r12
     590:	df 92       	push	r13
     592:	ef 92       	push	r14
     594:	ff 92       	push	r15
     596:	0f 93       	push	r16
     598:	1f 93       	push	r17
     59a:	cf 93       	push	r28
     59c:	df 93       	push	r29
     59e:	ec 01       	movw	r28, r24
     5a0:	4a 01       	movw	r8, r20
     5a2:	5b 01       	movw	r10, r22
     5a4:	62 2e       	mov	r6, r18
     5a6:	70 2e       	mov	r7, r16
     5a8:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
     5ac:	28 80       	ld	r2, Y
     5ae:	39 80       	ldd	r3, Y+1	; 0x01
     5b0:	4a 80       	ldd	r4, Y+2	; 0x02
     5b2:	5b 80       	ldd	r5, Y+3	; 0x03
     5b4:	01 11       	cpse	r16, r1
     5b6:	0d c0       	rjmp	.+26     	; 0x5d2 <xEventGroupWaitBits+0x58>
     5b8:	81 e0       	ldi	r24, 0x01	; 1
     5ba:	b2 01       	movw	r22, r4
     5bc:	a1 01       	movw	r20, r2
     5be:	48 21       	and	r20, r8
     5c0:	59 21       	and	r21, r9
     5c2:	6a 21       	and	r22, r10
     5c4:	7b 21       	and	r23, r11
     5c6:	45 2b       	or	r20, r21
     5c8:	46 2b       	or	r20, r22
     5ca:	47 2b       	or	r20, r23
     5cc:	79 f4       	brne	.+30     	; 0x5ec <xEventGroupWaitBits+0x72>
     5ce:	80 e0       	ldi	r24, 0x00	; 0
     5d0:	0d c0       	rjmp	.+26     	; 0x5ec <xEventGroupWaitBits+0x72>
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	b2 01       	movw	r22, r4
     5d6:	a1 01       	movw	r20, r2
     5d8:	48 21       	and	r20, r8
     5da:	59 21       	and	r21, r9
     5dc:	6a 21       	and	r22, r10
     5de:	7b 21       	and	r23, r11
     5e0:	48 15       	cp	r20, r8
     5e2:	59 05       	cpc	r21, r9
     5e4:	6a 05       	cpc	r22, r10
     5e6:	7b 05       	cpc	r23, r11
     5e8:	09 f0       	breq	.+2      	; 0x5ec <xEventGroupWaitBits+0x72>
     5ea:	80 e0       	ldi	r24, 0x00	; 0
     5ec:	88 23       	and	r24, r24
     5ee:	81 f0       	breq	.+32     	; 0x610 <xEventGroupWaitBits+0x96>
     5f0:	66 20       	and	r6, r6
     5f2:	09 f4       	brne	.+2      	; 0x5f6 <xEventGroupWaitBits+0x7c>
     5f4:	70 c0       	rjmp	.+224    	; 0x6d6 <xEventGroupWaitBits+0x15c>
     5f6:	80 94       	com	r8
     5f8:	90 94       	com	r9
     5fa:	a0 94       	com	r10
     5fc:	b0 94       	com	r11
     5fe:	82 20       	and	r8, r2
     600:	93 20       	and	r9, r3
     602:	a4 20       	and	r10, r4
     604:	b5 20       	and	r11, r5
     606:	88 82       	st	Y, r8
     608:	99 82       	std	Y+1, r9	; 0x01
     60a:	aa 82       	std	Y+2, r10	; 0x02
     60c:	bb 82       	std	Y+3, r11	; 0x03
     60e:	63 c0       	rjmp	.+198    	; 0x6d6 <xEventGroupWaitBits+0x15c>
     610:	c1 14       	cp	r12, r1
     612:	d1 04       	cpc	r13, r1
     614:	e1 04       	cpc	r14, r1
     616:	f1 04       	cpc	r15, r1
     618:	09 f4       	brne	.+2      	; 0x61c <xEventGroupWaitBits+0xa2>
     61a:	5d c0       	rjmp	.+186    	; 0x6d6 <xEventGroupWaitBits+0x15c>
     61c:	66 20       	and	r6, r6
     61e:	29 f0       	breq	.+10     	; 0x62a <xEventGroupWaitBits+0xb0>
     620:	40 e0       	ldi	r20, 0x00	; 0
     622:	50 e0       	ldi	r21, 0x00	; 0
     624:	60 e0       	ldi	r22, 0x00	; 0
     626:	71 e0       	ldi	r23, 0x01	; 1
     628:	03 c0       	rjmp	.+6      	; 0x630 <xEventGroupWaitBits+0xb6>
     62a:	40 e0       	ldi	r20, 0x00	; 0
     62c:	50 e0       	ldi	r21, 0x00	; 0
     62e:	ba 01       	movw	r22, r20
     630:	71 10       	cpse	r7, r1
     632:	74 60       	ori	r23, 0x04	; 4
     634:	48 29       	or	r20, r8
     636:	59 29       	or	r21, r9
     638:	6a 29       	or	r22, r10
     63a:	7b 29       	or	r23, r11
     63c:	97 01       	movw	r18, r14
     63e:	86 01       	movw	r16, r12
     640:	ce 01       	movw	r24, r28
     642:	04 96       	adiw	r24, 0x04	; 4
     644:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <vTaskPlaceOnUnorderedEventList>
     648:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
     64c:	81 11       	cpse	r24, r1
     64e:	02 c0       	rjmp	.+4      	; 0x654 <xEventGroupWaitBits+0xda>
     650:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
     654:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <uxTaskResetEventItemValue>
     658:	91 fd       	sbrc	r25, 1
     65a:	39 c0       	rjmp	.+114    	; 0x6ce <xEventGroupWaitBits+0x154>
     65c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     660:	ff 93       	push	r31
     662:	f8 7f       	andi	r31, 0xF8	; 248
     664:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     668:	68 81       	ld	r22, Y
     66a:	79 81       	ldd	r23, Y+1	; 0x01
     66c:	8a 81       	ldd	r24, Y+2	; 0x02
     66e:	9b 81       	ldd	r25, Y+3	; 0x03
     670:	71 10       	cpse	r7, r1
     672:	0d c0       	rjmp	.+26     	; 0x68e <xEventGroupWaitBits+0x114>
     674:	21 e0       	ldi	r18, 0x01	; 1
     676:	75 01       	movw	r14, r10
     678:	64 01       	movw	r12, r8
     67a:	c6 22       	and	r12, r22
     67c:	d7 22       	and	r13, r23
     67e:	e8 22       	and	r14, r24
     680:	f9 22       	and	r15, r25
     682:	cd 28       	or	r12, r13
     684:	ce 28       	or	r12, r14
     686:	cf 28       	or	r12, r15
     688:	79 f4       	brne	.+30     	; 0x6a8 <xEventGroupWaitBits+0x12e>
     68a:	20 e0       	ldi	r18, 0x00	; 0
     68c:	0d c0       	rjmp	.+26     	; 0x6a8 <xEventGroupWaitBits+0x12e>
     68e:	21 e0       	ldi	r18, 0x01	; 1
     690:	75 01       	movw	r14, r10
     692:	64 01       	movw	r12, r8
     694:	c6 22       	and	r12, r22
     696:	d7 22       	and	r13, r23
     698:	e8 22       	and	r14, r24
     69a:	f9 22       	and	r15, r25
     69c:	c8 14       	cp	r12, r8
     69e:	d9 04       	cpc	r13, r9
     6a0:	ea 04       	cpc	r14, r10
     6a2:	fb 04       	cpc	r15, r11
     6a4:	09 f0       	breq	.+2      	; 0x6a8 <xEventGroupWaitBits+0x12e>
     6a6:	20 e0       	ldi	r18, 0x00	; 0
     6a8:	22 23       	and	r18, r18
     6aa:	71 f0       	breq	.+28     	; 0x6c8 <xEventGroupWaitBits+0x14e>
     6ac:	66 20       	and	r6, r6
     6ae:	61 f0       	breq	.+24     	; 0x6c8 <xEventGroupWaitBits+0x14e>
     6b0:	80 94       	com	r8
     6b2:	90 94       	com	r9
     6b4:	a0 94       	com	r10
     6b6:	b0 94       	com	r11
     6b8:	86 22       	and	r8, r22
     6ba:	97 22       	and	r9, r23
     6bc:	a8 22       	and	r10, r24
     6be:	b9 22       	and	r11, r25
     6c0:	88 82       	st	Y, r8
     6c2:	99 82       	std	Y+1, r9	; 0x01
     6c4:	aa 82       	std	Y+2, r10	; 0x02
     6c6:	bb 82       	std	Y+3, r11	; 0x03
     6c8:	ff 91       	pop	r31
     6ca:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     6ce:	1b 01       	movw	r2, r22
     6d0:	2c 01       	movw	r4, r24
     6d2:	55 24       	eor	r5, r5
     6d4:	02 c0       	rjmp	.+4      	; 0x6da <xEventGroupWaitBits+0x160>
     6d6:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
     6da:	c2 01       	movw	r24, r4
     6dc:	b1 01       	movw	r22, r2
     6de:	df 91       	pop	r29
     6e0:	cf 91       	pop	r28
     6e2:	1f 91       	pop	r17
     6e4:	0f 91       	pop	r16
     6e6:	ff 90       	pop	r15
     6e8:	ef 90       	pop	r14
     6ea:	df 90       	pop	r13
     6ec:	cf 90       	pop	r12
     6ee:	bf 90       	pop	r11
     6f0:	af 90       	pop	r10
     6f2:	9f 90       	pop	r9
     6f4:	8f 90       	pop	r8
     6f6:	7f 90       	pop	r7
     6f8:	6f 90       	pop	r6
     6fa:	5f 90       	pop	r5
     6fc:	4f 90       	pop	r4
     6fe:	3f 90       	pop	r3
     700:	2f 90       	pop	r2
     702:	08 95       	ret

00000704 <xEventGroupClearBits>:
     704:	0f 93       	push	r16
     706:	1f 93       	push	r17
     708:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     70c:	ff 93       	push	r31
     70e:	f8 7f       	andi	r31, 0xF8	; 248
     710:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     714:	fc 01       	movw	r30, r24
     716:	00 81       	ld	r16, Z
     718:	11 81       	ldd	r17, Z+1	; 0x01
     71a:	22 81       	ldd	r18, Z+2	; 0x02
     71c:	33 81       	ldd	r19, Z+3	; 0x03
     71e:	40 95       	com	r20
     720:	50 95       	com	r21
     722:	60 95       	com	r22
     724:	70 95       	com	r23
     726:	40 23       	and	r20, r16
     728:	51 23       	and	r21, r17
     72a:	62 23       	and	r22, r18
     72c:	73 23       	and	r23, r19
     72e:	40 83       	st	Z, r20
     730:	51 83       	std	Z+1, r21	; 0x01
     732:	62 83       	std	Z+2, r22	; 0x02
     734:	73 83       	std	Z+3, r23	; 0x03
     736:	ff 91       	pop	r31
     738:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     73c:	c9 01       	movw	r24, r18
     73e:	b8 01       	movw	r22, r16
     740:	1f 91       	pop	r17
     742:	0f 91       	pop	r16
     744:	08 95       	ret

00000746 <xEventGroupSetBits>:
     746:	4f 92       	push	r4
     748:	5f 92       	push	r5
     74a:	6f 92       	push	r6
     74c:	7f 92       	push	r7
     74e:	af 92       	push	r10
     750:	bf 92       	push	r11
     752:	cf 92       	push	r12
     754:	df 92       	push	r13
     756:	ef 92       	push	r14
     758:	ff 92       	push	r15
     75a:	0f 93       	push	r16
     75c:	1f 93       	push	r17
     75e:	cf 93       	push	r28
     760:	df 93       	push	r29
     762:	ec 01       	movw	r28, r24
     764:	6a 01       	movw	r12, r20
     766:	7b 01       	movw	r14, r22
     768:	8c 01       	movw	r16, r24
     76a:	09 5f       	subi	r16, 0xF9	; 249
     76c:	1f 4f       	sbci	r17, 0xFF	; 255
     76e:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
     772:	eb 85       	ldd	r30, Y+11	; 0x0b
     774:	fc 85       	ldd	r31, Y+12	; 0x0c
     776:	88 81       	ld	r24, Y
     778:	99 81       	ldd	r25, Y+1	; 0x01
     77a:	aa 81       	ldd	r26, Y+2	; 0x02
     77c:	bb 81       	ldd	r27, Y+3	; 0x03
     77e:	c8 2a       	or	r12, r24
     780:	d9 2a       	or	r13, r25
     782:	ea 2a       	or	r14, r26
     784:	fb 2a       	or	r15, r27
     786:	c8 82       	st	Y, r12
     788:	d9 82       	std	Y+1, r13	; 0x01
     78a:	ea 82       	std	Y+2, r14	; 0x02
     78c:	fb 82       	std	Y+3, r15	; 0x03
     78e:	0e 17       	cp	r16, r30
     790:	1f 07       	cpc	r17, r31
     792:	09 f4       	brne	.+2      	; 0x796 <xEventGroupSetBits+0x50>
     794:	42 c0       	rjmp	.+132    	; 0x81a <xEventGroupSetBits+0xd4>
     796:	c1 2c       	mov	r12, r1
     798:	d1 2c       	mov	r13, r1
     79a:	76 01       	movw	r14, r12
     79c:	a4 80       	ldd	r10, Z+4	; 0x04
     79e:	b5 80       	ldd	r11, Z+5	; 0x05
     7a0:	80 81       	ld	r24, Z
     7a2:	91 81       	ldd	r25, Z+1	; 0x01
     7a4:	a2 81       	ldd	r26, Z+2	; 0x02
     7a6:	b3 81       	ldd	r27, Z+3	; 0x03
     7a8:	ac 01       	movw	r20, r24
     7aa:	bd 01       	movw	r22, r26
     7ac:	77 27       	eor	r23, r23
     7ae:	b2 fd       	sbrc	r27, 2
     7b0:	0f c0       	rjmp	.+30     	; 0x7d0 <xEventGroupSetBits+0x8a>
     7b2:	48 80       	ld	r4, Y
     7b4:	59 80       	ldd	r5, Y+1	; 0x01
     7b6:	6a 80       	ldd	r6, Y+2	; 0x02
     7b8:	7b 80       	ldd	r7, Y+3	; 0x03
     7ba:	44 22       	and	r4, r20
     7bc:	55 22       	and	r5, r21
     7be:	66 22       	and	r6, r22
     7c0:	77 22       	and	r7, r23
     7c2:	21 e0       	ldi	r18, 0x01	; 1
     7c4:	45 28       	or	r4, r5
     7c6:	46 28       	or	r4, r6
     7c8:	47 28       	or	r4, r7
     7ca:	89 f4       	brne	.+34     	; 0x7ee <xEventGroupSetBits+0xa8>
     7cc:	20 e0       	ldi	r18, 0x00	; 0
     7ce:	0f c0       	rjmp	.+30     	; 0x7ee <xEventGroupSetBits+0xa8>
     7d0:	48 80       	ld	r4, Y
     7d2:	59 80       	ldd	r5, Y+1	; 0x01
     7d4:	6a 80       	ldd	r6, Y+2	; 0x02
     7d6:	7b 80       	ldd	r7, Y+3	; 0x03
     7d8:	44 22       	and	r4, r20
     7da:	55 22       	and	r5, r21
     7dc:	66 22       	and	r6, r22
     7de:	77 22       	and	r7, r23
     7e0:	21 e0       	ldi	r18, 0x01	; 1
     7e2:	44 16       	cp	r4, r20
     7e4:	55 06       	cpc	r5, r21
     7e6:	66 06       	cpc	r6, r22
     7e8:	77 06       	cpc	r7, r23
     7ea:	09 f0       	breq	.+2      	; 0x7ee <xEventGroupSetBits+0xa8>
     7ec:	20 e0       	ldi	r18, 0x00	; 0
     7ee:	22 23       	and	r18, r18
     7f0:	71 f0       	breq	.+28     	; 0x80e <xEventGroupSetBits+0xc8>
     7f2:	b0 ff       	sbrs	r27, 0
     7f4:	04 c0       	rjmp	.+8      	; 0x7fe <xEventGroupSetBits+0xb8>
     7f6:	c4 2a       	or	r12, r20
     7f8:	d5 2a       	or	r13, r21
     7fa:	e6 2a       	or	r14, r22
     7fc:	f7 2a       	or	r15, r23
     7fe:	48 81       	ld	r20, Y
     800:	59 81       	ldd	r21, Y+1	; 0x01
     802:	6a 81       	ldd	r22, Y+2	; 0x02
     804:	7b 81       	ldd	r23, Y+3	; 0x03
     806:	72 60       	ori	r23, 0x02	; 2
     808:	cf 01       	movw	r24, r30
     80a:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <vTaskRemoveFromUnorderedEventList>
     80e:	ea 2d       	mov	r30, r10
     810:	fb 2d       	mov	r31, r11
     812:	0e 17       	cp	r16, r30
     814:	1f 07       	cpc	r17, r31
     816:	11 f6       	brne	.-124    	; 0x79c <xEventGroupSetBits+0x56>
     818:	03 c0       	rjmp	.+6      	; 0x820 <xEventGroupSetBits+0xda>
     81a:	c1 2c       	mov	r12, r1
     81c:	d1 2c       	mov	r13, r1
     81e:	76 01       	movw	r14, r12
     820:	c0 94       	com	r12
     822:	d0 94       	com	r13
     824:	e0 94       	com	r14
     826:	f0 94       	com	r15
     828:	88 81       	ld	r24, Y
     82a:	99 81       	ldd	r25, Y+1	; 0x01
     82c:	aa 81       	ldd	r26, Y+2	; 0x02
     82e:	bb 81       	ldd	r27, Y+3	; 0x03
     830:	c8 22       	and	r12, r24
     832:	d9 22       	and	r13, r25
     834:	ea 22       	and	r14, r26
     836:	fb 22       	and	r15, r27
     838:	c8 82       	st	Y, r12
     83a:	d9 82       	std	Y+1, r13	; 0x01
     83c:	ea 82       	std	Y+2, r14	; 0x02
     83e:	fb 82       	std	Y+3, r15	; 0x03
     840:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
     844:	68 81       	ld	r22, Y
     846:	79 81       	ldd	r23, Y+1	; 0x01
     848:	8a 81       	ldd	r24, Y+2	; 0x02
     84a:	9b 81       	ldd	r25, Y+3	; 0x03
     84c:	df 91       	pop	r29
     84e:	cf 91       	pop	r28
     850:	1f 91       	pop	r17
     852:	0f 91       	pop	r16
     854:	ff 90       	pop	r15
     856:	ef 90       	pop	r14
     858:	df 90       	pop	r13
     85a:	cf 90       	pop	r12
     85c:	bf 90       	pop	r11
     85e:	af 90       	pop	r10
     860:	7f 90       	pop	r7
     862:	6f 90       	pop	r6
     864:	5f 90       	pop	r5
     866:	4f 90       	pop	r4
     868:	08 95       	ret

0000086a <vEventGroupSetBitsCallback>:
     86a:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
     86e:	08 95       	ret

00000870 <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
     870:	0f 93       	push	r16
     872:	1f 93       	push	r17
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
     874:	89 01       	movw	r16, r18
     876:	9a 01       	movw	r18, r20
     878:	ab 01       	movw	r20, r22
     87a:	bc 01       	movw	r22, r24
     87c:	85 e3       	ldi	r24, 0x35	; 53
     87e:	94 e0       	ldi	r25, 0x04	; 4
     880:	0e 94 05 12 	call	0x240a	; 0x240a <xTimerPendFunctionCallFromISR>

		return xReturn;
	}
     884:	1f 91       	pop	r17
     886:	0f 91       	pop	r16
     888:	08 95       	ret

0000088a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
     88e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     890:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     894:	20 91 90 20 	lds	r18, 0x2090	; 0x802090 <__data_end>
     898:	30 91 91 20 	lds	r19, 0x2091	; 0x802091 <__data_end+0x1>
     89c:	c9 01       	movw	r24, r18
     89e:	8c 0f       	add	r24, r28
     8a0:	9d 1f       	adc	r25, r29
     8a2:	88 3b       	cpi	r24, 0xB8	; 184
     8a4:	4b e0       	ldi	r20, 0x0B	; 11
     8a6:	94 07       	cpc	r25, r20
     8a8:	58 f4       	brcc	.+22     	; 0x8c0 <pvPortMalloc+0x36>
     8aa:	28 17       	cp	r18, r24
     8ac:	39 07       	cpc	r19, r25
     8ae:	58 f4       	brcc	.+22     	; 0x8c6 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     8b0:	e9 01       	movw	r28, r18
     8b2:	ce 56       	subi	r28, 0x6E	; 110
     8b4:	df 4d       	sbci	r29, 0xDF	; 223
			xNextFreeByte += xWantedSize;			
     8b6:	80 93 90 20 	sts	0x2090, r24	; 0x802090 <__data_end>
     8ba:	90 93 91 20 	sts	0x2091, r25	; 0x802091 <__data_end+0x1>
     8be:	05 c0       	rjmp	.+10     	; 0x8ca <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     8c0:	c0 e0       	ldi	r28, 0x00	; 0
     8c2:	d0 e0       	ldi	r29, 0x00	; 0
     8c4:	02 c0       	rjmp	.+4      	; 0x8ca <pvPortMalloc+0x40>
     8c6:	c0 e0       	ldi	r28, 0x00	; 0
     8c8:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     8ca:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     8ce:	ce 01       	movw	r24, r28
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	08 95       	ret

000008d6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     8d6:	08 95       	ret

000008d8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     8d8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8da:	03 96       	adiw	r24, 0x03	; 3
     8dc:	81 83       	std	Z+1, r24	; 0x01
     8de:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8e0:	4f ef       	ldi	r20, 0xFF	; 255
     8e2:	5f ef       	ldi	r21, 0xFF	; 255
     8e4:	ba 01       	movw	r22, r20
     8e6:	43 83       	std	Z+3, r20	; 0x03
     8e8:	54 83       	std	Z+4, r21	; 0x04
     8ea:	65 83       	std	Z+5, r22	; 0x05
     8ec:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8ee:	87 83       	std	Z+7, r24	; 0x07
     8f0:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8f2:	81 87       	std	Z+9, r24	; 0x09
     8f4:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8f6:	10 82       	st	Z, r1
     8f8:	08 95       	ret

000008fa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8fa:	fc 01       	movw	r30, r24
     8fc:	12 86       	std	Z+10, r1	; 0x0a
     8fe:	13 86       	std	Z+11, r1	; 0x0b
     900:	08 95       	ret

00000902 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
     906:	9c 01       	movw	r18, r24
     908:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     90a:	dc 01       	movw	r26, r24
     90c:	11 96       	adiw	r26, 0x01	; 1
     90e:	cd 91       	ld	r28, X+
     910:	dc 91       	ld	r29, X
     912:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     914:	c4 83       	std	Z+4, r28	; 0x04
     916:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     918:	8e 81       	ldd	r24, Y+6	; 0x06
     91a:	9f 81       	ldd	r25, Y+7	; 0x07
     91c:	86 83       	std	Z+6, r24	; 0x06
     91e:	97 83       	std	Z+7, r25	; 0x07

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     920:	8e 81       	ldd	r24, Y+6	; 0x06
     922:	9f 81       	ldd	r25, Y+7	; 0x07
     924:	dc 01       	movw	r26, r24
     926:	14 96       	adiw	r26, 0x04	; 4
     928:	6d 93       	st	X+, r22
     92a:	7c 93       	st	X, r23
     92c:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxPrevious = pxNewListItem;
     92e:	6e 83       	std	Y+6, r22	; 0x06
     930:	7f 83       	std	Y+7, r23	; 0x07

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     932:	22 87       	std	Z+10, r18	; 0x0a
     934:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     936:	f9 01       	movw	r30, r18
     938:	80 81       	ld	r24, Z
     93a:	8f 5f       	subi	r24, 0xFF	; 255
     93c:	80 83       	st	Z, r24
}
     93e:	df 91       	pop	r29
     940:	cf 91       	pop	r28
     942:	08 95       	ret

00000944 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     944:	0f 93       	push	r16
     946:	1f 93       	push	r17
     948:	cf 93       	push	r28
     94a:	df 93       	push	r29
     94c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     94e:	08 81       	ld	r16, Y
     950:	19 81       	ldd	r17, Y+1	; 0x01
     952:	2a 81       	ldd	r18, Y+2	; 0x02
     954:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     956:	0f 3f       	cpi	r16, 0xFF	; 255
     958:	4f ef       	ldi	r20, 0xFF	; 255
     95a:	14 07       	cpc	r17, r20
     95c:	24 07       	cpc	r18, r20
     95e:	34 07       	cpc	r19, r20
     960:	21 f4       	brne	.+8      	; 0x96a <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     962:	fc 01       	movw	r30, r24
     964:	a1 85       	ldd	r26, Z+9	; 0x09
     966:	b2 85       	ldd	r27, Z+10	; 0x0a
     968:	11 c0       	rjmp	.+34     	; 0x98c <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     96a:	dc 01       	movw	r26, r24
     96c:	13 96       	adiw	r26, 0x03	; 3
     96e:	01 c0       	rjmp	.+2      	; 0x972 <vListInsert+0x2e>
     970:	df 01       	movw	r26, r30
     972:	14 96       	adiw	r26, 0x04	; 4
     974:	ed 91       	ld	r30, X+
     976:	fc 91       	ld	r31, X
     978:	15 97       	sbiw	r26, 0x05	; 5
     97a:	40 81       	ld	r20, Z
     97c:	51 81       	ldd	r21, Z+1	; 0x01
     97e:	62 81       	ldd	r22, Z+2	; 0x02
     980:	73 81       	ldd	r23, Z+3	; 0x03
     982:	04 17       	cp	r16, r20
     984:	15 07       	cpc	r17, r21
     986:	26 07       	cpc	r18, r22
     988:	37 07       	cpc	r19, r23
     98a:	90 f7       	brcc	.-28     	; 0x970 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     98c:	14 96       	adiw	r26, 0x04	; 4
     98e:	ed 91       	ld	r30, X+
     990:	fc 91       	ld	r31, X
     992:	15 97       	sbiw	r26, 0x05	; 5
     994:	ec 83       	std	Y+4, r30	; 0x04
     996:	fd 83       	std	Y+5, r31	; 0x05
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     998:	c6 83       	std	Z+6, r28	; 0x06
     99a:	d7 83       	std	Z+7, r29	; 0x07
	pxNewListItem->pxPrevious = pxIterator;
     99c:	ae 83       	std	Y+6, r26	; 0x06
     99e:	bf 83       	std	Y+7, r27	; 0x07
	pxIterator->pxNext = pxNewListItem;
     9a0:	14 96       	adiw	r26, 0x04	; 4
     9a2:	cd 93       	st	X+, r28
     9a4:	dc 93       	st	X, r29
     9a6:	15 97       	sbiw	r26, 0x05	; 5

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9a8:	8a 87       	std	Y+10, r24	; 0x0a
     9aa:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     9ac:	fc 01       	movw	r30, r24
     9ae:	20 81       	ld	r18, Z
     9b0:	2f 5f       	subi	r18, 0xFF	; 255
     9b2:	20 83       	st	Z, r18
}
     9b4:	df 91       	pop	r29
     9b6:	cf 91       	pop	r28
     9b8:	1f 91       	pop	r17
     9ba:	0f 91       	pop	r16
     9bc:	08 95       	ret

000009be <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
     9c2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     9c4:	a2 85       	ldd	r26, Z+10	; 0x0a
     9c6:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9c8:	c4 81       	ldd	r28, Z+4	; 0x04
     9ca:	d5 81       	ldd	r29, Z+5	; 0x05
     9cc:	86 81       	ldd	r24, Z+6	; 0x06
     9ce:	97 81       	ldd	r25, Z+7	; 0x07
     9d0:	8e 83       	std	Y+6, r24	; 0x06
     9d2:	9f 83       	std	Y+7, r25	; 0x07
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     9d4:	c6 81       	ldd	r28, Z+6	; 0x06
     9d6:	d7 81       	ldd	r29, Z+7	; 0x07
     9d8:	84 81       	ldd	r24, Z+4	; 0x04
     9da:	95 81       	ldd	r25, Z+5	; 0x05
     9dc:	8c 83       	std	Y+4, r24	; 0x04
     9de:	9d 83       	std	Y+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9e0:	11 96       	adiw	r26, 0x01	; 1
     9e2:	8d 91       	ld	r24, X+
     9e4:	9c 91       	ld	r25, X
     9e6:	12 97       	sbiw	r26, 0x02	; 2
     9e8:	e8 17       	cp	r30, r24
     9ea:	f9 07       	cpc	r31, r25
     9ec:	31 f4       	brne	.+12     	; 0x9fa <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9ee:	86 81       	ldd	r24, Z+6	; 0x06
     9f0:	97 81       	ldd	r25, Z+7	; 0x07
     9f2:	11 96       	adiw	r26, 0x01	; 1
     9f4:	8d 93       	st	X+, r24
     9f6:	9c 93       	st	X, r25
     9f8:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9fa:	12 86       	std	Z+10, r1	; 0x0a
     9fc:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     9fe:	8c 91       	ld	r24, X
     a00:	81 50       	subi	r24, 0x01	; 1
     a02:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     a04:	8c 91       	ld	r24, X
}
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	08 95       	ret

00000a0c <_portSetInterruptMaskFromIsr>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a0c:	e0 ea       	ldi	r30, 0xA0	; 160
     a0e:	f0 e0       	ldi	r31, 0x00	; 0
     a10:	82 81       	ldd	r24, Z+2	; 0x02
     a12:	92 81       	ldd	r25, Z+2	; 0x02
     a14:	98 7f       	andi	r25, 0xF8	; 248
     a16:	92 83       	std	Z+2, r25	; 0x02
     a18:	08 95       	ret

00000a1a <pxPortInitialiseStack>:
     a1a:	cf 92       	push	r12
     a1c:	df 92       	push	r13
     a1e:	ef 92       	push	r14
     a20:	ff 92       	push	r15
     a22:	31 e1       	ldi	r19, 0x11	; 17
     a24:	fc 01       	movw	r30, r24
     a26:	30 83       	st	Z, r19
     a28:	31 97       	sbiw	r30, 0x01	; 1
     a2a:	22 e2       	ldi	r18, 0x22	; 34
     a2c:	20 83       	st	Z, r18
     a2e:	31 97       	sbiw	r30, 0x01	; 1
     a30:	a3 e3       	ldi	r26, 0x33	; 51
     a32:	a0 83       	st	Z, r26
     a34:	6b 01       	movw	r12, r22
     a36:	e1 2c       	mov	r14, r1
     a38:	f1 2c       	mov	r15, r1
     a3a:	31 97       	sbiw	r30, 0x01	; 1
     a3c:	60 83       	st	Z, r22
     a3e:	31 97       	sbiw	r30, 0x01	; 1
     a40:	d0 82       	st	Z, r13
     a42:	31 97       	sbiw	r30, 0x01	; 1
     a44:	e0 82       	st	Z, r14
     a46:	31 97       	sbiw	r30, 0x01	; 1
     a48:	61 e3       	ldi	r22, 0x31	; 49
     a4a:	60 83       	st	Z, r22
     a4c:	31 97       	sbiw	r30, 0x01	; 1
     a4e:	60 e8       	ldi	r22, 0x80	; 128
     a50:	60 83       	st	Z, r22
     a52:	31 97       	sbiw	r30, 0x01	; 1
     a54:	67 e8       	ldi	r22, 0x87	; 135
     a56:	60 83       	st	Z, r22
     a58:	31 97       	sbiw	r30, 0x01	; 1
     a5a:	10 82       	st	Z, r1
     a5c:	31 97       	sbiw	r30, 0x01	; 1
     a5e:	10 82       	st	Z, r1
     a60:	31 97       	sbiw	r30, 0x01	; 1
     a62:	62 e0       	ldi	r22, 0x02	; 2
     a64:	60 83       	st	Z, r22
     a66:	31 97       	sbiw	r30, 0x01	; 1
     a68:	63 e0       	ldi	r22, 0x03	; 3
     a6a:	60 83       	st	Z, r22
     a6c:	31 97       	sbiw	r30, 0x01	; 1
     a6e:	64 e0       	ldi	r22, 0x04	; 4
     a70:	60 83       	st	Z, r22
     a72:	31 97       	sbiw	r30, 0x01	; 1
     a74:	65 e0       	ldi	r22, 0x05	; 5
     a76:	60 83       	st	Z, r22
     a78:	31 97       	sbiw	r30, 0x01	; 1
     a7a:	66 e0       	ldi	r22, 0x06	; 6
     a7c:	60 83       	st	Z, r22
     a7e:	31 97       	sbiw	r30, 0x01	; 1
     a80:	67 e0       	ldi	r22, 0x07	; 7
     a82:	60 83       	st	Z, r22
     a84:	31 97       	sbiw	r30, 0x01	; 1
     a86:	68 e0       	ldi	r22, 0x08	; 8
     a88:	60 83       	st	Z, r22
     a8a:	31 97       	sbiw	r30, 0x01	; 1
     a8c:	69 e0       	ldi	r22, 0x09	; 9
     a8e:	60 83       	st	Z, r22
     a90:	31 97       	sbiw	r30, 0x01	; 1
     a92:	60 e1       	ldi	r22, 0x10	; 16
     a94:	60 83       	st	Z, r22
     a96:	31 97       	sbiw	r30, 0x01	; 1
     a98:	30 83       	st	Z, r19
     a9a:	31 97       	sbiw	r30, 0x01	; 1
     a9c:	32 e1       	ldi	r19, 0x12	; 18
     a9e:	30 83       	st	Z, r19
     aa0:	31 97       	sbiw	r30, 0x01	; 1
     aa2:	33 e1       	ldi	r19, 0x13	; 19
     aa4:	30 83       	st	Z, r19
     aa6:	31 97       	sbiw	r30, 0x01	; 1
     aa8:	34 e1       	ldi	r19, 0x14	; 20
     aaa:	30 83       	st	Z, r19
     aac:	31 97       	sbiw	r30, 0x01	; 1
     aae:	35 e1       	ldi	r19, 0x15	; 21
     ab0:	30 83       	st	Z, r19
     ab2:	31 97       	sbiw	r30, 0x01	; 1
     ab4:	36 e1       	ldi	r19, 0x16	; 22
     ab6:	30 83       	st	Z, r19
     ab8:	31 97       	sbiw	r30, 0x01	; 1
     aba:	37 e1       	ldi	r19, 0x17	; 23
     abc:	30 83       	st	Z, r19
     abe:	31 97       	sbiw	r30, 0x01	; 1
     ac0:	38 e1       	ldi	r19, 0x18	; 24
     ac2:	30 83       	st	Z, r19
     ac4:	31 97       	sbiw	r30, 0x01	; 1
     ac6:	39 e1       	ldi	r19, 0x19	; 25
     ac8:	30 83       	st	Z, r19
     aca:	31 97       	sbiw	r30, 0x01	; 1
     acc:	30 e2       	ldi	r19, 0x20	; 32
     ace:	30 83       	st	Z, r19
     ad0:	31 97       	sbiw	r30, 0x01	; 1
     ad2:	31 e2       	ldi	r19, 0x21	; 33
     ad4:	30 83       	st	Z, r19
     ad6:	31 97       	sbiw	r30, 0x01	; 1
     ad8:	20 83       	st	Z, r18
     ada:	31 97       	sbiw	r30, 0x01	; 1
     adc:	23 e2       	ldi	r18, 0x23	; 35
     ade:	20 83       	st	Z, r18
     ae0:	6a 01       	movw	r12, r20
     ae2:	31 97       	sbiw	r30, 0x01	; 1
     ae4:	40 83       	st	Z, r20
     ae6:	31 97       	sbiw	r30, 0x01	; 1
     ae8:	d0 82       	st	Z, r13
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	26 e2       	ldi	r18, 0x26	; 38
     aee:	20 83       	st	Z, r18
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	27 e2       	ldi	r18, 0x27	; 39
     af4:	20 83       	st	Z, r18
     af6:	31 97       	sbiw	r30, 0x01	; 1
     af8:	28 e2       	ldi	r18, 0x28	; 40
     afa:	20 83       	st	Z, r18
     afc:	31 97       	sbiw	r30, 0x01	; 1
     afe:	29 e2       	ldi	r18, 0x29	; 41
     b00:	20 83       	st	Z, r18
     b02:	31 97       	sbiw	r30, 0x01	; 1
     b04:	20 e3       	ldi	r18, 0x30	; 48
     b06:	20 83       	st	Z, r18
     b08:	88 97       	sbiw	r24, 0x28	; 40
     b0a:	ff 90       	pop	r15
     b0c:	ef 90       	pop	r14
     b0e:	df 90       	pop	r13
     b10:	cf 90       	pop	r12
     b12:	08 95       	ret

00000b14 <xPortStartScheduler>:
     b14:	83 ef       	ldi	r24, 0xF3	; 243
     b16:	91 e0       	ldi	r25, 0x01	; 1
     b18:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     b1c:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
     b20:	65 e0       	ldi	r22, 0x05	; 5
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	98 e0       	ldi	r25, 0x08	; 8
     b26:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
     b2a:	61 e0       	ldi	r22, 0x01	; 1
     b2c:	80 e0       	ldi	r24, 0x00	; 0
     b2e:	98 e0       	ldi	r25, 0x08	; 8
     b30:	0e 94 98 02 	call	0x530	; 0x530 <TC0_SetOverflowIntLevel>
     b34:	a0 91 b8 2c 	lds	r26, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
     b38:	b0 91 b9 2c 	lds	r27, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
     b3c:	0d 90       	ld	r0, X+
     b3e:	0d be       	out	0x3d, r0	; 61
     b40:	0d 90       	ld	r0, X+
     b42:	0e be       	out	0x3e, r0	; 62
     b44:	ef 91       	pop	r30
     b46:	df 91       	pop	r29
     b48:	cf 91       	pop	r28
     b4a:	bf 91       	pop	r27
     b4c:	af 91       	pop	r26
     b4e:	9f 91       	pop	r25
     b50:	8f 91       	pop	r24
     b52:	7f 91       	pop	r23
     b54:	6f 91       	pop	r22
     b56:	5f 91       	pop	r21
     b58:	4f 91       	pop	r20
     b5a:	3f 91       	pop	r19
     b5c:	2f 91       	pop	r18
     b5e:	1f 91       	pop	r17
     b60:	0f 91       	pop	r16
     b62:	ff 90       	pop	r15
     b64:	ef 90       	pop	r14
     b66:	df 90       	pop	r13
     b68:	cf 90       	pop	r12
     b6a:	bf 90       	pop	r11
     b6c:	af 90       	pop	r10
     b6e:	9f 90       	pop	r9
     b70:	8f 90       	pop	r8
     b72:	7f 90       	pop	r7
     b74:	6f 90       	pop	r6
     b76:	5f 90       	pop	r5
     b78:	4f 90       	pop	r4
     b7a:	3f 90       	pop	r3
     b7c:	2f 90       	pop	r2
     b7e:	1f 90       	pop	r1
     b80:	0f 90       	pop	r0
     b82:	ff 91       	pop	r31
     b84:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b88:	ff 91       	pop	r31
     b8a:	ff bf       	out	0x3f, r31	; 63
     b8c:	ff 91       	pop	r31
     b8e:	08 95       	ret
     b90:	81 e0       	ldi	r24, 0x01	; 1
     b92:	08 95       	ret

00000b94 <vPortYield>:
// 
//
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b94:	ff 93       	push	r31
     b96:	ff b7       	in	r31, 0x3f	; 63
     b98:	ff 93       	push	r31
     b9a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b9e:	ff 93       	push	r31
     ba0:	f8 7f       	andi	r31, 0xF8	; 248
     ba2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ba6:	0f 92       	push	r0
     ba8:	1f 92       	push	r1
     baa:	11 24       	eor	r1, r1
     bac:	2f 92       	push	r2
     bae:	3f 92       	push	r3
     bb0:	4f 92       	push	r4
     bb2:	5f 92       	push	r5
     bb4:	6f 92       	push	r6
     bb6:	7f 92       	push	r7
     bb8:	8f 92       	push	r8
     bba:	9f 92       	push	r9
     bbc:	af 92       	push	r10
     bbe:	bf 92       	push	r11
     bc0:	cf 92       	push	r12
     bc2:	df 92       	push	r13
     bc4:	ef 92       	push	r14
     bc6:	ff 92       	push	r15
     bc8:	0f 93       	push	r16
     bca:	1f 93       	push	r17
     bcc:	2f 93       	push	r18
     bce:	3f 93       	push	r19
     bd0:	4f 93       	push	r20
     bd2:	5f 93       	push	r21
     bd4:	6f 93       	push	r22
     bd6:	7f 93       	push	r23
     bd8:	8f 93       	push	r24
     bda:	9f 93       	push	r25
     bdc:	af 93       	push	r26
     bde:	bf 93       	push	r27
     be0:	cf 93       	push	r28
     be2:	df 93       	push	r29
     be4:	ef 93       	push	r30
     be6:	a0 91 b8 2c 	lds	r26, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
     bea:	b0 91 b9 2c 	lds	r27, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
     bee:	0d b6       	in	r0, 0x3d	; 61
     bf0:	0d 92       	st	X+, r0
     bf2:	0e b6       	in	r0, 0x3e	; 62
     bf4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     bf6:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bfa:	a0 91 b8 2c 	lds	r26, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
     bfe:	b0 91 b9 2c 	lds	r27, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
     c02:	0d 90       	ld	r0, X+
     c04:	0d be       	out	0x3d, r0	; 61
     c06:	0d 90       	ld	r0, X+
     c08:	0e be       	out	0x3e, r0	; 62
     c0a:	ef 91       	pop	r30
     c0c:	df 91       	pop	r29
     c0e:	cf 91       	pop	r28
     c10:	bf 91       	pop	r27
     c12:	af 91       	pop	r26
     c14:	9f 91       	pop	r25
     c16:	8f 91       	pop	r24
     c18:	7f 91       	pop	r23
     c1a:	6f 91       	pop	r22
     c1c:	5f 91       	pop	r21
     c1e:	4f 91       	pop	r20
     c20:	3f 91       	pop	r19
     c22:	2f 91       	pop	r18
     c24:	1f 91       	pop	r17
     c26:	0f 91       	pop	r16
     c28:	ff 90       	pop	r15
     c2a:	ef 90       	pop	r14
     c2c:	df 90       	pop	r13
     c2e:	cf 90       	pop	r12
     c30:	bf 90       	pop	r11
     c32:	af 90       	pop	r10
     c34:	9f 90       	pop	r9
     c36:	8f 90       	pop	r8
     c38:	7f 90       	pop	r7
     c3a:	6f 90       	pop	r6
     c3c:	5f 90       	pop	r5
     c3e:	4f 90       	pop	r4
     c40:	3f 90       	pop	r3
     c42:	2f 90       	pop	r2
     c44:	1f 90       	pop	r1
     c46:	0f 90       	pop	r0
     c48:	ff 91       	pop	r31
     c4a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     c4e:	ff 91       	pop	r31
     c50:	ff bf       	out	0x3f, r31	; 63
     c52:	ff 91       	pop	r31
	asm volatile ( "ret" );
     c54:	08 95       	ret

00000c56 <portTaskSwitchContext>:
	//-----------------------------------------------------------
	//
	// The task switch is deferred until there is no more nesting.
	//
	void portTaskSwitchContext(signed portBASE_TYPE xSwitchRequired)
	{
     c56:	cf 93       	push	r28
		intTaskSwitchPending |= xSwitchRequired;					
     c58:	90 91 02 3f 	lds	r25, 0x3F02	; 0x803f02 <intTaskSwitchPending>
     c5c:	89 2b       	or	r24, r25
     c5e:	80 93 02 3f 	sts	0x3F02, r24	; 0x803f02 <intTaskSwitchPending>
																
		if(NOT_NESTING() && intTaskSwitchPending)					
     c62:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c66:	91 30       	cpi	r25, 0x01	; 1
     c68:	41 f0       	breq	.+16     	; 0xc7a <portTaskSwitchContext+0x24>
     c6a:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c6e:	92 30       	cpi	r25, 0x02	; 2
     c70:	21 f0       	breq	.+8      	; 0xc7a <portTaskSwitchContext+0x24>
     c72:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c76:	94 30       	cpi	r25, 0x04	; 4
     c78:	59 f4       	brne	.+22     	; 0xc90 <portTaskSwitchContext+0x3a>
     c7a:	88 23       	and	r24, r24
     c7c:	49 f0       	breq	.+18     	; 0xc90 <portTaskSwitchContext+0x3a>
		{															
			register unsigned portBASE_TYPE uxSavedPmicCtrlReg; 				
			extern void vTaskSwitchContext(void);   				
																
			// Critical section used, because vTaskSwitchContext handles FreeRTOS internal data structures.
 			uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR(); 
     c7e:	0e 94 06 05 	call	0xa0c	; 0xa0c <_portSetInterruptMaskFromIsr>
     c82:	c8 2f       	mov	r28, r24
			intTaskSwitchPending = 0;								
     c84:	10 92 02 3f 	sts	0x3F02, r1	; 0x803f02 <intTaskSwitchPending>
			vTaskSwitchContext();                   				
     c88:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <vTaskSwitchContext>
			portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedPmicCtrlReg);
     c8c:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		}                                          					
	}
     c90:	cf 91       	pop	r28
     c92:	08 95       	ret

00000c94 <__vector_14>:
	// the context is saved at the start of vPortYieldFromTick().  The tick
	// count is incremented after the context is saved.
	//
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
     c94:	ff 93       	push	r31
     c96:	ff b7       	in	r31, 0x3f	; 63
     c98:	ff 93       	push	r31
     c9a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     c9e:	ff 93       	push	r31
     ca0:	f8 7f       	andi	r31, 0xF8	; 248
     ca2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ca6:	0f 92       	push	r0
     ca8:	1f 92       	push	r1
     caa:	11 24       	eor	r1, r1
     cac:	2f 92       	push	r2
     cae:	3f 92       	push	r3
     cb0:	4f 92       	push	r4
     cb2:	5f 92       	push	r5
     cb4:	6f 92       	push	r6
     cb6:	7f 92       	push	r7
     cb8:	8f 92       	push	r8
     cba:	9f 92       	push	r9
     cbc:	af 92       	push	r10
     cbe:	bf 92       	push	r11
     cc0:	cf 92       	push	r12
     cc2:	df 92       	push	r13
     cc4:	ef 92       	push	r14
     cc6:	ff 92       	push	r15
     cc8:	0f 93       	push	r16
     cca:	1f 93       	push	r17
     ccc:	2f 93       	push	r18
     cce:	3f 93       	push	r19
     cd0:	4f 93       	push	r20
     cd2:	5f 93       	push	r21
     cd4:	6f 93       	push	r22
     cd6:	7f 93       	push	r23
     cd8:	8f 93       	push	r24
     cda:	9f 93       	push	r25
     cdc:	af 93       	push	r26
     cde:	bf 93       	push	r27
     ce0:	cf 93       	push	r28
     ce2:	df 93       	push	r29
     ce4:	ef 93       	push	r30
     ce6:	a0 91 b8 2c 	lds	r26, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
     cea:	b0 91 b9 2c 	lds	r27, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
     cee:	0d b6       	in	r0, 0x3d	; 61
     cf0:	0d 92       	st	X+, r0
     cf2:	0e b6       	in	r0, 0x3e	; 62
     cf4:	0d 92       	st	X+, r0
	//
	static void portTaskIncrementTick( void )
	{
		register unsigned portBASE_TYPE uxSavedPmicCtrlReg;

 		uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR();
     cf6:	0e 94 06 05 	call	0xa0c	; 0xa0c <_portSetInterruptMaskFromIsr>
     cfa:	c8 2f       	mov	r28, r24
		xTaskIncrementTick();
     cfc:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <xTaskIncrementTick>
 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedPmicCtrlReg );
     d00:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
		portTaskIncrementTick();
		//always try a task switch, but only if on kernel interrupt level
		portEND_SWITCHING_ISR(pdTRUE); 
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	0e 94 2b 06 	call	0xc56	; 0xc56 <portTaskSwitchContext>
     d0a:	a0 91 b8 2c 	lds	r26, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
     d0e:	b0 91 b9 2c 	lds	r27, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
     d12:	0d 90       	ld	r0, X+
     d14:	0d be       	out	0x3d, r0	; 61
     d16:	0d 90       	ld	r0, X+
     d18:	0e be       	out	0x3e, r0	; 62
     d1a:	ef 91       	pop	r30
     d1c:	df 91       	pop	r29
     d1e:	cf 91       	pop	r28
     d20:	bf 91       	pop	r27
     d22:	af 91       	pop	r26
     d24:	9f 91       	pop	r25
     d26:	8f 91       	pop	r24
     d28:	7f 91       	pop	r23
     d2a:	6f 91       	pop	r22
     d2c:	5f 91       	pop	r21
     d2e:	4f 91       	pop	r20
     d30:	3f 91       	pop	r19
     d32:	2f 91       	pop	r18
     d34:	1f 91       	pop	r17
     d36:	0f 91       	pop	r16
     d38:	ff 90       	pop	r15
     d3a:	ef 90       	pop	r14
     d3c:	df 90       	pop	r13
     d3e:	cf 90       	pop	r12
     d40:	bf 90       	pop	r11
     d42:	af 90       	pop	r10
     d44:	9f 90       	pop	r9
     d46:	8f 90       	pop	r8
     d48:	7f 90       	pop	r7
     d4a:	6f 90       	pop	r6
     d4c:	5f 90       	pop	r5
     d4e:	4f 90       	pop	r4
     d50:	3f 90       	pop	r3
     d52:	2f 90       	pop	r2
     d54:	1f 90       	pop	r1
     d56:	0f 90       	pop	r0
     d58:	ff 91       	pop	r31
     d5a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d5e:	ff 91       	pop	r31
     d60:	ff bf       	out	0x3f, r31	; 63
     d62:	ff 91       	pop	r31
     d64:	18 95       	reti

00000d66 <prvIsQueueEmpty>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
     d66:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d6a:	ff 93       	push	r31
     d6c:	f8 7f       	andi	r31, 0xF8	; 248
     d6e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d72:	fc 01       	movw	r30, r24
     d74:	96 8d       	ldd	r25, Z+30	; 0x1e
     d76:	ff 91       	pop	r31
     d78:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	91 11       	cpse	r25, r1
     d80:	80 e0       	ldi	r24, 0x00	; 0
     d82:	08 95       	ret

00000d84 <prvIsQueueFull>:
     d84:	dc 01       	movw	r26, r24
     d86:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d8a:	ff 93       	push	r31
     d8c:	f8 7f       	andi	r31, 0xF8	; 248
     d8e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d92:	5e 96       	adiw	r26, 0x1e	; 30
     d94:	9c 91       	ld	r25, X
     d96:	5e 97       	sbiw	r26, 0x1e	; 30
     d98:	ff 91       	pop	r31
     d9a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d9e:	81 e0       	ldi	r24, 0x01	; 1
     da0:	5f 96       	adiw	r26, 0x1f	; 31
     da2:	2c 91       	ld	r18, X
     da4:	29 13       	cpse	r18, r25
     da6:	80 e0       	ldi	r24, 0x00	; 0
     da8:	08 95       	ret

00000daa <prvCopyDataToQueue>:
     daa:	0f 93       	push	r16
     dac:	1f 93       	push	r17
     dae:	cf 93       	push	r28
     db0:	df 93       	push	r29
     db2:	ec 01       	movw	r28, r24
     db4:	04 2f       	mov	r16, r20
     db6:	1e 8d       	ldd	r17, Y+30	; 0x1e
     db8:	48 a1       	ldd	r20, Y+32	; 0x20
     dba:	44 23       	and	r20, r20
     dbc:	b9 f1       	breq	.+110    	; 0xe2c <prvCopyDataToQueue+0x82>
     dbe:	01 11       	cpse	r16, r1
     dc0:	16 c0       	rjmp	.+44     	; 0xdee <prvCopyDataToQueue+0x44>
     dc2:	50 e0       	ldi	r21, 0x00	; 0
     dc4:	8c 81       	ldd	r24, Y+4	; 0x04
     dc6:	9d 81       	ldd	r25, Y+5	; 0x05
     dc8:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <memcpy>
     dcc:	28 a1       	ldd	r18, Y+32	; 0x20
     dce:	8c 81       	ldd	r24, Y+4	; 0x04
     dd0:	9d 81       	ldd	r25, Y+5	; 0x05
     dd2:	82 0f       	add	r24, r18
     dd4:	91 1d       	adc	r25, r1
     dd6:	8c 83       	std	Y+4, r24	; 0x04
     dd8:	9d 83       	std	Y+5, r25	; 0x05
     dda:	2a 81       	ldd	r18, Y+2	; 0x02
     ddc:	3b 81       	ldd	r19, Y+3	; 0x03
     dde:	82 17       	cp	r24, r18
     de0:	93 07       	cpc	r25, r19
     de2:	20 f1       	brcs	.+72     	; 0xe2c <prvCopyDataToQueue+0x82>
     de4:	88 81       	ld	r24, Y
     de6:	99 81       	ldd	r25, Y+1	; 0x01
     de8:	8c 83       	std	Y+4, r24	; 0x04
     dea:	9d 83       	std	Y+5, r25	; 0x05
     dec:	1f c0       	rjmp	.+62     	; 0xe2c <prvCopyDataToQueue+0x82>
     dee:	50 e0       	ldi	r21, 0x00	; 0
     df0:	8e 81       	ldd	r24, Y+6	; 0x06
     df2:	9f 81       	ldd	r25, Y+7	; 0x07
     df4:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <memcpy>
     df8:	88 a1       	ldd	r24, Y+32	; 0x20
     dfa:	90 e0       	ldi	r25, 0x00	; 0
     dfc:	91 95       	neg	r25
     dfe:	81 95       	neg	r24
     e00:	91 09       	sbc	r25, r1
     e02:	2e 81       	ldd	r18, Y+6	; 0x06
     e04:	3f 81       	ldd	r19, Y+7	; 0x07
     e06:	28 0f       	add	r18, r24
     e08:	39 1f       	adc	r19, r25
     e0a:	2e 83       	std	Y+6, r18	; 0x06
     e0c:	3f 83       	std	Y+7, r19	; 0x07
     e0e:	48 81       	ld	r20, Y
     e10:	59 81       	ldd	r21, Y+1	; 0x01
     e12:	24 17       	cp	r18, r20
     e14:	35 07       	cpc	r19, r21
     e16:	30 f4       	brcc	.+12     	; 0xe24 <prvCopyDataToQueue+0x7a>
     e18:	2a 81       	ldd	r18, Y+2	; 0x02
     e1a:	3b 81       	ldd	r19, Y+3	; 0x03
     e1c:	82 0f       	add	r24, r18
     e1e:	93 1f       	adc	r25, r19
     e20:	8e 83       	std	Y+6, r24	; 0x06
     e22:	9f 83       	std	Y+7, r25	; 0x07
     e24:	02 30       	cpi	r16, 0x02	; 2
     e26:	11 f4       	brne	.+4      	; 0xe2c <prvCopyDataToQueue+0x82>
     e28:	11 11       	cpse	r17, r1
     e2a:	11 50       	subi	r17, 0x01	; 1
     e2c:	1f 5f       	subi	r17, 0xFF	; 255
     e2e:	1e 8f       	std	Y+30, r17	; 0x1e
     e30:	80 e0       	ldi	r24, 0x00	; 0
     e32:	df 91       	pop	r29
     e34:	cf 91       	pop	r28
     e36:	1f 91       	pop	r17
     e38:	0f 91       	pop	r16
     e3a:	08 95       	ret

00000e3c <prvCopyDataFromQueue>:
     e3c:	fc 01       	movw	r30, r24
     e3e:	40 a1       	ldd	r20, Z+32	; 0x20
     e40:	44 23       	and	r20, r20
     e42:	a9 f0       	breq	.+42     	; 0xe6e <prvCopyDataFromQueue+0x32>
     e44:	50 e0       	ldi	r21, 0x00	; 0
     e46:	26 81       	ldd	r18, Z+6	; 0x06
     e48:	37 81       	ldd	r19, Z+7	; 0x07
     e4a:	24 0f       	add	r18, r20
     e4c:	35 1f       	adc	r19, r21
     e4e:	26 83       	std	Z+6, r18	; 0x06
     e50:	37 83       	std	Z+7, r19	; 0x07
     e52:	82 81       	ldd	r24, Z+2	; 0x02
     e54:	93 81       	ldd	r25, Z+3	; 0x03
     e56:	28 17       	cp	r18, r24
     e58:	39 07       	cpc	r19, r25
     e5a:	20 f0       	brcs	.+8      	; 0xe64 <prvCopyDataFromQueue+0x28>
     e5c:	80 81       	ld	r24, Z
     e5e:	91 81       	ldd	r25, Z+1	; 0x01
     e60:	86 83       	std	Z+6, r24	; 0x06
     e62:	97 83       	std	Z+7, r25	; 0x07
     e64:	cb 01       	movw	r24, r22
     e66:	66 81       	ldd	r22, Z+6	; 0x06
     e68:	77 81       	ldd	r23, Z+7	; 0x07
     e6a:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <memcpy>
     e6e:	08 95       	ret

00000e70 <prvUnlockQueue>:
     e70:	ef 92       	push	r14
     e72:	ff 92       	push	r15
     e74:	0f 93       	push	r16
     e76:	1f 93       	push	r17
     e78:	cf 93       	push	r28
     e7a:	8c 01       	movw	r16, r24
     e7c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e80:	ff 93       	push	r31
     e82:	f8 7f       	andi	r31, 0xF8	; 248
     e84:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e88:	fc 01       	movw	r30, r24
     e8a:	c2 a1       	ldd	r28, Z+34	; 0x22
     e8c:	1c 16       	cp	r1, r28
     e8e:	ac f4       	brge	.+42     	; 0xeba <prvUnlockQueue+0x4a>
     e90:	83 89       	ldd	r24, Z+19	; 0x13
     e92:	81 11       	cpse	r24, r1
     e94:	06 c0       	rjmp	.+12     	; 0xea2 <prvUnlockQueue+0x32>
     e96:	11 c0       	rjmp	.+34     	; 0xeba <prvUnlockQueue+0x4a>
     e98:	f8 01       	movw	r30, r16
     e9a:	83 89       	ldd	r24, Z+19	; 0x13
     e9c:	81 11       	cpse	r24, r1
     e9e:	05 c0       	rjmp	.+10     	; 0xeaa <prvUnlockQueue+0x3a>
     ea0:	0c c0       	rjmp	.+24     	; 0xeba <prvUnlockQueue+0x4a>
     ea2:	78 01       	movw	r14, r16
     ea4:	f3 e1       	ldi	r31, 0x13	; 19
     ea6:	ef 0e       	add	r14, r31
     ea8:	f1 1c       	adc	r15, r1
     eaa:	c7 01       	movw	r24, r14
     eac:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
     eb0:	81 11       	cpse	r24, r1
     eb2:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vTaskMissedYield>
     eb6:	c1 50       	subi	r28, 0x01	; 1
     eb8:	79 f7       	brne	.-34     	; 0xe98 <prvUnlockQueue+0x28>
     eba:	8f ef       	ldi	r24, 0xFF	; 255
     ebc:	f8 01       	movw	r30, r16
     ebe:	82 a3       	std	Z+34, r24	; 0x22
     ec0:	ff 91       	pop	r31
     ec2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ec6:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     eca:	ff 93       	push	r31
     ecc:	f8 7f       	andi	r31, 0xF8	; 248
     ece:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ed2:	f8 01       	movw	r30, r16
     ed4:	c1 a1       	ldd	r28, Z+33	; 0x21
     ed6:	1c 16       	cp	r1, r28
     ed8:	ac f4       	brge	.+42     	; 0xf04 <prvUnlockQueue+0x94>
     eda:	80 85       	ldd	r24, Z+8	; 0x08
     edc:	81 11       	cpse	r24, r1
     ede:	06 c0       	rjmp	.+12     	; 0xeec <prvUnlockQueue+0x7c>
     ee0:	11 c0       	rjmp	.+34     	; 0xf04 <prvUnlockQueue+0x94>
     ee2:	f8 01       	movw	r30, r16
     ee4:	80 85       	ldd	r24, Z+8	; 0x08
     ee6:	81 11       	cpse	r24, r1
     ee8:	05 c0       	rjmp	.+10     	; 0xef4 <prvUnlockQueue+0x84>
     eea:	0c c0       	rjmp	.+24     	; 0xf04 <prvUnlockQueue+0x94>
     eec:	78 01       	movw	r14, r16
     eee:	f8 e0       	ldi	r31, 0x08	; 8
     ef0:	ef 0e       	add	r14, r31
     ef2:	f1 1c       	adc	r15, r1
     ef4:	c7 01       	movw	r24, r14
     ef6:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
     efa:	81 11       	cpse	r24, r1
     efc:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vTaskMissedYield>
     f00:	c1 50       	subi	r28, 0x01	; 1
     f02:	79 f7       	brne	.-34     	; 0xee2 <prvUnlockQueue+0x72>
     f04:	8f ef       	ldi	r24, 0xFF	; 255
     f06:	f8 01       	movw	r30, r16
     f08:	81 a3       	std	Z+33, r24	; 0x21
     f0a:	ff 91       	pop	r31
     f0c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f10:	cf 91       	pop	r28
     f12:	1f 91       	pop	r17
     f14:	0f 91       	pop	r16
     f16:	ff 90       	pop	r15
     f18:	ef 90       	pop	r14
     f1a:	08 95       	ret

00000f1c <xQueueGenericReset>:
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	ec 01       	movw	r28, r24
     f22:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f26:	ff 93       	push	r31
     f28:	f8 7f       	andi	r31, 0xF8	; 248
     f2a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f2e:	48 81       	ld	r20, Y
     f30:	59 81       	ldd	r21, Y+1	; 0x01
     f32:	28 a1       	ldd	r18, Y+32	; 0x20
     f34:	30 e0       	ldi	r19, 0x00	; 0
     f36:	7f 8d       	ldd	r23, Y+31	; 0x1f
     f38:	72 9f       	mul	r23, r18
     f3a:	c0 01       	movw	r24, r0
     f3c:	73 9f       	mul	r23, r19
     f3e:	90 0d       	add	r25, r0
     f40:	11 24       	eor	r1, r1
     f42:	fa 01       	movw	r30, r20
     f44:	e8 0f       	add	r30, r24
     f46:	f9 1f       	adc	r31, r25
     f48:	ea 83       	std	Y+2, r30	; 0x02
     f4a:	fb 83       	std	Y+3, r31	; 0x03
     f4c:	1e 8e       	std	Y+30, r1	; 0x1e
     f4e:	4c 83       	std	Y+4, r20	; 0x04
     f50:	5d 83       	std	Y+5, r21	; 0x05
     f52:	82 1b       	sub	r24, r18
     f54:	93 0b       	sbc	r25, r19
     f56:	84 0f       	add	r24, r20
     f58:	95 1f       	adc	r25, r21
     f5a:	8e 83       	std	Y+6, r24	; 0x06
     f5c:	9f 83       	std	Y+7, r25	; 0x07
     f5e:	8f ef       	ldi	r24, 0xFF	; 255
     f60:	89 a3       	std	Y+33, r24	; 0x21
     f62:	8a a3       	std	Y+34, r24	; 0x22
     f64:	61 11       	cpse	r22, r1
     f66:	0c c0       	rjmp	.+24     	; 0xf80 <xQueueGenericReset+0x64>
     f68:	88 85       	ldd	r24, Y+8	; 0x08
     f6a:	88 23       	and	r24, r24
     f6c:	89 f0       	breq	.+34     	; 0xf90 <xQueueGenericReset+0x74>
     f6e:	ce 01       	movw	r24, r28
     f70:	08 96       	adiw	r24, 0x08	; 8
     f72:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
     f76:	88 23       	and	r24, r24
     f78:	59 f0       	breq	.+22     	; 0xf90 <xQueueGenericReset+0x74>
     f7a:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
     f7e:	08 c0       	rjmp	.+16     	; 0xf90 <xQueueGenericReset+0x74>
     f80:	ce 01       	movw	r24, r28
     f82:	08 96       	adiw	r24, 0x08	; 8
     f84:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
     f88:	ce 01       	movw	r24, r28
     f8a:	43 96       	adiw	r24, 0x13	; 19
     f8c:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
     f90:	ff 91       	pop	r31
     f92:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f96:	81 e0       	ldi	r24, 0x01	; 1
     f98:	df 91       	pop	r29
     f9a:	cf 91       	pop	r28
     f9c:	08 95       	ret

00000f9e <xQueueGenericCreate>:
     f9e:	ff 92       	push	r15
     fa0:	0f 93       	push	r16
     fa2:	1f 93       	push	r17
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	08 2f       	mov	r16, r24
     faa:	16 2f       	mov	r17, r22
     fac:	f4 2e       	mov	r15, r20
     fae:	66 23       	and	r22, r22
     fb0:	c9 f0       	breq	.+50     	; 0xfe4 <xQueueGenericCreate+0x46>
     fb2:	86 9f       	mul	r24, r22
     fb4:	c0 01       	movw	r24, r0
     fb6:	11 24       	eor	r1, r1
     fb8:	85 96       	adiw	r24, 0x25	; 37
     fba:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
     fbe:	ec 01       	movw	r28, r24
     fc0:	00 97       	sbiw	r24, 0x00	; 0
     fc2:	49 f4       	brne	.+18     	; 0xfd6 <xQueueGenericCreate+0x38>
     fc4:	16 c0       	rjmp	.+44     	; 0xff2 <xQueueGenericCreate+0x54>
     fc6:	0f 8f       	std	Y+31, r16	; 0x1f
     fc8:	18 a3       	std	Y+32, r17	; 0x20
     fca:	61 e0       	ldi	r22, 0x01	; 1
     fcc:	ce 01       	movw	r24, r28
     fce:	0e 94 8e 07 	call	0xf1c	; 0xf1c <xQueueGenericReset>
     fd2:	fc a2       	std	Y+36, r15	; 0x24
     fd4:	0e c0       	rjmp	.+28     	; 0xff2 <xQueueGenericCreate+0x54>
     fd6:	85 96       	adiw	r24, 0x25	; 37
     fd8:	88 83       	st	Y, r24
     fda:	99 83       	std	Y+1, r25	; 0x01
     fdc:	f4 cf       	rjmp	.-24     	; 0xfc6 <xQueueGenericCreate+0x28>
     fde:	c8 83       	st	Y, r28
     fe0:	d9 83       	std	Y+1, r29	; 0x01
     fe2:	f1 cf       	rjmp	.-30     	; 0xfc6 <xQueueGenericCreate+0x28>
     fe4:	85 e2       	ldi	r24, 0x25	; 37
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
     fec:	ec 01       	movw	r28, r24
     fee:	89 2b       	or	r24, r25
     ff0:	b1 f7       	brne	.-20     	; 0xfde <xQueueGenericCreate+0x40>
     ff2:	ce 01       	movw	r24, r28
     ff4:	df 91       	pop	r29
     ff6:	cf 91       	pop	r28
     ff8:	1f 91       	pop	r17
     ffa:	0f 91       	pop	r16
     ffc:	ff 90       	pop	r15
     ffe:	08 95       	ret

00001000 <xQueueGenericSend>:
    1000:	af 92       	push	r10
    1002:	bf 92       	push	r11
    1004:	cf 92       	push	r12
    1006:	df 92       	push	r13
    1008:	ef 92       	push	r14
    100a:	ff 92       	push	r15
    100c:	0f 93       	push	r16
    100e:	1f 93       	push	r17
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	cd b7       	in	r28, 0x3d	; 61
    1016:	de b7       	in	r29, 0x3e	; 62
    1018:	29 97       	sbiw	r28, 0x09	; 9
    101a:	cd bf       	out	0x3d, r28	; 61
    101c:	de bf       	out	0x3e, r29	; 62
    101e:	7c 01       	movw	r14, r24
    1020:	5b 01       	movw	r10, r22
    1022:	2e 83       	std	Y+6, r18	; 0x06
    1024:	3f 83       	std	Y+7, r19	; 0x07
    1026:	48 87       	std	Y+8, r20	; 0x08
    1028:	59 87       	std	Y+9, r21	; 0x09
    102a:	10 e0       	ldi	r17, 0x00	; 0
    102c:	6c 01       	movw	r12, r24
    102e:	88 e0       	ldi	r24, 0x08	; 8
    1030:	c8 0e       	add	r12, r24
    1032:	d1 1c       	adc	r13, r1
    1034:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1038:	ff 93       	push	r31
    103a:	f8 7f       	andi	r31, 0xF8	; 248
    103c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1040:	f7 01       	movw	r30, r14
    1042:	96 8d       	ldd	r25, Z+30	; 0x1e
    1044:	87 8d       	ldd	r24, Z+31	; 0x1f
    1046:	98 17       	cp	r25, r24
    1048:	10 f0       	brcs	.+4      	; 0x104e <xQueueGenericSend+0x4e>
    104a:	02 30       	cpi	r16, 0x02	; 2
    104c:	d1 f4       	brne	.+52     	; 0x1082 <xQueueGenericSend+0x82>
    104e:	40 2f       	mov	r20, r16
    1050:	b5 01       	movw	r22, r10
    1052:	c7 01       	movw	r24, r14
    1054:	0e 94 d5 06 	call	0xdaa	; 0xdaa <prvCopyDataToQueue>
    1058:	f7 01       	movw	r30, r14
    105a:	93 89       	ldd	r25, Z+19	; 0x13
    105c:	99 23       	and	r25, r25
    105e:	49 f0       	breq	.+18     	; 0x1072 <xQueueGenericSend+0x72>
    1060:	c7 01       	movw	r24, r14
    1062:	43 96       	adiw	r24, 0x13	; 19
    1064:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
    1068:	88 23       	and	r24, r24
    106a:	31 f0       	breq	.+12     	; 0x1078 <xQueueGenericSend+0x78>
    106c:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1070:	03 c0       	rjmp	.+6      	; 0x1078 <xQueueGenericSend+0x78>
    1072:	81 11       	cpse	r24, r1
    1074:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1078:	ff 91       	pop	r31
    107a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	57 c0       	rjmp	.+174    	; 0x1130 <xQueueGenericSend+0x130>
    1082:	8e 81       	ldd	r24, Y+6	; 0x06
    1084:	9f 81       	ldd	r25, Y+7	; 0x07
    1086:	a8 85       	ldd	r26, Y+8	; 0x08
    1088:	b9 85       	ldd	r27, Y+9	; 0x09
    108a:	89 2b       	or	r24, r25
    108c:	8a 2b       	or	r24, r26
    108e:	8b 2b       	or	r24, r27
    1090:	29 f4       	brne	.+10     	; 0x109c <xQueueGenericSend+0x9c>
    1092:	ff 91       	pop	r31
    1094:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1098:	80 e0       	ldi	r24, 0x00	; 0
    109a:	4a c0       	rjmp	.+148    	; 0x1130 <xQueueGenericSend+0x130>
    109c:	11 11       	cpse	r17, r1
    109e:	05 c0       	rjmp	.+10     	; 0x10aa <xQueueGenericSend+0xaa>
    10a0:	ce 01       	movw	r24, r28
    10a2:	01 96       	adiw	r24, 0x01	; 1
    10a4:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskInternalSetTimeOutState>
    10a8:	11 e0       	ldi	r17, 0x01	; 1
    10aa:	ff 91       	pop	r31
    10ac:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10b0:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    10b4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10b8:	ff 93       	push	r31
    10ba:	f8 7f       	andi	r31, 0xF8	; 248
    10bc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10c0:	f7 01       	movw	r30, r14
    10c2:	81 a1       	ldd	r24, Z+33	; 0x21
    10c4:	8f 3f       	cpi	r24, 0xFF	; 255
    10c6:	09 f4       	brne	.+2      	; 0x10ca <xQueueGenericSend+0xca>
    10c8:	11 a2       	std	Z+33, r1	; 0x21
    10ca:	f7 01       	movw	r30, r14
    10cc:	82 a1       	ldd	r24, Z+34	; 0x22
    10ce:	8f 3f       	cpi	r24, 0xFF	; 255
    10d0:	09 f4       	brne	.+2      	; 0x10d4 <xQueueGenericSend+0xd4>
    10d2:	12 a2       	std	Z+34, r1	; 0x22
    10d4:	ff 91       	pop	r31
    10d6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10da:	be 01       	movw	r22, r28
    10dc:	6a 5f       	subi	r22, 0xFA	; 250
    10de:	7f 4f       	sbci	r23, 0xFF	; 255
    10e0:	ce 01       	movw	r24, r28
    10e2:	01 96       	adiw	r24, 0x01	; 1
    10e4:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <xTaskCheckForTimeOut>
    10e8:	81 11       	cpse	r24, r1
    10ea:	1c c0       	rjmp	.+56     	; 0x1124 <xQueueGenericSend+0x124>
    10ec:	c7 01       	movw	r24, r14
    10ee:	0e 94 c2 06 	call	0xd84	; 0xd84 <prvIsQueueFull>
    10f2:	88 23       	and	r24, r24
    10f4:	89 f0       	breq	.+34     	; 0x1118 <xQueueGenericSend+0x118>
    10f6:	4e 81       	ldd	r20, Y+6	; 0x06
    10f8:	5f 81       	ldd	r21, Y+7	; 0x07
    10fa:	68 85       	ldd	r22, Y+8	; 0x08
    10fc:	79 85       	ldd	r23, Y+9	; 0x09
    10fe:	c6 01       	movw	r24, r12
    1100:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <vTaskPlaceOnEventList>
    1104:	c7 01       	movw	r24, r14
    1106:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    110a:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    110e:	81 11       	cpse	r24, r1
    1110:	91 cf       	rjmp	.-222    	; 0x1034 <xQueueGenericSend+0x34>
    1112:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1116:	8e cf       	rjmp	.-228    	; 0x1034 <xQueueGenericSend+0x34>
    1118:	c7 01       	movw	r24, r14
    111a:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    111e:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    1122:	88 cf       	rjmp	.-240    	; 0x1034 <xQueueGenericSend+0x34>
    1124:	c7 01       	movw	r24, r14
    1126:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    112a:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    112e:	80 e0       	ldi	r24, 0x00	; 0
    1130:	29 96       	adiw	r28, 0x09	; 9
    1132:	cd bf       	out	0x3d, r28	; 61
    1134:	de bf       	out	0x3e, r29	; 62
    1136:	df 91       	pop	r29
    1138:	cf 91       	pop	r28
    113a:	1f 91       	pop	r17
    113c:	0f 91       	pop	r16
    113e:	ff 90       	pop	r15
    1140:	ef 90       	pop	r14
    1142:	df 90       	pop	r13
    1144:	cf 90       	pop	r12
    1146:	bf 90       	pop	r11
    1148:	af 90       	pop	r10
    114a:	08 95       	ret

0000114c <xQueueGenericSendFromISR>:
    114c:	af 92       	push	r10
    114e:	bf 92       	push	r11
    1150:	cf 92       	push	r12
    1152:	df 92       	push	r13
    1154:	ff 92       	push	r15
    1156:	0f 93       	push	r16
    1158:	1f 93       	push	r17
    115a:	cf 93       	push	r28
    115c:	df 93       	push	r29
    115e:	ec 01       	movw	r28, r24
    1160:	6b 01       	movw	r12, r22
    1162:	5a 01       	movw	r10, r20
    1164:	02 2f       	mov	r16, r18
    1166:	0e 94 06 05 	call	0xa0c	; 0xa0c <_portSetInterruptMaskFromIsr>
    116a:	f8 2e       	mov	r15, r24
    116c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    116e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1170:	98 17       	cp	r25, r24
    1172:	10 f0       	brcs	.+4      	; 0x1178 <xQueueGenericSendFromISR+0x2c>
    1174:	02 30       	cpi	r16, 0x02	; 2
    1176:	e1 f4       	brne	.+56     	; 0x11b0 <xQueueGenericSendFromISR+0x64>
    1178:	1a a1       	ldd	r17, Y+34	; 0x22
    117a:	40 2f       	mov	r20, r16
    117c:	b6 01       	movw	r22, r12
    117e:	ce 01       	movw	r24, r28
    1180:	0e 94 d5 06 	call	0xdaa	; 0xdaa <prvCopyDataToQueue>
    1184:	1f 3f       	cpi	r17, 0xFF	; 255
    1186:	81 f4       	brne	.+32     	; 0x11a8 <xQueueGenericSendFromISR+0x5c>
    1188:	8b 89       	ldd	r24, Y+19	; 0x13
    118a:	88 23       	and	r24, r24
    118c:	99 f0       	breq	.+38     	; 0x11b4 <xQueueGenericSendFromISR+0x68>
    118e:	ce 01       	movw	r24, r28
    1190:	43 96       	adiw	r24, 0x13	; 19
    1192:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
    1196:	88 23       	and	r24, r24
    1198:	79 f0       	breq	.+30     	; 0x11b8 <xQueueGenericSendFromISR+0x6c>
    119a:	a1 14       	cp	r10, r1
    119c:	b1 04       	cpc	r11, r1
    119e:	71 f0       	breq	.+28     	; 0x11bc <xQueueGenericSendFromISR+0x70>
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	f5 01       	movw	r30, r10
    11a4:	80 83       	st	Z, r24
    11a6:	0b c0       	rjmp	.+22     	; 0x11be <xQueueGenericSendFromISR+0x72>
    11a8:	1f 5f       	subi	r17, 0xFF	; 255
    11aa:	1a a3       	std	Y+34, r17	; 0x22
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	07 c0       	rjmp	.+14     	; 0x11be <xQueueGenericSendFromISR+0x72>
    11b0:	80 e0       	ldi	r24, 0x00	; 0
    11b2:	05 c0       	rjmp	.+10     	; 0x11be <xQueueGenericSendFromISR+0x72>
    11b4:	81 e0       	ldi	r24, 0x01	; 1
    11b6:	03 c0       	rjmp	.+6      	; 0x11be <xQueueGenericSendFromISR+0x72>
    11b8:	81 e0       	ldi	r24, 0x01	; 1
    11ba:	01 c0       	rjmp	.+2      	; 0x11be <xQueueGenericSendFromISR+0x72>
    11bc:	81 e0       	ldi	r24, 0x01	; 1
    11be:	f0 92 a2 00 	sts	0x00A2, r15	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	1f 91       	pop	r17
    11c8:	0f 91       	pop	r16
    11ca:	ff 90       	pop	r15
    11cc:	df 90       	pop	r13
    11ce:	cf 90       	pop	r12
    11d0:	bf 90       	pop	r11
    11d2:	af 90       	pop	r10
    11d4:	08 95       	ret

000011d6 <xQueueReceive>:
    11d6:	af 92       	push	r10
    11d8:	bf 92       	push	r11
    11da:	cf 92       	push	r12
    11dc:	df 92       	push	r13
    11de:	ef 92       	push	r14
    11e0:	ff 92       	push	r15
    11e2:	0f 93       	push	r16
    11e4:	1f 93       	push	r17
    11e6:	cf 93       	push	r28
    11e8:	df 93       	push	r29
    11ea:	cd b7       	in	r28, 0x3d	; 61
    11ec:	de b7       	in	r29, 0x3e	; 62
    11ee:	29 97       	sbiw	r28, 0x09	; 9
    11f0:	cd bf       	out	0x3d, r28	; 61
    11f2:	de bf       	out	0x3e, r29	; 62
    11f4:	8c 01       	movw	r16, r24
    11f6:	5b 01       	movw	r10, r22
    11f8:	2e 83       	std	Y+6, r18	; 0x06
    11fa:	3f 83       	std	Y+7, r19	; 0x07
    11fc:	48 87       	std	Y+8, r20	; 0x08
    11fe:	59 87       	std	Y+9, r21	; 0x09
    1200:	e1 2c       	mov	r14, r1
    1202:	6c 01       	movw	r12, r24
    1204:	83 e1       	ldi	r24, 0x13	; 19
    1206:	c8 0e       	add	r12, r24
    1208:	d1 1c       	adc	r13, r1
    120a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    120e:	ff 93       	push	r31
    1210:	f8 7f       	andi	r31, 0xF8	; 248
    1212:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1216:	f8 01       	movw	r30, r16
    1218:	f6 8c       	ldd	r15, Z+30	; 0x1e
    121a:	ff 20       	and	r15, r15
    121c:	b1 f0       	breq	.+44     	; 0x124a <xQueueReceive+0x74>
    121e:	b5 01       	movw	r22, r10
    1220:	c8 01       	movw	r24, r16
    1222:	0e 94 1e 07 	call	0xe3c	; 0xe3c <prvCopyDataFromQueue>
    1226:	fa 94       	dec	r15
    1228:	f8 01       	movw	r30, r16
    122a:	f6 8e       	std	Z+30, r15	; 0x1e
    122c:	80 85       	ldd	r24, Z+8	; 0x08
    122e:	88 23       	and	r24, r24
    1230:	39 f0       	breq	.+14     	; 0x1240 <xQueueReceive+0x6a>
    1232:	c8 01       	movw	r24, r16
    1234:	08 96       	adiw	r24, 0x08	; 8
    1236:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
    123a:	81 11       	cpse	r24, r1
    123c:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1240:	ff 91       	pop	r31
    1242:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	5e c0       	rjmp	.+188    	; 0x1306 <xQueueReceive+0x130>
    124a:	8e 81       	ldd	r24, Y+6	; 0x06
    124c:	9f 81       	ldd	r25, Y+7	; 0x07
    124e:	a8 85       	ldd	r26, Y+8	; 0x08
    1250:	b9 85       	ldd	r27, Y+9	; 0x09
    1252:	89 2b       	or	r24, r25
    1254:	8a 2b       	or	r24, r26
    1256:	8b 2b       	or	r24, r27
    1258:	29 f4       	brne	.+10     	; 0x1264 <xQueueReceive+0x8e>
    125a:	ff 91       	pop	r31
    125c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1260:	80 e0       	ldi	r24, 0x00	; 0
    1262:	51 c0       	rjmp	.+162    	; 0x1306 <xQueueReceive+0x130>
    1264:	e1 10       	cpse	r14, r1
    1266:	06 c0       	rjmp	.+12     	; 0x1274 <xQueueReceive+0x9e>
    1268:	ce 01       	movw	r24, r28
    126a:	01 96       	adiw	r24, 0x01	; 1
    126c:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskInternalSetTimeOutState>
    1270:	ee 24       	eor	r14, r14
    1272:	e3 94       	inc	r14
    1274:	ff 91       	pop	r31
    1276:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    127a:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    127e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1282:	ff 93       	push	r31
    1284:	f8 7f       	andi	r31, 0xF8	; 248
    1286:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    128a:	f8 01       	movw	r30, r16
    128c:	81 a1       	ldd	r24, Z+33	; 0x21
    128e:	8f 3f       	cpi	r24, 0xFF	; 255
    1290:	09 f4       	brne	.+2      	; 0x1294 <xQueueReceive+0xbe>
    1292:	11 a2       	std	Z+33, r1	; 0x21
    1294:	f8 01       	movw	r30, r16
    1296:	82 a1       	ldd	r24, Z+34	; 0x22
    1298:	8f 3f       	cpi	r24, 0xFF	; 255
    129a:	09 f4       	brne	.+2      	; 0x129e <xQueueReceive+0xc8>
    129c:	12 a2       	std	Z+34, r1	; 0x22
    129e:	ff 91       	pop	r31
    12a0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12a4:	be 01       	movw	r22, r28
    12a6:	6a 5f       	subi	r22, 0xFA	; 250
    12a8:	7f 4f       	sbci	r23, 0xFF	; 255
    12aa:	ce 01       	movw	r24, r28
    12ac:	01 96       	adiw	r24, 0x01	; 1
    12ae:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <xTaskCheckForTimeOut>
    12b2:	81 11       	cpse	r24, r1
    12b4:	1c c0       	rjmp	.+56     	; 0x12ee <xQueueReceive+0x118>
    12b6:	c8 01       	movw	r24, r16
    12b8:	0e 94 b3 06 	call	0xd66	; 0xd66 <prvIsQueueEmpty>
    12bc:	88 23       	and	r24, r24
    12be:	89 f0       	breq	.+34     	; 0x12e2 <xQueueReceive+0x10c>
    12c0:	4e 81       	ldd	r20, Y+6	; 0x06
    12c2:	5f 81       	ldd	r21, Y+7	; 0x07
    12c4:	68 85       	ldd	r22, Y+8	; 0x08
    12c6:	79 85       	ldd	r23, Y+9	; 0x09
    12c8:	c6 01       	movw	r24, r12
    12ca:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <vTaskPlaceOnEventList>
    12ce:	c8 01       	movw	r24, r16
    12d0:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    12d4:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    12d8:	81 11       	cpse	r24, r1
    12da:	97 cf       	rjmp	.-210    	; 0x120a <xQueueReceive+0x34>
    12dc:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    12e0:	94 cf       	rjmp	.-216    	; 0x120a <xQueueReceive+0x34>
    12e2:	c8 01       	movw	r24, r16
    12e4:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    12e8:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    12ec:	8e cf       	rjmp	.-228    	; 0x120a <xQueueReceive+0x34>
    12ee:	c8 01       	movw	r24, r16
    12f0:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    12f4:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    12f8:	c8 01       	movw	r24, r16
    12fa:	0e 94 b3 06 	call	0xd66	; 0xd66 <prvIsQueueEmpty>
    12fe:	88 23       	and	r24, r24
    1300:	09 f4       	brne	.+2      	; 0x1304 <xQueueReceive+0x12e>
    1302:	83 cf       	rjmp	.-250    	; 0x120a <xQueueReceive+0x34>
    1304:	80 e0       	ldi	r24, 0x00	; 0
    1306:	29 96       	adiw	r28, 0x09	; 9
    1308:	cd bf       	out	0x3d, r28	; 61
    130a:	de bf       	out	0x3e, r29	; 62
    130c:	df 91       	pop	r29
    130e:	cf 91       	pop	r28
    1310:	1f 91       	pop	r17
    1312:	0f 91       	pop	r16
    1314:	ff 90       	pop	r15
    1316:	ef 90       	pop	r14
    1318:	df 90       	pop	r13
    131a:	cf 90       	pop	r12
    131c:	bf 90       	pop	r11
    131e:	af 90       	pop	r10
    1320:	08 95       	ret

00001322 <uxQueueMessagesWaiting>:
    1322:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1326:	ff 93       	push	r31
    1328:	f8 7f       	andi	r31, 0xF8	; 248
    132a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    132e:	fc 01       	movw	r30, r24
    1330:	86 8d       	ldd	r24, Z+30	; 0x1e
    1332:	ff 91       	pop	r31
    1334:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1338:	08 95       	ret

0000133a <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1340:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1344:	ff 93       	push	r31
    1346:	f8 7f       	andi	r31, 0xF8	; 248
    1348:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    134c:	89 a1       	ldd	r24, Y+33	; 0x21
    134e:	8f 3f       	cpi	r24, 0xFF	; 255
    1350:	09 f4       	brne	.+2      	; 0x1354 <vQueueWaitForMessageRestricted+0x1a>
    1352:	19 a2       	std	Y+33, r1	; 0x21
    1354:	8a a1       	ldd	r24, Y+34	; 0x22
    1356:	8f 3f       	cpi	r24, 0xFF	; 255
    1358:	09 f4       	brne	.+2      	; 0x135c <vQueueWaitForMessageRestricted+0x22>
    135a:	1a a2       	std	Y+34, r1	; 0x22
    135c:	ff 91       	pop	r31
    135e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1362:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1364:	81 11       	cpse	r24, r1
    1366:	04 c0       	rjmp	.+8      	; 0x1370 <vQueueWaitForMessageRestricted+0x36>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1368:	ce 01       	movw	r24, r28
    136a:	43 96       	adiw	r24, 0x13	; 19
    136c:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1370:	ce 01       	movw	r24, r28
    1372:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
	}
    1376:	df 91       	pop	r29
    1378:	cf 91       	pop	r28
    137a:	08 95       	ret

0000137c <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
    137c:	e0 91 74 2c 	lds	r30, 0x2C74	; 0x802c74 <pxDelayedTaskList>
    1380:	f0 91 75 2c 	lds	r31, 0x2C75	; 0x802c75 <pxDelayedTaskList+0x1>
    1384:	80 81       	ld	r24, Z
    1386:	81 11       	cpse	r24, r1
    1388:	0c c0       	rjmp	.+24     	; 0x13a2 <prvResetNextTaskUnblockTime+0x26>
    138a:	8f ef       	ldi	r24, 0xFF	; 255
    138c:	9f ef       	ldi	r25, 0xFF	; 255
    138e:	dc 01       	movw	r26, r24
    1390:	80 93 4d 2c 	sts	0x2C4D, r24	; 0x802c4d <xNextTaskUnblockTime>
    1394:	90 93 4e 2c 	sts	0x2C4E, r25	; 0x802c4e <xNextTaskUnblockTime+0x1>
    1398:	a0 93 4f 2c 	sts	0x2C4F, r26	; 0x802c4f <xNextTaskUnblockTime+0x2>
    139c:	b0 93 50 2c 	sts	0x2C50, r27	; 0x802c50 <xNextTaskUnblockTime+0x3>
    13a0:	08 95       	ret
    13a2:	e0 91 74 2c 	lds	r30, 0x2C74	; 0x802c74 <pxDelayedTaskList>
    13a6:	f0 91 75 2c 	lds	r31, 0x2C75	; 0x802c75 <pxDelayedTaskList+0x1>
    13aa:	07 80       	ldd	r0, Z+7	; 0x07
    13ac:	f0 85       	ldd	r31, Z+8	; 0x08
    13ae:	e0 2d       	mov	r30, r0
    13b0:	00 84       	ldd	r0, Z+8	; 0x08
    13b2:	f1 85       	ldd	r31, Z+9	; 0x09
    13b4:	e0 2d       	mov	r30, r0
    13b6:	82 81       	ldd	r24, Z+2	; 0x02
    13b8:	93 81       	ldd	r25, Z+3	; 0x03
    13ba:	a4 81       	ldd	r26, Z+4	; 0x04
    13bc:	b5 81       	ldd	r27, Z+5	; 0x05
    13be:	80 93 4d 2c 	sts	0x2C4D, r24	; 0x802c4d <xNextTaskUnblockTime>
    13c2:	90 93 4e 2c 	sts	0x2C4E, r25	; 0x802c4e <xNextTaskUnblockTime+0x1>
    13c6:	a0 93 4f 2c 	sts	0x2C4F, r26	; 0x802c4f <xNextTaskUnblockTime+0x2>
    13ca:	b0 93 50 2c 	sts	0x2C50, r27	; 0x802c50 <xNextTaskUnblockTime+0x3>
    13ce:	08 95       	ret

000013d0 <prvAddCurrentTaskToDelayedList>:
    13d0:	8f 92       	push	r8
    13d2:	9f 92       	push	r9
    13d4:	af 92       	push	r10
    13d6:	bf 92       	push	r11
    13d8:	cf 92       	push	r12
    13da:	df 92       	push	r13
    13dc:	ef 92       	push	r14
    13de:	ff 92       	push	r15
    13e0:	cf 93       	push	r28
    13e2:	6b 01       	movw	r12, r22
    13e4:	7c 01       	movw	r14, r24
    13e6:	c4 2f       	mov	r28, r20
    13e8:	80 90 57 2c 	lds	r8, 0x2C57	; 0x802c57 <xTickCount>
    13ec:	90 90 58 2c 	lds	r9, 0x2C58	; 0x802c58 <xTickCount+0x1>
    13f0:	a0 90 59 2c 	lds	r10, 0x2C59	; 0x802c59 <xTickCount+0x2>
    13f4:	b0 90 5a 2c 	lds	r11, 0x2C5A	; 0x802c5a <xTickCount+0x3>
    13f8:	80 91 b8 2c 	lds	r24, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    13fc:	90 91 b9 2c 	lds	r25, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1400:	02 96       	adiw	r24, 0x02	; 2
    1402:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1406:	8f ef       	ldi	r24, 0xFF	; 255
    1408:	c8 16       	cp	r12, r24
    140a:	d8 06       	cpc	r13, r24
    140c:	e8 06       	cpc	r14, r24
    140e:	f8 06       	cpc	r15, r24
    1410:	69 f4       	brne	.+26     	; 0x142c <prvAddCurrentTaskToDelayedList+0x5c>
    1412:	cc 23       	and	r28, r28
    1414:	59 f0       	breq	.+22     	; 0x142c <prvAddCurrentTaskToDelayedList+0x5c>
    1416:	60 91 b8 2c 	lds	r22, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    141a:	70 91 b9 2c 	lds	r23, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    141e:	6e 5f       	subi	r22, 0xFE	; 254
    1420:	7f 4f       	sbci	r23, 0xFF	; 255
    1422:	8c e5       	ldi	r24, 0x5C	; 92
    1424:	9c e2       	ldi	r25, 0x2C	; 44
    1426:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    142a:	3f c0       	rjmp	.+126    	; 0x14aa <prvAddCurrentTaskToDelayedList+0xda>
    142c:	c8 0c       	add	r12, r8
    142e:	d9 1c       	adc	r13, r9
    1430:	ea 1c       	adc	r14, r10
    1432:	fb 1c       	adc	r15, r11
    1434:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1438:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    143c:	c2 82       	std	Z+2, r12	; 0x02
    143e:	d3 82       	std	Z+3, r13	; 0x03
    1440:	e4 82       	std	Z+4, r14	; 0x04
    1442:	f5 82       	std	Z+5, r15	; 0x05
    1444:	c8 14       	cp	r12, r8
    1446:	d9 04       	cpc	r13, r9
    1448:	ea 04       	cpc	r14, r10
    144a:	fb 04       	cpc	r15, r11
    144c:	68 f4       	brcc	.+26     	; 0x1468 <prvAddCurrentTaskToDelayedList+0x98>
    144e:	60 91 b8 2c 	lds	r22, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1452:	70 91 b9 2c 	lds	r23, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1456:	80 91 72 2c 	lds	r24, 0x2C72	; 0x802c72 <pxOverflowDelayedTaskList>
    145a:	90 91 73 2c 	lds	r25, 0x2C73	; 0x802c73 <pxOverflowDelayedTaskList+0x1>
    145e:	6e 5f       	subi	r22, 0xFE	; 254
    1460:	7f 4f       	sbci	r23, 0xFF	; 255
    1462:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1466:	21 c0       	rjmp	.+66     	; 0x14aa <prvAddCurrentTaskToDelayedList+0xda>
    1468:	60 91 b8 2c 	lds	r22, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    146c:	70 91 b9 2c 	lds	r23, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1470:	80 91 74 2c 	lds	r24, 0x2C74	; 0x802c74 <pxDelayedTaskList>
    1474:	90 91 75 2c 	lds	r25, 0x2C75	; 0x802c75 <pxDelayedTaskList+0x1>
    1478:	6e 5f       	subi	r22, 0xFE	; 254
    147a:	7f 4f       	sbci	r23, 0xFF	; 255
    147c:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1480:	80 91 4d 2c 	lds	r24, 0x2C4D	; 0x802c4d <xNextTaskUnblockTime>
    1484:	90 91 4e 2c 	lds	r25, 0x2C4E	; 0x802c4e <xNextTaskUnblockTime+0x1>
    1488:	a0 91 4f 2c 	lds	r26, 0x2C4F	; 0x802c4f <xNextTaskUnblockTime+0x2>
    148c:	b0 91 50 2c 	lds	r27, 0x2C50	; 0x802c50 <xNextTaskUnblockTime+0x3>
    1490:	c8 16       	cp	r12, r24
    1492:	d9 06       	cpc	r13, r25
    1494:	ea 06       	cpc	r14, r26
    1496:	fb 06       	cpc	r15, r27
    1498:	40 f4       	brcc	.+16     	; 0x14aa <prvAddCurrentTaskToDelayedList+0xda>
    149a:	c0 92 4d 2c 	sts	0x2C4D, r12	; 0x802c4d <xNextTaskUnblockTime>
    149e:	d0 92 4e 2c 	sts	0x2C4E, r13	; 0x802c4e <xNextTaskUnblockTime+0x1>
    14a2:	e0 92 4f 2c 	sts	0x2C4F, r14	; 0x802c4f <xNextTaskUnblockTime+0x2>
    14a6:	f0 92 50 2c 	sts	0x2C50, r15	; 0x802c50 <xNextTaskUnblockTime+0x3>
    14aa:	cf 91       	pop	r28
    14ac:	ff 90       	pop	r15
    14ae:	ef 90       	pop	r14
    14b0:	df 90       	pop	r13
    14b2:	cf 90       	pop	r12
    14b4:	bf 90       	pop	r11
    14b6:	af 90       	pop	r10
    14b8:	9f 90       	pop	r9
    14ba:	8f 90       	pop	r8
    14bc:	08 95       	ret

000014be <prvIdleTask>:
    14be:	cc e8       	ldi	r28, 0x8C	; 140
    14c0:	dc e2       	ldi	r29, 0x2C	; 44
    14c2:	88 81       	ld	r24, Y
    14c4:	82 30       	cpi	r24, 0x02	; 2
    14c6:	10 f0       	brcs	.+4      	; 0x14cc <prvIdleTask+0xe>
    14c8:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    14cc:	0e 94 0d 14 	call	0x281a	; 0x281a <vApplicationIdleHook>
    14d0:	f8 cf       	rjmp	.-16     	; 0x14c2 <prvIdleTask+0x4>

000014d2 <xTaskCreate>:
    14d2:	4f 92       	push	r4
    14d4:	5f 92       	push	r5
    14d6:	6f 92       	push	r6
    14d8:	7f 92       	push	r7
    14da:	8f 92       	push	r8
    14dc:	9f 92       	push	r9
    14de:	af 92       	push	r10
    14e0:	bf 92       	push	r11
    14e2:	cf 92       	push	r12
    14e4:	df 92       	push	r13
    14e6:	ef 92       	push	r14
    14e8:	ff 92       	push	r15
    14ea:	0f 93       	push	r16
    14ec:	cf 93       	push	r28
    14ee:	df 93       	push	r29
    14f0:	4c 01       	movw	r8, r24
    14f2:	6b 01       	movw	r12, r22
    14f4:	5a 01       	movw	r10, r20
    14f6:	29 01       	movw	r4, r18
    14f8:	ca 01       	movw	r24, r20
    14fa:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
    14fe:	3c 01       	movw	r6, r24
    1500:	89 2b       	or	r24, r25
    1502:	09 f4       	brne	.+2      	; 0x1506 <xTaskCreate+0x34>
    1504:	ea c0       	rjmp	.+468    	; 0x16da <xTaskCreate+0x208>
    1506:	8c e2       	ldi	r24, 0x2C	; 44
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
    150e:	ec 01       	movw	r28, r24
    1510:	89 2b       	or	r24, r25
    1512:	b1 f0       	breq	.+44     	; 0x1540 <xTaskCreate+0x6e>
    1514:	6b 8e       	std	Y+27, r6	; 0x1b
    1516:	7c 8e       	std	Y+28, r7	; 0x1c
    1518:	a5 01       	movw	r20, r10
    151a:	65 ea       	ldi	r22, 0xA5	; 165
    151c:	70 e0       	ldi	r23, 0x00	; 0
    151e:	c3 01       	movw	r24, r6
    1520:	0e 94 f8 1d 	call	0x3bf0	; 0x3bf0 <memset>
    1524:	21 e0       	ldi	r18, 0x01	; 1
    1526:	a2 1a       	sub	r10, r18
    1528:	b1 08       	sbc	r11, r1
    152a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    152c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    152e:	a8 0e       	add	r10, r24
    1530:	b9 1e       	adc	r11, r25
    1532:	d6 01       	movw	r26, r12
    1534:	8c 91       	ld	r24, X
    1536:	8d 8f       	std	Y+29, r24	; 0x1d
    1538:	8c 91       	ld	r24, X
    153a:	81 11       	cpse	r24, r1
    153c:	05 c0       	rjmp	.+10     	; 0x1548 <xTaskCreate+0x76>
    153e:	18 c0       	rjmp	.+48     	; 0x1570 <xTaskCreate+0x9e>
    1540:	c3 01       	movw	r24, r6
    1542:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortFree>
    1546:	c9 c0       	rjmp	.+402    	; 0x16da <xTaskCreate+0x208>
    1548:	ae 01       	movw	r20, r28
    154a:	42 5e       	subi	r20, 0xE2	; 226
    154c:	5f 4f       	sbci	r21, 0xFF	; 255
    154e:	f6 01       	movw	r30, r12
    1550:	31 96       	adiw	r30, 0x01	; 1
    1552:	b8 e0       	ldi	r27, 0x08	; 8
    1554:	cb 0e       	add	r12, r27
    1556:	d1 1c       	adc	r13, r1
    1558:	cf 01       	movw	r24, r30
    155a:	21 91       	ld	r18, Z+
    155c:	da 01       	movw	r26, r20
    155e:	2d 93       	st	X+, r18
    1560:	ad 01       	movw	r20, r26
    1562:	dc 01       	movw	r26, r24
    1564:	8c 91       	ld	r24, X
    1566:	88 23       	and	r24, r24
    1568:	19 f0       	breq	.+6      	; 0x1570 <xTaskCreate+0x9e>
    156a:	ec 15       	cp	r30, r12
    156c:	fd 05       	cpc	r31, r13
    156e:	a1 f7       	brne	.-24     	; 0x1558 <xTaskCreate+0x86>
    1570:	1c a2       	std	Y+36, r1	; 0x24
    1572:	04 30       	cpi	r16, 0x04	; 4
    1574:	08 f0       	brcs	.+2      	; 0x1578 <xTaskCreate+0xa6>
    1576:	03 e0       	ldi	r16, 0x03	; 3
    1578:	0a 8f       	std	Y+26, r16	; 0x1a
    157a:	6e 01       	movw	r12, r28
    157c:	b2 e0       	ldi	r27, 0x02	; 2
    157e:	cb 0e       	add	r12, r27
    1580:	d1 1c       	adc	r13, r1
    1582:	c6 01       	movw	r24, r12
    1584:	0e 94 7d 04 	call	0x8fa	; 0x8fa <vListInitialiseItem>
    1588:	ce 01       	movw	r24, r28
    158a:	0e 96       	adiw	r24, 0x0e	; 14
    158c:	0e 94 7d 04 	call	0x8fa	; 0x8fa <vListInitialiseItem>
    1590:	ca 87       	std	Y+10, r28	; 0x0a
    1592:	db 87       	std	Y+11, r29	; 0x0b
    1594:	84 e0       	ldi	r24, 0x04	; 4
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	a0 e0       	ldi	r26, 0x00	; 0
    159a:	b0 e0       	ldi	r27, 0x00	; 0
    159c:	80 1b       	sub	r24, r16
    159e:	91 09       	sbc	r25, r1
    15a0:	a1 09       	sbc	r26, r1
    15a2:	b1 09       	sbc	r27, r1
    15a4:	8e 87       	std	Y+14, r24	; 0x0e
    15a6:	9f 87       	std	Y+15, r25	; 0x0f
    15a8:	a8 8b       	std	Y+16, r26	; 0x10
    15aa:	b9 8b       	std	Y+17, r27	; 0x11
    15ac:	ce 8b       	std	Y+22, r28	; 0x16
    15ae:	df 8b       	std	Y+23, r29	; 0x17
    15b0:	1f a2       	std	Y+39, r1	; 0x27
    15b2:	18 a6       	std	Y+40, r1	; 0x28
    15b4:	19 a6       	std	Y+41, r1	; 0x29
    15b6:	1a a6       	std	Y+42, r1	; 0x2a
    15b8:	1b a6       	std	Y+43, r1	; 0x2b
    15ba:	a2 01       	movw	r20, r4
    15bc:	b4 01       	movw	r22, r8
    15be:	c5 01       	movw	r24, r10
    15c0:	0e 94 0d 05 	call	0xa1a	; 0xa1a <pxPortInitialiseStack>
    15c4:	88 83       	st	Y, r24
    15c6:	99 83       	std	Y+1, r25	; 0x01
    15c8:	e1 14       	cp	r14, r1
    15ca:	f1 04       	cpc	r15, r1
    15cc:	19 f0       	breq	.+6      	; 0x15d4 <xTaskCreate+0x102>
    15ce:	f7 01       	movw	r30, r14
    15d0:	c0 83       	st	Z, r28
    15d2:	d1 83       	std	Z+1, r29	; 0x01
    15d4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15d8:	ff 93       	push	r31
    15da:	f8 7f       	andi	r31, 0xF8	; 248
    15dc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15e0:	80 91 5b 2c 	lds	r24, 0x2C5B	; 0x802c5b <uxCurrentNumberOfTasks>
    15e4:	8f 5f       	subi	r24, 0xFF	; 255
    15e6:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <uxCurrentNumberOfTasks>
    15ea:	80 91 b8 2c 	lds	r24, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    15ee:	90 91 b9 2c 	lds	r25, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    15f2:	89 2b       	or	r24, r25
    15f4:	a9 f5       	brne	.+106    	; 0x1660 <xTaskCreate+0x18e>
    15f6:	c0 93 b8 2c 	sts	0x2CB8, r28	; 0x802cb8 <pxCurrentTCB>
    15fa:	d0 93 b9 2c 	sts	0x2CB9, r29	; 0x802cb9 <pxCurrentTCB+0x1>
    15fe:	80 91 5b 2c 	lds	r24, 0x2C5B	; 0x802c5b <uxCurrentNumberOfTasks>
    1602:	81 30       	cpi	r24, 0x01	; 1
    1604:	e9 f5       	brne	.+122    	; 0x1680 <xTaskCreate+0x1ae>
    1606:	8c e8       	ldi	r24, 0x8C	; 140
    1608:	9c e2       	ldi	r25, 0x2C	; 44
    160a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    160e:	87 e9       	ldi	r24, 0x97	; 151
    1610:	9c e2       	ldi	r25, 0x2C	; 44
    1612:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1616:	82 ea       	ldi	r24, 0xA2	; 162
    1618:	9c e2       	ldi	r25, 0x2C	; 44
    161a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    161e:	8d ea       	ldi	r24, 0xAD	; 173
    1620:	9c e2       	ldi	r25, 0x2C	; 44
    1622:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1626:	81 e8       	ldi	r24, 0x81	; 129
    1628:	9c e2       	ldi	r25, 0x2C	; 44
    162a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    162e:	86 e7       	ldi	r24, 0x76	; 118
    1630:	9c e2       	ldi	r25, 0x2C	; 44
    1632:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1636:	87 e6       	ldi	r24, 0x67	; 103
    1638:	9c e2       	ldi	r25, 0x2C	; 44
    163a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    163e:	8c e5       	ldi	r24, 0x5C	; 92
    1640:	9c e2       	ldi	r25, 0x2C	; 44
    1642:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1646:	81 e8       	ldi	r24, 0x81	; 129
    1648:	9c e2       	ldi	r25, 0x2C	; 44
    164a:	80 93 74 2c 	sts	0x2C74, r24	; 0x802c74 <pxDelayedTaskList>
    164e:	90 93 75 2c 	sts	0x2C75, r25	; 0x802c75 <pxDelayedTaskList+0x1>
    1652:	86 e7       	ldi	r24, 0x76	; 118
    1654:	9c e2       	ldi	r25, 0x2C	; 44
    1656:	80 93 72 2c 	sts	0x2C72, r24	; 0x802c72 <pxOverflowDelayedTaskList>
    165a:	90 93 73 2c 	sts	0x2C73, r25	; 0x802c73 <pxOverflowDelayedTaskList+0x1>
    165e:	10 c0       	rjmp	.+32     	; 0x1680 <xTaskCreate+0x1ae>
    1660:	80 91 55 2c 	lds	r24, 0x2C55	; 0x802c55 <xSchedulerRunning>
    1664:	81 11       	cpse	r24, r1
    1666:	0c c0       	rjmp	.+24     	; 0x1680 <xTaskCreate+0x1ae>
    1668:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    166c:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1670:	92 8d       	ldd	r25, Z+26	; 0x1a
    1672:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1674:	89 17       	cp	r24, r25
    1676:	20 f0       	brcs	.+8      	; 0x1680 <xTaskCreate+0x1ae>
    1678:	c0 93 b8 2c 	sts	0x2CB8, r28	; 0x802cb8 <pxCurrentTCB>
    167c:	d0 93 b9 2c 	sts	0x2CB9, r29	; 0x802cb9 <pxCurrentTCB+0x1>
    1680:	80 91 51 2c 	lds	r24, 0x2C51	; 0x802c51 <uxTaskNumber>
    1684:	8f 5f       	subi	r24, 0xFF	; 255
    1686:	80 93 51 2c 	sts	0x2C51, r24	; 0x802c51 <uxTaskNumber>
    168a:	8d a3       	std	Y+37, r24	; 0x25
    168c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    168e:	90 91 56 2c 	lds	r25, 0x2C56	; 0x802c56 <uxTopReadyPriority>
    1692:	98 17       	cp	r25, r24
    1694:	10 f4       	brcc	.+4      	; 0x169a <xTaskCreate+0x1c8>
    1696:	80 93 56 2c 	sts	0x2C56, r24	; 0x802c56 <uxTopReadyPriority>
    169a:	fb e0       	ldi	r31, 0x0B	; 11
    169c:	8f 9f       	mul	r24, r31
    169e:	c0 01       	movw	r24, r0
    16a0:	11 24       	eor	r1, r1
    16a2:	b6 01       	movw	r22, r12
    16a4:	84 57       	subi	r24, 0x74	; 116
    16a6:	93 4d       	sbci	r25, 0xD3	; 211
    16a8:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    16ac:	ff 91       	pop	r31
    16ae:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    16b2:	80 91 55 2c 	lds	r24, 0x2C55	; 0x802c55 <xSchedulerRunning>
    16b6:	88 23       	and	r24, r24
    16b8:	61 f0       	breq	.+24     	; 0x16d2 <xTaskCreate+0x200>
    16ba:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    16be:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    16c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    16c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16c6:	98 17       	cp	r25, r24
    16c8:	30 f4       	brcc	.+12     	; 0x16d6 <xTaskCreate+0x204>
    16ca:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    16ce:	81 e0       	ldi	r24, 0x01	; 1
    16d0:	05 c0       	rjmp	.+10     	; 0x16dc <xTaskCreate+0x20a>
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	03 c0       	rjmp	.+6      	; 0x16dc <xTaskCreate+0x20a>
    16d6:	81 e0       	ldi	r24, 0x01	; 1
    16d8:	01 c0       	rjmp	.+2      	; 0x16dc <xTaskCreate+0x20a>
    16da:	8f ef       	ldi	r24, 0xFF	; 255
    16dc:	df 91       	pop	r29
    16de:	cf 91       	pop	r28
    16e0:	0f 91       	pop	r16
    16e2:	ff 90       	pop	r15
    16e4:	ef 90       	pop	r14
    16e6:	df 90       	pop	r13
    16e8:	cf 90       	pop	r12
    16ea:	bf 90       	pop	r11
    16ec:	af 90       	pop	r10
    16ee:	9f 90       	pop	r9
    16f0:	8f 90       	pop	r8
    16f2:	7f 90       	pop	r7
    16f4:	6f 90       	pop	r6
    16f6:	5f 90       	pop	r5
    16f8:	4f 90       	pop	r4
    16fa:	08 95       	ret

000016fc <vTaskStartScheduler>:
    16fc:	ef 92       	push	r14
    16fe:	ff 92       	push	r15
    1700:	0f 93       	push	r16
    1702:	0f 2e       	mov	r0, r31
    1704:	fb e4       	ldi	r31, 0x4B	; 75
    1706:	ef 2e       	mov	r14, r31
    1708:	fc e2       	ldi	r31, 0x2C	; 44
    170a:	ff 2e       	mov	r15, r31
    170c:	f0 2d       	mov	r31, r0
    170e:	00 e0       	ldi	r16, 0x00	; 0
    1710:	20 e0       	ldi	r18, 0x00	; 0
    1712:	30 e0       	ldi	r19, 0x00	; 0
    1714:	48 ec       	ldi	r20, 0xC8	; 200
    1716:	50 e0       	ldi	r21, 0x00	; 0
    1718:	60 e0       	ldi	r22, 0x00	; 0
    171a:	70 e2       	ldi	r23, 0x20	; 32
    171c:	8f e5       	ldi	r24, 0x5F	; 95
    171e:	9a e0       	ldi	r25, 0x0A	; 10
    1720:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
    1724:	81 30       	cpi	r24, 0x01	; 1
    1726:	09 f5       	brne	.+66     	; 0x176a <vTaskStartScheduler+0x6e>
    1728:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <xTimerCreateTimerTask>
    172c:	81 30       	cpi	r24, 0x01	; 1
    172e:	e9 f4       	brne	.+58     	; 0x176a <vTaskStartScheduler+0x6e>
    1730:	e0 ea       	ldi	r30, 0xA0	; 160
    1732:	f0 e0       	ldi	r31, 0x00	; 0
    1734:	82 81       	ldd	r24, Z+2	; 0x02
    1736:	88 7f       	andi	r24, 0xF8	; 248
    1738:	82 83       	std	Z+2, r24	; 0x02
    173a:	8f ef       	ldi	r24, 0xFF	; 255
    173c:	9f ef       	ldi	r25, 0xFF	; 255
    173e:	dc 01       	movw	r26, r24
    1740:	80 93 4d 2c 	sts	0x2C4D, r24	; 0x802c4d <xNextTaskUnblockTime>
    1744:	90 93 4e 2c 	sts	0x2C4E, r25	; 0x802c4e <xNextTaskUnblockTime+0x1>
    1748:	a0 93 4f 2c 	sts	0x2C4F, r26	; 0x802c4f <xNextTaskUnblockTime+0x2>
    174c:	b0 93 50 2c 	sts	0x2C50, r27	; 0x802c50 <xNextTaskUnblockTime+0x3>
    1750:	81 e0       	ldi	r24, 0x01	; 1
    1752:	80 93 55 2c 	sts	0x2C55, r24	; 0x802c55 <xSchedulerRunning>
    1756:	10 92 57 2c 	sts	0x2C57, r1	; 0x802c57 <xTickCount>
    175a:	10 92 58 2c 	sts	0x2C58, r1	; 0x802c58 <xTickCount+0x1>
    175e:	10 92 59 2c 	sts	0x2C59, r1	; 0x802c59 <xTickCount+0x2>
    1762:	10 92 5a 2c 	sts	0x2C5A, r1	; 0x802c5a <xTickCount+0x3>
    1766:	0e 94 8a 05 	call	0xb14	; 0xb14 <xPortStartScheduler>
    176a:	0f 91       	pop	r16
    176c:	ff 90       	pop	r15
    176e:	ef 90       	pop	r14
    1770:	08 95       	ret

00001772 <vTaskSuspendAll>:
    1772:	80 91 4a 2c 	lds	r24, 0x2C4A	; 0x802c4a <uxSchedulerSuspended>
    1776:	8f 5f       	subi	r24, 0xFF	; 255
    1778:	80 93 4a 2c 	sts	0x2C4A, r24	; 0x802c4a <uxSchedulerSuspended>
    177c:	08 95       	ret

0000177e <xTaskGetTickCount>:
    177e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1782:	ff 93       	push	r31
    1784:	f8 7f       	andi	r31, 0xF8	; 248
    1786:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    178a:	60 91 57 2c 	lds	r22, 0x2C57	; 0x802c57 <xTickCount>
    178e:	70 91 58 2c 	lds	r23, 0x2C58	; 0x802c58 <xTickCount+0x1>
    1792:	80 91 59 2c 	lds	r24, 0x2C59	; 0x802c59 <xTickCount+0x2>
    1796:	90 91 5a 2c 	lds	r25, 0x2C5A	; 0x802c5a <xTickCount+0x3>
    179a:	ff 91       	pop	r31
    179c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    17a0:	08 95       	ret

000017a2 <xTaskIncrementTick>:
    17a2:	af 92       	push	r10
    17a4:	bf 92       	push	r11
    17a6:	cf 92       	push	r12
    17a8:	df 92       	push	r13
    17aa:	ef 92       	push	r14
    17ac:	ff 92       	push	r15
    17ae:	0f 93       	push	r16
    17b0:	1f 93       	push	r17
    17b2:	cf 93       	push	r28
    17b4:	df 93       	push	r29
    17b6:	80 91 4a 2c 	lds	r24, 0x2C4A	; 0x802c4a <uxSchedulerSuspended>
    17ba:	81 11       	cpse	r24, r1
    17bc:	ad c0       	rjmp	.+346    	; 0x1918 <xTaskIncrementTick+0x176>
    17be:	c0 90 57 2c 	lds	r12, 0x2C57	; 0x802c57 <xTickCount>
    17c2:	d0 90 58 2c 	lds	r13, 0x2C58	; 0x802c58 <xTickCount+0x1>
    17c6:	e0 90 59 2c 	lds	r14, 0x2C59	; 0x802c59 <xTickCount+0x2>
    17ca:	f0 90 5a 2c 	lds	r15, 0x2C5A	; 0x802c5a <xTickCount+0x3>
    17ce:	8f ef       	ldi	r24, 0xFF	; 255
    17d0:	c8 1a       	sub	r12, r24
    17d2:	d8 0a       	sbc	r13, r24
    17d4:	e8 0a       	sbc	r14, r24
    17d6:	f8 0a       	sbc	r15, r24
    17d8:	c0 92 57 2c 	sts	0x2C57, r12	; 0x802c57 <xTickCount>
    17dc:	d0 92 58 2c 	sts	0x2C58, r13	; 0x802c58 <xTickCount+0x1>
    17e0:	e0 92 59 2c 	sts	0x2C59, r14	; 0x802c59 <xTickCount+0x2>
    17e4:	f0 92 5a 2c 	sts	0x2C5A, r15	; 0x802c5a <xTickCount+0x3>
    17e8:	c1 14       	cp	r12, r1
    17ea:	d1 04       	cpc	r13, r1
    17ec:	e1 04       	cpc	r14, r1
    17ee:	f1 04       	cpc	r15, r1
    17f0:	b9 f4       	brne	.+46     	; 0x1820 <xTaskIncrementTick+0x7e>
    17f2:	80 91 74 2c 	lds	r24, 0x2C74	; 0x802c74 <pxDelayedTaskList>
    17f6:	90 91 75 2c 	lds	r25, 0x2C75	; 0x802c75 <pxDelayedTaskList+0x1>
    17fa:	20 91 72 2c 	lds	r18, 0x2C72	; 0x802c72 <pxOverflowDelayedTaskList>
    17fe:	30 91 73 2c 	lds	r19, 0x2C73	; 0x802c73 <pxOverflowDelayedTaskList+0x1>
    1802:	20 93 74 2c 	sts	0x2C74, r18	; 0x802c74 <pxDelayedTaskList>
    1806:	30 93 75 2c 	sts	0x2C75, r19	; 0x802c75 <pxDelayedTaskList+0x1>
    180a:	80 93 72 2c 	sts	0x2C72, r24	; 0x802c72 <pxOverflowDelayedTaskList>
    180e:	90 93 73 2c 	sts	0x2C73, r25	; 0x802c73 <pxOverflowDelayedTaskList+0x1>
    1812:	80 91 52 2c 	lds	r24, 0x2C52	; 0x802c52 <xNumOfOverflows>
    1816:	8f 5f       	subi	r24, 0xFF	; 255
    1818:	80 93 52 2c 	sts	0x2C52, r24	; 0x802c52 <xNumOfOverflows>
    181c:	0e 94 be 09 	call	0x137c	; 0x137c <prvResetNextTaskUnblockTime>
    1820:	80 91 4d 2c 	lds	r24, 0x2C4D	; 0x802c4d <xNextTaskUnblockTime>
    1824:	90 91 4e 2c 	lds	r25, 0x2C4E	; 0x802c4e <xNextTaskUnblockTime+0x1>
    1828:	a0 91 4f 2c 	lds	r26, 0x2C4F	; 0x802c4f <xNextTaskUnblockTime+0x2>
    182c:	b0 91 50 2c 	lds	r27, 0x2C50	; 0x802c50 <xNextTaskUnblockTime+0x3>
    1830:	c8 16       	cp	r12, r24
    1832:	d9 06       	cpc	r13, r25
    1834:	ea 06       	cpc	r14, r26
    1836:	fb 06       	cpc	r15, r27
    1838:	10 f4       	brcc	.+4      	; 0x183e <xTaskIncrementTick+0x9c>
    183a:	b1 2c       	mov	r11, r1
    183c:	5c c0       	rjmp	.+184    	; 0x18f6 <xTaskIncrementTick+0x154>
    183e:	b1 2c       	mov	r11, r1
    1840:	0f 2e       	mov	r0, r31
    1842:	fb e0       	ldi	r31, 0x0B	; 11
    1844:	af 2e       	mov	r10, r31
    1846:	f0 2d       	mov	r31, r0
    1848:	e0 91 74 2c 	lds	r30, 0x2C74	; 0x802c74 <pxDelayedTaskList>
    184c:	f0 91 75 2c 	lds	r31, 0x2C75	; 0x802c75 <pxDelayedTaskList+0x1>
    1850:	80 81       	ld	r24, Z
    1852:	81 11       	cpse	r24, r1
    1854:	0c c0       	rjmp	.+24     	; 0x186e <xTaskIncrementTick+0xcc>
    1856:	8f ef       	ldi	r24, 0xFF	; 255
    1858:	9f ef       	ldi	r25, 0xFF	; 255
    185a:	dc 01       	movw	r26, r24
    185c:	80 93 4d 2c 	sts	0x2C4D, r24	; 0x802c4d <xNextTaskUnblockTime>
    1860:	90 93 4e 2c 	sts	0x2C4E, r25	; 0x802c4e <xNextTaskUnblockTime+0x1>
    1864:	a0 93 4f 2c 	sts	0x2C4F, r26	; 0x802c4f <xNextTaskUnblockTime+0x2>
    1868:	b0 93 50 2c 	sts	0x2C50, r27	; 0x802c50 <xNextTaskUnblockTime+0x3>
    186c:	44 c0       	rjmp	.+136    	; 0x18f6 <xTaskIncrementTick+0x154>
    186e:	e0 91 74 2c 	lds	r30, 0x2C74	; 0x802c74 <pxDelayedTaskList>
    1872:	f0 91 75 2c 	lds	r31, 0x2C75	; 0x802c75 <pxDelayedTaskList+0x1>
    1876:	07 80       	ldd	r0, Z+7	; 0x07
    1878:	f0 85       	ldd	r31, Z+8	; 0x08
    187a:	e0 2d       	mov	r30, r0
    187c:	c0 85       	ldd	r28, Z+8	; 0x08
    187e:	d1 85       	ldd	r29, Z+9	; 0x09
    1880:	8a 81       	ldd	r24, Y+2	; 0x02
    1882:	9b 81       	ldd	r25, Y+3	; 0x03
    1884:	ac 81       	ldd	r26, Y+4	; 0x04
    1886:	bd 81       	ldd	r27, Y+5	; 0x05
    1888:	c8 16       	cp	r12, r24
    188a:	d9 06       	cpc	r13, r25
    188c:	ea 06       	cpc	r14, r26
    188e:	fb 06       	cpc	r15, r27
    1890:	48 f4       	brcc	.+18     	; 0x18a4 <xTaskIncrementTick+0x102>
    1892:	80 93 4d 2c 	sts	0x2C4D, r24	; 0x802c4d <xNextTaskUnblockTime>
    1896:	90 93 4e 2c 	sts	0x2C4E, r25	; 0x802c4e <xNextTaskUnblockTime+0x1>
    189a:	a0 93 4f 2c 	sts	0x2C4F, r26	; 0x802c4f <xNextTaskUnblockTime+0x2>
    189e:	b0 93 50 2c 	sts	0x2C50, r27	; 0x802c50 <xNextTaskUnblockTime+0x3>
    18a2:	29 c0       	rjmp	.+82     	; 0x18f6 <xTaskIncrementTick+0x154>
    18a4:	8e 01       	movw	r16, r28
    18a6:	0e 5f       	subi	r16, 0xFE	; 254
    18a8:	1f 4f       	sbci	r17, 0xFF	; 255
    18aa:	c8 01       	movw	r24, r16
    18ac:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    18b0:	88 8d       	ldd	r24, Y+24	; 0x18
    18b2:	99 8d       	ldd	r25, Y+25	; 0x19
    18b4:	89 2b       	or	r24, r25
    18b6:	21 f0       	breq	.+8      	; 0x18c0 <xTaskIncrementTick+0x11e>
    18b8:	ce 01       	movw	r24, r28
    18ba:	0e 96       	adiw	r24, 0x0e	; 14
    18bc:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    18c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    18c2:	90 91 56 2c 	lds	r25, 0x2C56	; 0x802c56 <uxTopReadyPriority>
    18c6:	98 17       	cp	r25, r24
    18c8:	10 f4       	brcc	.+4      	; 0x18ce <xTaskIncrementTick+0x12c>
    18ca:	80 93 56 2c 	sts	0x2C56, r24	; 0x802c56 <uxTopReadyPriority>
    18ce:	a8 9e       	mul	r10, r24
    18d0:	c0 01       	movw	r24, r0
    18d2:	11 24       	eor	r1, r1
    18d4:	b8 01       	movw	r22, r16
    18d6:	84 57       	subi	r24, 0x74	; 116
    18d8:	93 4d       	sbci	r25, 0xD3	; 211
    18da:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    18de:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    18e2:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    18e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    18ea:	98 17       	cp	r25, r24
    18ec:	08 f4       	brcc	.+2      	; 0x18f0 <xTaskIncrementTick+0x14e>
    18ee:	ac cf       	rjmp	.-168    	; 0x1848 <xTaskIncrementTick+0xa6>
    18f0:	bb 24       	eor	r11, r11
    18f2:	b3 94       	inc	r11
    18f4:	a9 cf       	rjmp	.-174    	; 0x1848 <xTaskIncrementTick+0xa6>
    18f6:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    18fa:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    18fe:	e2 8d       	ldd	r30, Z+26	; 0x1a
    1900:	8b e0       	ldi	r24, 0x0B	; 11
    1902:	e8 9f       	mul	r30, r24
    1904:	f0 01       	movw	r30, r0
    1906:	11 24       	eor	r1, r1
    1908:	e4 57       	subi	r30, 0x74	; 116
    190a:	f3 4d       	sbci	r31, 0xD3	; 211
    190c:	80 81       	ld	r24, Z
    190e:	82 30       	cpi	r24, 0x02	; 2
    1910:	48 f0       	brcs	.+18     	; 0x1924 <xTaskIncrementTick+0x182>
    1912:	bb 24       	eor	r11, r11
    1914:	b3 94       	inc	r11
    1916:	06 c0       	rjmp	.+12     	; 0x1924 <xTaskIncrementTick+0x182>
    1918:	80 91 54 2c 	lds	r24, 0x2C54	; 0x802c54 <uxPendedTicks>
    191c:	8f 5f       	subi	r24, 0xFF	; 255
    191e:	80 93 54 2c 	sts	0x2C54, r24	; 0x802c54 <uxPendedTicks>
    1922:	b1 2c       	mov	r11, r1
    1924:	80 91 53 2c 	lds	r24, 0x2C53	; 0x802c53 <xYieldPending>
    1928:	88 23       	and	r24, r24
    192a:	11 f0       	breq	.+4      	; 0x1930 <xTaskIncrementTick+0x18e>
    192c:	bb 24       	eor	r11, r11
    192e:	b3 94       	inc	r11
    1930:	8b 2d       	mov	r24, r11
    1932:	df 91       	pop	r29
    1934:	cf 91       	pop	r28
    1936:	1f 91       	pop	r17
    1938:	0f 91       	pop	r16
    193a:	ff 90       	pop	r15
    193c:	ef 90       	pop	r14
    193e:	df 90       	pop	r13
    1940:	cf 90       	pop	r12
    1942:	bf 90       	pop	r11
    1944:	af 90       	pop	r10
    1946:	08 95       	ret

00001948 <xTaskResumeAll>:
    1948:	cf 92       	push	r12
    194a:	df 92       	push	r13
    194c:	ef 92       	push	r14
    194e:	ff 92       	push	r15
    1950:	0f 93       	push	r16
    1952:	1f 93       	push	r17
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    195c:	ff 93       	push	r31
    195e:	f8 7f       	andi	r31, 0xF8	; 248
    1960:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1964:	80 91 4a 2c 	lds	r24, 0x2C4A	; 0x802c4a <uxSchedulerSuspended>
    1968:	81 50       	subi	r24, 0x01	; 1
    196a:	80 93 4a 2c 	sts	0x2C4A, r24	; 0x802c4a <uxSchedulerSuspended>
    196e:	80 91 4a 2c 	lds	r24, 0x2C4A	; 0x802c4a <uxSchedulerSuspended>
    1972:	81 11       	cpse	r24, r1
    1974:	5c c0       	rjmp	.+184    	; 0x1a2e <xTaskResumeAll+0xe6>
    1976:	80 91 5b 2c 	lds	r24, 0x2C5B	; 0x802c5b <uxCurrentNumberOfTasks>
    197a:	81 11       	cpse	r24, r1
    197c:	2c c0       	rjmp	.+88     	; 0x19d6 <xTaskResumeAll+0x8e>
    197e:	5a c0       	rjmp	.+180    	; 0x1a34 <xTaskResumeAll+0xec>
    1980:	d7 01       	movw	r26, r14
    1982:	17 96       	adiw	r26, 0x07	; 7
    1984:	ed 91       	ld	r30, X+
    1986:	fc 91       	ld	r31, X
    1988:	18 97       	sbiw	r26, 0x08	; 8
    198a:	c0 85       	ldd	r28, Z+8	; 0x08
    198c:	d1 85       	ldd	r29, Z+9	; 0x09
    198e:	ce 01       	movw	r24, r28
    1990:	0e 96       	adiw	r24, 0x0e	; 14
    1992:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1996:	8e 01       	movw	r16, r28
    1998:	0e 5f       	subi	r16, 0xFE	; 254
    199a:	1f 4f       	sbci	r17, 0xFF	; 255
    199c:	c8 01       	movw	r24, r16
    199e:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    19a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19a4:	90 91 56 2c 	lds	r25, 0x2C56	; 0x802c56 <uxTopReadyPriority>
    19a8:	98 17       	cp	r25, r24
    19aa:	10 f4       	brcc	.+4      	; 0x19b0 <xTaskResumeAll+0x68>
    19ac:	80 93 56 2c 	sts	0x2C56, r24	; 0x802c56 <uxTopReadyPriority>
    19b0:	d8 9e       	mul	r13, r24
    19b2:	c0 01       	movw	r24, r0
    19b4:	11 24       	eor	r1, r1
    19b6:	b8 01       	movw	r22, r16
    19b8:	84 57       	subi	r24, 0x74	; 116
    19ba:	93 4d       	sbci	r25, 0xD3	; 211
    19bc:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    19c0:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    19c4:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    19c8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    19cc:	98 17       	cp	r25, r24
    19ce:	88 f0       	brcs	.+34     	; 0x19f2 <xTaskResumeAll+0xaa>
    19d0:	c0 92 53 2c 	sts	0x2C53, r12	; 0x802c53 <xYieldPending>
    19d4:	0e c0       	rjmp	.+28     	; 0x19f2 <xTaskResumeAll+0xaa>
    19d6:	c0 e0       	ldi	r28, 0x00	; 0
    19d8:	d0 e0       	ldi	r29, 0x00	; 0
    19da:	0f 2e       	mov	r0, r31
    19dc:	f7 e6       	ldi	r31, 0x67	; 103
    19de:	ef 2e       	mov	r14, r31
    19e0:	fc e2       	ldi	r31, 0x2C	; 44
    19e2:	ff 2e       	mov	r15, r31
    19e4:	f0 2d       	mov	r31, r0
    19e6:	0f 2e       	mov	r0, r31
    19e8:	fb e0       	ldi	r31, 0x0B	; 11
    19ea:	df 2e       	mov	r13, r31
    19ec:	f0 2d       	mov	r31, r0
    19ee:	cc 24       	eor	r12, r12
    19f0:	c3 94       	inc	r12
    19f2:	f7 01       	movw	r30, r14
    19f4:	80 81       	ld	r24, Z
    19f6:	81 11       	cpse	r24, r1
    19f8:	c3 cf       	rjmp	.-122    	; 0x1980 <xTaskResumeAll+0x38>
    19fa:	cd 2b       	or	r28, r29
    19fc:	11 f0       	breq	.+4      	; 0x1a02 <xTaskResumeAll+0xba>
    19fe:	0e 94 be 09 	call	0x137c	; 0x137c <prvResetNextTaskUnblockTime>
    1a02:	c0 91 54 2c 	lds	r28, 0x2C54	; 0x802c54 <uxPendedTicks>
    1a06:	cc 23       	and	r28, r28
    1a08:	51 f0       	breq	.+20     	; 0x1a1e <xTaskResumeAll+0xd6>
    1a0a:	d1 e0       	ldi	r29, 0x01	; 1
    1a0c:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <xTaskIncrementTick>
    1a10:	81 11       	cpse	r24, r1
    1a12:	d0 93 53 2c 	sts	0x2C53, r29	; 0x802c53 <xYieldPending>
    1a16:	c1 50       	subi	r28, 0x01	; 1
    1a18:	c9 f7       	brne	.-14     	; 0x1a0c <xTaskResumeAll+0xc4>
    1a1a:	10 92 54 2c 	sts	0x2C54, r1	; 0x802c54 <uxPendedTicks>
    1a1e:	80 91 53 2c 	lds	r24, 0x2C53	; 0x802c53 <xYieldPending>
    1a22:	88 23       	and	r24, r24
    1a24:	31 f0       	breq	.+12     	; 0x1a32 <xTaskResumeAll+0xea>
    1a26:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1a2a:	81 e0       	ldi	r24, 0x01	; 1
    1a2c:	03 c0       	rjmp	.+6      	; 0x1a34 <xTaskResumeAll+0xec>
    1a2e:	80 e0       	ldi	r24, 0x00	; 0
    1a30:	01 c0       	rjmp	.+2      	; 0x1a34 <xTaskResumeAll+0xec>
    1a32:	80 e0       	ldi	r24, 0x00	; 0
    1a34:	ff 91       	pop	r31
    1a36:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1a3a:	df 91       	pop	r29
    1a3c:	cf 91       	pop	r28
    1a3e:	1f 91       	pop	r17
    1a40:	0f 91       	pop	r16
    1a42:	ff 90       	pop	r15
    1a44:	ef 90       	pop	r14
    1a46:	df 90       	pop	r13
    1a48:	cf 90       	pop	r12
    1a4a:	08 95       	ret

00001a4c <vTaskDelay>:
    1a4c:	cf 92       	push	r12
    1a4e:	df 92       	push	r13
    1a50:	ef 92       	push	r14
    1a52:	ff 92       	push	r15
    1a54:	6b 01       	movw	r12, r22
    1a56:	7c 01       	movw	r14, r24
    1a58:	67 2b       	or	r22, r23
    1a5a:	68 2b       	or	r22, r24
    1a5c:	69 2b       	or	r22, r25
    1a5e:	59 f0       	breq	.+22     	; 0x1a76 <vTaskDelay+0x2a>
    1a60:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    1a64:	40 e0       	ldi	r20, 0x00	; 0
    1a66:	c7 01       	movw	r24, r14
    1a68:	b6 01       	movw	r22, r12
    1a6a:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1a6e:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    1a72:	81 11       	cpse	r24, r1
    1a74:	02 c0       	rjmp	.+4      	; 0x1a7a <vTaskDelay+0x2e>
    1a76:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1a7a:	ff 90       	pop	r15
    1a7c:	ef 90       	pop	r14
    1a7e:	df 90       	pop	r13
    1a80:	cf 90       	pop	r12
    1a82:	08 95       	ret

00001a84 <vTaskSwitchContext>:
    1a84:	80 91 4a 2c 	lds	r24, 0x2C4A	; 0x802c4a <uxSchedulerSuspended>
    1a88:	88 23       	and	r24, r24
    1a8a:	21 f0       	breq	.+8      	; 0x1a94 <vTaskSwitchContext+0x10>
    1a8c:	81 e0       	ldi	r24, 0x01	; 1
    1a8e:	80 93 53 2c 	sts	0x2C53, r24	; 0x802c53 <xYieldPending>
    1a92:	08 95       	ret
    1a94:	10 92 53 2c 	sts	0x2C53, r1	; 0x802c53 <xYieldPending>
    1a98:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1a9c:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1aa0:	03 8c       	ldd	r0, Z+27	; 0x1b
    1aa2:	f4 8d       	ldd	r31, Z+28	; 0x1c
    1aa4:	e0 2d       	mov	r30, r0
    1aa6:	80 81       	ld	r24, Z
    1aa8:	91 81       	ldd	r25, Z+1	; 0x01
    1aaa:	a2 81       	ldd	r26, Z+2	; 0x02
    1aac:	b3 81       	ldd	r27, Z+3	; 0x03
    1aae:	85 3a       	cpi	r24, 0xA5	; 165
    1ab0:	95 4a       	sbci	r25, 0xA5	; 165
    1ab2:	a5 4a       	sbci	r26, 0xA5	; 165
    1ab4:	b5 4a       	sbci	r27, 0xA5	; 165
    1ab6:	d9 f4       	brne	.+54     	; 0x1aee <vTaskSwitchContext+0x6a>
    1ab8:	84 81       	ldd	r24, Z+4	; 0x04
    1aba:	95 81       	ldd	r25, Z+5	; 0x05
    1abc:	a6 81       	ldd	r26, Z+6	; 0x06
    1abe:	b7 81       	ldd	r27, Z+7	; 0x07
    1ac0:	85 3a       	cpi	r24, 0xA5	; 165
    1ac2:	95 4a       	sbci	r25, 0xA5	; 165
    1ac4:	a5 4a       	sbci	r26, 0xA5	; 165
    1ac6:	b5 4a       	sbci	r27, 0xA5	; 165
    1ac8:	91 f4       	brne	.+36     	; 0x1aee <vTaskSwitchContext+0x6a>
    1aca:	80 85       	ldd	r24, Z+8	; 0x08
    1acc:	91 85       	ldd	r25, Z+9	; 0x09
    1ace:	a2 85       	ldd	r26, Z+10	; 0x0a
    1ad0:	b3 85       	ldd	r27, Z+11	; 0x0b
    1ad2:	85 3a       	cpi	r24, 0xA5	; 165
    1ad4:	95 4a       	sbci	r25, 0xA5	; 165
    1ad6:	a5 4a       	sbci	r26, 0xA5	; 165
    1ad8:	b5 4a       	sbci	r27, 0xA5	; 165
    1ada:	49 f4       	brne	.+18     	; 0x1aee <vTaskSwitchContext+0x6a>
    1adc:	84 85       	ldd	r24, Z+12	; 0x0c
    1ade:	95 85       	ldd	r25, Z+13	; 0x0d
    1ae0:	a6 85       	ldd	r26, Z+14	; 0x0e
    1ae2:	b7 85       	ldd	r27, Z+15	; 0x0f
    1ae4:	85 3a       	cpi	r24, 0xA5	; 165
    1ae6:	95 4a       	sbci	r25, 0xA5	; 165
    1ae8:	a5 4a       	sbci	r26, 0xA5	; 165
    1aea:	b5 4a       	sbci	r27, 0xA5	; 165
    1aec:	61 f0       	breq	.+24     	; 0x1b06 <vTaskSwitchContext+0x82>
    1aee:	60 91 b8 2c 	lds	r22, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1af2:	70 91 b9 2c 	lds	r23, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1af6:	80 91 b8 2c 	lds	r24, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1afa:	90 91 b9 2c 	lds	r25, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1afe:	63 5e       	subi	r22, 0xE3	; 227
    1b00:	7f 4f       	sbci	r23, 0xFF	; 255
    1b02:	0e 94 a5 02 	call	0x54a	; 0x54a <vApplicationStackOverflowHook>
    1b06:	80 91 56 2c 	lds	r24, 0x2C56	; 0x802c56 <uxTopReadyPriority>
    1b0a:	28 2f       	mov	r18, r24
    1b0c:	30 e0       	ldi	r19, 0x00	; 0
    1b0e:	9b e0       	ldi	r25, 0x0B	; 11
    1b10:	89 9f       	mul	r24, r25
    1b12:	f0 01       	movw	r30, r0
    1b14:	11 24       	eor	r1, r1
    1b16:	e4 57       	subi	r30, 0x74	; 116
    1b18:	f3 4d       	sbci	r31, 0xD3	; 211
    1b1a:	90 81       	ld	r25, Z
    1b1c:	91 11       	cpse	r25, r1
    1b1e:	0e c0       	rjmp	.+28     	; 0x1b3c <vTaskSwitchContext+0xb8>
    1b20:	4b e0       	ldi	r20, 0x0B	; 11
    1b22:	81 50       	subi	r24, 0x01	; 1
    1b24:	28 2f       	mov	r18, r24
    1b26:	30 e0       	ldi	r19, 0x00	; 0
    1b28:	42 9f       	mul	r20, r18
    1b2a:	f0 01       	movw	r30, r0
    1b2c:	43 9f       	mul	r20, r19
    1b2e:	f0 0d       	add	r31, r0
    1b30:	11 24       	eor	r1, r1
    1b32:	e4 57       	subi	r30, 0x74	; 116
    1b34:	f3 4d       	sbci	r31, 0xD3	; 211
    1b36:	90 81       	ld	r25, Z
    1b38:	99 23       	and	r25, r25
    1b3a:	99 f3       	breq	.-26     	; 0x1b22 <vTaskSwitchContext+0x9e>
    1b3c:	9b e0       	ldi	r25, 0x0B	; 11
    1b3e:	92 9f       	mul	r25, r18
    1b40:	a0 01       	movw	r20, r0
    1b42:	93 9f       	mul	r25, r19
    1b44:	50 0d       	add	r21, r0
    1b46:	11 24       	eor	r1, r1
    1b48:	da 01       	movw	r26, r20
    1b4a:	a4 57       	subi	r26, 0x74	; 116
    1b4c:	b3 4d       	sbci	r27, 0xD3	; 211
    1b4e:	11 96       	adiw	r26, 0x01	; 1
    1b50:	ed 91       	ld	r30, X+
    1b52:	fc 91       	ld	r31, X
    1b54:	12 97       	sbiw	r26, 0x02	; 2
    1b56:	04 80       	ldd	r0, Z+4	; 0x04
    1b58:	f5 81       	ldd	r31, Z+5	; 0x05
    1b5a:	e0 2d       	mov	r30, r0
    1b5c:	11 96       	adiw	r26, 0x01	; 1
    1b5e:	ed 93       	st	X+, r30
    1b60:	fc 93       	st	X, r31
    1b62:	12 97       	sbiw	r26, 0x02	; 2
    1b64:	41 57       	subi	r20, 0x71	; 113
    1b66:	53 4d       	sbci	r21, 0xD3	; 211
    1b68:	e4 17       	cp	r30, r20
    1b6a:	f5 07       	cpc	r31, r21
    1b6c:	29 f4       	brne	.+10     	; 0x1b78 <vTaskSwitchContext+0xf4>
    1b6e:	44 81       	ldd	r20, Z+4	; 0x04
    1b70:	55 81       	ldd	r21, Z+5	; 0x05
    1b72:	fd 01       	movw	r30, r26
    1b74:	41 83       	std	Z+1, r20	; 0x01
    1b76:	52 83       	std	Z+2, r21	; 0x02
    1b78:	9b e0       	ldi	r25, 0x0B	; 11
    1b7a:	92 9f       	mul	r25, r18
    1b7c:	f0 01       	movw	r30, r0
    1b7e:	93 9f       	mul	r25, r19
    1b80:	f0 0d       	add	r31, r0
    1b82:	11 24       	eor	r1, r1
    1b84:	e4 57       	subi	r30, 0x74	; 116
    1b86:	f3 4d       	sbci	r31, 0xD3	; 211
    1b88:	01 80       	ldd	r0, Z+1	; 0x01
    1b8a:	f2 81       	ldd	r31, Z+2	; 0x02
    1b8c:	e0 2d       	mov	r30, r0
    1b8e:	20 85       	ldd	r18, Z+8	; 0x08
    1b90:	31 85       	ldd	r19, Z+9	; 0x09
    1b92:	20 93 b8 2c 	sts	0x2CB8, r18	; 0x802cb8 <pxCurrentTCB>
    1b96:	30 93 b9 2c 	sts	0x2CB9, r19	; 0x802cb9 <pxCurrentTCB+0x1>
    1b9a:	80 93 56 2c 	sts	0x2C56, r24	; 0x802c56 <uxTopReadyPriority>
    1b9e:	08 95       	ret

00001ba0 <vTaskPlaceOnEventList>:
    1ba0:	cf 92       	push	r12
    1ba2:	df 92       	push	r13
    1ba4:	ef 92       	push	r14
    1ba6:	ff 92       	push	r15
    1ba8:	6a 01       	movw	r12, r20
    1baa:	7b 01       	movw	r14, r22
    1bac:	60 91 b8 2c 	lds	r22, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1bb0:	70 91 b9 2c 	lds	r23, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1bb4:	62 5f       	subi	r22, 0xF2	; 242
    1bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb8:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1bbc:	41 e0       	ldi	r20, 0x01	; 1
    1bbe:	c7 01       	movw	r24, r14
    1bc0:	b6 01       	movw	r22, r12
    1bc2:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1bc6:	ff 90       	pop	r15
    1bc8:	ef 90       	pop	r14
    1bca:	df 90       	pop	r13
    1bcc:	cf 90       	pop	r12
    1bce:	08 95       	ret

00001bd0 <vTaskPlaceOnUnorderedEventList>:
    1bd0:	cf 92       	push	r12
    1bd2:	df 92       	push	r13
    1bd4:	ef 92       	push	r14
    1bd6:	ff 92       	push	r15
    1bd8:	0f 93       	push	r16
    1bda:	1f 93       	push	r17
    1bdc:	68 01       	movw	r12, r16
    1bde:	79 01       	movw	r14, r18
    1be0:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1be4:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1be8:	70 68       	ori	r23, 0x80	; 128
    1bea:	46 87       	std	Z+14, r20	; 0x0e
    1bec:	57 87       	std	Z+15, r21	; 0x0f
    1bee:	60 8b       	std	Z+16, r22	; 0x10
    1bf0:	71 8b       	std	Z+17, r23	; 0x11
    1bf2:	60 91 b8 2c 	lds	r22, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1bf6:	70 91 b9 2c 	lds	r23, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1bfa:	62 5f       	subi	r22, 0xF2	; 242
    1bfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bfe:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1c02:	41 e0       	ldi	r20, 0x01	; 1
    1c04:	c7 01       	movw	r24, r14
    1c06:	b6 01       	movw	r22, r12
    1c08:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1c0c:	1f 91       	pop	r17
    1c0e:	0f 91       	pop	r16
    1c10:	ff 90       	pop	r15
    1c12:	ef 90       	pop	r14
    1c14:	df 90       	pop	r13
    1c16:	cf 90       	pop	r12
    1c18:	08 95       	ret

00001c1a <vTaskPlaceOnEventListRestricted>:
    1c1a:	cf 92       	push	r12
    1c1c:	df 92       	push	r13
    1c1e:	ef 92       	push	r14
    1c20:	ff 92       	push	r15
    1c22:	cf 93       	push	r28
    1c24:	6a 01       	movw	r12, r20
    1c26:	7b 01       	movw	r14, r22
    1c28:	c2 2f       	mov	r28, r18
    1c2a:	60 91 b8 2c 	lds	r22, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1c2e:	70 91 b9 2c 	lds	r23, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1c32:	62 5f       	subi	r22, 0xF2	; 242
    1c34:	7f 4f       	sbci	r23, 0xFF	; 255
    1c36:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1c3a:	cc 23       	and	r28, r28
    1c3c:	21 f0       	breq	.+8      	; 0x1c46 <vTaskPlaceOnEventListRestricted+0x2c>
    1c3e:	cc 24       	eor	r12, r12
    1c40:	ca 94       	dec	r12
    1c42:	dc 2c       	mov	r13, r12
    1c44:	76 01       	movw	r14, r12
    1c46:	4c 2f       	mov	r20, r28
    1c48:	c7 01       	movw	r24, r14
    1c4a:	b6 01       	movw	r22, r12
    1c4c:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1c50:	cf 91       	pop	r28
    1c52:	ff 90       	pop	r15
    1c54:	ef 90       	pop	r14
    1c56:	df 90       	pop	r13
    1c58:	cf 90       	pop	r12
    1c5a:	08 95       	ret

00001c5c <xTaskRemoveFromEventList>:
    1c5c:	0f 93       	push	r16
    1c5e:	1f 93       	push	r17
    1c60:	cf 93       	push	r28
    1c62:	df 93       	push	r29
    1c64:	dc 01       	movw	r26, r24
    1c66:	17 96       	adiw	r26, 0x07	; 7
    1c68:	ed 91       	ld	r30, X+
    1c6a:	fc 91       	ld	r31, X
    1c6c:	18 97       	sbiw	r26, 0x08	; 8
    1c6e:	c0 85       	ldd	r28, Z+8	; 0x08
    1c70:	d1 85       	ldd	r29, Z+9	; 0x09
    1c72:	8e 01       	movw	r16, r28
    1c74:	02 5f       	subi	r16, 0xF2	; 242
    1c76:	1f 4f       	sbci	r17, 0xFF	; 255
    1c78:	c8 01       	movw	r24, r16
    1c7a:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1c7e:	80 91 4a 2c 	lds	r24, 0x2C4A	; 0x802c4a <uxSchedulerSuspended>
    1c82:	81 11       	cpse	r24, r1
    1c84:	16 c0       	rjmp	.+44     	; 0x1cb2 <xTaskRemoveFromEventList+0x56>
    1c86:	0c 50       	subi	r16, 0x0C	; 12
    1c88:	11 09       	sbc	r17, r1
    1c8a:	c8 01       	movw	r24, r16
    1c8c:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1c90:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c92:	90 91 56 2c 	lds	r25, 0x2C56	; 0x802c56 <uxTopReadyPriority>
    1c96:	98 17       	cp	r25, r24
    1c98:	10 f4       	brcc	.+4      	; 0x1c9e <xTaskRemoveFromEventList+0x42>
    1c9a:	80 93 56 2c 	sts	0x2C56, r24	; 0x802c56 <uxTopReadyPriority>
    1c9e:	bb e0       	ldi	r27, 0x0B	; 11
    1ca0:	8b 9f       	mul	r24, r27
    1ca2:	c0 01       	movw	r24, r0
    1ca4:	11 24       	eor	r1, r1
    1ca6:	b8 01       	movw	r22, r16
    1ca8:	84 57       	subi	r24, 0x74	; 116
    1caa:	93 4d       	sbci	r25, 0xD3	; 211
    1cac:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1cb0:	05 c0       	rjmp	.+10     	; 0x1cbc <xTaskRemoveFromEventList+0x60>
    1cb2:	b8 01       	movw	r22, r16
    1cb4:	87 e6       	ldi	r24, 0x67	; 103
    1cb6:	9c e2       	ldi	r25, 0x2C	; 44
    1cb8:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1cbc:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1cc0:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1cc4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1cc6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cc8:	89 17       	cp	r24, r25
    1cca:	20 f4       	brcc	.+8      	; 0x1cd4 <xTaskRemoveFromEventList+0x78>
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	80 93 53 2c 	sts	0x2C53, r24	; 0x802c53 <xYieldPending>
    1cd2:	01 c0       	rjmp	.+2      	; 0x1cd6 <xTaskRemoveFromEventList+0x7a>
    1cd4:	80 e0       	ldi	r24, 0x00	; 0
    1cd6:	df 91       	pop	r29
    1cd8:	cf 91       	pop	r28
    1cda:	1f 91       	pop	r17
    1cdc:	0f 91       	pop	r16
    1cde:	08 95       	ret

00001ce0 <vTaskRemoveFromUnorderedEventList>:
    1ce0:	0f 93       	push	r16
    1ce2:	1f 93       	push	r17
    1ce4:	cf 93       	push	r28
    1ce6:	df 93       	push	r29
    1ce8:	70 68       	ori	r23, 0x80	; 128
    1cea:	fc 01       	movw	r30, r24
    1cec:	40 83       	st	Z, r20
    1cee:	51 83       	std	Z+1, r21	; 0x01
    1cf0:	62 83       	std	Z+2, r22	; 0x02
    1cf2:	73 83       	std	Z+3, r23	; 0x03
    1cf4:	c0 85       	ldd	r28, Z+8	; 0x08
    1cf6:	d1 85       	ldd	r29, Z+9	; 0x09
    1cf8:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1cfc:	8e 01       	movw	r16, r28
    1cfe:	0e 5f       	subi	r16, 0xFE	; 254
    1d00:	1f 4f       	sbci	r17, 0xFF	; 255
    1d02:	c8 01       	movw	r24, r16
    1d04:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1d08:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d0a:	90 91 56 2c 	lds	r25, 0x2C56	; 0x802c56 <uxTopReadyPriority>
    1d0e:	98 17       	cp	r25, r24
    1d10:	10 f4       	brcc	.+4      	; 0x1d16 <vTaskRemoveFromUnorderedEventList+0x36>
    1d12:	80 93 56 2c 	sts	0x2C56, r24	; 0x802c56 <uxTopReadyPriority>
    1d16:	fb e0       	ldi	r31, 0x0B	; 11
    1d18:	8f 9f       	mul	r24, r31
    1d1a:	c0 01       	movw	r24, r0
    1d1c:	11 24       	eor	r1, r1
    1d1e:	b8 01       	movw	r22, r16
    1d20:	84 57       	subi	r24, 0x74	; 116
    1d22:	93 4d       	sbci	r25, 0xD3	; 211
    1d24:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1d28:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1d2c:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1d30:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d32:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d34:	89 17       	cp	r24, r25
    1d36:	18 f4       	brcc	.+6      	; 0x1d3e <vTaskRemoveFromUnorderedEventList+0x5e>
    1d38:	81 e0       	ldi	r24, 0x01	; 1
    1d3a:	80 93 53 2c 	sts	0x2C53, r24	; 0x802c53 <xYieldPending>
    1d3e:	df 91       	pop	r29
    1d40:	cf 91       	pop	r28
    1d42:	1f 91       	pop	r17
    1d44:	0f 91       	pop	r16
    1d46:	08 95       	ret

00001d48 <vTaskInternalSetTimeOutState>:
    1d48:	20 91 52 2c 	lds	r18, 0x2C52	; 0x802c52 <xNumOfOverflows>
    1d4c:	fc 01       	movw	r30, r24
    1d4e:	20 83       	st	Z, r18
    1d50:	40 91 57 2c 	lds	r20, 0x2C57	; 0x802c57 <xTickCount>
    1d54:	50 91 58 2c 	lds	r21, 0x2C58	; 0x802c58 <xTickCount+0x1>
    1d58:	60 91 59 2c 	lds	r22, 0x2C59	; 0x802c59 <xTickCount+0x2>
    1d5c:	70 91 5a 2c 	lds	r23, 0x2C5A	; 0x802c5a <xTickCount+0x3>
    1d60:	41 83       	std	Z+1, r20	; 0x01
    1d62:	52 83       	std	Z+2, r21	; 0x02
    1d64:	63 83       	std	Z+3, r22	; 0x03
    1d66:	74 83       	std	Z+4, r23	; 0x04
    1d68:	08 95       	ret

00001d6a <xTaskCheckForTimeOut>:
    1d6a:	cf 92       	push	r12
    1d6c:	df 92       	push	r13
    1d6e:	ef 92       	push	r14
    1d70:	ff 92       	push	r15
    1d72:	0f 93       	push	r16
    1d74:	1f 93       	push	r17
    1d76:	cf 93       	push	r28
    1d78:	df 93       	push	r29
    1d7a:	db 01       	movw	r26, r22
    1d7c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d80:	ff 93       	push	r31
    1d82:	f8 7f       	andi	r31, 0xF8	; 248
    1d84:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d88:	40 91 57 2c 	lds	r20, 0x2C57	; 0x802c57 <xTickCount>
    1d8c:	50 91 58 2c 	lds	r21, 0x2C58	; 0x802c58 <xTickCount+0x1>
    1d90:	60 91 59 2c 	lds	r22, 0x2C59	; 0x802c59 <xTickCount+0x2>
    1d94:	70 91 5a 2c 	lds	r23, 0x2C5A	; 0x802c5a <xTickCount+0x3>
    1d98:	0d 91       	ld	r16, X+
    1d9a:	1d 91       	ld	r17, X+
    1d9c:	2d 91       	ld	r18, X+
    1d9e:	3c 91       	ld	r19, X
    1da0:	13 97       	sbiw	r26, 0x03	; 3
    1da2:	0f 3f       	cpi	r16, 0xFF	; 255
    1da4:	cf ef       	ldi	r28, 0xFF	; 255
    1da6:	1c 07       	cpc	r17, r28
    1da8:	2c 07       	cpc	r18, r28
    1daa:	3c 07       	cpc	r19, r28
    1dac:	69 f1       	breq	.+90     	; 0x1e08 <xTaskCheckForTimeOut+0x9e>
    1dae:	fc 01       	movw	r30, r24
    1db0:	c1 80       	ldd	r12, Z+1	; 0x01
    1db2:	d2 80       	ldd	r13, Z+2	; 0x02
    1db4:	e3 80       	ldd	r14, Z+3	; 0x03
    1db6:	f4 80       	ldd	r15, Z+4	; 0x04
    1db8:	e0 91 52 2c 	lds	r30, 0x2C52	; 0x802c52 <xNumOfOverflows>
    1dbc:	ec 01       	movw	r28, r24
    1dbe:	f8 81       	ld	r31, Y
    1dc0:	fe 17       	cp	r31, r30
    1dc2:	29 f0       	breq	.+10     	; 0x1dce <xTaskCheckForTimeOut+0x64>
    1dc4:	4c 15       	cp	r20, r12
    1dc6:	5d 05       	cpc	r21, r13
    1dc8:	6e 05       	cpc	r22, r14
    1dca:	7f 05       	cpc	r23, r15
    1dcc:	f8 f4       	brcc	.+62     	; 0x1e0c <xTaskCheckForTimeOut+0xa2>
    1dce:	4c 19       	sub	r20, r12
    1dd0:	5d 09       	sbc	r21, r13
    1dd2:	6e 09       	sbc	r22, r14
    1dd4:	7f 09       	sbc	r23, r15
    1dd6:	40 17       	cp	r20, r16
    1dd8:	51 07       	cpc	r21, r17
    1dda:	62 07       	cpc	r22, r18
    1ddc:	73 07       	cpc	r23, r19
    1dde:	68 f4       	brcc	.+26     	; 0x1dfa <xTaskCheckForTimeOut+0x90>
    1de0:	fd 01       	movw	r30, r26
    1de2:	04 1b       	sub	r16, r20
    1de4:	15 0b       	sbc	r17, r21
    1de6:	26 0b       	sbc	r18, r22
    1de8:	37 0b       	sbc	r19, r23
    1dea:	00 83       	st	Z, r16
    1dec:	11 83       	std	Z+1, r17	; 0x01
    1dee:	22 83       	std	Z+2, r18	; 0x02
    1df0:	33 83       	std	Z+3, r19	; 0x03
    1df2:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskInternalSetTimeOutState>
    1df6:	80 e0       	ldi	r24, 0x00	; 0
    1df8:	0a c0       	rjmp	.+20     	; 0x1e0e <xTaskCheckForTimeOut+0xa4>
    1dfa:	1d 92       	st	X+, r1
    1dfc:	1d 92       	st	X+, r1
    1dfe:	1d 92       	st	X+, r1
    1e00:	1c 92       	st	X, r1
    1e02:	13 97       	sbiw	r26, 0x03	; 3
    1e04:	81 e0       	ldi	r24, 0x01	; 1
    1e06:	03 c0       	rjmp	.+6      	; 0x1e0e <xTaskCheckForTimeOut+0xa4>
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	01 c0       	rjmp	.+2      	; 0x1e0e <xTaskCheckForTimeOut+0xa4>
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	ff 91       	pop	r31
    1e10:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1e14:	df 91       	pop	r29
    1e16:	cf 91       	pop	r28
    1e18:	1f 91       	pop	r17
    1e1a:	0f 91       	pop	r16
    1e1c:	ff 90       	pop	r15
    1e1e:	ef 90       	pop	r14
    1e20:	df 90       	pop	r13
    1e22:	cf 90       	pop	r12
    1e24:	08 95       	ret

00001e26 <vTaskMissedYield>:
    1e26:	81 e0       	ldi	r24, 0x01	; 1
    1e28:	80 93 53 2c 	sts	0x2C53, r24	; 0x802c53 <xYieldPending>
    1e2c:	08 95       	ret

00001e2e <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    1e2e:	80 91 55 2c 	lds	r24, 0x2C55	; 0x802c55 <xSchedulerRunning>
    1e32:	88 23       	and	r24, r24
    1e34:	31 f0       	breq	.+12     	; 0x1e42 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1e36:	80 91 4a 2c 	lds	r24, 0x2C4A	; 0x802c4a <uxSchedulerSuspended>
    1e3a:	88 23       	and	r24, r24
    1e3c:	21 f0       	breq	.+8      	; 0x1e46 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1e3e:	80 e0       	ldi	r24, 0x00	; 0
    1e40:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1e42:	81 e0       	ldi	r24, 0x01	; 1
    1e44:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    1e46:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    1e48:	08 95       	ret

00001e4a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    1e4a:	cf 92       	push	r12
    1e4c:	df 92       	push	r13
    1e4e:	ef 92       	push	r14
    1e50:	ff 92       	push	r15
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1e52:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1e56:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1e5a:	66 85       	ldd	r22, Z+14	; 0x0e
    1e5c:	77 85       	ldd	r23, Z+15	; 0x0f
    1e5e:	80 89       	ldd	r24, Z+16	; 0x10
    1e60:	91 89       	ldd	r25, Z+17	; 0x11

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e62:	e0 91 b8 2c 	lds	r30, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1e66:	f0 91 b9 2c 	lds	r31, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1e6a:	a0 91 b8 2c 	lds	r26, 0x2CB8	; 0x802cb8 <pxCurrentTCB>
    1e6e:	b0 91 b9 2c 	lds	r27, 0x2CB9	; 0x802cb9 <pxCurrentTCB+0x1>
    1e72:	5a 96       	adiw	r26, 0x1a	; 26
    1e74:	2c 91       	ld	r18, X
    1e76:	c1 2c       	mov	r12, r1
    1e78:	d1 2c       	mov	r13, r1
    1e7a:	76 01       	movw	r14, r12
    1e7c:	68 94       	set
    1e7e:	c2 f8       	bld	r12, 2
    1e80:	c2 1a       	sub	r12, r18
    1e82:	d1 08       	sbc	r13, r1
    1e84:	e1 08       	sbc	r14, r1
    1e86:	f1 08       	sbc	r15, r1
    1e88:	c6 86       	std	Z+14, r12	; 0x0e
    1e8a:	d7 86       	std	Z+15, r13	; 0x0f
    1e8c:	e0 8a       	std	Z+16, r14	; 0x10
    1e8e:	f1 8a       	std	Z+17, r15	; 0x11

	return uxReturn;
}
    1e90:	ff 90       	pop	r15
    1e92:	ef 90       	pop	r14
    1e94:	df 90       	pop	r13
    1e96:	cf 90       	pop	r12
    1e98:	08 95       	ret

00001e9a <prvInsertTimerInActiveList>:

	taskENTER_CRITICAL();
	{
		pxTimer->pvTimerID = pvNewID;
	}
	taskEXIT_CRITICAL();
    1e9a:	cf 92       	push	r12
    1e9c:	df 92       	push	r13
    1e9e:	ef 92       	push	r14
    1ea0:	ff 92       	push	r15
    1ea2:	0f 93       	push	r16
    1ea4:	1f 93       	push	r17
    1ea6:	fc 01       	movw	r30, r24
    1ea8:	42 83       	std	Z+2, r20	; 0x02
    1eaa:	53 83       	std	Z+3, r21	; 0x03
    1eac:	64 83       	std	Z+4, r22	; 0x04
    1eae:	75 83       	std	Z+5, r23	; 0x05
    1eb0:	82 87       	std	Z+10, r24	; 0x0a
    1eb2:	93 87       	std	Z+11, r25	; 0x0b
    1eb4:	04 17       	cp	r16, r20
    1eb6:	15 07       	cpc	r17, r21
    1eb8:	26 07       	cpc	r18, r22
    1eba:	37 07       	cpc	r19, r23
    1ebc:	c0 f0       	brcs	.+48     	; 0x1eee <prvInsertTimerInActiveList+0x54>
    1ebe:	0c 19       	sub	r16, r12
    1ec0:	1d 09       	sbc	r17, r13
    1ec2:	2e 09       	sbc	r18, r14
    1ec4:	3f 09       	sbc	r19, r15
    1ec6:	86 85       	ldd	r24, Z+14	; 0x0e
    1ec8:	97 85       	ldd	r25, Z+15	; 0x0f
    1eca:	a0 89       	ldd	r26, Z+16	; 0x10
    1ecc:	b1 89       	ldd	r27, Z+17	; 0x11
    1ece:	08 17       	cp	r16, r24
    1ed0:	19 07       	cpc	r17, r25
    1ed2:	2a 07       	cpc	r18, r26
    1ed4:	3b 07       	cpc	r19, r27
    1ed6:	00 f5       	brcc	.+64     	; 0x1f18 <prvInsertTimerInActiveList+0x7e>
    1ed8:	bf 01       	movw	r22, r30
    1eda:	6e 5f       	subi	r22, 0xFE	; 254
    1edc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ede:	80 91 c2 2c 	lds	r24, 0x2CC2	; 0x802cc2 <pxOverflowTimerList>
    1ee2:	90 91 c3 2c 	lds	r25, 0x2CC3	; 0x802cc3 <pxOverflowTimerList+0x1>
    1ee6:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1eea:	80 e0       	ldi	r24, 0x00	; 0
    1eec:	18 c0       	rjmp	.+48     	; 0x1f1e <prvInsertTimerInActiveList+0x84>
    1eee:	0c 15       	cp	r16, r12
    1ef0:	1d 05       	cpc	r17, r13
    1ef2:	2e 05       	cpc	r18, r14
    1ef4:	3f 05       	cpc	r19, r15
    1ef6:	28 f4       	brcc	.+10     	; 0x1f02 <prvInsertTimerInActiveList+0x68>
    1ef8:	4c 15       	cp	r20, r12
    1efa:	5d 05       	cpc	r21, r13
    1efc:	6e 05       	cpc	r22, r14
    1efe:	7f 05       	cpc	r23, r15
    1f00:	68 f4       	brcc	.+26     	; 0x1f1c <prvInsertTimerInActiveList+0x82>
    1f02:	bf 01       	movw	r22, r30
    1f04:	6e 5f       	subi	r22, 0xFE	; 254
    1f06:	7f 4f       	sbci	r23, 0xFF	; 255
    1f08:	80 91 c4 2c 	lds	r24, 0x2CC4	; 0x802cc4 <pxCurrentTimerList>
    1f0c:	90 91 c5 2c 	lds	r25, 0x2CC5	; 0x802cc5 <pxCurrentTimerList+0x1>
    1f10:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1f14:	80 e0       	ldi	r24, 0x00	; 0
    1f16:	03 c0       	rjmp	.+6      	; 0x1f1e <prvInsertTimerInActiveList+0x84>
    1f18:	81 e0       	ldi	r24, 0x01	; 1
    1f1a:	01 c0       	rjmp	.+2      	; 0x1f1e <prvInsertTimerInActiveList+0x84>
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	1f 91       	pop	r17
    1f20:	0f 91       	pop	r16
    1f22:	ff 90       	pop	r15
    1f24:	ef 90       	pop	r14
    1f26:	df 90       	pop	r13
    1f28:	cf 90       	pop	r12
    1f2a:	08 95       	ret

00001f2c <prvCheckForValidListAndQueue>:
    1f2c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f30:	ff 93       	push	r31
    1f32:	f8 7f       	andi	r31, 0xF8	; 248
    1f34:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f38:	80 91 c0 2c 	lds	r24, 0x2CC0	; 0x802cc0 <xTimerQueue>
    1f3c:	90 91 c1 2c 	lds	r25, 0x2CC1	; 0x802cc1 <xTimerQueue+0x1>
    1f40:	89 2b       	or	r24, r25
    1f42:	e9 f4       	brne	.+58     	; 0x1f7e <prvCheckForValidListAndQueue+0x52>
    1f44:	81 ed       	ldi	r24, 0xD1	; 209
    1f46:	9c e2       	ldi	r25, 0x2C	; 44
    1f48:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1f4c:	86 ec       	ldi	r24, 0xC6	; 198
    1f4e:	9c e2       	ldi	r25, 0x2C	; 44
    1f50:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1f54:	81 ed       	ldi	r24, 0xD1	; 209
    1f56:	9c e2       	ldi	r25, 0x2C	; 44
    1f58:	80 93 c4 2c 	sts	0x2CC4, r24	; 0x802cc4 <pxCurrentTimerList>
    1f5c:	90 93 c5 2c 	sts	0x2CC5, r25	; 0x802cc5 <pxCurrentTimerList+0x1>
    1f60:	86 ec       	ldi	r24, 0xC6	; 198
    1f62:	9c e2       	ldi	r25, 0x2C	; 44
    1f64:	80 93 c2 2c 	sts	0x2CC2, r24	; 0x802cc2 <pxOverflowTimerList>
    1f68:	90 93 c3 2c 	sts	0x2CC3, r25	; 0x802cc3 <pxOverflowTimerList+0x1>
    1f6c:	40 e0       	ldi	r20, 0x00	; 0
    1f6e:	69 e0       	ldi	r22, 0x09	; 9
    1f70:	85 e0       	ldi	r24, 0x05	; 5
    1f72:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericCreate>
    1f76:	80 93 c0 2c 	sts	0x2CC0, r24	; 0x802cc0 <xTimerQueue>
    1f7a:	90 93 c1 2c 	sts	0x2CC1, r25	; 0x802cc1 <xTimerQueue+0x1>
    1f7e:	ff 91       	pop	r31
    1f80:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f84:	08 95       	ret

00001f86 <xTimerCreateTimerTask>:
    1f86:	ef 92       	push	r14
    1f88:	ff 92       	push	r15
    1f8a:	0f 93       	push	r16
    1f8c:	0e 94 96 0f 	call	0x1f2c	; 0x1f2c <prvCheckForValidListAndQueue>
    1f90:	80 91 c0 2c 	lds	r24, 0x2CC0	; 0x802cc0 <xTimerQueue>
    1f94:	90 91 c1 2c 	lds	r25, 0x2CC1	; 0x802cc1 <xTimerQueue+0x1>
    1f98:	89 2b       	or	r24, r25
    1f9a:	91 f0       	breq	.+36     	; 0x1fc0 <xTimerCreateTimerTask+0x3a>
    1f9c:	0f 2e       	mov	r0, r31
    1f9e:	fe eb       	ldi	r31, 0xBE	; 190
    1fa0:	ef 2e       	mov	r14, r31
    1fa2:	fc e2       	ldi	r31, 0x2C	; 44
    1fa4:	ff 2e       	mov	r15, r31
    1fa6:	f0 2d       	mov	r31, r0
    1fa8:	03 e0       	ldi	r16, 0x03	; 3
    1faa:	20 e0       	ldi	r18, 0x00	; 0
    1fac:	30 e0       	ldi	r19, 0x00	; 0
    1fae:	48 ec       	ldi	r20, 0xC8	; 200
    1fb0:	50 e0       	ldi	r21, 0x00	; 0
    1fb2:	65 e0       	ldi	r22, 0x05	; 5
    1fb4:	70 e2       	ldi	r23, 0x20	; 32
    1fb6:	86 ed       	ldi	r24, 0xD6	; 214
    1fb8:	90 e1       	ldi	r25, 0x10	; 16
    1fba:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
    1fbe:	01 c0       	rjmp	.+2      	; 0x1fc2 <xTimerCreateTimerTask+0x3c>
    1fc0:	80 e0       	ldi	r24, 0x00	; 0
    1fc2:	0f 91       	pop	r16
    1fc4:	ff 90       	pop	r15
    1fc6:	ef 90       	pop	r14
    1fc8:	08 95       	ret

00001fca <xTimerGenericCommand>:
    1fca:	8f 92       	push	r8
    1fcc:	9f 92       	push	r9
    1fce:	af 92       	push	r10
    1fd0:	bf 92       	push	r11
    1fd2:	cf 92       	push	r12
    1fd4:	df 92       	push	r13
    1fd6:	ef 92       	push	r14
    1fd8:	ff 92       	push	r15
    1fda:	0f 93       	push	r16
    1fdc:	1f 93       	push	r17
    1fde:	cf 93       	push	r28
    1fe0:	df 93       	push	r29
    1fe2:	cd b7       	in	r28, 0x3d	; 61
    1fe4:	de b7       	in	r29, 0x3e	; 62
    1fe6:	29 97       	sbiw	r28, 0x09	; 9
    1fe8:	cd bf       	out	0x3d, r28	; 61
    1fea:	de bf       	out	0x3e, r29	; 62
    1fec:	e0 91 c0 2c 	lds	r30, 0x2CC0	; 0x802cc0 <xTimerQueue>
    1ff0:	f0 91 c1 2c 	lds	r31, 0x2CC1	; 0x802cc1 <xTimerQueue+0x1>
    1ff4:	30 97       	sbiw	r30, 0x00	; 0
    1ff6:	89 f1       	breq	.+98     	; 0x205a <xTimerGenericCommand+0x90>
    1ff8:	69 83       	std	Y+1, r22	; 0x01
    1ffa:	2a 83       	std	Y+2, r18	; 0x02
    1ffc:	3b 83       	std	Y+3, r19	; 0x03
    1ffe:	4c 83       	std	Y+4, r20	; 0x04
    2000:	5d 83       	std	Y+5, r21	; 0x05
    2002:	8e 83       	std	Y+6, r24	; 0x06
    2004:	9f 83       	std	Y+7, r25	; 0x07
    2006:	66 30       	cpi	r22, 0x06	; 6
    2008:	fc f4       	brge	.+62     	; 0x2048 <xTimerGenericCommand+0x7e>
    200a:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <xTaskGetSchedulerState>
    200e:	82 30       	cpi	r24, 0x02	; 2
    2010:	69 f4       	brne	.+26     	; 0x202c <xTimerGenericCommand+0x62>
    2012:	00 e0       	ldi	r16, 0x00	; 0
    2014:	a7 01       	movw	r20, r14
    2016:	96 01       	movw	r18, r12
    2018:	be 01       	movw	r22, r28
    201a:	6f 5f       	subi	r22, 0xFF	; 255
    201c:	7f 4f       	sbci	r23, 0xFF	; 255
    201e:	80 91 c0 2c 	lds	r24, 0x2CC0	; 0x802cc0 <xTimerQueue>
    2022:	90 91 c1 2c 	lds	r25, 0x2CC1	; 0x802cc1 <xTimerQueue+0x1>
    2026:	0e 94 00 08 	call	0x1000	; 0x1000 <xQueueGenericSend>
    202a:	18 c0       	rjmp	.+48     	; 0x205c <xTimerGenericCommand+0x92>
    202c:	00 e0       	ldi	r16, 0x00	; 0
    202e:	20 e0       	ldi	r18, 0x00	; 0
    2030:	30 e0       	ldi	r19, 0x00	; 0
    2032:	a9 01       	movw	r20, r18
    2034:	be 01       	movw	r22, r28
    2036:	6f 5f       	subi	r22, 0xFF	; 255
    2038:	7f 4f       	sbci	r23, 0xFF	; 255
    203a:	80 91 c0 2c 	lds	r24, 0x2CC0	; 0x802cc0 <xTimerQueue>
    203e:	90 91 c1 2c 	lds	r25, 0x2CC1	; 0x802cc1 <xTimerQueue+0x1>
    2042:	0e 94 00 08 	call	0x1000	; 0x1000 <xQueueGenericSend>
    2046:	0a c0       	rjmp	.+20     	; 0x205c <xTimerGenericCommand+0x92>
    2048:	20 e0       	ldi	r18, 0x00	; 0
    204a:	a8 01       	movw	r20, r16
    204c:	be 01       	movw	r22, r28
    204e:	6f 5f       	subi	r22, 0xFF	; 255
    2050:	7f 4f       	sbci	r23, 0xFF	; 255
    2052:	cf 01       	movw	r24, r30
    2054:	0e 94 a6 08 	call	0x114c	; 0x114c <xQueueGenericSendFromISR>
    2058:	01 c0       	rjmp	.+2      	; 0x205c <xTimerGenericCommand+0x92>
    205a:	80 e0       	ldi	r24, 0x00	; 0
    205c:	29 96       	adiw	r28, 0x09	; 9
    205e:	cd bf       	out	0x3d, r28	; 61
    2060:	de bf       	out	0x3e, r29	; 62
    2062:	df 91       	pop	r29
    2064:	cf 91       	pop	r28
    2066:	1f 91       	pop	r17
    2068:	0f 91       	pop	r16
    206a:	ff 90       	pop	r15
    206c:	ef 90       	pop	r14
    206e:	df 90       	pop	r13
    2070:	cf 90       	pop	r12
    2072:	bf 90       	pop	r11
    2074:	af 90       	pop	r10
    2076:	9f 90       	pop	r9
    2078:	8f 90       	pop	r8
    207a:	08 95       	ret

0000207c <prvSampleTimeNow>:
    207c:	2f 92       	push	r2
    207e:	3f 92       	push	r3
    2080:	4f 92       	push	r4
    2082:	5f 92       	push	r5
    2084:	6f 92       	push	r6
    2086:	7f 92       	push	r7
    2088:	8f 92       	push	r8
    208a:	9f 92       	push	r9
    208c:	af 92       	push	r10
    208e:	bf 92       	push	r11
    2090:	cf 92       	push	r12
    2092:	df 92       	push	r13
    2094:	ef 92       	push	r14
    2096:	ff 92       	push	r15
    2098:	0f 93       	push	r16
    209a:	1f 93       	push	r17
    209c:	cf 93       	push	r28
    209e:	df 93       	push	r29
    20a0:	1c 01       	movw	r2, r24
    20a2:	0e 94 bf 0b 	call	0x177e	; 0x177e <xTaskGetTickCount>
    20a6:	2b 01       	movw	r4, r22
    20a8:	3c 01       	movw	r6, r24
    20aa:	80 91 ba 2c 	lds	r24, 0x2CBA	; 0x802cba <xLastTime.4745>
    20ae:	90 91 bb 2c 	lds	r25, 0x2CBB	; 0x802cbb <xLastTime.4745+0x1>
    20b2:	a0 91 bc 2c 	lds	r26, 0x2CBC	; 0x802cbc <xLastTime.4745+0x2>
    20b6:	b0 91 bd 2c 	lds	r27, 0x2CBD	; 0x802cbd <xLastTime.4745+0x3>
    20ba:	48 16       	cp	r4, r24
    20bc:	59 06       	cpc	r5, r25
    20be:	6a 06       	cpc	r6, r26
    20c0:	7b 06       	cpc	r7, r27
    20c2:	08 f0       	brcs	.+2      	; 0x20c6 <prvSampleTimeNow+0x4a>
    20c4:	54 c0       	rjmp	.+168    	; 0x216e <prvSampleTimeNow+0xf2>
    20c6:	3c c0       	rjmp	.+120    	; 0x2140 <prvSampleTimeNow+0xc4>
    20c8:	07 80       	ldd	r0, Z+7	; 0x07
    20ca:	f0 85       	ldd	r31, Z+8	; 0x08
    20cc:	e0 2d       	mov	r30, r0
    20ce:	80 80       	ld	r8, Z
    20d0:	91 80       	ldd	r9, Z+1	; 0x01
    20d2:	a2 80       	ldd	r10, Z+2	; 0x02
    20d4:	b3 80       	ldd	r11, Z+3	; 0x03
    20d6:	c0 85       	ldd	r28, Z+8	; 0x08
    20d8:	d1 85       	ldd	r29, Z+9	; 0x09
    20da:	8e 01       	movw	r16, r28
    20dc:	0e 5f       	subi	r16, 0xFE	; 254
    20de:	1f 4f       	sbci	r17, 0xFF	; 255
    20e0:	c8 01       	movw	r24, r16
    20e2:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    20e6:	ed 89       	ldd	r30, Y+21	; 0x15
    20e8:	fe 89       	ldd	r31, Y+22	; 0x16
    20ea:	ce 01       	movw	r24, r28
    20ec:	19 95       	eicall
    20ee:	8a 89       	ldd	r24, Y+18	; 0x12
    20f0:	81 30       	cpi	r24, 0x01	; 1
    20f2:	31 f5       	brne	.+76     	; 0x2140 <prvSampleTimeNow+0xc4>
    20f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    20f6:	9f 85       	ldd	r25, Y+15	; 0x0f
    20f8:	a8 89       	ldd	r26, Y+16	; 0x10
    20fa:	b9 89       	ldd	r27, Y+17	; 0x11
    20fc:	88 0d       	add	r24, r8
    20fe:	99 1d       	adc	r25, r9
    2100:	aa 1d       	adc	r26, r10
    2102:	bb 1d       	adc	r27, r11
    2104:	88 16       	cp	r8, r24
    2106:	99 06       	cpc	r9, r25
    2108:	aa 06       	cpc	r10, r26
    210a:	bb 06       	cpc	r11, r27
    210c:	70 f4       	brcc	.+28     	; 0x212a <prvSampleTimeNow+0xae>
    210e:	8a 83       	std	Y+2, r24	; 0x02
    2110:	9b 83       	std	Y+3, r25	; 0x03
    2112:	ac 83       	std	Y+4, r26	; 0x04
    2114:	bd 83       	std	Y+5, r27	; 0x05
    2116:	ca 87       	std	Y+10, r28	; 0x0a
    2118:	db 87       	std	Y+11, r29	; 0x0b
    211a:	b8 01       	movw	r22, r16
    211c:	80 91 c4 2c 	lds	r24, 0x2CC4	; 0x802cc4 <pxCurrentTimerList>
    2120:	90 91 c5 2c 	lds	r25, 0x2CC5	; 0x802cc5 <pxCurrentTimerList+0x1>
    2124:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    2128:	0b c0       	rjmp	.+22     	; 0x2140 <prvSampleTimeNow+0xc4>
    212a:	c1 2c       	mov	r12, r1
    212c:	d1 2c       	mov	r13, r1
    212e:	76 01       	movw	r14, r12
    2130:	00 e0       	ldi	r16, 0x00	; 0
    2132:	10 e0       	ldi	r17, 0x00	; 0
    2134:	a5 01       	movw	r20, r10
    2136:	94 01       	movw	r18, r8
    2138:	60 e0       	ldi	r22, 0x00	; 0
    213a:	ce 01       	movw	r24, r28
    213c:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <xTimerGenericCommand>
    2140:	e0 91 c4 2c 	lds	r30, 0x2CC4	; 0x802cc4 <pxCurrentTimerList>
    2144:	f0 91 c5 2c 	lds	r31, 0x2CC5	; 0x802cc5 <pxCurrentTimerList+0x1>
    2148:	80 81       	ld	r24, Z
    214a:	81 11       	cpse	r24, r1
    214c:	bd cf       	rjmp	.-134    	; 0x20c8 <prvSampleTimeNow+0x4c>
    214e:	80 91 c2 2c 	lds	r24, 0x2CC2	; 0x802cc2 <pxOverflowTimerList>
    2152:	90 91 c3 2c 	lds	r25, 0x2CC3	; 0x802cc3 <pxOverflowTimerList+0x1>
    2156:	80 93 c4 2c 	sts	0x2CC4, r24	; 0x802cc4 <pxCurrentTimerList>
    215a:	90 93 c5 2c 	sts	0x2CC5, r25	; 0x802cc5 <pxCurrentTimerList+0x1>
    215e:	e0 93 c2 2c 	sts	0x2CC2, r30	; 0x802cc2 <pxOverflowTimerList>
    2162:	f0 93 c3 2c 	sts	0x2CC3, r31	; 0x802cc3 <pxOverflowTimerList+0x1>
    2166:	81 e0       	ldi	r24, 0x01	; 1
    2168:	f1 01       	movw	r30, r2
    216a:	80 83       	st	Z, r24
    216c:	02 c0       	rjmp	.+4      	; 0x2172 <prvSampleTimeNow+0xf6>
    216e:	f1 01       	movw	r30, r2
    2170:	10 82       	st	Z, r1
    2172:	40 92 ba 2c 	sts	0x2CBA, r4	; 0x802cba <xLastTime.4745>
    2176:	50 92 bb 2c 	sts	0x2CBB, r5	; 0x802cbb <xLastTime.4745+0x1>
    217a:	60 92 bc 2c 	sts	0x2CBC, r6	; 0x802cbc <xLastTime.4745+0x2>
    217e:	70 92 bd 2c 	sts	0x2CBD, r7	; 0x802cbd <xLastTime.4745+0x3>
    2182:	c3 01       	movw	r24, r6
    2184:	b2 01       	movw	r22, r4
    2186:	df 91       	pop	r29
    2188:	cf 91       	pop	r28
    218a:	1f 91       	pop	r17
    218c:	0f 91       	pop	r16
    218e:	ff 90       	pop	r15
    2190:	ef 90       	pop	r14
    2192:	df 90       	pop	r13
    2194:	cf 90       	pop	r12
    2196:	bf 90       	pop	r11
    2198:	af 90       	pop	r10
    219a:	9f 90       	pop	r9
    219c:	8f 90       	pop	r8
    219e:	7f 90       	pop	r7
    21a0:	6f 90       	pop	r6
    21a2:	5f 90       	pop	r5
    21a4:	4f 90       	pop	r4
    21a6:	3f 90       	pop	r3
    21a8:	2f 90       	pop	r2
    21aa:	08 95       	ret

000021ac <prvTimerTask>:
    21ac:	cf 93       	push	r28
    21ae:	df 93       	push	r29
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
    21b4:	2e 97       	sbiw	r28, 0x0e	; 14
    21b6:	cd bf       	out	0x3d, r28	; 61
    21b8:	de bf       	out	0x3e, r29	; 62
    21ba:	ce 01       	movw	r24, r28
    21bc:	01 96       	adiw	r24, 0x01	; 1
    21be:	1c 01       	movw	r2, r24
    21c0:	a8 2e       	mov	r10, r24
    21c2:	b3 2c       	mov	r11, r3
    21c4:	e0 91 c4 2c 	lds	r30, 0x2CC4	; 0x802cc4 <pxCurrentTimerList>
    21c8:	f0 91 c5 2c 	lds	r31, 0x2CC5	; 0x802cc5 <pxCurrentTimerList+0x1>
    21cc:	80 81       	ld	r24, Z
    21ce:	88 23       	and	r24, r24
    21d0:	09 f4       	brne	.+2      	; 0x21d4 <prvTimerTask+0x28>
    21d2:	03 c1       	rjmp	.+518    	; 0x23da <prvTimerTask+0x22e>
    21d4:	07 80       	ldd	r0, Z+7	; 0x07
    21d6:	f0 85       	ldd	r31, Z+8	; 0x08
    21d8:	e0 2d       	mov	r30, r0
    21da:	40 80       	ld	r4, Z
    21dc:	51 80       	ldd	r5, Z+1	; 0x01
    21de:	62 80       	ldd	r6, Z+2	; 0x02
    21e0:	73 80       	ldd	r7, Z+3	; 0x03
    21e2:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    21e6:	c1 01       	movw	r24, r2
    21e8:	0e 94 3e 10 	call	0x207c	; 0x207c <prvSampleTimeNow>
    21ec:	6b 87       	std	Y+11, r22	; 0x0b
    21ee:	7c 87       	std	Y+12, r23	; 0x0c
    21f0:	8d 87       	std	Y+13, r24	; 0x0d
    21f2:	9e 87       	std	Y+14, r25	; 0x0e
    21f4:	89 81       	ldd	r24, Y+1	; 0x01
    21f6:	81 11       	cpse	r24, r1
    21f8:	5e c0       	rjmp	.+188    	; 0x22b6 <prvTimerTask+0x10a>
    21fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    21fc:	9c 85       	ldd	r25, Y+12	; 0x0c
    21fe:	ad 85       	ldd	r26, Y+13	; 0x0d
    2200:	be 85       	ldd	r27, Y+14	; 0x0e
    2202:	84 15       	cp	r24, r4
    2204:	95 05       	cpc	r25, r5
    2206:	a6 05       	cpc	r26, r6
    2208:	b7 05       	cpc	r27, r7
    220a:	e8 f1       	brcs	.+122    	; 0x2286 <prvTimerTask+0xda>
    220c:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    2210:	e0 91 c4 2c 	lds	r30, 0x2CC4	; 0x802cc4 <pxCurrentTimerList>
    2214:	f0 91 c5 2c 	lds	r31, 0x2CC5	; 0x802cc5 <pxCurrentTimerList+0x1>
    2218:	07 80       	ldd	r0, Z+7	; 0x07
    221a:	f0 85       	ldd	r31, Z+8	; 0x08
    221c:	e0 2d       	mov	r30, r0
    221e:	80 84       	ldd	r8, Z+8	; 0x08
    2220:	91 84       	ldd	r9, Z+9	; 0x09
    2222:	c4 01       	movw	r24, r8
    2224:	02 96       	adiw	r24, 0x02	; 2
    2226:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    222a:	d4 01       	movw	r26, r8
    222c:	52 96       	adiw	r26, 0x12	; 18
    222e:	8c 91       	ld	r24, X
    2230:	52 97       	sbiw	r26, 0x12	; 18
    2232:	81 30       	cpi	r24, 0x01	; 1
    2234:	01 f5       	brne	.+64     	; 0x2276 <prvTimerTask+0xca>
    2236:	1e 96       	adiw	r26, 0x0e	; 14
    2238:	4d 91       	ld	r20, X+
    223a:	5d 91       	ld	r21, X+
    223c:	6d 91       	ld	r22, X+
    223e:	7c 91       	ld	r23, X
    2240:	51 97       	sbiw	r26, 0x11	; 17
    2242:	44 0d       	add	r20, r4
    2244:	55 1d       	adc	r21, r5
    2246:	66 1d       	adc	r22, r6
    2248:	77 1d       	adc	r23, r7
    224a:	73 01       	movw	r14, r6
    224c:	62 01       	movw	r12, r4
    224e:	0b 85       	ldd	r16, Y+11	; 0x0b
    2250:	1c 85       	ldd	r17, Y+12	; 0x0c
    2252:	2d 85       	ldd	r18, Y+13	; 0x0d
    2254:	3e 85       	ldd	r19, Y+14	; 0x0e
    2256:	c4 01       	movw	r24, r8
    2258:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <prvInsertTimerInActiveList>
    225c:	88 23       	and	r24, r24
    225e:	59 f0       	breq	.+22     	; 0x2276 <prvTimerTask+0xca>
    2260:	c1 2c       	mov	r12, r1
    2262:	d1 2c       	mov	r13, r1
    2264:	76 01       	movw	r14, r12
    2266:	00 e0       	ldi	r16, 0x00	; 0
    2268:	10 e0       	ldi	r17, 0x00	; 0
    226a:	a3 01       	movw	r20, r6
    226c:	92 01       	movw	r18, r4
    226e:	60 e0       	ldi	r22, 0x00	; 0
    2270:	c4 01       	movw	r24, r8
    2272:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <xTimerGenericCommand>
    2276:	d4 01       	movw	r26, r8
    2278:	55 96       	adiw	r26, 0x15	; 21
    227a:	ed 91       	ld	r30, X+
    227c:	fc 91       	ld	r31, X
    227e:	56 97       	sbiw	r26, 0x16	; 22
    2280:	c4 01       	movw	r24, r8
    2282:	19 95       	eicall
    2284:	9c c0       	rjmp	.+312    	; 0x23be <prvTimerTask+0x212>
    2286:	20 e0       	ldi	r18, 0x00	; 0
    2288:	b3 01       	movw	r22, r6
    228a:	a2 01       	movw	r20, r4
    228c:	8b 85       	ldd	r24, Y+11	; 0x0b
    228e:	9c 85       	ldd	r25, Y+12	; 0x0c
    2290:	ad 85       	ldd	r26, Y+13	; 0x0d
    2292:	be 85       	ldd	r27, Y+14	; 0x0e
    2294:	48 1b       	sub	r20, r24
    2296:	59 0b       	sbc	r21, r25
    2298:	6a 0b       	sbc	r22, r26
    229a:	7b 0b       	sbc	r23, r27
    229c:	80 91 c0 2c 	lds	r24, 0x2CC0	; 0x802cc0 <xTimerQueue>
    22a0:	90 91 c1 2c 	lds	r25, 0x2CC1	; 0x802cc1 <xTimerQueue+0x1>
    22a4:	0e 94 9d 09 	call	0x133a	; 0x133a <vQueueWaitForMessageRestricted>
    22a8:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    22ac:	81 11       	cpse	r24, r1
    22ae:	87 c0       	rjmp	.+270    	; 0x23be <prvTimerTask+0x212>
    22b0:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    22b4:	84 c0       	rjmp	.+264    	; 0x23be <prvTimerTask+0x212>
    22b6:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    22ba:	81 c0       	rjmp	.+258    	; 0x23be <prvTimerTask+0x212>
    22bc:	89 81       	ldd	r24, Y+1	; 0x01
    22be:	88 23       	and	r24, r24
    22c0:	6c f4       	brge	.+26     	; 0x22dc <prvTimerTask+0x130>
    22c2:	4e 81       	ldd	r20, Y+6	; 0x06
    22c4:	5f 81       	ldd	r21, Y+7	; 0x07
    22c6:	68 85       	ldd	r22, Y+8	; 0x08
    22c8:	79 85       	ldd	r23, Y+9	; 0x09
    22ca:	ea 81       	ldd	r30, Y+2	; 0x02
    22cc:	fb 81       	ldd	r31, Y+3	; 0x03
    22ce:	8c 81       	ldd	r24, Y+4	; 0x04
    22d0:	9d 81       	ldd	r25, Y+5	; 0x05
    22d2:	19 95       	eicall
    22d4:	89 81       	ldd	r24, Y+1	; 0x01
    22d6:	88 23       	and	r24, r24
    22d8:	0c f4       	brge	.+2      	; 0x22dc <prvTimerTask+0x130>
    22da:	71 c0       	rjmp	.+226    	; 0x23be <prvTimerTask+0x212>
    22dc:	8e 80       	ldd	r8, Y+6	; 0x06
    22de:	9f 80       	ldd	r9, Y+7	; 0x07
    22e0:	d4 01       	movw	r26, r8
    22e2:	1c 96       	adiw	r26, 0x0c	; 12
    22e4:	8d 91       	ld	r24, X+
    22e6:	9c 91       	ld	r25, X
    22e8:	1d 97       	sbiw	r26, 0x0d	; 13
    22ea:	89 2b       	or	r24, r25
    22ec:	21 f0       	breq	.+8      	; 0x22f6 <prvTimerTask+0x14a>
    22ee:	c4 01       	movw	r24, r8
    22f0:	02 96       	adiw	r24, 0x02	; 2
    22f2:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    22f6:	ce 01       	movw	r24, r28
    22f8:	0a 96       	adiw	r24, 0x0a	; 10
    22fa:	0e 94 3e 10 	call	0x207c	; 0x207c <prvSampleTimeNow>
    22fe:	8b 01       	movw	r16, r22
    2300:	9c 01       	movw	r18, r24
    2302:	89 81       	ldd	r24, Y+1	; 0x01
    2304:	08 2e       	mov	r0, r24
    2306:	00 0c       	add	r0, r0
    2308:	99 0b       	sbc	r25, r25
    230a:	aa 0b       	sbc	r26, r26
    230c:	bb 0b       	sbc	r27, r27
    230e:	8a 30       	cpi	r24, 0x0A	; 10
    2310:	91 05       	cpc	r25, r1
    2312:	08 f0       	brcs	.+2      	; 0x2316 <prvTimerTask+0x16a>
    2314:	54 c0       	rjmp	.+168    	; 0x23be <prvTimerTask+0x212>
    2316:	fc 01       	movw	r30, r24
    2318:	88 27       	eor	r24, r24
    231a:	e2 50       	subi	r30, 0x02	; 2
    231c:	ff 4f       	sbci	r31, 0xFF	; 255
    231e:	8f 4f       	sbci	r24, 0xFF	; 255
    2320:	0c 94 e7 1d 	jmp	0x3bce	; 0x3bce <__tablejump2__>
    2324:	ca 80       	ldd	r12, Y+2	; 0x02
    2326:	db 80       	ldd	r13, Y+3	; 0x03
    2328:	ec 80       	ldd	r14, Y+4	; 0x04
    232a:	fd 80       	ldd	r15, Y+5	; 0x05
    232c:	f4 01       	movw	r30, r8
    232e:	46 85       	ldd	r20, Z+14	; 0x0e
    2330:	57 85       	ldd	r21, Z+15	; 0x0f
    2332:	60 89       	ldd	r22, Z+16	; 0x10
    2334:	71 89       	ldd	r23, Z+17	; 0x11
    2336:	4c 0d       	add	r20, r12
    2338:	5d 1d       	adc	r21, r13
    233a:	6e 1d       	adc	r22, r14
    233c:	7f 1d       	adc	r23, r15
    233e:	c4 01       	movw	r24, r8
    2340:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <prvInsertTimerInActiveList>
    2344:	88 23       	and	r24, r24
    2346:	d9 f1       	breq	.+118    	; 0x23be <prvTimerTask+0x212>
    2348:	d4 01       	movw	r26, r8
    234a:	55 96       	adiw	r26, 0x15	; 21
    234c:	ed 91       	ld	r30, X+
    234e:	fc 91       	ld	r31, X
    2350:	56 97       	sbiw	r26, 0x16	; 22
    2352:	c4 01       	movw	r24, r8
    2354:	19 95       	eicall
    2356:	f4 01       	movw	r30, r8
    2358:	82 89       	ldd	r24, Z+18	; 0x12
    235a:	81 30       	cpi	r24, 0x01	; 1
    235c:	81 f5       	brne	.+96     	; 0x23be <prvTimerTask+0x212>
    235e:	4a 81       	ldd	r20, Y+2	; 0x02
    2360:	5b 81       	ldd	r21, Y+3	; 0x03
    2362:	6c 81       	ldd	r22, Y+4	; 0x04
    2364:	7d 81       	ldd	r23, Y+5	; 0x05
    2366:	86 85       	ldd	r24, Z+14	; 0x0e
    2368:	97 85       	ldd	r25, Z+15	; 0x0f
    236a:	a0 89       	ldd	r26, Z+16	; 0x10
    236c:	b1 89       	ldd	r27, Z+17	; 0x11
    236e:	9a 01       	movw	r18, r20
    2370:	ab 01       	movw	r20, r22
    2372:	28 0f       	add	r18, r24
    2374:	39 1f       	adc	r19, r25
    2376:	4a 1f       	adc	r20, r26
    2378:	5b 1f       	adc	r21, r27
    237a:	c1 2c       	mov	r12, r1
    237c:	d1 2c       	mov	r13, r1
    237e:	76 01       	movw	r14, r12
    2380:	00 e0       	ldi	r16, 0x00	; 0
    2382:	10 e0       	ldi	r17, 0x00	; 0
    2384:	60 e0       	ldi	r22, 0x00	; 0
    2386:	c4 01       	movw	r24, r8
    2388:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <xTimerGenericCommand>
    238c:	18 c0       	rjmp	.+48     	; 0x23be <prvTimerTask+0x212>
    238e:	4a 81       	ldd	r20, Y+2	; 0x02
    2390:	5b 81       	ldd	r21, Y+3	; 0x03
    2392:	6c 81       	ldd	r22, Y+4	; 0x04
    2394:	7d 81       	ldd	r23, Y+5	; 0x05
    2396:	d4 01       	movw	r26, r8
    2398:	1e 96       	adiw	r26, 0x0e	; 14
    239a:	4d 93       	st	X+, r20
    239c:	5d 93       	st	X+, r21
    239e:	6d 93       	st	X+, r22
    23a0:	7c 93       	st	X, r23
    23a2:	51 97       	sbiw	r26, 0x11	; 17
    23a4:	40 0f       	add	r20, r16
    23a6:	51 1f       	adc	r21, r17
    23a8:	62 1f       	adc	r22, r18
    23aa:	73 1f       	adc	r23, r19
    23ac:	68 01       	movw	r12, r16
    23ae:	79 01       	movw	r14, r18
    23b0:	c4 01       	movw	r24, r8
    23b2:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <prvInsertTimerInActiveList>
    23b6:	03 c0       	rjmp	.+6      	; 0x23be <prvTimerTask+0x212>
    23b8:	c4 01       	movw	r24, r8
    23ba:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortFree>
    23be:	20 e0       	ldi	r18, 0x00	; 0
    23c0:	30 e0       	ldi	r19, 0x00	; 0
    23c2:	a9 01       	movw	r20, r18
    23c4:	6a 2d       	mov	r22, r10
    23c6:	7b 2d       	mov	r23, r11
    23c8:	80 91 c0 2c 	lds	r24, 0x2CC0	; 0x802cc0 <xTimerQueue>
    23cc:	90 91 c1 2c 	lds	r25, 0x2CC1	; 0x802cc1 <xTimerQueue+0x1>
    23d0:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <xQueueReceive>
    23d4:	81 11       	cpse	r24, r1
    23d6:	72 cf       	rjmp	.-284    	; 0x22bc <prvTimerTask+0x110>
    23d8:	f5 ce       	rjmp	.-534    	; 0x21c4 <prvTimerTask+0x18>
    23da:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    23de:	c1 01       	movw	r24, r2
    23e0:	0e 94 3e 10 	call	0x207c	; 0x207c <prvSampleTimeNow>
    23e4:	6b 87       	std	Y+11, r22	; 0x0b
    23e6:	7c 87       	std	Y+12, r23	; 0x0c
    23e8:	8d 87       	std	Y+13, r24	; 0x0d
    23ea:	9e 87       	std	Y+14, r25	; 0x0e
    23ec:	89 81       	ldd	r24, Y+1	; 0x01
    23ee:	81 11       	cpse	r24, r1
    23f0:	62 cf       	rjmp	.-316    	; 0x22b6 <prvTimerTask+0x10a>
    23f2:	e0 91 c2 2c 	lds	r30, 0x2CC2	; 0x802cc2 <pxOverflowTimerList>
    23f6:	f0 91 c3 2c 	lds	r31, 0x2CC3	; 0x802cc3 <pxOverflowTimerList+0x1>
    23fa:	80 81       	ld	r24, Z
    23fc:	21 e0       	ldi	r18, 0x01	; 1
    23fe:	81 11       	cpse	r24, r1
    2400:	20 e0       	ldi	r18, 0x00	; 0
    2402:	41 2c       	mov	r4, r1
    2404:	51 2c       	mov	r5, r1
    2406:	32 01       	movw	r6, r4
    2408:	3f cf       	rjmp	.-386    	; 0x2288 <prvTimerTask+0xdc>

0000240a <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
    240a:	0f 93       	push	r16
    240c:	1f 93       	push	r17
    240e:	cf 93       	push	r28
    2410:	df 93       	push	r29
    2412:	cd b7       	in	r28, 0x3d	; 61
    2414:	de b7       	in	r29, 0x3e	; 62
    2416:	29 97       	sbiw	r28, 0x09	; 9
    2418:	cd bf       	out	0x3d, r28	; 61
    241a:	de bf       	out	0x3e, r29	; 62
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    241c:	ee ef       	ldi	r30, 0xFE	; 254
    241e:	e9 83       	std	Y+1, r30	; 0x01
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    2420:	8a 83       	std	Y+2, r24	; 0x02
    2422:	9b 83       	std	Y+3, r25	; 0x03
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    2424:	6c 83       	std	Y+4, r22	; 0x04
    2426:	7d 83       	std	Y+5, r23	; 0x05
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    2428:	2e 83       	std	Y+6, r18	; 0x06
    242a:	3f 83       	std	Y+7, r19	; 0x07
    242c:	48 87       	std	Y+8, r20	; 0x08
    242e:	59 87       	std	Y+9, r21	; 0x09

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2430:	20 e0       	ldi	r18, 0x00	; 0
    2432:	a8 01       	movw	r20, r16
    2434:	be 01       	movw	r22, r28
    2436:	6f 5f       	subi	r22, 0xFF	; 255
    2438:	7f 4f       	sbci	r23, 0xFF	; 255
    243a:	80 91 c0 2c 	lds	r24, 0x2CC0	; 0x802cc0 <xTimerQueue>
    243e:	90 91 c1 2c 	lds	r25, 0x2CC1	; 0x802cc1 <xTimerQueue+0x1>
    2442:	0e 94 a6 08 	call	0x114c	; 0x114c <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
    2446:	29 96       	adiw	r28, 0x09	; 9
    2448:	cd bf       	out	0x3d, r28	; 61
    244a:	de bf       	out	0x3e, r29	; 62
    244c:	df 91       	pop	r29
    244e:	cf 91       	pop	r28
    2450:	1f 91       	pop	r17
    2452:	0f 91       	pop	r16
    2454:	08 95       	ret

00002456 <vInitClock>:
#include "clksys_driver.h"


void vInitClock(void)
{
	CLKSYS_Enable( OSC_RC2MEN_bm );
    2456:	e0 e5       	ldi	r30, 0x50	; 80
    2458:	f0 e0       	ldi	r31, 0x00	; 0
    245a:	80 81       	ld	r24, Z
    245c:	81 60       	ori	r24, 0x01	; 1
    245e:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC2MRDY_bm ) == 0 );
    2460:	81 81       	ldd	r24, Z+1	; 0x01
    2462:	80 ff       	sbrs	r24, 0
    2464:	fd cf       	rjmp	.-6      	; 0x2460 <vInitClock+0xa>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC2M_gc );
    2466:	80 e0       	ldi	r24, 0x00	; 0
    2468:	0e 94 77 02 	call	0x4ee	; 0x4ee <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
    246c:	8e e1       	ldi	r24, 0x1E	; 30
    246e:	0e 94 67 02 	call	0x4ce	; 0x4ce <CLKSYS_Disable>
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    2472:	60 e0       	ldi	r22, 0x00	; 0
    2474:	80 e0       	ldi	r24, 0x00	; 0
    2476:	0e 94 71 02 	call	0x4e2	; 0x4e2 <CLKSYS_Prescalers_Config>
	CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,false,OSC_XOSCSEL_XTAL_256CLK_gc );
    247a:	43 e0       	ldi	r20, 0x03	; 3
    247c:	60 e0       	ldi	r22, 0x00	; 0
    247e:	80 e4       	ldi	r24, 0x40	; 64
    2480:	0e 94 58 02 	call	0x4b0	; 0x4b0 <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
    2484:	e0 e5       	ldi	r30, 0x50	; 80
    2486:	f0 e0       	ldi	r31, 0x00	; 0
    2488:	80 81       	ld	r24, Z
    248a:	88 60       	ori	r24, 0x08	; 8
    248c:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    248e:	81 81       	ldd	r24, Z+1	; 0x01
    2490:	83 ff       	sbrs	r24, 3
    2492:	fd cf       	rjmp	.-6      	; 0x248e <vInitClock+0x38>
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 4 );
    2494:	64 e0       	ldi	r22, 0x04	; 4
    2496:	80 ec       	ldi	r24, 0xC0	; 192
    2498:	0e 94 62 02 	call	0x4c4	; 0x4c4 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    249c:	e0 e5       	ldi	r30, 0x50	; 80
    249e:	f0 e0       	ldi	r31, 0x00	; 0
    24a0:	80 81       	ld	r24, Z
    24a2:	80 61       	ori	r24, 0x10	; 16
    24a4:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    24a6:	60 e0       	ldi	r22, 0x00	; 0
    24a8:	80 e0       	ldi	r24, 0x00	; 0
    24aa:	0e 94 71 02 	call	0x4e2	; 0x4e2 <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    24ae:	e0 e5       	ldi	r30, 0x50	; 80
    24b0:	f0 e0       	ldi	r31, 0x00	; 0
    24b2:	81 81       	ldd	r24, Z+1	; 0x01
    24b4:	84 ff       	sbrs	r24, 4
    24b6:	fd cf       	rjmp	.-6      	; 0x24b2 <vInitClock+0x5c>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    24b8:	84 e0       	ldi	r24, 0x04	; 4
    24ba:	0e 94 77 02 	call	0x4ee	; 0x4ee <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm);
    24be:	87 e0       	ldi	r24, 0x07	; 7
    24c0:	0e 94 67 02 	call	0x4ce	; 0x4ce <CLKSYS_Disable>
    24c4:	08 95       	ret

000024c6 <vLedBlink>:
	return 0;
}

void vLedBlink(void *pvParameters) {
	(void) pvParameters;
	PORTF.DIRSET = PIN0_bm; /*LED1*/
    24c6:	e0 ea       	ldi	r30, 0xA0	; 160
    24c8:	f6 e0       	ldi	r31, 0x06	; 6
    24ca:	81 e0       	ldi	r24, 0x01	; 1
    24cc:	81 83       	std	Z+1, r24	; 0x01
	PORTF.OUT = 0x01;
    24ce:	84 83       	std	Z+4, r24	; 0x04
	for(;;) {
		//PORTF.OUTTGL = 0x01;				
		vTaskDelay(100 / portTICK_RATE_MS);
    24d0:	64 e6       	ldi	r22, 0x64	; 100
    24d2:	70 e0       	ldi	r23, 0x00	; 0
    24d4:	80 e0       	ldi	r24, 0x00	; 0
    24d6:	90 e0       	ldi	r25, 0x00	; 0
    24d8:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
    24dc:	f9 cf       	rjmp	.-14     	; 0x24d0 <vLedBlink+0xa>

000024de <vWrite_Display>:
void vWrite_Display(void *pvParameters){
	EventBits_t uxBits;
	for (;;)
	{
			vDisplayClear();
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    24de:	0f 2e       	mov	r0, r31
    24e0:	fd e0       	ldi	r31, 0x0D	; 13
    24e2:	ef 2e       	mov	r14, r31
    24e4:	f0 e2       	ldi	r31, 0x20	; 32
    24e6:	ff 2e       	mov	r15, r31
    24e8:	f0 2d       	mov	r31, r0
			vDisplayWriteStringAtPos(1,0,"buffer_a:b %d : %d",buffer_a[1],buffer_b[1]);
    24ea:	0f 2e       	mov	r0, r31
    24ec:	f0 e0       	ldi	r31, 0x00	; 0
    24ee:	af 2e       	mov	r10, r31
    24f0:	ff e2       	ldi	r31, 0x2F	; 47
    24f2:	bf 2e       	mov	r11, r31
    24f4:	f0 2d       	mov	r31, r0
    24f6:	0f 2e       	mov	r0, r31
    24f8:	f2 e0       	ldi	r31, 0x02	; 2
    24fa:	cf 2e       	mov	r12, r31
    24fc:	f7 e3       	ldi	r31, 0x37	; 55
    24fe:	df 2e       	mov	r13, r31
    2500:	f0 2d       	mov	r31, r0
    2502:	0d e1       	ldi	r16, 0x1D	; 29
    2504:	10 e2       	ldi	r17, 0x20	; 32
    2506:	55 24       	eor	r5, r5
    2508:	53 94       	inc	r5
			vDisplayWriteStringAtPos(2,0,"peak: %d  : %d ",high_peak_a,high_peak_b);
    250a:	c0 e3       	ldi	r28, 0x30	; 48
    250c:	d0 e2       	ldi	r29, 0x20	; 32
    250e:	68 94       	set
    2510:	66 24       	eor	r6, r6
    2512:	61 f8       	bld	r6, 1
			vDisplayWriteStringAtPos(3,0,"Status: %d",sinus_status);
    2514:	0f 2e       	mov	r0, r31
    2516:	f0 e4       	ldi	r31, 0x40	; 64
    2518:	8f 2e       	mov	r8, r31
    251a:	f0 e2       	ldi	r31, 0x20	; 32
    251c:	9f 2e       	mov	r9, r31
    251e:	f0 2d       	mov	r31, r0
    2520:	0f 2e       	mov	r0, r31
    2522:	f3 e0       	ldi	r31, 0x03	; 3
    2524:	7f 2e       	mov	r7, r31
    2526:	f0 2d       	mov	r31, r0
}
void vWrite_Display(void *pvParameters){
	EventBits_t uxBits;
	for (;;)
	{
			vDisplayClear();
    2528:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <vDisplayClear>
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    252c:	ff 92       	push	r15
    252e:	ef 92       	push	r14
    2530:	1f 92       	push	r1
    2532:	1f 92       	push	r1
    2534:	1f 92       	push	r1
    2536:	1f 92       	push	r1
    2538:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(1,0,"buffer_a:b %d : %d",buffer_a[1],buffer_b[1]);
    253c:	f5 01       	movw	r30, r10
    253e:	91 81       	ldd	r25, Z+1	; 0x01
    2540:	f6 01       	movw	r30, r12
    2542:	81 81       	ldd	r24, Z+1	; 0x01
    2544:	1f 92       	push	r1
    2546:	9f 93       	push	r25
    2548:	1f 92       	push	r1
    254a:	8f 93       	push	r24
    254c:	1f 93       	push	r17
    254e:	0f 93       	push	r16
    2550:	1f 92       	push	r1
    2552:	1f 92       	push	r1
    2554:	1f 92       	push	r1
    2556:	5f 92       	push	r5
    2558:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(2,0,"peak: %d  : %d ",high_peak_a,high_peak_b);
    255c:	80 91 0c 3f 	lds	r24, 0x3F0C	; 0x803f0c <high_peak_b+0x1>
    2560:	8f 93       	push	r24
    2562:	80 91 0b 3f 	lds	r24, 0x3F0B	; 0x803f0b <high_peak_b>
    2566:	8f 93       	push	r24
    2568:	80 91 06 3f 	lds	r24, 0x3F06	; 0x803f06 <high_peak_a+0x1>
    256c:	8f 93       	push	r24
    256e:	80 91 05 3f 	lds	r24, 0x3F05	; 0x803f05 <high_peak_a>
    2572:	8f 93       	push	r24
    2574:	df 93       	push	r29
    2576:	cf 93       	push	r28
    2578:	1f 92       	push	r1
    257a:	1f 92       	push	r1
    257c:	1f 92       	push	r1
    257e:	6f 92       	push	r6
    2580:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(3,0,"Status: %d",sinus_status);
    2584:	80 91 1c 3f 	lds	r24, 0x3F1C	; 0x803f1c <sinus_status+0x1>
    2588:	8f 93       	push	r24
    258a:	80 91 1b 3f 	lds	r24, 0x3F1B	; 0x803f1b <sinus_status>
    258e:	8f 93       	push	r24
    2590:	9f 92       	push	r9
    2592:	8f 92       	push	r8
    2594:	1f 92       	push	r1
    2596:	1f 92       	push	r1
    2598:	1f 92       	push	r1
    259a:	7f 92       	push	r7
    259c:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <vDisplayWriteStringAtPos>
			vTaskStartScheduler();
    25a0:	ed b7       	in	r30, 0x3d	; 61
    25a2:	fe b7       	in	r31, 0x3e	; 62
    25a4:	b2 96       	adiw	r30, 0x22	; 34
    25a6:	ed bf       	out	0x3d, r30	; 61
    25a8:	fe bf       	out	0x3e, r31	; 62
    25aa:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <vTaskStartScheduler>
			vTaskDelay(100 / portTICK_RATE_MS);
    25ae:	64 e6       	ldi	r22, 0x64	; 100
    25b0:	70 e0       	ldi	r23, 0x00	; 0
    25b2:	80 e0       	ldi	r24, 0x00	; 0
    25b4:	90 e0       	ldi	r25, 0x00	; 0
    25b6:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
    25ba:	b6 cf       	rjmp	.-148    	; 0x2528 <vWrite_Display+0x4a>

000025bc <vRead_DMA>:
	int i = 0;
	int pos_peak_array[2047], neg_peak_array[2047], position_pos_array[2047], position_neg_array[2047];
	EventBits_t uxBits;
	for (;;)
	{			
		uxBits = xEventGroupWaitBits(
    25bc:	cc 24       	eor	r12, r12
    25be:	ca 94       	dec	r12
    25c0:	dc 2c       	mov	r13, r12
    25c2:	76 01       	movw	r14, r12
    25c4:	00 e0       	ldi	r16, 0x00	; 0
    25c6:	21 e0       	ldi	r18, 0x01	; 1
    25c8:	43 e0       	ldi	r20, 0x03	; 3
    25ca:	50 e0       	ldi	r21, 0x00	; 0
    25cc:	60 e0       	ldi	r22, 0x00	; 0
    25ce:	70 e0       	ldi	r23, 0x00	; 0
    25d0:	80 91 02 2e 	lds	r24, 0x2E02	; 0x802e02 <xSignalProcessEventGroup>
    25d4:	90 91 03 2e 	lds	r25, 0x2E03	; 0x802e03 <xSignalProcessEventGroup+0x1>
    25d8:	0e 94 bd 02 	call	0x57a	; 0x57a <xEventGroupWaitBits>
								Process_Signal_BufferA | Process_Signal_BufferB, /* The bits within the event group to wait for. */
								pdTRUE,        /* Bits should be cleared before returning. */
								pdFALSE,       /* Don't wait for both bits, either bit will do. */
								portMAX_DELAY );/* Wait a maximum for either bit to be set. */								
		//process signal values
			if (uxBits & Process_Signal_BufferA) // if "BufferA" bit is set, read out bufferA
    25dc:	60 ff       	sbrs	r22, 0
    25de:	92 c0       	rjmp	.+292    	; 0x2704 <vRead_DMA+0x148>
    25e0:	c0 90 07 3f 	lds	r12, 0x3F07	; 0x803f07 <position_high_peak_a>
    25e4:	d0 90 08 3f 	lds	r13, 0x3F08	; 0x803f08 <position_high_peak_a+0x1>
    25e8:	60 91 0f 3f 	lds	r22, 0x3F0F	; 0x803f0f <low_peak_a>
    25ec:	70 91 10 3f 	lds	r23, 0x3F10	; 0x803f10 <low_peak_a+0x1>
    25f0:	e0 90 13 3f 	lds	r14, 0x3F13	; 0x803f13 <position_low_peak_a>
    25f4:	f0 90 14 3f 	lds	r15, 0x3F14	; 0x803f14 <position_low_peak_a+0x1>
    25f8:	00 91 1b 3f 	lds	r16, 0x3F1B	; 0x803f1b <sinus_status>
    25fc:	10 91 1c 3f 	lds	r17, 0x3F1C	; 0x803f1c <sinus_status+0x1>
    2600:	a0 91 15 3f 	lds	r26, 0x3F15	; 0x803f15 <count_after_high_peak>
    2604:	b0 91 16 3f 	lds	r27, 0x3F16	; 0x803f16 <count_after_high_peak+0x1>
    2608:	40 91 05 3f 	lds	r20, 0x3F05	; 0x803f05 <high_peak_a>
    260c:	50 91 06 3f 	lds	r21, 0x3F06	; 0x803f06 <high_peak_a+0x1>
    2610:	c0 91 17 3f 	lds	r28, 0x3F17	; 0x803f17 <count_after_low_peak>
    2614:	d0 91 18 3f 	lds	r29, 0x3F18	; 0x803f18 <count_after_low_peak+0x1>
    2618:	80 e0       	ldi	r24, 0x00	; 0
    261a:	90 e0       	ldi	r25, 0x00	; 0
			{
				for(i=0;i<2047;i++)
				{
					if (buffer_a[i] > high_peak_a)	//if buffer bigger than current high_peak
    261c:	fc 01       	movw	r30, r24
    261e:	ee 5f       	subi	r30, 0xFE	; 254
    2620:	f8 4c       	sbci	r31, 0xC8	; 200
    2622:	20 81       	ld	r18, Z
    2624:	30 e0       	ldi	r19, 0x00	; 0
    2626:	42 17       	cp	r20, r18
    2628:	53 07       	cpc	r21, r19
    262a:	44 f4       	brge	.+16     	; 0x263c <vRead_DMA+0x80>
					{
						high_peak_a = buffer_a[i];	// store new peak
    262c:	fc 01       	movw	r30, r24
    262e:	ee 5f       	subi	r30, 0xFE	; 254
    2630:	f8 4c       	sbci	r31, 0xC8	; 200
    2632:	40 81       	ld	r20, Z
    2634:	50 e0       	ldi	r21, 0x00	; 0
						position_high_peak_a = i;	// store array position of new peak
    2636:	c8 2e       	mov	r12, r24
    2638:	d9 2e       	mov	r13, r25
    263a:	10 c0       	rjmp	.+32     	; 0x265c <vRead_DMA+0xa0>
					}				
					else if(100 < buffer_a[i] < high_peak_a)
    263c:	fc 01       	movw	r30, r24
    263e:	ee 5f       	subi	r30, 0xFE	; 254
    2640:	f8 4c       	sbci	r31, 0xC8	; 200
    2642:	e0 81       	ld	r30, Z
    2644:	21 e0       	ldi	r18, 0x01	; 1
    2646:	30 e0       	ldi	r19, 0x00	; 0
    2648:	e5 36       	cpi	r30, 0x65	; 101
    264a:	10 f4       	brcc	.+4      	; 0x2650 <vRead_DMA+0x94>
    264c:	20 e0       	ldi	r18, 0x00	; 0
    264e:	30 e0       	ldi	r19, 0x00	; 0
    2650:	24 17       	cp	r18, r20
    2652:	35 07       	cpc	r19, r21
    2654:	1c f4       	brge	.+6      	; 0x265c <vRead_DMA+0xa0>
					{
						count_after_high_peak++;	//count up -> to make sure, that it's no distortion
    2656:	11 96       	adiw	r26, 0x01	; 1
						sinus_status = 1;		// status
    2658:	01 e0       	ldi	r16, 0x01	; 1
    265a:	10 e0       	ldi	r17, 0x00	; 0
					}
					if (buffer_a[i] < low_peak_a)		//if buffer bigger than current high_peak
    265c:	fc 01       	movw	r30, r24
    265e:	ee 5f       	subi	r30, 0xFE	; 254
    2660:	f8 4c       	sbci	r31, 0xC8	; 200
    2662:	20 81       	ld	r18, Z
    2664:	30 e0       	ldi	r19, 0x00	; 0
    2666:	26 17       	cp	r18, r22
    2668:	37 07       	cpc	r19, r23
    266a:	44 f4       	brge	.+16     	; 0x267c <vRead_DMA+0xc0>
					{
						low_peak_a = buffer_a[i];	// store new peak
    266c:	fc 01       	movw	r30, r24
    266e:	ee 5f       	subi	r30, 0xFE	; 254
    2670:	f8 4c       	sbci	r31, 0xC8	; 200
    2672:	60 81       	ld	r22, Z
    2674:	70 e0       	ldi	r23, 0x00	; 0
						position_low_peak_a = i;	// store array position of new peak
    2676:	e8 2e       	mov	r14, r24
    2678:	f9 2e       	mov	r15, r25
    267a:	11 c0       	rjmp	.+34     	; 0x269e <vRead_DMA+0xe2>
					}
					else if ((100 > buffer_a[i]) &&(buffer_a[i] > low_peak_a))	//if buffer value below 0 and bigger than low peak ***sinus increases***
    267c:	fc 01       	movw	r30, r24
    267e:	ee 5f       	subi	r30, 0xFE	; 254
    2680:	f8 4c       	sbci	r31, 0xC8	; 200
    2682:	20 81       	ld	r18, Z
    2684:	24 36       	cpi	r18, 0x64	; 100
    2686:	58 f4       	brcc	.+22     	; 0x269e <vRead_DMA+0xe2>
    2688:	fc 01       	movw	r30, r24
    268a:	ee 5f       	subi	r30, 0xFE	; 254
    268c:	f8 4c       	sbci	r31, 0xC8	; 200
    268e:	20 81       	ld	r18, Z
    2690:	30 e0       	ldi	r19, 0x00	; 0
    2692:	62 17       	cp	r22, r18
    2694:	73 07       	cpc	r23, r19
    2696:	1c f4       	brge	.+6      	; 0x269e <vRead_DMA+0xe2>
					{
						count_after_low_peak++;		//count up -> to make sure, that it's no distortion
    2698:	21 96       	adiw	r28, 0x01	; 1
						sinus_status = 0;		//status
    269a:	00 e0       	ldi	r16, 0x00	; 0
    269c:	10 e0       	ldi	r17, 0x00	; 0
					}
					/* store detected peak values in array:*/
					if ((count_after_high_peak > 50))
    269e:	a3 33       	cpi	r26, 0x33	; 51
    26a0:	b1 05       	cpc	r27, r1
    26a2:	2c f0       	brlt	.+10     	; 0x26ae <vRead_DMA+0xf2>
					{
						if (high_peak_a > 200)
    26a4:	49 3c       	cpi	r20, 0xC9	; 201
    26a6:	51 05       	cpc	r21, r1
    26a8:	14 f0       	brlt	.+4      	; 0x26ae <vRead_DMA+0xf2>
						{
							pos_peak_array[count_array_position_H] = high_peak_a;					//store peak in array
							position_pos_array[count_array_position_H] = position_high_peak_a;		//store position of peak in array
							count_array_position_H++;												//increase array position
							high_peak_a = 0;														//reset peak value to let it detect peaks again from 0 
    26aa:	40 e0       	ldi	r20, 0x00	; 0
    26ac:	50 e0       	ldi	r21, 0x00	; 0
						}
					}
					if (count_after_low_peak > 50)
    26ae:	c3 33       	cpi	r28, 0x33	; 51
    26b0:	d1 05       	cpc	r29, r1
    26b2:	2c f0       	brlt	.+10     	; 0x26be <vRead_DMA+0x102>
					{
						if (low_peak_a < 50)
    26b4:	62 33       	cpi	r22, 0x32	; 50
    26b6:	71 05       	cpc	r23, r1
    26b8:	14 f4       	brge	.+4      	; 0x26be <vRead_DMA+0x102>
						{
							neg_peak_array[count_array_position_L] = low_peak_a;
							position_neg_array[count_array_position_L] = position_low_peak_a;
							count_array_position_L++;
							low_peak_a = 0;
    26ba:	60 e0       	ldi	r22, 0x00	; 0
    26bc:	70 e0       	ldi	r23, 0x00	; 0
								pdFALSE,       /* Don't wait for both bits, either bit will do. */
								portMAX_DELAY );/* Wait a maximum for either bit to be set. */								
		//process signal values
			if (uxBits & Process_Signal_BufferA) // if "BufferA" bit is set, read out bufferA
			{
				for(i=0;i<2047;i++)
    26be:	01 96       	adiw	r24, 0x01	; 1
    26c0:	8f 3f       	cpi	r24, 0xFF	; 255
    26c2:	27 e0       	ldi	r18, 0x07	; 7
    26c4:	92 07       	cpc	r25, r18
    26c6:	09 f0       	breq	.+2      	; 0x26ca <vRead_DMA+0x10e>
    26c8:	a9 cf       	rjmp	.-174    	; 0x261c <vRead_DMA+0x60>
    26ca:	60 93 0f 3f 	sts	0x3F0F, r22	; 0x803f0f <low_peak_a>
    26ce:	70 93 10 3f 	sts	0x3F10, r23	; 0x803f10 <low_peak_a+0x1>
    26d2:	40 93 05 3f 	sts	0x3F05, r20	; 0x803f05 <high_peak_a>
    26d6:	50 93 06 3f 	sts	0x3F06, r21	; 0x803f06 <high_peak_a+0x1>
    26da:	c0 92 07 3f 	sts	0x3F07, r12	; 0x803f07 <position_high_peak_a>
    26de:	d0 92 08 3f 	sts	0x3F08, r13	; 0x803f08 <position_high_peak_a+0x1>
    26e2:	a0 93 15 3f 	sts	0x3F15, r26	; 0x803f15 <count_after_high_peak>
    26e6:	b0 93 16 3f 	sts	0x3F16, r27	; 0x803f16 <count_after_high_peak+0x1>
    26ea:	00 93 1b 3f 	sts	0x3F1B, r16	; 0x803f1b <sinus_status>
    26ee:	10 93 1c 3f 	sts	0x3F1C, r17	; 0x803f1c <sinus_status+0x1>
    26f2:	e0 92 13 3f 	sts	0x3F13, r14	; 0x803f13 <position_low_peak_a>
    26f6:	f0 92 14 3f 	sts	0x3F14, r15	; 0x803f14 <position_low_peak_a+0x1>
    26fa:	c0 93 17 3f 	sts	0x3F17, r28	; 0x803f17 <count_after_low_peak>
    26fe:	d0 93 18 3f 	sts	0x3F18, r29	; 0x803f18 <count_after_low_peak+0x1>
    2702:	84 c0       	rjmp	.+264    	; 0x280c <vRead_DMA+0x250>
					
					
				}

			}
			else if (uxBits & Process_Signal_BufferB)
    2704:	61 ff       	sbrs	r22, 1
    2706:	82 c0       	rjmp	.+260    	; 0x280c <vRead_DMA+0x250>
    2708:	40 91 0b 3f 	lds	r20, 0x3F0B	; 0x803f0b <high_peak_b>
    270c:	50 91 0c 3f 	lds	r21, 0x3F0C	; 0x803f0c <high_peak_b+0x1>
    2710:	c0 90 19 3f 	lds	r12, 0x3F19	; 0x803f19 <position_high_peak_b>
    2714:	d0 90 1a 3f 	lds	r13, 0x3F1A	; 0x803f1a <position_high_peak_b+0x1>
    2718:	a0 91 15 3f 	lds	r26, 0x3F15	; 0x803f15 <count_after_high_peak>
    271c:	b0 91 16 3f 	lds	r27, 0x3F16	; 0x803f16 <count_after_high_peak+0x1>
    2720:	60 91 03 3f 	lds	r22, 0x3F03	; 0x803f03 <low_peak_b>
    2724:	70 91 04 3f 	lds	r23, 0x3F04	; 0x803f04 <low_peak_b+0x1>
    2728:	e0 90 0d 3f 	lds	r14, 0x3F0D	; 0x803f0d <position_low_peak_b>
    272c:	f0 90 0e 3f 	lds	r15, 0x3F0E	; 0x803f0e <position_low_peak_b+0x1>
    2730:	00 91 17 3f 	lds	r16, 0x3F17	; 0x803f17 <count_after_low_peak>
    2734:	10 91 18 3f 	lds	r17, 0x3F18	; 0x803f18 <count_after_low_peak+0x1>
    2738:	c0 91 1b 3f 	lds	r28, 0x3F1B	; 0x803f1b <sinus_status>
    273c:	d0 91 1c 3f 	lds	r29, 0x3F1C	; 0x803f1c <sinus_status+0x1>
    2740:	80 e0       	ldi	r24, 0x00	; 0
    2742:	90 e0       	ldi	r25, 0x00	; 0
			{
				for (i=0;i<2047;i++)
				{
					if (buffer_b[i] > high_peak_b)	//if buffer bigger than current high_peak
    2744:	fc 01       	movw	r30, r24
    2746:	e0 50       	subi	r30, 0x00	; 0
    2748:	f1 4d       	sbci	r31, 0xD1	; 209
    274a:	20 81       	ld	r18, Z
    274c:	30 e0       	ldi	r19, 0x00	; 0
    274e:	42 17       	cp	r20, r18
    2750:	53 07       	cpc	r21, r19
    2752:	44 f4       	brge	.+16     	; 0x2764 <vRead_DMA+0x1a8>
					{
						high_peak_b = buffer_b[i];	// store new peak
    2754:	fc 01       	movw	r30, r24
    2756:	e0 50       	subi	r30, 0x00	; 0
    2758:	f1 4d       	sbci	r31, 0xD1	; 209
    275a:	40 81       	ld	r20, Z
    275c:	50 e0       	ldi	r21, 0x00	; 0
						position_high_peak_b = i;	// store array position of new peak
    275e:	c8 2e       	mov	r12, r24
    2760:	d9 2e       	mov	r13, r25
    2762:	10 c0       	rjmp	.+32     	; 0x2784 <vRead_DMA+0x1c8>
					}				
					else if(100 < buffer_b[i] < high_peak_b)
    2764:	fc 01       	movw	r30, r24
    2766:	e0 50       	subi	r30, 0x00	; 0
    2768:	f1 4d       	sbci	r31, 0xD1	; 209
    276a:	e0 81       	ld	r30, Z
    276c:	21 e0       	ldi	r18, 0x01	; 1
    276e:	30 e0       	ldi	r19, 0x00	; 0
    2770:	e5 36       	cpi	r30, 0x65	; 101
    2772:	10 f4       	brcc	.+4      	; 0x2778 <vRead_DMA+0x1bc>
    2774:	20 e0       	ldi	r18, 0x00	; 0
    2776:	30 e0       	ldi	r19, 0x00	; 0
    2778:	24 17       	cp	r18, r20
    277a:	35 07       	cpc	r19, r21
    277c:	1c f4       	brge	.+6      	; 0x2784 <vRead_DMA+0x1c8>
					{
						count_after_high_peak++;	//count up -> to make sure, that it's no distortion
    277e:	11 96       	adiw	r26, 0x01	; 1
						sinus_status = 1;		// status
    2780:	c1 e0       	ldi	r28, 0x01	; 1
    2782:	d0 e0       	ldi	r29, 0x00	; 0
					}
					if (buffer_b[i] < low_peak_b)		//if buffer bigger than current high_peak
    2784:	fc 01       	movw	r30, r24
    2786:	e0 50       	subi	r30, 0x00	; 0
    2788:	f1 4d       	sbci	r31, 0xD1	; 209
    278a:	20 81       	ld	r18, Z
    278c:	30 e0       	ldi	r19, 0x00	; 0
    278e:	26 17       	cp	r18, r22
    2790:	37 07       	cpc	r19, r23
    2792:	44 f4       	brge	.+16     	; 0x27a4 <vRead_DMA+0x1e8>
					{
						low_peak_b = buffer_b[i];	// store new peak
    2794:	fc 01       	movw	r30, r24
    2796:	e0 50       	subi	r30, 0x00	; 0
    2798:	f1 4d       	sbci	r31, 0xD1	; 209
    279a:	60 81       	ld	r22, Z
    279c:	70 e0       	ldi	r23, 0x00	; 0
						position_low_peak_b = i;	// store array position of new peak
    279e:	e8 2e       	mov	r14, r24
    27a0:	f9 2e       	mov	r15, r25
    27a2:	12 c0       	rjmp	.+36     	; 0x27c8 <vRead_DMA+0x20c>
					}
					else if ((100 > buffer_b[i]) &&(buffer_b[i] > low_peak_b))	//if buffer value below 0 and bigger than low peak ***sinus increases***
    27a4:	fc 01       	movw	r30, r24
    27a6:	e0 50       	subi	r30, 0x00	; 0
    27a8:	f1 4d       	sbci	r31, 0xD1	; 209
    27aa:	20 81       	ld	r18, Z
    27ac:	24 36       	cpi	r18, 0x64	; 100
    27ae:	60 f4       	brcc	.+24     	; 0x27c8 <vRead_DMA+0x20c>
    27b0:	fc 01       	movw	r30, r24
    27b2:	e0 50       	subi	r30, 0x00	; 0
    27b4:	f1 4d       	sbci	r31, 0xD1	; 209
    27b6:	20 81       	ld	r18, Z
    27b8:	30 e0       	ldi	r19, 0x00	; 0
    27ba:	62 17       	cp	r22, r18
    27bc:	73 07       	cpc	r23, r19
    27be:	24 f4       	brge	.+8      	; 0x27c8 <vRead_DMA+0x20c>
					{
						count_after_low_peak++;		//count up -> to make sure, that it's no distortion
    27c0:	0f 5f       	subi	r16, 0xFF	; 255
    27c2:	1f 4f       	sbci	r17, 0xFF	; 255
						sinus_status = 0;		//status
    27c4:	c0 e0       	ldi	r28, 0x00	; 0
    27c6:	d0 e0       	ldi	r29, 0x00	; 0
				}

			}
			else if (uxBits & Process_Signal_BufferB)
			{
				for (i=0;i<2047;i++)
    27c8:	01 96       	adiw	r24, 0x01	; 1
    27ca:	8f 3f       	cpi	r24, 0xFF	; 255
    27cc:	27 e0       	ldi	r18, 0x07	; 7
    27ce:	92 07       	cpc	r25, r18
    27d0:	09 f0       	breq	.+2      	; 0x27d4 <vRead_DMA+0x218>
    27d2:	b8 cf       	rjmp	.-144    	; 0x2744 <vRead_DMA+0x188>
    27d4:	a0 93 15 3f 	sts	0x3F15, r26	; 0x803f15 <count_after_high_peak>
    27d8:	b0 93 16 3f 	sts	0x3F16, r27	; 0x803f16 <count_after_high_peak+0x1>
    27dc:	c0 93 1b 3f 	sts	0x3F1B, r28	; 0x803f1b <sinus_status>
    27e0:	d0 93 1c 3f 	sts	0x3F1C, r29	; 0x803f1c <sinus_status+0x1>
    27e4:	00 93 17 3f 	sts	0x3F17, r16	; 0x803f17 <count_after_low_peak>
    27e8:	10 93 18 3f 	sts	0x3F18, r17	; 0x803f18 <count_after_low_peak+0x1>
    27ec:	40 93 0b 3f 	sts	0x3F0B, r20	; 0x803f0b <high_peak_b>
    27f0:	50 93 0c 3f 	sts	0x3F0C, r21	; 0x803f0c <high_peak_b+0x1>
    27f4:	c0 92 19 3f 	sts	0x3F19, r12	; 0x803f19 <position_high_peak_b>
    27f8:	d0 92 1a 3f 	sts	0x3F1A, r13	; 0x803f1a <position_high_peak_b+0x1>
    27fc:	60 93 03 3f 	sts	0x3F03, r22	; 0x803f03 <low_peak_b>
    2800:	70 93 04 3f 	sts	0x3F04, r23	; 0x803f04 <low_peak_b+0x1>
    2804:	e0 92 0d 3f 	sts	0x3F0D, r14	; 0x803f0d <position_low_peak_b>
    2808:	f0 92 0e 3f 	sts	0x3F0E, r15	; 0x803f0e <position_low_peak_b+0x1>
						count_after_low_peak++;		//count up -> to make sure, that it's no distortion
						sinus_status = 0;		//status
					}
				}
			}
		vTaskDelay(100 / portTICK_RATE_MS);
    280c:	64 e6       	ldi	r22, 0x64	; 100
    280e:	70 e0       	ldi	r23, 0x00	; 0
    2810:	80 e0       	ldi	r24, 0x00	; 0
    2812:	90 e0       	ldi	r25, 0x00	; 0
    2814:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
	}
    2818:	d1 ce       	rjmp	.-606    	; 0x25bc <vRead_DMA>

0000281a <vApplicationIdleHook>:
int count_after_high_peak, count_after_low_peak;
int sinus_status;		// 0 = rising up; 1 = rising down


void vApplicationIdleHook( void )
{	
    281a:	08 95       	ret

0000281c <main>:
	
}

int main(void)
{
    281c:	ef 92       	push	r14
    281e:	ff 92       	push	r15
    2820:	0f 93       	push	r16
    2822:	cf 93       	push	r28
    resetReason_t reason = getResetReason();
    2824:	0e 94 83 1b 	call	0x3706	; 0x3706 <getResetReason>
    2828:	c8 2f       	mov	r28, r24

	vInitClock();
    282a:	0e 94 2b 12 	call	0x2456	; 0x2456 <vInitClock>
	vInitDisplay();
    282e:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <vInitDisplay>
	
	xTaskCreate( vLedBlink, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+10, NULL, 1, &ledTask);
    2832:	0f 2e       	mov	r0, r31
    2834:	f9 e0       	ldi	r31, 0x09	; 9
    2836:	ef 2e       	mov	r14, r31
    2838:	ff e3       	ldi	r31, 0x3F	; 63
    283a:	ff 2e       	mov	r15, r31
    283c:	f0 2d       	mov	r31, r0
    283e:	01 e0       	ldi	r16, 0x01	; 1
    2840:	20 e0       	ldi	r18, 0x00	; 0
    2842:	30 e0       	ldi	r19, 0x00	; 0
    2844:	42 ed       	ldi	r20, 0xD2	; 210
    2846:	50 e0       	ldi	r21, 0x00	; 0
    2848:	6b e4       	ldi	r22, 0x4B	; 75
    284a:	70 e2       	ldi	r23, 0x20	; 32
    284c:	83 e6       	ldi	r24, 0x63	; 99
    284e:	92 e1       	ldi	r25, 0x12	; 18
    2850:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xTaskCreate( vRead_DMA, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+500, NULL, 1, &my_read_DMA);
    2854:	0f 2e       	mov	r0, r31
    2856:	f1 e1       	ldi	r31, 0x11	; 17
    2858:	ef 2e       	mov	r14, r31
    285a:	ff e3       	ldi	r31, 0x3F	; 63
    285c:	ff 2e       	mov	r15, r31
    285e:	f0 2d       	mov	r31, r0
    2860:	20 e0       	ldi	r18, 0x00	; 0
    2862:	30 e0       	ldi	r19, 0x00	; 0
    2864:	4c eb       	ldi	r20, 0xBC	; 188
    2866:	52 e0       	ldi	r21, 0x02	; 2
    2868:	6b e4       	ldi	r22, 0x4B	; 75
    286a:	70 e2       	ldi	r23, 0x20	; 32
    286c:	8e ed       	ldi	r24, 0xDE	; 222
    286e:	92 e1       	ldi	r25, 0x12	; 18
    2870:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xTaskCreate( vWrite_Display, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+10, NULL, 1, &my_Display);
    2874:	0f 2e       	mov	r0, r31
    2876:	fd e1       	ldi	r31, 0x1D	; 29
    2878:	ef 2e       	mov	r14, r31
    287a:	ff e3       	ldi	r31, 0x3F	; 63
    287c:	ff 2e       	mov	r15, r31
    287e:	f0 2d       	mov	r31, r0
    2880:	20 e0       	ldi	r18, 0x00	; 0
    2882:	30 e0       	ldi	r19, 0x00	; 0
    2884:	42 ed       	ldi	r20, 0xD2	; 210
    2886:	50 e0       	ldi	r21, 0x00	; 0
    2888:	6b e4       	ldi	r22, 0x4B	; 75
    288a:	70 e2       	ldi	r23, 0x20	; 32
    288c:	8f e6       	ldi	r24, 0x6F	; 111
    288e:	92 e1       	ldi	r25, 0x12	; 18
    2890:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xTaskCreate( vTask_DMAHandler, (const char *) "dmaHandler", configMINIMAL_STACK_SIZE + 100, NULL, 1, &TaskDMAHandler);		
    2894:	0f 2e       	mov	r0, r31
    2896:	ff e1       	ldi	r31, 0x1F	; 31
    2898:	ef 2e       	mov	r14, r31
    289a:	ff e3       	ldi	r31, 0x3F	; 63
    289c:	ff 2e       	mov	r15, r31
    289e:	f0 2d       	mov	r31, r0
    28a0:	20 e0       	ldi	r18, 0x00	; 0
    28a2:	30 e0       	ldi	r19, 0x00	; 0
    28a4:	4c e2       	ldi	r20, 0x2C	; 44
    28a6:	51 e0       	ldi	r21, 0x01	; 1
    28a8:	64 e5       	ldi	r22, 0x54	; 84
    28aa:	70 e2       	ldi	r23, 0x20	; 32
    28ac:	8a ec       	ldi	r24, 0xCA	; 202
    28ae:	9a e1       	ldi	r25, 0x1A	; 26
    28b0:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xSignalProcessEventGroup = xEventGroupCreate();
    28b4:	0e 94 a8 02 	call	0x550	; 0x550 <xEventGroupCreate>
    28b8:	80 93 02 2e 	sts	0x2E02, r24	; 0x802e02 <xSignalProcessEventGroup>
    28bc:	90 93 03 2e 	sts	0x2E03, r25	; 0x802e03 <xSignalProcessEventGroup+0x1>
	vInitDMA();			
    28c0:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <vInitDMA>

	vDisplayClear();
    28c4:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <vDisplayClear>
	vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    28c8:	8d e0       	ldi	r24, 0x0D	; 13
    28ca:	90 e2       	ldi	r25, 0x20	; 32
    28cc:	9f 93       	push	r25
    28ce:	8f 93       	push	r24
    28d0:	1f 92       	push	r1
    28d2:	1f 92       	push	r1
    28d4:	1f 92       	push	r1
    28d6:	1f 92       	push	r1
    28d8:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(1,0,"EDUBoard 1.0");
    28dc:	8f e5       	ldi	r24, 0x5F	; 95
    28de:	90 e2       	ldi	r25, 0x20	; 32
    28e0:	9f 93       	push	r25
    28e2:	8f 93       	push	r24
    28e4:	1f 92       	push	r1
    28e6:	1f 92       	push	r1
    28e8:	1f 92       	push	r1
    28ea:	81 e0       	ldi	r24, 0x01	; 1
    28ec:	8f 93       	push	r24
    28ee:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(2,0,"Template");
    28f2:	8c e6       	ldi	r24, 0x6C	; 108
    28f4:	90 e2       	ldi	r25, 0x20	; 32
    28f6:	9f 93       	push	r25
    28f8:	8f 93       	push	r24
    28fa:	1f 92       	push	r1
    28fc:	1f 92       	push	r1
    28fe:	1f 92       	push	r1
    2900:	82 e0       	ldi	r24, 0x02	; 2
    2902:	8f 93       	push	r24
    2904:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(3,0,"ResetReason: %d", reason);
    2908:	1f 92       	push	r1
    290a:	cf 93       	push	r28
    290c:	85 e7       	ldi	r24, 0x75	; 117
    290e:	90 e2       	ldi	r25, 0x20	; 32
    2910:	9f 93       	push	r25
    2912:	8f 93       	push	r24
    2914:	1f 92       	push	r1
    2916:	1f 92       	push	r1
    2918:	1f 92       	push	r1
    291a:	83 e0       	ldi	r24, 0x03	; 3
    291c:	8f 93       	push	r24
    291e:	0e 94 27 17 	call	0x2e4e	; 0x2e4e <vDisplayWriteStringAtPos>
	vTaskStartScheduler();
    2922:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <vTaskStartScheduler>
    2926:	8d b7       	in	r24, 0x3d	; 61
    2928:	9e b7       	in	r25, 0x3e	; 62
    292a:	4a 96       	adiw	r24, 0x1a	; 26
    292c:	8d bf       	out	0x3d, r24	; 61
    292e:	9e bf       	out	0x3e, r25	; 62
	return 0;
}
    2930:	80 e0       	ldi	r24, 0x00	; 0
    2932:	90 e0       	ldi	r25, 0x00	; 0
    2934:	cf 91       	pop	r28
    2936:	0f 91       	pop	r16
    2938:	ff 90       	pop	r15
    293a:	ef 90       	pop	r14
    293c:	08 95       	ret

0000293e <__vector_108>:
 void displayHome() {
	 command(0x02);
 }
 void _displayClear() {
	 command(0x01);
	 delayUS(2000);
    293e:	1f 92       	push	r1
    2940:	0f 92       	push	r0
    2942:	0f b6       	in	r0, 0x3f	; 63
    2944:	0f 92       	push	r0
    2946:	11 24       	eor	r1, r1
    2948:	0b b6       	in	r0, 0x3b	; 59
    294a:	0f 92       	push	r0
    294c:	2f 93       	push	r18
    294e:	3f 93       	push	r19
    2950:	4f 93       	push	r20
    2952:	5f 93       	push	r21
    2954:	6f 93       	push	r22
    2956:	7f 93       	push	r23
    2958:	8f 93       	push	r24
    295a:	9f 93       	push	r25
    295c:	af 93       	push	r26
    295e:	bf 93       	push	r27
    2960:	ef 93       	push	r30
    2962:	ff 93       	push	r31
    2964:	cf 93       	push	r28
    2966:	df 93       	push	r29
    2968:	1f 92       	push	r1
    296a:	cd b7       	in	r28, 0x3d	; 61
    296c:	de b7       	in	r29, 0x3e	; 62
    296e:	19 82       	std	Y+1, r1	; 0x01
    2970:	9e 01       	movw	r18, r28
    2972:	2f 5f       	subi	r18, 0xFF	; 255
    2974:	3f 4f       	sbci	r19, 0xFF	; 255
    2976:	41 e0       	ldi	r20, 0x01	; 1
    2978:	50 e0       	ldi	r21, 0x00	; 0
    297a:	60 e0       	ldi	r22, 0x00	; 0
    297c:	70 e0       	ldi	r23, 0x00	; 0
    297e:	80 91 23 3f 	lds	r24, 0x3F23	; 0x803f23 <egDisplayTiming>
    2982:	90 91 24 3f 	lds	r25, 0x3F24	; 0x803f24 <egDisplayTiming+0x1>
    2986:	0e 94 38 04 	call	0x870	; 0x870 <xEventGroupSetBitsFromISR>
    298a:	60 e0       	ldi	r22, 0x00	; 0
    298c:	80 e0       	ldi	r24, 0x00	; 0
    298e:	9b e0       	ldi	r25, 0x0B	; 11
    2990:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
    2994:	10 92 06 0b 	sts	0x0B06, r1	; 0x800b06 <__TEXT_REGION_LENGTH__+0x700b06>
    2998:	0f 90       	pop	r0
    299a:	df 91       	pop	r29
    299c:	cf 91       	pop	r28
    299e:	ff 91       	pop	r31
    29a0:	ef 91       	pop	r30
    29a2:	bf 91       	pop	r27
    29a4:	af 91       	pop	r26
    29a6:	9f 91       	pop	r25
    29a8:	8f 91       	pop	r24
    29aa:	7f 91       	pop	r23
    29ac:	6f 91       	pop	r22
    29ae:	5f 91       	pop	r21
    29b0:	4f 91       	pop	r20
    29b2:	3f 91       	pop	r19
    29b4:	2f 91       	pop	r18
    29b6:	0f 90       	pop	r0
    29b8:	0b be       	out	0x3b, r0	; 59
    29ba:	0f 90       	pop	r0
    29bc:	0f be       	out	0x3f, r0	; 63
    29be:	0f 90       	pop	r0
    29c0:	1f 90       	pop	r1
    29c2:	18 95       	reti

000029c4 <delayUS>:
    29c4:	cf 92       	push	r12
    29c6:	df 92       	push	r13
    29c8:	ef 92       	push	r14
    29ca:	ff 92       	push	r15
    29cc:	0f 93       	push	r16
    29ce:	6b 01       	movw	r12, r22
    29d0:	7c 01       	movw	r14, r24
    29d2:	82 e0       	ldi	r24, 0x02	; 2
    29d4:	c8 16       	cp	r12, r24
    29d6:	d1 04       	cpc	r13, r1
    29d8:	e1 04       	cpc	r14, r1
    29da:	f1 04       	cpc	r15, r1
    29dc:	08 f4       	brcc	.+2      	; 0x29e0 <delayUS+0x1c>
    29de:	4e c0       	rjmp	.+156    	; 0x2a7c <delayUS+0xb8>
    29e0:	e0 e0       	ldi	r30, 0x00	; 0
    29e2:	fb e0       	ldi	r31, 0x0B	; 11
    29e4:	81 e0       	ldi	r24, 0x01	; 1
    29e6:	86 83       	std	Z+6, r24	; 0x06
    29e8:	10 a2       	std	Z+32, r1	; 0x20
    29ea:	11 a2       	std	Z+33, r1	; 0x21
    29ec:	60 e0       	ldi	r22, 0x00	; 0
    29ee:	80 e0       	ldi	r24, 0x00	; 0
    29f0:	9b e0       	ldi	r25, 0x0B	; 11
    29f2:	0e 94 92 02 	call	0x524	; 0x524 <TC0_ConfigWGM>
    29f6:	8e ef       	ldi	r24, 0xFE	; 254
    29f8:	c8 16       	cp	r12, r24
    29fa:	8f ef       	ldi	r24, 0xFF	; 255
    29fc:	d8 06       	cpc	r13, r24
    29fe:	e1 04       	cpc	r14, r1
    2a00:	f1 04       	cpc	r15, r1
    2a02:	70 f4       	brcc	.+28     	; 0x2a20 <delayUS+0x5c>
    2a04:	f6 94       	lsr	r15
    2a06:	e7 94       	ror	r14
    2a08:	d7 94       	ror	r13
    2a0a:	c7 94       	ror	r12
    2a0c:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2a10:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2a14:	65 e0       	ldi	r22, 0x05	; 5
    2a16:	80 e0       	ldi	r24, 0x00	; 0
    2a18:	9b e0       	ldi	r25, 0x0B	; 11
    2a1a:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
    2a1e:	19 c0       	rjmp	.+50     	; 0x2a52 <delayUS+0x8e>
    2a20:	80 e4       	ldi	r24, 0x40	; 64
    2a22:	c8 16       	cp	r12, r24
    2a24:	82 e4       	ldi	r24, 0x42	; 66
    2a26:	d8 06       	cpc	r13, r24
    2a28:	8f e0       	ldi	r24, 0x0F	; 15
    2a2a:	e8 06       	cpc	r14, r24
    2a2c:	f1 04       	cpc	r15, r1
    2a2e:	88 f4       	brcc	.+34     	; 0x2a52 <delayUS+0x8e>
    2a30:	68 94       	set
    2a32:	14 f8       	bld	r1, 4
    2a34:	f6 94       	lsr	r15
    2a36:	e7 94       	ror	r14
    2a38:	d7 94       	ror	r13
    2a3a:	c7 94       	ror	r12
    2a3c:	16 94       	lsr	r1
    2a3e:	d1 f7       	brne	.-12     	; 0x2a34 <delayUS+0x70>
    2a40:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2a44:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2a48:	67 e0       	ldi	r22, 0x07	; 7
    2a4a:	80 e0       	ldi	r24, 0x00	; 0
    2a4c:	9b e0       	ldi	r25, 0x0B	; 11
    2a4e:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
    2a52:	0f 2e       	mov	r0, r31
    2a54:	f4 ef       	ldi	r31, 0xF4	; 244
    2a56:	cf 2e       	mov	r12, r31
    2a58:	dd 24       	eor	r13, r13
    2a5a:	d3 94       	inc	r13
    2a5c:	e1 2c       	mov	r14, r1
    2a5e:	f1 2c       	mov	r15, r1
    2a60:	f0 2d       	mov	r31, r0
    2a62:	00 e0       	ldi	r16, 0x00	; 0
    2a64:	21 e0       	ldi	r18, 0x01	; 1
    2a66:	41 e0       	ldi	r20, 0x01	; 1
    2a68:	50 e0       	ldi	r21, 0x00	; 0
    2a6a:	60 e0       	ldi	r22, 0x00	; 0
    2a6c:	70 e0       	ldi	r23, 0x00	; 0
    2a6e:	80 91 23 3f 	lds	r24, 0x3F23	; 0x803f23 <egDisplayTiming>
    2a72:	90 91 24 3f 	lds	r25, 0x3F24	; 0x803f24 <egDisplayTiming+0x1>
    2a76:	0e 94 bd 02 	call	0x57a	; 0x57a <xEventGroupWaitBits>
    2a7a:	11 c0       	rjmp	.+34     	; 0x2a9e <delayUS+0xda>
    2a7c:	e0 e0       	ldi	r30, 0x00	; 0
    2a7e:	fb e0       	ldi	r31, 0x0B	; 11
    2a80:	81 e0       	ldi	r24, 0x01	; 1
    2a82:	86 83       	std	Z+6, r24	; 0x06
    2a84:	10 a2       	std	Z+32, r1	; 0x20
    2a86:	11 a2       	std	Z+33, r1	; 0x21
    2a88:	60 e0       	ldi	r22, 0x00	; 0
    2a8a:	80 e0       	ldi	r24, 0x00	; 0
    2a8c:	9b e0       	ldi	r25, 0x0B	; 11
    2a8e:	0e 94 92 02 	call	0x524	; 0x524 <TC0_ConfigWGM>
    2a92:	c1 2c       	mov	r12, r1
    2a94:	d1 2c       	mov	r13, r1
    2a96:	76 01       	movw	r14, r12
    2a98:	68 94       	set
    2a9a:	c1 f8       	bld	r12, 1
    2a9c:	b3 cf       	rjmp	.-154    	; 0x2a04 <delayUS+0x40>
    2a9e:	0f 91       	pop	r16
    2aa0:	ff 90       	pop	r15
    2aa2:	ef 90       	pop	r14
    2aa4:	df 90       	pop	r13
    2aa6:	cf 90       	pop	r12
    2aa8:	08 95       	ret

00002aaa <setPort>:
    2aaa:	82 95       	swap	r24
    2aac:	80 7f       	andi	r24, 0xF0	; 240
    2aae:	e0 e0       	ldi	r30, 0x00	; 0
    2ab0:	f6 e0       	ldi	r31, 0x06	; 6
    2ab2:	94 81       	ldd	r25, Z+4	; 0x04
    2ab4:	28 2f       	mov	r18, r24
    2ab6:	2f 60       	ori	r18, 0x0F	; 15
    2ab8:	92 23       	and	r25, r18
    2aba:	94 83       	std	Z+4, r25	; 0x04
    2abc:	94 81       	ldd	r25, Z+4	; 0x04
    2abe:	89 2b       	or	r24, r25
    2ac0:	84 83       	std	Z+4, r24	; 0x04
    2ac2:	08 95       	ret

00002ac4 <Nybble>:
    2ac4:	1f 93       	push	r17
    2ac6:	cf 93       	push	r28
    2ac8:	df 93       	push	r29
    2aca:	c0 e6       	ldi	r28, 0x60	; 96
    2acc:	d6 e0       	ldi	r29, 0x06	; 6
    2ace:	14 e0       	ldi	r17, 0x04	; 4
    2ad0:	1d 83       	std	Y+5, r17	; 0x05
    2ad2:	61 e0       	ldi	r22, 0x01	; 1
    2ad4:	70 e0       	ldi	r23, 0x00	; 0
    2ad6:	80 e0       	ldi	r24, 0x00	; 0
    2ad8:	90 e0       	ldi	r25, 0x00	; 0
    2ada:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <delayUS>
    2ade:	1e 83       	std	Y+6, r17	; 0x06
    2ae0:	df 91       	pop	r29
    2ae2:	cf 91       	pop	r28
    2ae4:	1f 91       	pop	r17
    2ae6:	08 95       	ret

00002ae8 <command>:
    2ae8:	cf 93       	push	r28
    2aea:	c8 2f       	mov	r28, r24
    2aec:	82 95       	swap	r24
    2aee:	8f 70       	andi	r24, 0x0F	; 15
    2af0:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <setPort>
    2af4:	e0 e6       	ldi	r30, 0x60	; 96
    2af6:	f6 e0       	ldi	r31, 0x06	; 6
    2af8:	81 e0       	ldi	r24, 0x01	; 1
    2afa:	86 83       	std	Z+6, r24	; 0x06
    2afc:	82 e0       	ldi	r24, 0x02	; 2
    2afe:	86 83       	std	Z+6, r24	; 0x06
    2b00:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <Nybble>
    2b04:	8c 2f       	mov	r24, r28
    2b06:	8f 70       	andi	r24, 0x0F	; 15
    2b08:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <setPort>
    2b0c:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <Nybble>
    2b10:	cf 91       	pop	r28
    2b12:	08 95       	ret

00002b14 <write>:
    2b14:	cf 93       	push	r28
    2b16:	c8 2f       	mov	r28, r24
    2b18:	82 95       	swap	r24
    2b1a:	8f 70       	andi	r24, 0x0F	; 15
    2b1c:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <setPort>
    2b20:	e0 e6       	ldi	r30, 0x60	; 96
    2b22:	f6 e0       	ldi	r31, 0x06	; 6
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	85 83       	std	Z+5, r24	; 0x05
    2b28:	82 e0       	ldi	r24, 0x02	; 2
    2b2a:	86 83       	std	Z+6, r24	; 0x06
    2b2c:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <Nybble>
    2b30:	8c 2f       	mov	r24, r28
    2b32:	8f 70       	andi	r24, 0x0F	; 15
    2b34:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <setPort>
    2b38:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <Nybble>
    2b3c:	cf 91       	pop	r28
    2b3e:	08 95       	ret

00002b40 <vInitDisplay>:
 }
 
 void vInitDisplay() {
    2b40:	ef 92       	push	r14
    2b42:	ff 92       	push	r15
    2b44:	0f 93       	push	r16
	PORTA.DIRSET = PIN4_bm;
    2b46:	e0 e0       	ldi	r30, 0x00	; 0
    2b48:	f6 e0       	ldi	r31, 0x06	; 6
    2b4a:	80 e1       	ldi	r24, 0x10	; 16
    2b4c:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN5_bm;
    2b4e:	80 e2       	ldi	r24, 0x20	; 32
    2b50:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN6_bm;
    2b52:	80 e4       	ldi	r24, 0x40	; 64
    2b54:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN7_bm;
    2b56:	80 e8       	ldi	r24, 0x80	; 128
    2b58:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN0_bm;
    2b5a:	a0 e6       	ldi	r26, 0x60	; 96
    2b5c:	b6 e0       	ldi	r27, 0x06	; 6
    2b5e:	81 e0       	ldi	r24, 0x01	; 1
    2b60:	11 96       	adiw	r26, 0x01	; 1
    2b62:	8c 93       	st	X, r24
    2b64:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN1_bm;
    2b66:	82 e0       	ldi	r24, 0x02	; 2
    2b68:	11 96       	adiw	r26, 0x01	; 1
    2b6a:	8c 93       	st	X, r24
    2b6c:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN2_bm;
    2b6e:	84 e0       	ldi	r24, 0x04	; 4
    2b70:	11 96       	adiw	r26, 0x01	; 1
    2b72:	8c 93       	st	X, r24
    2b74:	11 97       	sbiw	r26, 0x01	; 1
	PORTA.OUT &= 0x0F;
    2b76:	84 81       	ldd	r24, Z+4	; 0x04
    2b78:	8f 70       	andi	r24, 0x0F	; 15
    2b7a:	84 83       	std	Z+4, r24	; 0x04
	PORTD.OUT &= 0xF8;
    2b7c:	14 96       	adiw	r26, 0x04	; 4
    2b7e:	8c 91       	ld	r24, X
    2b80:	14 97       	sbiw	r26, 0x04	; 4
    2b82:	88 7f       	andi	r24, 0xF8	; 248
    2b84:	14 96       	adiw	r26, 0x04	; 4
    2b86:	8c 93       	st	X, r24

	if((displayLineQueue = xQueueCreate(DISPLAY_QUEUE_DEPTH, sizeof(displayLine_t))) == NULL)
    2b88:	40 e0       	ldi	r20, 0x00	; 0
    2b8a:	66 e1       	ldi	r22, 0x16	; 22
    2b8c:	88 e0       	ldi	r24, 0x08	; 8
    2b8e:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericCreate>
    2b92:	80 93 21 3f 	sts	0x3F21, r24	; 0x803f21 <displayLineQueue>
    2b96:	90 93 22 3f 	sts	0x3F22, r25	; 0x803f22 <displayLineQueue+0x1>
	{
		//error(ERR_QUEUE_CREATE_HANDLE_NULL);
	}
	
	egDisplayTiming = xEventGroupCreate();
    2b9a:	0e 94 a8 02 	call	0x550	; 0x550 <xEventGroupCreate>
    2b9e:	80 93 23 3f 	sts	0x3F23, r24	; 0x803f23 <egDisplayTiming>
    2ba2:	90 93 24 3f 	sts	0x3F24, r25	; 0x803f24 <egDisplayTiming+0x1>
	

	xTaskCreate(vDisplayUpdateTask, (const char*) "dispUpdate", configMINIMAL_STACK_SIZE+150, NULL, 1, NULL);	
    2ba6:	e1 2c       	mov	r14, r1
    2ba8:	f1 2c       	mov	r15, r1
    2baa:	01 e0       	ldi	r16, 0x01	; 1
    2bac:	20 e0       	ldi	r18, 0x00	; 0
    2bae:	30 e0       	ldi	r19, 0x00	; 0
    2bb0:	4e e5       	ldi	r20, 0x5E	; 94
    2bb2:	51 e0       	ldi	r21, 0x01	; 1
    2bb4:	65 e8       	ldi	r22, 0x85	; 133
    2bb6:	70 e2       	ldi	r23, 0x20	; 32
    2bb8:	8e e3       	ldi	r24, 0x3E	; 62
    2bba:	96 e1       	ldi	r25, 0x16	; 22
    2bbc:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
 }
    2bc0:	0f 91       	pop	r16
    2bc2:	ff 90       	pop	r15
    2bc4:	ef 90       	pop	r14
    2bc6:	08 95       	ret

00002bc8 <_displaySetPos>:
 
 void _displaySetPos(int line, int pos) {
	 switch(line) {
    2bc8:	81 30       	cpi	r24, 0x01	; 1
    2bca:	91 05       	cpc	r25, r1
    2bcc:	79 f0       	breq	.+30     	; 0x2bec <_displaySetPos+0x24>
    2bce:	1c f4       	brge	.+6      	; 0x2bd6 <_displaySetPos+0xe>
    2bd0:	89 2b       	or	r24, r25
    2bd2:	39 f0       	breq	.+14     	; 0x2be2 <_displaySetPos+0x1a>
    2bd4:	19 c0       	rjmp	.+50     	; 0x2c08 <_displaySetPos+0x40>
    2bd6:	82 30       	cpi	r24, 0x02	; 2
    2bd8:	91 05       	cpc	r25, r1
    2bda:	69 f0       	breq	.+26     	; 0x2bf6 <_displaySetPos+0x2e>
    2bdc:	03 97       	sbiw	r24, 0x03	; 3
    2bde:	81 f0       	breq	.+32     	; 0x2c00 <_displaySetPos+0x38>
    2be0:	13 c0       	rjmp	.+38     	; 0x2c08 <_displaySetPos+0x40>
		 case 0:
		 command(0x80 + 0x00 + pos);
    2be2:	80 e8       	ldi	r24, 0x80	; 128
    2be4:	86 0f       	add	r24, r22
    2be6:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <command>
		 break;
    2bea:	0e c0       	rjmp	.+28     	; 0x2c08 <_displaySetPos+0x40>
		 case 1:
		 command(0x80 + 0x40 + pos);
    2bec:	80 ec       	ldi	r24, 0xC0	; 192
    2bee:	86 0f       	add	r24, r22
    2bf0:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <command>
		 break;
    2bf4:	09 c0       	rjmp	.+18     	; 0x2c08 <_displaySetPos+0x40>
		 case 2:
		 command(0x80 + 0x14 + pos);
    2bf6:	84 e9       	ldi	r24, 0x94	; 148
    2bf8:	86 0f       	add	r24, r22
    2bfa:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <command>
		 break;
    2bfe:	04 c0       	rjmp	.+8      	; 0x2c08 <_displaySetPos+0x40>
		 case 3:
		 command(0x80 + 0x54 + pos);
    2c00:	84 ed       	ldi	r24, 0xD4	; 212
    2c02:	86 0f       	add	r24, r22
    2c04:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <command>
		 break;
	 }
	 delayUS(39);
    2c08:	67 e2       	ldi	r22, 0x27	; 39
    2c0a:	70 e0       	ldi	r23, 0x00	; 0
    2c0c:	80 e0       	ldi	r24, 0x00	; 0
    2c0e:	90 e0       	ldi	r25, 0x00	; 0
    2c10:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <delayUS>
    2c14:	08 95       	ret

00002c16 <_displayWriteChar>:
 }

 void _displayWriteChar(char c) {
	 write(c);
    2c16:	0e 94 8a 15 	call	0x2b14	; 0x2b14 <write>
	 delayUS(43);
    2c1a:	6b e2       	ldi	r22, 0x2B	; 43
    2c1c:	70 e0       	ldi	r23, 0x00	; 0
    2c1e:	80 e0       	ldi	r24, 0x00	; 0
    2c20:	90 e0       	ldi	r25, 0x00	; 0
    2c22:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <delayUS>
    2c26:	08 95       	ret

00002c28 <_displayWriteString>:
 }
 
 void _displayWriteString(char* s) {
    2c28:	0f 93       	push	r16
    2c2a:	1f 93       	push	r17
    2c2c:	cf 93       	push	r28
    2c2e:	df 93       	push	r29
    2c30:	fc 01       	movw	r30, r24
	 for(int i = 0; i < 20; i++) {
		 if(s[i] == '\0') {
    2c32:	80 81       	ld	r24, Z
    2c34:	81 11       	cpse	r24, r1
    2c36:	0a c0       	rjmp	.+20     	; 0x2c4c <_displayWriteString+0x24>
    2c38:	11 c0       	rjmp	.+34     	; 0x2c5c <_displayWriteString+0x34>
    2c3a:	89 91       	ld	r24, Y+
    2c3c:	88 23       	and	r24, r24
    2c3e:	71 f0       	breq	.+28     	; 0x2c5c <_displayWriteString+0x34>
			 break;
		 }
		 _displayWriteChar(s[i]);
    2c40:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <_displayWriteChar>
	 write(c);
	 delayUS(43);
 }
 
 void _displayWriteString(char* s) {
	 for(int i = 0; i < 20; i++) {
    2c44:	0c 17       	cp	r16, r28
    2c46:	1d 07       	cpc	r17, r29
    2c48:	c1 f7       	brne	.-16     	; 0x2c3a <_displayWriteString+0x12>
    2c4a:	08 c0       	rjmp	.+16     	; 0x2c5c <_displayWriteString+0x34>
    2c4c:	8f 01       	movw	r16, r30
		 if(s[i] == '\0') {
			 break;
		 }
		 _displayWriteChar(s[i]);
    2c4e:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <_displayWriteChar>
    2c52:	e8 01       	movw	r28, r16
    2c54:	21 96       	adiw	r28, 0x01	; 1
    2c56:	0c 5e       	subi	r16, 0xEC	; 236
    2c58:	1f 4f       	sbci	r17, 0xFF	; 255
    2c5a:	ef cf       	rjmp	.-34     	; 0x2c3a <_displayWriteString+0x12>
	 }
 }
    2c5c:	df 91       	pop	r29
    2c5e:	cf 91       	pop	r28
    2c60:	1f 91       	pop	r17
    2c62:	0f 91       	pop	r16
    2c64:	08 95       	ret

00002c66 <_displayWriteStringAtPos>:

 void _displayWriteStringAtPos(int line, int pos, char* s) {
    2c66:	cf 93       	push	r28
    2c68:	df 93       	push	r29
    2c6a:	ea 01       	movw	r28, r20
	 _displaySetPos(line, pos);
    2c6c:	0e 94 e4 15 	call	0x2bc8	; 0x2bc8 <_displaySetPos>
	 _displayWriteString(s);
    2c70:	ce 01       	movw	r24, r28
    2c72:	0e 94 14 16 	call	0x2c28	; 0x2c28 <_displayWriteString>
 }
    2c76:	df 91       	pop	r29
    2c78:	cf 91       	pop	r28
    2c7a:	08 95       	ret

00002c7c <vDisplayUpdateTask>:

 void vDisplayUpdateTask(void *pvParameters) {
    2c7c:	cf 93       	push	r28
    2c7e:	df 93       	push	r29
    2c80:	cd b7       	in	r28, 0x3d	; 61
    2c82:	de b7       	in	r29, 0x3e	; 62
    2c84:	c6 56       	subi	r28, 0x66	; 102
    2c86:	d1 09       	sbc	r29, r1
    2c88:	cd bf       	out	0x3d, r28	; 61
    2c8a:	de bf       	out	0x3e, r29	; 62
    2c8c:	5e 01       	movw	r10, r28
    2c8e:	41 e5       	ldi	r20, 0x51	; 81
    2c90:	a4 0e       	add	r10, r20
    2c92:	b1 1c       	adc	r11, r1
    2c94:	fe 01       	movw	r30, r28
    2c96:	31 96       	adiw	r30, 0x01	; 1
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
			displayLines[i][j] = 0x20;
    2c98:	20 e2       	ldi	r18, 0x20	; 32
    2c9a:	08 c0       	rjmp	.+16     	; 0x2cac <vDisplayUpdateTask+0x30>
    2c9c:	21 93       	st	Z+, r18
 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
    2c9e:	e8 17       	cp	r30, r24
    2ca0:	f9 07       	cpc	r31, r25
    2ca2:	e1 f7       	brne	.-8      	; 0x2c9c <vDisplayUpdateTask+0x20>
    2ca4:	fc 01       	movw	r30, r24

 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
    2ca6:	a8 16       	cp	r10, r24
    2ca8:	b9 06       	cpc	r11, r25
    2caa:	19 f0       	breq	.+6      	; 0x2cb2 <vDisplayUpdateTask+0x36>
    2cac:	cf 01       	movw	r24, r30
    2cae:	44 96       	adiw	r24, 0x14	; 20
    2cb0:	f5 cf       	rjmp	.-22     	; 0x2c9c <vDisplayUpdateTask+0x20>
			displayLines[i][j] = 0x20;
		}
	 }
	 displayLine_t newLine;

	 delayUS(40000);
    2cb2:	60 e4       	ldi	r22, 0x40	; 64
    2cb4:	7c e9       	ldi	r23, 0x9C	; 156
    2cb6:	80 e0       	ldi	r24, 0x00	; 0
    2cb8:	90 e0       	ldi	r25, 0x00	; 0
    2cba:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <delayUS>
	 setPort(0x03);
    2cbe:	83 e0       	ldi	r24, 0x03	; 3
    2cc0:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <setPort>
	 delayUS(5000);
    2cc4:	68 e8       	ldi	r22, 0x88	; 136
    2cc6:	73 e1       	ldi	r23, 0x13	; 19
    2cc8:	80 e0       	ldi	r24, 0x00	; 0
    2cca:	90 e0       	ldi	r25, 0x00	; 0
    2ccc:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <delayUS>
	 Nybble();
    2cd0:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <Nybble>
	 delayUS(160);
    2cd4:	60 ea       	ldi	r22, 0xA0	; 160
    2cd6:	70 e0       	ldi	r23, 0x00	; 0
    2cd8:	80 e0       	ldi	r24, 0x00	; 0
    2cda:	90 e0       	ldi	r25, 0x00	; 0
    2cdc:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <delayUS>
	 Nybble();
    2ce0:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <Nybble>
	 delayUS(160);
    2ce4:	60 ea       	ldi	r22, 0xA0	; 160
    2ce6:	70 e0       	ldi	r23, 0x00	; 0
    2ce8:	80 e0       	ldi	r24, 0x00	; 0
    2cea:	90 e0       	ldi	r25, 0x00	; 0
    2cec:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <delayUS>
	 Nybble();
    2cf0:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <Nybble>
	 delayUS(160);
    2cf4:	60 ea       	ldi	r22, 0xA0	; 160
    2cf6:	70 e0       	ldi	r23, 0x00	; 0
    2cf8:	80 e0       	ldi	r24, 0x00	; 0
    2cfa:	90 e0       	ldi	r25, 0x00	; 0
    2cfc:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <delayUS>
	 setPort(0x02);
    2d00:	82 e0       	ldi	r24, 0x02	; 2
    2d02:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <setPort>
	 Nybble();
    2d06:	0e 94 62 15 	call	0x2ac4	; 0x2ac4 <Nybble>
	 command(0x28);
    2d0a:	88 e2       	ldi	r24, 0x28	; 40
    2d0c:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <command>
	 command(0x10);
    2d10:	80 e1       	ldi	r24, 0x10	; 16
    2d12:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <command>
	 command(0x0C); //Cursor and Blinking off
    2d16:	8c e0       	ldi	r24, 0x0C	; 12
    2d18:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <command>
	 command(0x06);
    2d1c:	86 e0       	ldi	r24, 0x06	; 6
    2d1e:	0e 94 74 15 	call	0x2ae8	; 0x2ae8 <command>
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2d22:	10 e2       	ldi	r17, 0x20	; 32
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2d24:	6e 01       	movw	r12, r28
    2d26:	51 e5       	ldi	r21, 0x51	; 81
    2d28:	c5 0e       	add	r12, r21
    2d2a:	d1 1c       	adc	r13, r1
    2d2c:	0f 2e       	mov	r0, r31
    2d2e:	f4 e1       	ldi	r31, 0x14	; 20
    2d30:	4f 2e       	mov	r4, r31
    2d32:	f0 2d       	mov	r31, r0
    2d34:	0f 2e       	mov	r0, r31
    2d36:	f6 e1       	ldi	r31, 0x16	; 22
    2d38:	8f 2e       	mov	r8, r31
    2d3a:	91 2c       	mov	r9, r1
    2d3c:	f0 2d       	mov	r31, r0
    2d3e:	5c 2c       	mov	r5, r12
    2d40:	0d 2d       	mov	r16, r13
	 command(0x10);
	 command(0x0C); //Cursor and Blinking off
	 command(0x06);
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
    2d42:	68 ec       	ldi	r22, 0xC8	; 200
    2d44:	70 e0       	ldi	r23, 0x00	; 0
    2d46:	80 e0       	ldi	r24, 0x00	; 0
    2d48:	90 e0       	ldi	r25, 0x00	; 0
    2d4a:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
    2d4e:	40 e0       	ldi	r20, 0x00	; 0
    2d50:	50 e0       	ldi	r21, 0x00	; 0
    2d52:	ba 01       	movw	r22, r20
    2d54:	80 91 23 3f 	lds	r24, 0x3F23	; 0x803f23 <egDisplayTiming>
    2d58:	90 91 24 3f 	lds	r25, 0x3F24	; 0x803f24 <egDisplayTiming+0x1>
    2d5c:	0e 94 82 03 	call	0x704	; 0x704 <xEventGroupClearBits>
    2d60:	67 2b       	or	r22, r23
    2d62:	68 2b       	or	r22, r24
    2d64:	69 2b       	or	r22, r25
    2d66:	09 f4       	brne	.+2      	; 0x2d6a <vDisplayUpdateTask+0xee>
    2d68:	49 c0       	rjmp	.+146    	; 0x2dfc <vDisplayUpdateTask+0x180>
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2d6a:	42 e0       	ldi	r20, 0x02	; 2
    2d6c:	50 e0       	ldi	r21, 0x00	; 0
    2d6e:	60 e0       	ldi	r22, 0x00	; 0
    2d70:	70 e0       	ldi	r23, 0x00	; 0
    2d72:	80 91 23 3f 	lds	r24, 0x3F23	; 0x803f23 <egDisplayTiming>
    2d76:	90 91 24 3f 	lds	r25, 0x3F24	; 0x803f24 <egDisplayTiming+0x1>
    2d7a:	0e 94 82 03 	call	0x704	; 0x704 <xEventGroupClearBits>
    2d7e:	fe 01       	movw	r30, r28
    2d80:	31 96       	adiw	r30, 0x01	; 1
    2d82:	08 c0       	rjmp	.+16     	; 0x2d94 <vDisplayUpdateTask+0x118>
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2d84:	11 93       	st	Z+, r17
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
    2d86:	e8 17       	cp	r30, r24
    2d88:	f9 07       	cpc	r31, r25
    2d8a:	e1 f7       	brne	.-8      	; 0x2d84 <vDisplayUpdateTask+0x108>
    2d8c:	fc 01       	movw	r30, r24
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
    2d8e:	8a 15       	cp	r24, r10
    2d90:	9b 05       	cpc	r25, r11
    2d92:	a1 f1       	breq	.+104    	; 0x2dfc <vDisplayUpdateTask+0x180>
    2d94:	cf 01       	movw	r24, r30
    2d96:	44 96       	adiw	r24, 0x14	; 20
    2d98:	f5 cf       	rjmp	.-22     	; 0x2d84 <vDisplayUpdateTask+0x108>
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2d9a:	2f ef       	ldi	r18, 0xFF	; 255
    2d9c:	3f ef       	ldi	r19, 0xFF	; 255
    2d9e:	a9 01       	movw	r20, r18
    2da0:	65 2d       	mov	r22, r5
    2da2:	70 2f       	mov	r23, r16
    2da4:	80 91 21 3f 	lds	r24, 0x3F21	; 0x803f21 <displayLineQueue>
    2da8:	90 91 22 3f 	lds	r25, 0x3F22	; 0x803f22 <displayLineQueue+0x1>
    2dac:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <xQueueReceive>
    2db0:	88 23       	and	r24, r24
    2db2:	21 f1       	breq	.+72     	; 0x2dfc <vDisplayUpdateTask+0x180>
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2db4:	f6 01       	movw	r30, r12
    2db6:	21 81       	ldd	r18, Z+1	; 0x01
    2db8:	82 2f       	mov	r24, r18
    2dba:	90 e0       	ldi	r25, 0x00	; 0
    2dbc:	44 97       	sbiw	r24, 0x14	; 20
    2dbe:	f4 f4       	brge	.+60     	; 0x2dfc <vDisplayUpdateTask+0x180>
    2dc0:	82 81       	ldd	r24, Z+2	; 0x02
    2dc2:	88 23       	and	r24, r24
    2dc4:	d9 f0       	breq	.+54     	; 0x2dfc <vDisplayUpdateTask+0x180>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
    2dc6:	90 81       	ld	r25, Z
    2dc8:	30 e0       	ldi	r19, 0x00	; 0
    2dca:	d9 01       	movw	r26, r18
    2dcc:	49 9e       	mul	r4, r25
    2dce:	a0 0d       	add	r26, r0
    2dd0:	b1 1d       	adc	r27, r1
    2dd2:	11 24       	eor	r1, r1
    2dd4:	41 e0       	ldi	r20, 0x01	; 1
    2dd6:	50 e0       	ldi	r21, 0x00	; 0
    2dd8:	4c 0f       	add	r20, r28
    2dda:	5d 1f       	adc	r21, r29
    2ddc:	a4 0f       	add	r26, r20
    2dde:	b5 1f       	adc	r27, r21
    2de0:	33 96       	adiw	r30, 0x03	; 3
    2de2:	a4 01       	movw	r20, r8
    2de4:	42 1b       	sub	r20, r18
    2de6:	53 0b       	sbc	r21, r19
    2de8:	9a 01       	movw	r18, r20
    2dea:	2c 0d       	add	r18, r12
    2dec:	3d 1d       	adc	r19, r13
    2dee:	8d 93       	st	X+, r24
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2df0:	e2 17       	cp	r30, r18
    2df2:	f3 07       	cpc	r31, r19
    2df4:	19 f0       	breq	.+6      	; 0x2dfc <vDisplayUpdateTask+0x180>
    2df6:	81 91       	ld	r24, Z+
    2df8:	81 11       	cpse	r24, r1
    2dfa:	f9 cf       	rjmp	.-14     	; 0x2dee <vDisplayUpdateTask+0x172>
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
    2dfc:	80 91 21 3f 	lds	r24, 0x3F21	; 0x803f21 <displayLineQueue>
    2e00:	90 91 22 3f 	lds	r25, 0x3F22	; 0x803f22 <displayLineQueue+0x1>
    2e04:	0e 94 91 09 	call	0x1322	; 0x1322 <uxQueueMessagesWaiting>
    2e08:	81 11       	cpse	r24, r1
    2e0a:	c7 cf       	rjmp	.-114    	; 0x2d9a <vDisplayUpdateTask+0x11e>
    2e0c:	ce 01       	movw	r24, r28
    2e0e:	01 96       	adiw	r24, 0x01	; 1
    2e10:	7c 01       	movw	r14, r24
    2e12:	61 2c       	mov	r6, r1
    2e14:	71 2c       	mov	r7, r1
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
			 _displayWriteStringAtPos(i,0,&displayLines[i][0]);
    2e16:	a7 01       	movw	r20, r14
    2e18:	60 e0       	ldi	r22, 0x00	; 0
    2e1a:	70 e0       	ldi	r23, 0x00	; 0
    2e1c:	c3 01       	movw	r24, r6
    2e1e:	0e 94 33 16 	call	0x2c66	; 0x2c66 <_displayWriteStringAtPos>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
    2e22:	9f ef       	ldi	r25, 0xFF	; 255
    2e24:	69 1a       	sub	r6, r25
    2e26:	79 0a       	sbc	r7, r25
    2e28:	e4 e1       	ldi	r30, 0x14	; 20
    2e2a:	ee 0e       	add	r14, r30
    2e2c:	f1 1c       	adc	r15, r1
    2e2e:	f4 e0       	ldi	r31, 0x04	; 4
    2e30:	6f 16       	cp	r6, r31
    2e32:	71 04       	cpc	r7, r1
    2e34:	81 f7       	brne	.-32     	; 0x2e16 <vDisplayUpdateTask+0x19a>
    2e36:	85 cf       	rjmp	.-246    	; 0x2d42 <vDisplayUpdateTask+0xc6>

00002e38 <vDisplayClear>:
	 }
 }
 

void vDisplayClear() {
	xEventGroupSetBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2e38:	42 e0       	ldi	r20, 0x02	; 2
    2e3a:	50 e0       	ldi	r21, 0x00	; 0
    2e3c:	60 e0       	ldi	r22, 0x00	; 0
    2e3e:	70 e0       	ldi	r23, 0x00	; 0
    2e40:	80 91 23 3f 	lds	r24, 0x3F23	; 0x803f23 <egDisplayTiming>
    2e44:	90 91 24 3f 	lds	r25, 0x3F24	; 0x803f24 <egDisplayTiming+0x1>
    2e48:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
    2e4c:	08 95       	ret

00002e4e <vDisplayWriteStringAtPos>:
}

void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
    2e4e:	2f 92       	push	r2
    2e50:	3f 92       	push	r3
    2e52:	4f 92       	push	r4
    2e54:	5f 92       	push	r5
    2e56:	6f 92       	push	r6
    2e58:	7f 92       	push	r7
    2e5a:	8f 92       	push	r8
    2e5c:	9f 92       	push	r9
    2e5e:	af 92       	push	r10
    2e60:	bf 92       	push	r11
    2e62:	cf 92       	push	r12
    2e64:	df 92       	push	r13
    2e66:	ef 92       	push	r14
    2e68:	ff 92       	push	r15
    2e6a:	0f 93       	push	r16
    2e6c:	1f 93       	push	r17
    2e6e:	cf 93       	push	r28
    2e70:	df 93       	push	r29
    2e72:	cd b7       	in	r28, 0x3d	; 61
    2e74:	de b7       	in	r29, 0x3e	; 62
    2e76:	6d 97       	sbiw	r28, 0x1d	; 29
    2e78:	cd bf       	out	0x3d, r28	; 61
    2e7a:	de bf       	out	0x3e, r29	; 62
    2e7c:	2b a9       	ldd	r18, Y+51	; 0x33
    2e7e:	2b 8f       	std	Y+27, r18	; 0x1b
    2e80:	af a9       	ldd	r26, Y+55	; 0x37
    2e82:	b8 ad       	ldd	r27, Y+56	; 0x38
	va_list arg;	
	va_start(arg, fmt);
    2e84:	7e 01       	movw	r14, r28
    2e86:	39 e3       	ldi	r19, 0x39	; 57
    2e88:	e3 0e       	add	r14, r19
    2e8a:	f1 1c       	adc	r15, r1
    2e8c:	24 e0       	ldi	r18, 0x04	; 4
    2e8e:	3d e2       	ldi	r19, 0x2D	; 45
	display_vprintf(line, pos, fmt, arg);
    2e90:	e0 ef       	ldi	r30, 0xF0	; 240
    2e92:	fc e2       	ldi	r31, 0x2C	; 44
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
    2e94:	11 92       	st	Z+, r1
	char ch;
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
    2e96:	e2 17       	cp	r30, r18
    2e98:	f3 07       	cpc	r31, r19
    2e9a:	e1 f7       	brne	.-8      	; 0x2e94 <vDisplayWriteStringAtPos+0x46>
    2e9c:	0f 2e       	mov	r0, r31
    2e9e:	fc ed       	ldi	r31, 0xDC	; 220
    2ea0:	af 2e       	mov	r10, r31
    2ea2:	fc e2       	ldi	r31, 0x2C	; 44
    2ea4:	bf 2e       	mov	r11, r31
    2ea6:	f0 2d       	mov	r31, r0
    2ea8:	20 ef       	ldi	r18, 0xF0	; 240
    2eaa:	3c e2       	ldi	r19, 0x2C	; 44
    2eac:	f5 01       	movw	r30, r10
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
    2eae:	11 92       	st	Z+, r1
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    2eb0:	e2 17       	cp	r30, r18
    2eb2:	f3 07       	cpc	r31, r19
    2eb4:	e1 f7       	brne	.-8      	; 0x2eae <vDisplayWriteStringAtPos+0x60>
    2eb6:	81 2c       	mov	r8, r1
    2eb8:	91 2c       	mov	r9, r1
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    2eba:	0f 2e       	mov	r0, r31
    2ebc:	f0 ef       	ldi	r31, 0xF0	; 240
    2ebe:	cf 2e       	mov	r12, r31
    2ec0:	fc e2       	ldi	r31, 0x2C	; 44
    2ec2:	df 2e       	mov	r13, r31
    2ec4:	f0 2d       	mov	r31, r0
    2ec6:	fc c2       	rjmp	.+1528   	; 0x34c0 <vDisplayWriteStringAtPos+0x672>
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
    2ec8:	85 32       	cpi	r24, 0x25	; 37
    2eca:	09 f0       	breq	.+2      	; 0x2ece <vDisplayWriteStringAtPos+0x80>
    2ecc:	e8 c2       	rjmp	.+1488   	; 0x349e <vDisplayWriteStringAtPos+0x650>
			switch (ch = *fmt++) {
    2ece:	2d 01       	movw	r4, r26
    2ed0:	82 e0       	ldi	r24, 0x02	; 2
    2ed2:	48 0e       	add	r4, r24
    2ed4:	51 1c       	adc	r5, r1
    2ed6:	11 96       	adiw	r26, 0x01	; 1
    2ed8:	8c 91       	ld	r24, X
    2eda:	85 36       	cpi	r24, 0x65	; 101
    2edc:	09 f4       	brne	.+2      	; 0x2ee0 <vDisplayWriteStringAtPos+0x92>
    2ede:	db c1       	rjmp	.+950    	; 0x3296 <vDisplayWriteStringAtPos+0x448>
    2ee0:	38 f4       	brcc	.+14     	; 0x2ef0 <vDisplayWriteStringAtPos+0xa2>
    2ee2:	83 36       	cpi	r24, 0x63	; 99
    2ee4:	c1 f0       	breq	.+48     	; 0x2f16 <vDisplayWriteStringAtPos+0xc8>
    2ee6:	08 f0       	brcs	.+2      	; 0x2eea <vDisplayWriteStringAtPos+0x9c>
    2ee8:	48 c0       	rjmp	.+144    	; 0x2f7a <vDisplayWriteStringAtPos+0x12c>
    2eea:	85 32       	cpi	r24, 0x25	; 37
    2eec:	51 f0       	breq	.+20     	; 0x2f02 <vDisplayWriteStringAtPos+0xb4>
    2eee:	e7 c2       	rjmp	.+1486   	; 0x34be <vDisplayWriteStringAtPos+0x670>
    2ef0:	83 37       	cpi	r24, 0x73	; 115
    2ef2:	f9 f0       	breq	.+62     	; 0x2f32 <vDisplayWriteStringAtPos+0xe4>
    2ef4:	88 37       	cpi	r24, 0x78	; 120
    2ef6:	09 f4       	brne	.+2      	; 0x2efa <vDisplayWriteStringAtPos+0xac>
    2ef8:	68 c0       	rjmp	.+208    	; 0x2fca <vDisplayWriteStringAtPos+0x17c>
    2efa:	86 36       	cpi	r24, 0x66	; 102
    2efc:	09 f0       	breq	.+2      	; 0x2f00 <vDisplayWriteStringAtPos+0xb2>
    2efe:	df c2       	rjmp	.+1470   	; 0x34be <vDisplayWriteStringAtPos+0x670>
    2f00:	8c c0       	rjmp	.+280    	; 0x301a <vDisplayWriteStringAtPos+0x1cc>
				/* %% - print out a single %    */
				case '%':
				str[length] = '%';
    2f02:	f4 01       	movw	r30, r8
    2f04:	e4 52       	subi	r30, 0x24	; 36
    2f06:	f3 4d       	sbci	r31, 0xD3	; 211
    2f08:	95 e2       	ldi	r25, 0x25	; 37
    2f0a:	90 83       	st	Z, r25
				length++;
    2f0c:	af ef       	ldi	r26, 0xFF	; 255
    2f0e:	8a 1a       	sub	r8, r26
    2f10:	9a 0a       	sbc	r9, r26
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2f12:	d2 01       	movw	r26, r4
    2f14:	d5 c2       	rjmp	.+1450   	; 0x34c0 <vDisplayWriteStringAtPos+0x672>
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
				str[length] = char_temp;
    2f16:	f4 01       	movw	r30, r8
    2f18:	e4 52       	subi	r30, 0x24	; 36
    2f1a:	f3 4d       	sbci	r31, 0xD3	; 211
    2f1c:	d7 01       	movw	r26, r14
    2f1e:	8c 91       	ld	r24, X
    2f20:	80 83       	st	Z, r24
				length++;
    2f22:	bf ef       	ldi	r27, 0xFF	; 255
    2f24:	8b 1a       	sub	r8, r27
    2f26:	9b 0a       	sbc	r9, r27
				length++;
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
    2f28:	f7 01       	movw	r30, r14
    2f2a:	32 96       	adiw	r30, 0x02	; 2
    2f2c:	7f 01       	movw	r14, r30
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2f2e:	d2 01       	movw	r26, r4
    2f30:	c7 c2       	rjmp	.+1422   	; 0x34c0 <vDisplayWriteStringAtPos+0x672>
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2f32:	a7 01       	movw	r20, r14
    2f34:	4e 5f       	subi	r20, 0xFE	; 254
    2f36:	5f 4f       	sbci	r21, 0xFF	; 255
    2f38:	d7 01       	movw	r26, r14
    2f3a:	8d 91       	ld	r24, X+
    2f3c:	9c 91       	ld	r25, X
    2f3e:	9c 01       	movw	r18, r24
    2f40:	b4 01       	movw	r22, r8
    2f42:	f4 01       	movw	r30, r8
    2f44:	e4 52       	subi	r30, 0x24	; 36
    2f46:	f3 4d       	sbci	r31, 0xD3	; 211
				for(int i = 0; i < strlen(string_temp);i++) {
    2f48:	00 e0       	ldi	r16, 0x00	; 0
    2f4a:	10 e0       	ldi	r17, 0x00	; 0
    2f4c:	06 c0       	rjmp	.+12     	; 0x2f5a <vDisplayWriteStringAtPos+0x10c>
					str[length+i] = string_temp[i];
    2f4e:	d9 01       	movw	r26, r18
    2f50:	fd 90       	ld	r15, X+
    2f52:	9d 01       	movw	r18, r26
    2f54:	f1 92       	st	Z+, r15
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
				for(int i = 0; i < strlen(string_temp);i++) {
    2f56:	0f 5f       	subi	r16, 0xFF	; 255
    2f58:	1f 4f       	sbci	r17, 0xFF	; 255
    2f5a:	dc 01       	movw	r26, r24
    2f5c:	0d 90       	ld	r0, X+
    2f5e:	00 20       	and	r0, r0
    2f60:	e9 f7       	brne	.-6      	; 0x2f5c <vDisplayWriteStringAtPos+0x10e>
    2f62:	11 97       	sbiw	r26, 0x01	; 1
    2f64:	a8 1b       	sub	r26, r24
    2f66:	b9 0b       	sbc	r27, r25
    2f68:	0a 17       	cp	r16, r26
    2f6a:	1b 07       	cpc	r17, r27
    2f6c:	80 f3       	brcs	.-32     	; 0x2f4e <vDisplayWriteStringAtPos+0x100>
					str[length+i] = string_temp[i];
				}
				length += strlen(string_temp);
    2f6e:	4d 01       	movw	r8, r26
    2f70:	86 0e       	add	r8, r22
    2f72:	97 1e       	adc	r9, r23
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2f74:	7a 01       	movw	r14, r20
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2f76:	d2 01       	movw	r26, r4
    2f78:	a3 c2       	rjmp	.+1350   	; 0x34c0 <vDisplayWriteStringAtPos+0x672>
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    2f7a:	87 01       	movw	r16, r14
    2f7c:	0e 5f       	subi	r16, 0xFE	; 254
    2f7e:	1f 4f       	sbci	r17, 0xFF	; 255
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    2f80:	4a e0       	ldi	r20, 0x0A	; 10
    2f82:	b6 01       	movw	r22, r12
    2f84:	f7 01       	movw	r30, r14
    2f86:	80 81       	ld	r24, Z
    2f88:	91 81       	ldd	r25, Z+1	; 0x01
    2f8a:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <__itoa_ncheck>
    2f8e:	94 01       	movw	r18, r8
    2f90:	d4 01       	movw	r26, r8
    2f92:	a4 52       	subi	r26, 0x24	; 36
    2f94:	b3 4d       	sbci	r27, 0xD3	; 211
    2f96:	40 ef       	ldi	r20, 0xF0	; 240
    2f98:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    2f9a:	80 e0       	ldi	r24, 0x00	; 0
    2f9c:	90 e0       	ldi	r25, 0x00	; 0
    2f9e:	05 c0       	rjmp	.+10     	; 0x2faa <vDisplayWriteStringAtPos+0x15c>
					str[length+i] = buffer[i];
    2fa0:	fa 01       	movw	r30, r20
    2fa2:	61 91       	ld	r22, Z+
    2fa4:	af 01       	movw	r20, r30
    2fa6:	6d 93       	st	X+, r22

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    2fa8:	01 96       	adiw	r24, 0x01	; 1
    2faa:	f6 01       	movw	r30, r12
    2fac:	01 90       	ld	r0, Z+
    2fae:	00 20       	and	r0, r0
    2fb0:	e9 f7       	brne	.-6      	; 0x2fac <vDisplayWriteStringAtPos+0x15e>
    2fb2:	31 97       	sbiw	r30, 0x01	; 1
    2fb4:	e0 5f       	subi	r30, 0xF0	; 240
    2fb6:	fc 42       	sbci	r31, 0x2C	; 44
    2fb8:	8e 17       	cp	r24, r30
    2fba:	9f 07       	cpc	r25, r31
    2fbc:	88 f3       	brcs	.-30     	; 0x2fa0 <vDisplayWriteStringAtPos+0x152>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    2fbe:	4f 01       	movw	r8, r30
    2fc0:	82 0e       	add	r8, r18
    2fc2:	93 1e       	adc	r9, r19
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    2fc4:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2fc6:	d2 01       	movw	r26, r4
    2fc8:	7b c2       	rjmp	.+1270   	; 0x34c0 <vDisplayWriteStringAtPos+0x672>
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    2fca:	87 01       	movw	r16, r14
    2fcc:	0e 5f       	subi	r16, 0xFE	; 254
    2fce:	1f 4f       	sbci	r17, 0xFF	; 255
    2fd0:	40 e1       	ldi	r20, 0x10	; 16
    2fd2:	b6 01       	movw	r22, r12
    2fd4:	d7 01       	movw	r26, r14
    2fd6:	8d 91       	ld	r24, X+
    2fd8:	9c 91       	ld	r25, X
    2fda:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <__itoa_ncheck>
    2fde:	94 01       	movw	r18, r8
    2fe0:	f4 01       	movw	r30, r8
    2fe2:	e4 52       	subi	r30, 0x24	; 36
    2fe4:	f3 4d       	sbci	r31, 0xD3	; 211
    2fe6:	40 ef       	ldi	r20, 0xF0	; 240
    2fe8:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    2fea:	80 e0       	ldi	r24, 0x00	; 0
    2fec:	90 e0       	ldi	r25, 0x00	; 0
    2fee:	05 c0       	rjmp	.+10     	; 0x2ffa <vDisplayWriteStringAtPos+0x1ac>
					str[length+i] = buffer[i];
    2ff0:	da 01       	movw	r26, r20
    2ff2:	6d 91       	ld	r22, X+
    2ff4:	ad 01       	movw	r20, r26
    2ff6:	61 93       	st	Z+, r22

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    2ff8:	01 96       	adiw	r24, 0x01	; 1
    2ffa:	d6 01       	movw	r26, r12
    2ffc:	0d 90       	ld	r0, X+
    2ffe:	00 20       	and	r0, r0
    3000:	e9 f7       	brne	.-6      	; 0x2ffc <vDisplayWriteStringAtPos+0x1ae>
    3002:	11 97       	sbiw	r26, 0x01	; 1
    3004:	a0 5f       	subi	r26, 0xF0	; 240
    3006:	bc 42       	sbci	r27, 0x2C	; 44
    3008:	8a 17       	cp	r24, r26
    300a:	9b 07       	cpc	r25, r27
    300c:	88 f3       	brcs	.-30     	; 0x2ff0 <vDisplayWriteStringAtPos+0x1a2>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    300e:	4d 01       	movw	r8, r26
    3010:	82 0e       	add	r8, r18
    3012:	93 1e       	adc	r9, r19
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    3014:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3016:	d2 01       	movw	r26, r4
    3018:	53 c2       	rjmp	.+1190   	; 0x34c0 <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    301a:	17 01       	movw	r2, r14
    301c:	b4 e0       	ldi	r27, 0x04	; 4
    301e:	2b 0e       	add	r2, r27
    3020:	31 1c       	adc	r3, r1
    3022:	d7 01       	movw	r26, r14
    3024:	8d 91       	ld	r24, X+
    3026:	9d 91       	ld	r25, X+
    3028:	0d 90       	ld	r0, X+
    302a:	bc 91       	ld	r27, X
    302c:	a0 2d       	mov	r26, r0
    302e:	8f 8b       	std	Y+23, r24	; 0x17
    3030:	98 8f       	std	Y+24, r25	; 0x18
    3032:	a9 8f       	std	Y+25, r26	; 0x19
    3034:	ba 8f       	std	Y+26, r27	; 0x1a

    int exponent = 0;
    int places = 0;
    static const int width = 4;

    if (value == 0.0) {
    3036:	20 e0       	ldi	r18, 0x00	; 0
    3038:	30 e0       	ldi	r19, 0x00	; 0
    303a:	a9 01       	movw	r20, r18
    303c:	bc 01       	movw	r22, r24
    303e:	cd 01       	movw	r24, r26
    3040:	0e 94 16 1c 	call	0x382c	; 0x382c <__cmpsf2>
    3044:	81 11       	cpse	r24, r1
    3046:	05 c0       	rjmp	.+10     	; 0x3052 <vDisplayWriteStringAtPos+0x204>
        buffer[0] = '0';
    3048:	20 e3       	ldi	r18, 0x30	; 48
    304a:	f6 01       	movw	r30, r12
    304c:	20 83       	st	Z, r18
        buffer[1] = '\0';
    304e:	11 82       	std	Z+1, r1	; 0x01
    3050:	04 c1       	rjmp	.+520    	; 0x325a <vDisplayWriteStringAtPos+0x40c>
        return;
    }         

    if (value < 0.0) {
    3052:	20 e0       	ldi	r18, 0x00	; 0
    3054:	30 e0       	ldi	r19, 0x00	; 0
    3056:	a9 01       	movw	r20, r18
    3058:	6f 89       	ldd	r22, Y+23	; 0x17
    305a:	78 8d       	ldd	r23, Y+24	; 0x18
    305c:	89 8d       	ldd	r24, Y+25	; 0x19
    305e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3060:	0e 94 16 1c 	call	0x382c	; 0x382c <__cmpsf2>
    3064:	88 23       	and	r24, r24
    3066:	9c f4       	brge	.+38     	; 0x308e <vDisplayWriteStringAtPos+0x240>
        *buffer++ = '-';
    3068:	ed e2       	ldi	r30, 0x2D	; 45
    306a:	d6 01       	movw	r26, r12
    306c:	ec 93       	st	X, r30
        value = -value;
    306e:	8f 89       	ldd	r24, Y+23	; 0x17
    3070:	98 8d       	ldd	r25, Y+24	; 0x18
    3072:	a9 8d       	ldd	r26, Y+25	; 0x19
    3074:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3076:	b0 58       	subi	r27, 0x80	; 128
    3078:	8f 8b       	std	Y+23, r24	; 0x17
    307a:	98 8f       	std	Y+24, r25	; 0x18
    307c:	a9 8f       	std	Y+25, r26	; 0x19
    307e:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
        *buffer++ = '-';
    3080:	0f 2e       	mov	r0, r31
    3082:	f1 ef       	ldi	r31, 0xF1	; 241
    3084:	6f 2e       	mov	r6, r31
    3086:	fc e2       	ldi	r31, 0x2C	; 44
    3088:	7f 2e       	mov	r7, r31
    308a:	f0 2d       	mov	r31, r0
    308c:	01 c0       	rjmp	.+2      	; 0x3090 <vDisplayWriteStringAtPos+0x242>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
    308e:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3090:	20 e0       	ldi	r18, 0x00	; 0
    3092:	30 e0       	ldi	r19, 0x00	; 0
    3094:	40 e8       	ldi	r20, 0x80	; 128
    3096:	5f e3       	ldi	r21, 0x3F	; 63
    3098:	6f 89       	ldd	r22, Y+23	; 0x17
    309a:	78 8d       	ldd	r23, Y+24	; 0x18
    309c:	89 8d       	ldd	r24, Y+25	; 0x19
    309e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    30a0:	0e 94 75 1d 	call	0x3aea	; 0x3aea <__gesf2>
    30a4:	88 23       	and	r24, r24
    30a6:	0c f4       	brge	.+2      	; 0x30aa <vDisplayWriteStringAtPos+0x25c>
    30a8:	44 c2       	rjmp	.+1160   	; 0x3532 <vDisplayWriteStringAtPos+0x6e4>
    30aa:	00 e0       	ldi	r16, 0x00	; 0
    30ac:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    30ae:	20 e0       	ldi	r18, 0x00	; 0
    30b0:	30 e0       	ldi	r19, 0x00	; 0
    30b2:	40 e2       	ldi	r20, 0x20	; 32
    30b4:	51 e4       	ldi	r21, 0x41	; 65
    30b6:	6f 89       	ldd	r22, Y+23	; 0x17
    30b8:	78 8d       	ldd	r23, Y+24	; 0x18
    30ba:	89 8d       	ldd	r24, Y+25	; 0x19
    30bc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    30be:	0e 94 1b 1c 	call	0x3836	; 0x3836 <__divsf3>
    30c2:	6f 8b       	std	Y+23, r22	; 0x17
    30c4:	78 8f       	std	Y+24, r23	; 0x18
    30c6:	89 8f       	std	Y+25, r24	; 0x19
    30c8:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    30ca:	0f 5f       	subi	r16, 0xFF	; 255
    30cc:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    30ce:	20 e0       	ldi	r18, 0x00	; 0
    30d0:	30 e0       	ldi	r19, 0x00	; 0
    30d2:	40 e8       	ldi	r20, 0x80	; 128
    30d4:	5f e3       	ldi	r21, 0x3F	; 63
    30d6:	0e 94 75 1d 	call	0x3aea	; 0x3aea <__gesf2>
    30da:	88 23       	and	r24, r24
    30dc:	44 f7       	brge	.-48     	; 0x30ae <vDisplayWriteStringAtPos+0x260>
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    30de:	2d ec       	ldi	r18, 0xCD	; 205
    30e0:	3c ec       	ldi	r19, 0xCC	; 204
    30e2:	4c ec       	ldi	r20, 0xCC	; 204
    30e4:	5d e3       	ldi	r21, 0x3D	; 61
    30e6:	6f 89       	ldd	r22, Y+23	; 0x17
    30e8:	78 8d       	ldd	r23, Y+24	; 0x18
    30ea:	89 8d       	ldd	r24, Y+25	; 0x19
    30ec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    30ee:	0e 94 16 1c 	call	0x382c	; 0x382c <__cmpsf2>
    30f2:	88 23       	and	r24, r24
    30f4:	1c f0       	brlt	.+6      	; 0x30fc <vDisplayWriteStringAtPos+0x2ae>
    30f6:	1a c0       	rjmp	.+52     	; 0x312c <vDisplayWriteStringAtPos+0x2de>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    30f8:	00 e0       	ldi	r16, 0x00	; 0
    30fa:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
        value *= 10.0;
    30fc:	20 e0       	ldi	r18, 0x00	; 0
    30fe:	30 e0       	ldi	r19, 0x00	; 0
    3100:	40 e2       	ldi	r20, 0x20	; 32
    3102:	51 e4       	ldi	r21, 0x41	; 65
    3104:	6f 89       	ldd	r22, Y+23	; 0x17
    3106:	78 8d       	ldd	r23, Y+24	; 0x18
    3108:	89 8d       	ldd	r24, Y+25	; 0x19
    310a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    310c:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <__mulsf3>
    3110:	6f 8b       	std	Y+23, r22	; 0x17
    3112:	78 8f       	std	Y+24, r23	; 0x18
    3114:	89 8f       	std	Y+25, r24	; 0x19
    3116:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    3118:	01 50       	subi	r16, 0x01	; 1
    311a:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    311c:	2d ec       	ldi	r18, 0xCD	; 205
    311e:	3c ec       	ldi	r19, 0xCC	; 204
    3120:	4c ec       	ldi	r20, 0xCC	; 204
    3122:	5d e3       	ldi	r21, 0x3D	; 61
    3124:	0e 94 16 1c 	call	0x382c	; 0x382c <__cmpsf2>
    3128:	88 23       	and	r24, r24
    312a:	44 f3       	brlt	.-48     	; 0x30fc <vDisplayWriteStringAtPos+0x2ae>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    312c:	10 16       	cp	r1, r16
    312e:	11 06       	cpc	r1, r17
    3130:	ac f5       	brge	.+106    	; 0x319c <vDisplayWriteStringAtPos+0x34e>
    3132:	73 01       	movw	r14, r6
    3134:	d3 01       	movw	r26, r6
    3136:	a0 0f       	add	r26, r16
    3138:	b1 1f       	adc	r27, r17
    313a:	ac 8f       	std	Y+28, r26	; 0x1c
    313c:	bd 8f       	std	Y+29, r27	; 0x1d
    313e:	3d 01       	movw	r6, r26
    3140:	6f 89       	ldd	r22, Y+23	; 0x17
    3142:	78 8d       	ldd	r23, Y+24	; 0x18
    3144:	89 8d       	ldd	r24, Y+25	; 0x19
    3146:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10;
    3148:	20 e0       	ldi	r18, 0x00	; 0
    314a:	30 e0       	ldi	r19, 0x00	; 0
    314c:	40 e2       	ldi	r20, 0x20	; 32
    314e:	51 e4       	ldi	r21, 0x41	; 65
    3150:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <__mulsf3>
    3154:	6f 8b       	std	Y+23, r22	; 0x17
    3156:	78 8f       	std	Y+24, r23	; 0x18
    3158:	89 8f       	std	Y+25, r24	; 0x19
    315a:	9a 8f       	std	Y+26, r25	; 0x1a
    315c:	0e 94 8d 1c 	call	0x391a	; 0x391a <__fixsfsi>
        *buffer++ = digit + '0';
    3160:	20 e3       	ldi	r18, 0x30	; 48
    3162:	26 0f       	add	r18, r22
    3164:	f7 01       	movw	r30, r14
    3166:	21 93       	st	Z+, r18
    3168:	7f 01       	movw	r14, r30
        value = value * 10 - digit;
    316a:	07 2e       	mov	r0, r23
    316c:	00 0c       	add	r0, r0
    316e:	88 0b       	sbc	r24, r24
    3170:	99 0b       	sbc	r25, r25
    3172:	0e 94 c5 1c 	call	0x398a	; 0x398a <__floatsisf>
    3176:	9b 01       	movw	r18, r22
    3178:	ac 01       	movw	r20, r24
    317a:	6f 89       	ldd	r22, Y+23	; 0x17
    317c:	78 8d       	ldd	r23, Y+24	; 0x18
    317e:	89 8d       	ldd	r24, Y+25	; 0x19
    3180:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3182:	0e 94 a9 1b 	call	0x3752	; 0x3752 <__subsf3>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    3186:	e6 14       	cp	r14, r6
    3188:	f7 04       	cpc	r15, r7
    318a:	f1 f6       	brne	.-68     	; 0x3148 <vDisplayWriteStringAtPos+0x2fa>
    318c:	6f 8b       	std	Y+23, r22	; 0x17
    318e:	78 8f       	std	Y+24, r23	; 0x18
    3190:	89 8f       	std	Y+25, r24	; 0x19
    3192:	9a 8f       	std	Y+26, r25	; 0x1a
        value = value * 10 - digit;
        ++places;
        --exponent;
    }

    if (places == 0)
    3194:	01 15       	cp	r16, r1
    3196:	11 05       	cpc	r17, r1
    3198:	89 f4       	brne	.+34     	; 0x31bc <vDisplayWriteStringAtPos+0x36e>
    319a:	db c1       	rjmp	.+950    	; 0x3552 <vDisplayWriteStringAtPos+0x704>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    319c:	c8 01       	movw	r24, r16
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    319e:	e0 e3       	ldi	r30, 0x30	; 48
    31a0:	d3 01       	movw	r26, r6
    31a2:	ec 93       	st	X, r30

    *buffer++ = '.';
    31a4:	73 01       	movw	r14, r6
    31a6:	f2 e0       	ldi	r31, 0x02	; 2
    31a8:	ef 0e       	add	r14, r31
    31aa:	f1 1c       	adc	r15, r1
    31ac:	2e e2       	ldi	r18, 0x2E	; 46
    31ae:	11 96       	adiw	r26, 0x01	; 1
    31b0:	2c 93       	st	X, r18

    while (exponent < 0 && places < width) {
    31b2:	99 23       	and	r25, r25
    31b4:	6c f0       	brlt	.+26     	; 0x31d0 <vDisplayWriteStringAtPos+0x382>
    31b6:	00 e0       	ldi	r16, 0x00	; 0
    31b8:	10 e0       	ldi	r17, 0x00	; 0
    31ba:	1f c0       	rjmp	.+62     	; 0x31fa <vDisplayWriteStringAtPos+0x3ac>
    }

    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';
    31bc:	ec 8c       	ldd	r14, Y+28	; 0x1c
    31be:	fd 8c       	ldd	r15, Y+29	; 0x1d
    31c0:	3f ef       	ldi	r19, 0xFF	; 255
    31c2:	e3 1a       	sub	r14, r19
    31c4:	f3 0a       	sbc	r15, r19
    31c6:	ee e2       	ldi	r30, 0x2E	; 46
    31c8:	ac 8d       	ldd	r26, Y+28	; 0x1c
    31ca:	bd 8d       	ldd	r27, Y+29	; 0x1d
    31cc:	ec 93       	st	X, r30
    31ce:	12 c0       	rjmp	.+36     	; 0x31f4 <vDisplayWriteStringAtPos+0x3a6>

    while (exponent < 0 && places < width) {
    31d0:	00 e0       	ldi	r16, 0x00	; 0
    31d2:	10 e0       	ldi	r17, 0x00	; 0
        *buffer++ = '0';
    31d4:	ff ef       	ldi	r31, 0xFF	; 255
    31d6:	ef 1a       	sub	r14, r31
    31d8:	ff 0a       	sbc	r15, r31
    31da:	f7 01       	movw	r30, r14
    31dc:	31 97       	sbiw	r30, 0x01	; 1
    31de:	20 e3       	ldi	r18, 0x30	; 48
    31e0:	20 83       	st	Z, r18
        --exponent;
    31e2:	01 97       	sbiw	r24, 0x01	; 1
        ++places;
    31e4:	0f 5f       	subi	r16, 0xFF	; 255
    31e6:	1f 4f       	sbci	r17, 0xFF	; 255
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    31e8:	99 23       	and	r25, r25
    31ea:	24 f4       	brge	.+8      	; 0x31f4 <vDisplayWriteStringAtPos+0x3a6>
    31ec:	04 30       	cpi	r16, 0x04	; 4
    31ee:	11 05       	cpc	r17, r1
    31f0:	8c f3       	brlt	.-30     	; 0x31d4 <vDisplayWriteStringAtPos+0x386>
    31f2:	31 c0       	rjmp	.+98     	; 0x3256 <vDisplayWriteStringAtPos+0x408>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    31f4:	04 30       	cpi	r16, 0x04	; 4
    31f6:	11 05       	cpc	r17, r1
    31f8:	74 f5       	brge	.+92     	; 0x3256 <vDisplayWriteStringAtPos+0x408>
    31fa:	37 01       	movw	r6, r14
    31fc:	84 e0       	ldi	r24, 0x04	; 4
    31fe:	90 e0       	ldi	r25, 0x00	; 0
    3200:	80 1b       	sub	r24, r16
    3202:	91 0b       	sbc	r25, r17
    3204:	e8 0e       	add	r14, r24
    3206:	f9 1e       	adc	r15, r25
    3208:	87 01       	movw	r16, r14
    320a:	6f 89       	ldd	r22, Y+23	; 0x17
    320c:	78 8d       	ldd	r23, Y+24	; 0x18
    320e:	89 8d       	ldd	r24, Y+25	; 0x19
    3210:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10.0;
    3212:	20 e0       	ldi	r18, 0x00	; 0
    3214:	30 e0       	ldi	r19, 0x00	; 0
    3216:	40 e2       	ldi	r20, 0x20	; 32
    3218:	51 e4       	ldi	r21, 0x41	; 65
    321a:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <__mulsf3>
    321e:	6f 8b       	std	Y+23, r22	; 0x17
    3220:	78 8f       	std	Y+24, r23	; 0x18
    3222:	89 8f       	std	Y+25, r24	; 0x19
    3224:	9a 8f       	std	Y+26, r25	; 0x1a
    3226:	0e 94 8d 1c 	call	0x391a	; 0x391a <__fixsfsi>
        *buffer++ = digit + '0';
    322a:	20 e3       	ldi	r18, 0x30	; 48
    322c:	26 0f       	add	r18, r22
    322e:	d3 01       	movw	r26, r6
    3230:	2d 93       	st	X+, r18
    3232:	3d 01       	movw	r6, r26
        value = value * 10.0 - digit;
    3234:	07 2e       	mov	r0, r23
    3236:	00 0c       	add	r0, r0
    3238:	88 0b       	sbc	r24, r24
    323a:	99 0b       	sbc	r25, r25
    323c:	0e 94 c5 1c 	call	0x398a	; 0x398a <__floatsisf>
    3240:	9b 01       	movw	r18, r22
    3242:	ac 01       	movw	r20, r24
    3244:	6f 89       	ldd	r22, Y+23	; 0x17
    3246:	78 8d       	ldd	r23, Y+24	; 0x18
    3248:	89 8d       	ldd	r24, Y+25	; 0x19
    324a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    324c:	0e 94 a9 1b 	call	0x3752	; 0x3752 <__subsf3>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    3250:	60 16       	cp	r6, r16
    3252:	71 06       	cpc	r7, r17
    3254:	f1 f6       	brne	.-68     	; 0x3212 <vDisplayWriteStringAtPos+0x3c4>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
        ++places;
    }
    *buffer = '\0';
    3256:	f7 01       	movw	r30, r14
    3258:	10 82       	st	Z, r1
    325a:	94 01       	movw	r18, r8
    325c:	f4 01       	movw	r30, r8
    325e:	e4 52       	subi	r30, 0x24	; 36
    3260:	f3 4d       	sbci	r31, 0xD3	; 211
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    3262:	40 ef       	ldi	r20, 0xF0	; 240
    3264:	5c e2       	ldi	r21, 0x2C	; 44
    3266:	80 e0       	ldi	r24, 0x00	; 0
    3268:	90 e0       	ldi	r25, 0x00	; 0
    326a:	05 c0       	rjmp	.+10     	; 0x3276 <vDisplayWriteStringAtPos+0x428>

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    326c:	da 01       	movw	r26, r20
    326e:	6d 91       	ld	r22, X+
    3270:	ad 01       	movw	r20, r26
    3272:	61 93       	st	Z+, r22
				break;

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    3274:	01 96       	adiw	r24, 0x01	; 1
    3276:	d6 01       	movw	r26, r12
    3278:	0d 90       	ld	r0, X+
    327a:	00 20       	and	r0, r0
    327c:	e9 f7       	brne	.-6      	; 0x3278 <vDisplayWriteStringAtPos+0x42a>
    327e:	11 97       	sbiw	r26, 0x01	; 1
    3280:	a0 5f       	subi	r26, 0xF0	; 240
    3282:	bc 42       	sbci	r27, 0x2C	; 44
    3284:	8a 17       	cp	r24, r26
    3286:	9b 07       	cpc	r25, r27
    3288:	88 f3       	brcs	.-30     	; 0x326c <vDisplayWriteStringAtPos+0x41e>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    328a:	4d 01       	movw	r8, r26
    328c:	82 0e       	add	r8, r18
    328e:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    3290:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3292:	d2 01       	movw	r26, r4
    3294:	15 c1       	rjmp	.+554    	; 0x34c0 <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    3296:	17 01       	movw	r2, r14
    3298:	b4 e0       	ldi	r27, 0x04	; 4
    329a:	2b 0e       	add	r2, r27
    329c:	31 1c       	adc	r3, r1
    329e:	d7 01       	movw	r26, r14
    32a0:	8d 91       	ld	r24, X+
    32a2:	9d 91       	ld	r25, X+
    32a4:	0d 90       	ld	r0, X+
    32a6:	bc 91       	ld	r27, X
    32a8:	a0 2d       	mov	r26, r0
    32aa:	8f 8b       	std	Y+23, r24	; 0x17
    32ac:	98 8f       	std	Y+24, r25	; 0x18
    32ae:	a9 8f       	std	Y+25, r26	; 0x19
    32b0:	ba 8f       	std	Y+26, r27	; 0x1a

void ftoa_sci(char *buffer, double value) {
    int exponent = 0;    
    static const int width = 4;

    if (value == 0.0) {
    32b2:	20 e0       	ldi	r18, 0x00	; 0
    32b4:	30 e0       	ldi	r19, 0x00	; 0
    32b6:	a9 01       	movw	r20, r18
    32b8:	bc 01       	movw	r22, r24
    32ba:	cd 01       	movw	r24, r26
    32bc:	0e 94 16 1c 	call	0x382c	; 0x382c <__cmpsf2>
    32c0:	81 11       	cpse	r24, r1
    32c2:	05 c0       	rjmp	.+10     	; 0x32ce <vDisplayWriteStringAtPos+0x480>
        buffer[0] = '0';
    32c4:	20 e3       	ldi	r18, 0x30	; 48
    32c6:	f6 01       	movw	r30, r12
    32c8:	20 83       	st	Z, r18
        buffer[1] = '\0';
    32ca:	11 82       	std	Z+1, r1	; 0x01
    32cc:	ca c0       	rjmp	.+404    	; 0x3462 <vDisplayWriteStringAtPos+0x614>
        return;
    }

    if (value < 0.0) {
    32ce:	20 e0       	ldi	r18, 0x00	; 0
    32d0:	30 e0       	ldi	r19, 0x00	; 0
    32d2:	a9 01       	movw	r20, r18
    32d4:	6f 89       	ldd	r22, Y+23	; 0x17
    32d6:	78 8d       	ldd	r23, Y+24	; 0x18
    32d8:	89 8d       	ldd	r24, Y+25	; 0x19
    32da:	9a 8d       	ldd	r25, Y+26	; 0x1a
    32dc:	0e 94 16 1c 	call	0x382c	; 0x382c <__cmpsf2>
    32e0:	88 23       	and	r24, r24
    32e2:	9c f4       	brge	.+38     	; 0x330a <vDisplayWriteStringAtPos+0x4bc>
        *buffer++ = '-';
    32e4:	ed e2       	ldi	r30, 0x2D	; 45
    32e6:	d6 01       	movw	r26, r12
    32e8:	ec 93       	st	X, r30
        value = -value;
    32ea:	8f 89       	ldd	r24, Y+23	; 0x17
    32ec:	98 8d       	ldd	r25, Y+24	; 0x18
    32ee:	a9 8d       	ldd	r26, Y+25	; 0x19
    32f0:	ba 8d       	ldd	r27, Y+26	; 0x1a
    32f2:	b0 58       	subi	r27, 0x80	; 128
    32f4:	8f 8b       	std	Y+23, r24	; 0x17
    32f6:	98 8f       	std	Y+24, r25	; 0x18
    32f8:	a9 8f       	std	Y+25, r26	; 0x19
    32fa:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
        *buffer++ = '-';
    32fc:	0f 2e       	mov	r0, r31
    32fe:	f1 ef       	ldi	r31, 0xF1	; 241
    3300:	6f 2e       	mov	r6, r31
    3302:	fc e2       	ldi	r31, 0x2C	; 44
    3304:	7f 2e       	mov	r7, r31
    3306:	f0 2d       	mov	r31, r0
    3308:	01 c0       	rjmp	.+2      	; 0x330c <vDisplayWriteStringAtPos+0x4be>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
    330a:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    330c:	20 e0       	ldi	r18, 0x00	; 0
    330e:	30 e0       	ldi	r19, 0x00	; 0
    3310:	40 e8       	ldi	r20, 0x80	; 128
    3312:	5f e3       	ldi	r21, 0x3F	; 63
    3314:	6f 89       	ldd	r22, Y+23	; 0x17
    3316:	78 8d       	ldd	r23, Y+24	; 0x18
    3318:	89 8d       	ldd	r24, Y+25	; 0x19
    331a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    331c:	0e 94 75 1d 	call	0x3aea	; 0x3aea <__gesf2>
    3320:	88 23       	and	r24, r24
    3322:	dc f0       	brlt	.+54     	; 0x335a <vDisplayWriteStringAtPos+0x50c>
    3324:	00 e0       	ldi	r16, 0x00	; 0
    3326:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    3328:	20 e0       	ldi	r18, 0x00	; 0
    332a:	30 e0       	ldi	r19, 0x00	; 0
    332c:	40 e2       	ldi	r20, 0x20	; 32
    332e:	51 e4       	ldi	r21, 0x41	; 65
    3330:	6f 89       	ldd	r22, Y+23	; 0x17
    3332:	78 8d       	ldd	r23, Y+24	; 0x18
    3334:	89 8d       	ldd	r24, Y+25	; 0x19
    3336:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3338:	0e 94 1b 1c 	call	0x3836	; 0x3836 <__divsf3>
    333c:	6f 8b       	std	Y+23, r22	; 0x17
    333e:	78 8f       	std	Y+24, r23	; 0x18
    3340:	89 8f       	std	Y+25, r24	; 0x19
    3342:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    3344:	0f 5f       	subi	r16, 0xFF	; 255
    3346:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3348:	20 e0       	ldi	r18, 0x00	; 0
    334a:	30 e0       	ldi	r19, 0x00	; 0
    334c:	40 e8       	ldi	r20, 0x80	; 128
    334e:	5f e3       	ldi	r21, 0x3F	; 63
    3350:	0e 94 75 1d 	call	0x3aea	; 0x3aea <__gesf2>
    3354:	88 23       	and	r24, r24
    3356:	44 f7       	brge	.-48     	; 0x3328 <vDisplayWriteStringAtPos+0x4da>
    3358:	02 c0       	rjmp	.+4      	; 0x335e <vDisplayWriteStringAtPos+0x510>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    335a:	00 e0       	ldi	r16, 0x00	; 0
    335c:	10 e0       	ldi	r17, 0x00	; 0
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    335e:	2d ec       	ldi	r18, 0xCD	; 205
    3360:	3c ec       	ldi	r19, 0xCC	; 204
    3362:	4c ec       	ldi	r20, 0xCC	; 204
    3364:	5d e3       	ldi	r21, 0x3D	; 61
    3366:	6f 89       	ldd	r22, Y+23	; 0x17
    3368:	78 8d       	ldd	r23, Y+24	; 0x18
    336a:	89 8d       	ldd	r24, Y+25	; 0x19
    336c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    336e:	0e 94 16 1c 	call	0x382c	; 0x382c <__cmpsf2>
    3372:	88 23       	and	r24, r24
    3374:	c4 f4       	brge	.+48     	; 0x33a6 <vDisplayWriteStringAtPos+0x558>
        value *= 10.0;
    3376:	20 e0       	ldi	r18, 0x00	; 0
    3378:	30 e0       	ldi	r19, 0x00	; 0
    337a:	40 e2       	ldi	r20, 0x20	; 32
    337c:	51 e4       	ldi	r21, 0x41	; 65
    337e:	6f 89       	ldd	r22, Y+23	; 0x17
    3380:	78 8d       	ldd	r23, Y+24	; 0x18
    3382:	89 8d       	ldd	r24, Y+25	; 0x19
    3384:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3386:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <__mulsf3>
    338a:	6f 8b       	std	Y+23, r22	; 0x17
    338c:	78 8f       	std	Y+24, r23	; 0x18
    338e:	89 8f       	std	Y+25, r24	; 0x19
    3390:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    3392:	01 50       	subi	r16, 0x01	; 1
    3394:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3396:	2d ec       	ldi	r18, 0xCD	; 205
    3398:	3c ec       	ldi	r19, 0xCC	; 204
    339a:	4c ec       	ldi	r20, 0xCC	; 204
    339c:	5d e3       	ldi	r21, 0x3D	; 61
    339e:	0e 94 16 1c 	call	0x382c	; 0x382c <__cmpsf2>
    33a2:	88 23       	and	r24, r24
    33a4:	44 f3       	brlt	.-48     	; 0x3376 <vDisplayWriteStringAtPos+0x528>
        value = -value;
    }

    exponent = normalize(&value);

    int digit = value * 10.0;
    33a6:	20 e0       	ldi	r18, 0x00	; 0
    33a8:	30 e0       	ldi	r19, 0x00	; 0
    33aa:	40 e2       	ldi	r20, 0x20	; 32
    33ac:	51 e4       	ldi	r21, 0x41	; 65
    33ae:	6f 89       	ldd	r22, Y+23	; 0x17
    33b0:	78 8d       	ldd	r23, Y+24	; 0x18
    33b2:	89 8d       	ldd	r24, Y+25	; 0x19
    33b4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33b6:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <__mulsf3>
    33ba:	6f 8b       	std	Y+23, r22	; 0x17
    33bc:	78 8f       	std	Y+24, r23	; 0x18
    33be:	89 8f       	std	Y+25, r24	; 0x19
    33c0:	9a 8f       	std	Y+26, r25	; 0x1a
    33c2:	0e 94 8d 1c 	call	0x391a	; 0x391a <__fixsfsi>
    *buffer++ = digit + '0';
    33c6:	20 e3       	ldi	r18, 0x30	; 48
    33c8:	26 0f       	add	r18, r22
    33ca:	d3 01       	movw	r26, r6
    33cc:	2c 93       	st	X, r18
    value = value * 10.0 - digit;
    33ce:	07 2e       	mov	r0, r23
    33d0:	00 0c       	add	r0, r0
    33d2:	88 0b       	sbc	r24, r24
    33d4:	99 0b       	sbc	r25, r25
    33d6:	0e 94 c5 1c 	call	0x398a	; 0x398a <__floatsisf>
    33da:	9b 01       	movw	r18, r22
    33dc:	ac 01       	movw	r20, r24
    33de:	6f 89       	ldd	r22, Y+23	; 0x17
    33e0:	78 8d       	ldd	r23, Y+24	; 0x18
    33e2:	89 8d       	ldd	r24, Y+25	; 0x19
    33e4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33e6:	0e 94 a9 1b 	call	0x3752	; 0x3752 <__subsf3>
    --exponent;
    33ea:	f8 01       	movw	r30, r16
    33ec:	31 97       	sbiw	r30, 0x01	; 1
    33ee:	ec 8f       	std	Y+28, r30	; 0x1c
    33f0:	fd 8f       	std	Y+29, r31	; 0x1d

    *buffer++ = '.';
    33f2:	ee e2       	ldi	r30, 0x2E	; 46
    33f4:	d3 01       	movw	r26, r6
    33f6:	11 96       	adiw	r26, 0x01	; 1
    33f8:	ec 93       	st	X, r30
    33fa:	83 01       	movw	r16, r6
    33fc:	0e 5f       	subi	r16, 0xFE	; 254
    33fe:	1f 4f       	sbci	r17, 0xFF	; 255
    3400:	73 01       	movw	r14, r6
    3402:	f6 e0       	ldi	r31, 0x06	; 6
    3404:	ef 0e       	add	r14, r31
    3406:	f1 1c       	adc	r15, r1

    for (int i = 0; i < width; i++) {
        int digit = value * 10.0;
    3408:	20 e0       	ldi	r18, 0x00	; 0
    340a:	30 e0       	ldi	r19, 0x00	; 0
    340c:	40 e2       	ldi	r20, 0x20	; 32
    340e:	51 e4       	ldi	r21, 0x41	; 65
    3410:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <__mulsf3>
    3414:	6f 8b       	std	Y+23, r22	; 0x17
    3416:	78 8f       	std	Y+24, r23	; 0x18
    3418:	89 8f       	std	Y+25, r24	; 0x19
    341a:	9a 8f       	std	Y+26, r25	; 0x1a
    341c:	0e 94 8d 1c 	call	0x391a	; 0x391a <__fixsfsi>
        *buffer++ = digit + '0';
    3420:	20 e3       	ldi	r18, 0x30	; 48
    3422:	26 0f       	add	r18, r22
    3424:	d8 01       	movw	r26, r16
    3426:	2d 93       	st	X+, r18
    3428:	8d 01       	movw	r16, r26
        value = value * 10.0 - digit;
    342a:	07 2e       	mov	r0, r23
    342c:	00 0c       	add	r0, r0
    342e:	88 0b       	sbc	r24, r24
    3430:	99 0b       	sbc	r25, r25
    3432:	0e 94 c5 1c 	call	0x398a	; 0x398a <__floatsisf>
    3436:	9b 01       	movw	r18, r22
    3438:	ac 01       	movw	r20, r24
    343a:	6f 89       	ldd	r22, Y+23	; 0x17
    343c:	78 8d       	ldd	r23, Y+24	; 0x18
    343e:	89 8d       	ldd	r24, Y+25	; 0x19
    3440:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3442:	0e 94 a9 1b 	call	0x3752	; 0x3752 <__subsf3>
    value = value * 10.0 - digit;
    --exponent;

    *buffer++ = '.';

    for (int i = 0; i < width; i++) {
    3446:	0e 15       	cp	r16, r14
    3448:	1f 05       	cpc	r17, r15
    344a:	f1 f6       	brne	.-68     	; 0x3408 <vDisplayWriteStringAtPos+0x5ba>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
    }

    *buffer++ = 'e';
    344c:	25 e6       	ldi	r18, 0x65	; 101
    344e:	f3 01       	movw	r30, r6
    3450:	26 83       	std	Z+6, r18	; 0x06
    3452:	b3 01       	movw	r22, r6
    3454:	69 5f       	subi	r22, 0xF9	; 249
    3456:	7f 4f       	sbci	r23, 0xFF	; 255
    3458:	4a e0       	ldi	r20, 0x0A	; 10
    345a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    345c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    345e:	0e 94 ff 1d 	call	0x3bfe	; 0x3bfe <__itoa_ncheck>
    3462:	94 01       	movw	r18, r8
    3464:	f4 01       	movw	r30, r8
    3466:	e4 52       	subi	r30, 0x24	; 36
    3468:	f3 4d       	sbci	r31, 0xD3	; 211
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    346a:	40 ef       	ldi	r20, 0xF0	; 240
    346c:	5c e2       	ldi	r21, 0x2C	; 44
    346e:	80 e0       	ldi	r24, 0x00	; 0
    3470:	90 e0       	ldi	r25, 0x00	; 0
    3472:	05 c0       	rjmp	.+10     	; 0x347e <vDisplayWriteStringAtPos+0x630>

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    3474:	da 01       	movw	r26, r20
    3476:	6d 91       	ld	r22, X+
    3478:	ad 01       	movw	r20, r26
    347a:	61 93       	st	Z+, r22
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    347c:	01 96       	adiw	r24, 0x01	; 1
    347e:	d6 01       	movw	r26, r12
    3480:	0d 90       	ld	r0, X+
    3482:	00 20       	and	r0, r0
    3484:	e9 f7       	brne	.-6      	; 0x3480 <vDisplayWriteStringAtPos+0x632>
    3486:	11 97       	sbiw	r26, 0x01	; 1
    3488:	a0 5f       	subi	r26, 0xF0	; 240
    348a:	bc 42       	sbci	r27, 0x2C	; 44
    348c:	8a 17       	cp	r24, r26
    348e:	9b 07       	cpc	r25, r27
    3490:	88 f3       	brcs	.-30     	; 0x3474 <vDisplayWriteStringAtPos+0x626>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    3492:	4d 01       	movw	r8, r26
    3494:	82 0e       	add	r8, r18
    3496:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    3498:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    349a:	d2 01       	movw	r26, r4
    349c:	11 c0       	rjmp	.+34     	; 0x34c0 <vDisplayWriteStringAtPos+0x672>
				break;
			}
		}
		else {
			str[length] = ch;
			if(str[length] == '\n') {
    349e:	8a 30       	cpi	r24, 0x0A	; 10
    34a0:	29 f0       	breq	.+10     	; 0x34ac <vDisplayWriteStringAtPos+0x65e>
				length += strlen(buffer);
				break;
			}
		}
		else {
			str[length] = ch;
    34a2:	f4 01       	movw	r30, r8
    34a4:	e4 52       	subi	r30, 0x24	; 36
    34a6:	f3 4d       	sbci	r31, 0xD3	; 211
    34a8:	80 83       	st	Z, r24
    34aa:	04 c0       	rjmp	.+8      	; 0x34b4 <vDisplayWriteStringAtPos+0x666>
			if(str[length] == '\n') {
				str[length] = '\0';				
    34ac:	f4 01       	movw	r30, r8
    34ae:	e4 52       	subi	r30, 0x24	; 36
    34b0:	f3 4d       	sbci	r31, 0xD3	; 211
    34b2:	10 82       	st	Z, r1
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    34b4:	11 96       	adiw	r26, 0x01	; 1
		else {
			str[length] = ch;
			if(str[length] == '\n') {
				str[length] = '\0';				
			}
			length++;
    34b6:	ef ef       	ldi	r30, 0xFF	; 255
    34b8:	8e 1a       	sub	r8, r30
    34ba:	9e 0a       	sbc	r9, r30
    34bc:	01 c0       	rjmp	.+2      	; 0x34c0 <vDisplayWriteStringAtPos+0x672>
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    34be:	d2 01       	movw	r26, r4
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    34c0:	8c 91       	ld	r24, X
    34c2:	81 11       	cpse	r24, r1
    34c4:	01 cd       	rjmp	.-1534   	; 0x2ec8 <vDisplayWriteStringAtPos+0x7a>
				str[length] = '\0';				
			}
			length++;
		}
	}
	if(length + pos >= 20) {
    34c6:	8d a9       	ldd	r24, Y+53	; 0x35
    34c8:	9e a9       	ldd	r25, Y+54	; 0x36
    34ca:	88 0d       	add	r24, r8
    34cc:	99 1d       	adc	r25, r9
    34ce:	44 97       	sbiw	r24, 0x14	; 20
    34d0:	3c f0       	brlt	.+14     	; 0x34e0 <vDisplayWriteStringAtPos+0x692>
		length = 20-pos;
    34d2:	84 e1       	ldi	r24, 0x14	; 20
    34d4:	90 e0       	ldi	r25, 0x00	; 0
    34d6:	4c 01       	movw	r8, r24
    34d8:	2d a9       	ldd	r18, Y+53	; 0x35
    34da:	3e a9       	ldd	r19, Y+54	; 0x36
    34dc:	82 1a       	sub	r8, r18
    34de:	93 0a       	sbc	r9, r19
    34e0:	fe 01       	movw	r30, r28
    34e2:	33 96       	adiw	r30, 0x03	; 3
    34e4:	ce 01       	movw	r24, r28
    34e6:	47 96       	adiw	r24, 0x17	; 23
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    34e8:	df 01       	movw	r26, r30
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
    34ea:	1d 92       	st	X+, r1
	}
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
    34ec:	a8 17       	cp	r26, r24
    34ee:	b9 07       	cpc	r27, r25
    34f0:	e1 f7       	brne	.-8      	; 0x34ea <vDisplayWriteStringAtPos+0x69c>
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
    34f2:	3b 8d       	ldd	r19, Y+27	; 0x1b
    34f4:	39 83       	std	Y+1, r19	; 0x01
	newLine.displayPos = pos;
    34f6:	8d a9       	ldd	r24, Y+53	; 0x35
    34f8:	8a 83       	std	Y+2, r24	; 0x02
	for(int i = 0; i < length;i++) {
    34fa:	18 14       	cp	r1, r8
    34fc:	19 04       	cpc	r1, r9
    34fe:	5c f4       	brge	.+22     	; 0x3516 <vDisplayWriteStringAtPos+0x6c8>
    3500:	ce 01       	movw	r24, r28
    3502:	88 0d       	add	r24, r8
    3504:	99 1d       	adc	r25, r9
    3506:	03 96       	adiw	r24, 0x03	; 3
		newLine.displayBuffer[i] = str[i];
    3508:	d5 01       	movw	r26, r10
    350a:	2d 91       	ld	r18, X+
    350c:	5d 01       	movw	r10, r26
    350e:	21 93       	st	Z+, r18
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
	newLine.displayPos = pos;
	for(int i = 0; i < length;i++) {
    3510:	8e 17       	cp	r24, r30
    3512:	9f 07       	cpc	r25, r31
    3514:	c9 f7       	brne	.-14     	; 0x3508 <vDisplayWriteStringAtPos+0x6ba>
		newLine.displayBuffer[i] = str[i];
	}	
	xQueueSend(displayLineQueue, (void *) &newLine, portMAX_DELAY);
    3516:	00 e0       	ldi	r16, 0x00	; 0
    3518:	2f ef       	ldi	r18, 0xFF	; 255
    351a:	3f ef       	ldi	r19, 0xFF	; 255
    351c:	a9 01       	movw	r20, r18
    351e:	be 01       	movw	r22, r28
    3520:	6f 5f       	subi	r22, 0xFF	; 255
    3522:	7f 4f       	sbci	r23, 0xFF	; 255
    3524:	80 91 21 3f 	lds	r24, 0x3F21	; 0x803f21 <displayLineQueue>
    3528:	90 91 22 3f 	lds	r25, 0x3F22	; 0x803f22 <displayLineQueue+0x1>
    352c:	0e 94 00 08 	call	0x1000	; 0x1000 <xQueueGenericSend>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    3530:	1b c0       	rjmp	.+54     	; 0x3568 <vDisplayWriteStringAtPos+0x71a>
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3532:	2d ec       	ldi	r18, 0xCD	; 205
    3534:	3c ec       	ldi	r19, 0xCC	; 204
    3536:	4c ec       	ldi	r20, 0xCC	; 204
    3538:	5d e3       	ldi	r21, 0x3D	; 61
    353a:	6f 89       	ldd	r22, Y+23	; 0x17
    353c:	78 8d       	ldd	r23, Y+24	; 0x18
    353e:	89 8d       	ldd	r24, Y+25	; 0x19
    3540:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3542:	0e 94 16 1c 	call	0x382c	; 0x382c <__cmpsf2>
    3546:	88 23       	and	r24, r24
    3548:	0c f4       	brge	.+2      	; 0x354c <vDisplayWriteStringAtPos+0x6fe>
    354a:	d6 cd       	rjmp	.-1108   	; 0x30f8 <vDisplayWriteStringAtPos+0x2aa>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    354c:	80 e0       	ldi	r24, 0x00	; 0
    354e:	90 e0       	ldi	r25, 0x00	; 0
    3550:	26 ce       	rjmp	.-948    	; 0x319e <vDisplayWriteStringAtPos+0x350>
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    3552:	20 e3       	ldi	r18, 0x30	; 48
    3554:	ec 8d       	ldd	r30, Y+28	; 0x1c
    3556:	fd 8d       	ldd	r31, Y+29	; 0x1d
    3558:	20 83       	st	Z, r18

    *buffer++ = '.';
    355a:	7f 01       	movw	r14, r30
    355c:	32 e0       	ldi	r19, 0x02	; 2
    355e:	e3 0e       	add	r14, r19
    3560:	f1 1c       	adc	r15, r1
    3562:	8e e2       	ldi	r24, 0x2E	; 46
    3564:	81 83       	std	Z+1, r24	; 0x01
    3566:	46 ce       	rjmp	.-884    	; 0x31f4 <vDisplayWriteStringAtPos+0x3a6>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    3568:	6d 96       	adiw	r28, 0x1d	; 29
    356a:	cd bf       	out	0x3d, r28	; 61
    356c:	de bf       	out	0x3e, r29	; 62
    356e:	df 91       	pop	r29
    3570:	cf 91       	pop	r28
    3572:	1f 91       	pop	r17
    3574:	0f 91       	pop	r16
    3576:	ff 90       	pop	r15
    3578:	ef 90       	pop	r14
    357a:	df 90       	pop	r13
    357c:	cf 90       	pop	r12
    357e:	bf 90       	pop	r11
    3580:	af 90       	pop	r10
    3582:	9f 90       	pop	r9
    3584:	8f 90       	pop	r8
    3586:	7f 90       	pop	r7
    3588:	6f 90       	pop	r6
    358a:	5f 90       	pop	r5
    358c:	4f 90       	pop	r4
    358e:	3f 90       	pop	r3
    3590:	2f 90       	pop	r2
    3592:	08 95       	ret

00003594 <vTask_DMAHandler>:
EventGroupHandle_t xSignalProcessEventGroup;

void vTask_DMAHandler(void *pvParameters) 
{
	//Do things and Stuff with DMA!
	xDMAProcessEventGroup = xEventGroupCreate();
    3594:	0e 94 a8 02 	call	0x550	; 0x550 <xEventGroupCreate>
    3598:	80 93 06 2d 	sts	0x2D06, r24	; 0x802d06 <xDMAProcessEventGroup>
    359c:	90 93 07 2d 	sts	0x2D07, r25	; 0x802d07 <xDMAProcessEventGroup+0x1>
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,count_after_peak = 0;
	PORTF.DIRSET = PIN1_bm; /*LED1*/
    35a0:	e0 ea       	ldi	r30, 0xA0	; 160
    35a2:	f6 e0       	ldi	r31, 0x06	; 6
    35a4:	82 e0       	ldi	r24, 0x02	; 2
    35a6:	81 83       	std	Z+1, r24	; 0x01
	PORTF.DIRSET = PIN2_bm; /*LED2*/
    35a8:	94 e0       	ldi	r25, 0x04	; 4
    35aa:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN0_bm;
    35ac:	e0 e8       	ldi	r30, 0x80	; 128
    35ae:	f6 e0       	ldi	r31, 0x06	; 6
    35b0:	91 e0       	ldi	r25, 0x01	; 1
    35b2:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN1_bm;
    35b4:	81 83       	std	Z+1, r24	; 0x01
{
	//Do things and Stuff with DMA!
	xDMAProcessEventGroup = xEventGroupCreate();
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,count_after_peak = 0;
    35b6:	a1 2c       	mov	r10, r1
    35b8:	b1 2c       	mov	r11, r1
						}
				}
			}
			count_buffer_b++;
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x04));
    35ba:	0f 2e       	mov	r0, r31
    35bc:	f0 ea       	ldi	r31, 0xA0	; 160
    35be:	8f 2e       	mov	r8, r31
    35c0:	f6 e0       	ldi	r31, 0x06	; 6
    35c2:	9f 2e       	mov	r9, r31
    35c4:	f0 2d       	mov	r31, r0
	PORTE.DIRSET = PIN0_bm;
	PORTE.DIRSET = PIN1_bm;
	
	while(1)
	{
		uxBits = xEventGroupWaitBits(
    35c6:	cc 24       	eor	r12, r12
    35c8:	ca 94       	dec	r12
    35ca:	dc 2c       	mov	r13, r12
    35cc:	76 01       	movw	r14, r12
    35ce:	00 e0       	ldi	r16, 0x00	; 0
    35d0:	21 e0       	ldi	r18, 0x01	; 1
    35d2:	43 e0       	ldi	r20, 0x03	; 3
    35d4:	50 e0       	ldi	r21, 0x00	; 0
    35d6:	60 e0       	ldi	r22, 0x00	; 0
    35d8:	70 e0       	ldi	r23, 0x00	; 0
    35da:	80 91 06 2d 	lds	r24, 0x2D06	; 0x802d06 <xDMAProcessEventGroup>
    35de:	90 91 07 2d 	lds	r25, 0x2D07	; 0x802d07 <xDMAProcessEventGroup+0x1>
    35e2:	0e 94 bd 02 	call	0x57a	; 0x57a <xEventGroupWaitBits>
		pdTRUE,        /* Bits should be cleared before returning. */
		pdFALSE,       /* Don't wait for both bits, either bit will do. */
		portMAX_DELAY );/* Wait a maximum for either bit to be set. */
			
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
    35e6:	60 ff       	sbrs	r22, 0
    35e8:	43 c0       	rjmp	.+134    	; 0x3670 <vTask_DMAHandler+0xdc>
		{
			//Do stuff with BufferA
			//buffer_a ....
			count_array_a++; // test number of write cycles
    35ea:	80 91 00 37 	lds	r24, 0x3700	; 0x803700 <count_array_a>
    35ee:	90 91 01 37 	lds	r25, 0x3701	; 0x803701 <count_array_a+0x1>
    35f2:	01 96       	adiw	r24, 0x01	; 1
    35f4:	80 93 00 37 	sts	0x3700, r24	; 0x803700 <count_array_a>
    35f8:	90 93 01 37 	sts	0x3701, r25	; 0x803701 <count_array_a+0x1>
			for (i=0;i<2047;i++)//Detect signal 
    35fc:	c0 e0       	ldi	r28, 0x00	; 0
    35fe:	d0 e0       	ldi	r29, 0x00	; 0
			{
				if (buffer_a[i] >= 20)
    3600:	fe 01       	movw	r30, r28
    3602:	ee 5f       	subi	r30, 0xFE	; 254
    3604:	f8 4c       	sbci	r31, 0xC8	; 200
    3606:	80 81       	ld	r24, Z
    3608:	84 31       	cpi	r24, 0x14	; 20
    360a:	70 f0       	brcs	.+28     	; 0x3628 <vTask_DMAHandler+0x94>
				{
					xResult = xEventGroupSetBits(
    360c:	42 e0       	ldi	r20, 0x02	; 2
    360e:	50 e0       	ldi	r21, 0x00	; 0
    3610:	60 e0       	ldi	r22, 0x00	; 0
    3612:	70 e0       	ldi	r23, 0x00	; 0
    3614:	80 91 02 2e 	lds	r24, 0x2E02	; 0x802e02 <xSignalProcessEventGroup>
    3618:	90 91 03 2e 	lds	r25, 0x2E03	; 0x802e03 <xSignalProcessEventGroup+0x1>
    361c:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
    3620:	16 2f       	mov	r17, r22
								);
					if( xResult & Process_Signal_BufferB )		//test if Eventgroup bit is set
					{
						//count_array_a++;
					}
					count_after_peak = 0;
    3622:	a1 2c       	mov	r10, r1
    3624:	b1 2c       	mov	r11, r1
    3626:	12 c0       	rjmp	.+36     	; 0x364c <vTask_DMAHandler+0xb8>
				}
				
				else											// if value is under threshold, it shall stop calculating the signal
				{
					count_after_peak++;							// wait 100 counts to make sure that signal has stopped
    3628:	8f ef       	ldi	r24, 0xFF	; 255
    362a:	a8 1a       	sub	r10, r24
    362c:	b8 0a       	sbc	r11, r24
					if (count_after_peak >=100)					// no signal stop calculating -> set event bits to 0
    362e:	e4 e6       	ldi	r30, 0x64	; 100
    3630:	ae 16       	cp	r10, r30
    3632:	b1 04       	cpc	r11, r1
    3634:	5c f0       	brlt	.+22     	; 0x364c <vTask_DMAHandler+0xb8>
					{											// no signal stop calculating -> set event bits to 0
						xResult = xEventGroupClearBits(			// clear event bits
    3636:	43 e0       	ldi	r20, 0x03	; 3
    3638:	50 e0       	ldi	r21, 0x00	; 0
    363a:	60 e0       	ldi	r22, 0x00	; 0
    363c:	70 e0       	ldi	r23, 0x00	; 0
    363e:	80 91 02 2e 	lds	r24, 0x2E02	; 0x802e02 <xSignalProcessEventGroup>
    3642:	90 91 03 2e 	lds	r25, 0x2E03	; 0x802e03 <xSignalProcessEventGroup+0x1>
    3646:	0e 94 82 03 	call	0x704	; 0x704 <xEventGroupClearBits>
    364a:	16 2f       	mov	r17, r22
		if(uxBits & DMA_EVT_GRP_BufferA)
		{
			//Do stuff with BufferA
			//buffer_a ....
			count_array_a++; // test number of write cycles
			for (i=0;i<2047;i++)//Detect signal 
    364c:	21 96       	adiw	r28, 0x01	; 1
    364e:	cf 3f       	cpi	r28, 0xFF	; 255
    3650:	f7 e0       	ldi	r31, 0x07	; 7
    3652:	df 07       	cpc	r29, r31
    3654:	a9 f6       	brne	.-86     	; 0x3600 <vTask_DMAHandler+0x6c>
											Process_Signal_BufferA|Process_Signal_BufferB
											);												
					}
				}
			}
			count_buffer_a++;
    3656:	80 91 05 2d 	lds	r24, 0x2D05	; 0x802d05 <count_buffer_a>
    365a:	8f 5f       	subi	r24, 0xFF	; 255
    365c:	80 93 05 2d 	sts	0x2D05, r24	; 0x802d05 <count_buffer_a>
			
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x02));
    3660:	f4 01       	movw	r30, r8
    3662:	84 81       	ldd	r24, Z+4	; 0x04
    3664:	8d 7f       	andi	r24, 0xFD	; 253
    3666:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x04;	
    3668:	84 81       	ldd	r24, Z+4	; 0x04
    366a:	84 60       	ori	r24, 0x04	; 4
    366c:	84 83       	std	Z+4, r24	; 0x04
    366e:	44 c0       	rjmp	.+136    	; 0x36f8 <vTask_DMAHandler+0x164>
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			count_array_b++; // test number of write cycles
    3670:	80 91 fe 2e 	lds	r24, 0x2EFE	; 0x802efe <count_array_b>
    3674:	90 91 ff 2e 	lds	r25, 0x2EFF	; 0x802eff <count_array_b+0x1>
    3678:	01 96       	adiw	r24, 0x01	; 1
    367a:	80 93 fe 2e 	sts	0x2EFE, r24	; 0x802efe <count_array_b>
    367e:	90 93 ff 2e 	sts	0x2EFF, r25	; 0x802eff <count_array_b+0x1>
			i = i;
			for (i=0;i<2047;i++)
    3682:	c0 e0       	ldi	r28, 0x00	; 0
    3684:	d0 e0       	ldi	r29, 0x00	; 0
			{				
				if (buffer_b[i] >= 20)
    3686:	fe 01       	movw	r30, r28
    3688:	e0 50       	subi	r30, 0x00	; 0
    368a:	f1 4d       	sbci	r31, 0xD1	; 209
    368c:	80 81       	ld	r24, Z
    368e:	84 31       	cpi	r24, 0x14	; 20
    3690:	58 f0       	brcs	.+22     	; 0x36a8 <vTask_DMAHandler+0x114>
				{
				xResult = xEventGroupSetBits(
    3692:	41 e0       	ldi	r20, 0x01	; 1
    3694:	50 e0       	ldi	r21, 0x00	; 0
    3696:	60 e0       	ldi	r22, 0x00	; 0
    3698:	70 e0       	ldi	r23, 0x00	; 0
    369a:	80 91 02 2e 	lds	r24, 0x2E02	; 0x802e02 <xSignalProcessEventGroup>
    369e:	90 91 03 2e 	lds	r25, 0x2E03	; 0x802e03 <xSignalProcessEventGroup+0x1>
    36a2:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
    36a6:	16 2f       	mov	r17, r22
									xSignalProcessEventGroup,   /* The event group being updated. */
									Process_Signal_BufferA		/* The bits being set. */
									);	
				}
				if(xResult & Process_Signal_BufferA)			//test if Eventgroup bit is set
    36a8:	10 ff       	sbrs	r17, 0
    36aa:	03 c0       	rjmp	.+6      	; 0x36b2 <vTask_DMAHandler+0x11e>
				{
					{
						//count_array_b++;
					}
					count_buffer_a = 0;
    36ac:	10 92 05 2d 	sts	0x2D05, r1	; 0x802d05 <count_buffer_a>
    36b0:	12 c0       	rjmp	.+36     	; 0x36d6 <vTask_DMAHandler+0x142>
				}
				else											// if value is under threshold, it shall stop calculating the signal
				{
					count_after_peak++;					
    36b2:	ff ef       	ldi	r31, 0xFF	; 255
    36b4:	af 1a       	sub	r10, r31
    36b6:	bf 0a       	sbc	r11, r31
					if (count_after_peak >=100)					// wait 100 counts to make sure that signal has stopped
    36b8:	84 e6       	ldi	r24, 0x64	; 100
    36ba:	a8 16       	cp	r10, r24
    36bc:	b1 04       	cpc	r11, r1
    36be:	5c f0       	brlt	.+22     	; 0x36d6 <vTask_DMAHandler+0x142>
					{									
						xResult = xEventGroupClearBits(			// clear event bits
    36c0:	43 e0       	ldi	r20, 0x03	; 3
    36c2:	50 e0       	ldi	r21, 0x00	; 0
    36c4:	60 e0       	ldi	r22, 0x00	; 0
    36c6:	70 e0       	ldi	r23, 0x00	; 0
    36c8:	80 91 02 2e 	lds	r24, 0x2E02	; 0x802e02 <xSignalProcessEventGroup>
    36cc:	90 91 03 2e 	lds	r25, 0x2E03	; 0x802e03 <xSignalProcessEventGroup+0x1>
    36d0:	0e 94 82 03 	call	0x704	; 0x704 <xEventGroupClearBits>
    36d4:	16 2f       	mov	r17, r22
		{						
			//Do stuff with BufferB
			//buffer_b ....
			count_array_b++; // test number of write cycles
			i = i;
			for (i=0;i<2047;i++)
    36d6:	21 96       	adiw	r28, 0x01	; 1
    36d8:	cf 3f       	cpi	r28, 0xFF	; 255
    36da:	e7 e0       	ldi	r30, 0x07	; 7
    36dc:	de 07       	cpc	r29, r30
    36de:	99 f6       	brne	.-90     	; 0x3686 <vTask_DMAHandler+0xf2>
												Process_Signal_BufferA|Process_Signal_BufferB
												);										// no signal stop calculating -> set event bits to 0
						}
				}
			}
			count_buffer_b++;
    36e0:	80 91 04 2d 	lds	r24, 0x2D04	; 0x802d04 <count_buffer_b>
    36e4:	8f 5f       	subi	r24, 0xFF	; 255
    36e6:	80 93 04 2d 	sts	0x2D04, r24	; 0x802d04 <count_buffer_b>
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x04));
    36ea:	f4 01       	movw	r30, r8
    36ec:	84 81       	ldd	r24, Z+4	; 0x04
    36ee:	8b 7f       	andi	r24, 0xFB	; 251
    36f0:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x02;
    36f2:	84 81       	ldd	r24, Z+4	; 0x04
    36f4:	82 60       	ori	r24, 0x02	; 2
    36f6:	84 83       	std	Z+4, r24	; 0x04
		}
	vTaskDelay(100 / portTICK_RATE_MS);
    36f8:	64 e6       	ldi	r22, 0x64	; 100
    36fa:	70 e0       	ldi	r23, 0x00	; 0
    36fc:	80 e0       	ldi	r24, 0x00	; 0
    36fe:	90 e0       	ldi	r25, 0x00	; 0
    3700:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
	}
    3704:	60 cf       	rjmp	.-320    	; 0x35c6 <vTask_DMAHandler+0x32>

00003706 <getResetReason>:
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
	 // software reset ?
	 if( RST.STATUS & RST_SRF_bm )
    3706:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    370a:	85 ff       	sbrs	r24, 5
    370c:	05 c0       	rjmp	.+10     	; 0x3718 <getResetReason+0x12>
	 {
		 // reset this bit
		 RST.STATUS = RST_SRF_bm;
    370e:	80 e2       	ldi	r24, 0x20	; 32
    3710:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_SOFTWARERESET;
    3714:	81 e0       	ldi	r24, 0x01	; 1
    3716:	08 95       	ret
	 }
	 // power on reset ?
	 else if( RST.STATUS & RST_PORF_bm)
    3718:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    371c:	80 ff       	sbrs	r24, 0
    371e:	05 c0       	rjmp	.+10     	; 0x372a <getResetReason+0x24>
	 {
		 // reset this bit
		 RST.STATUS = RST_PORF_bm;
    3720:	81 e0       	ldi	r24, 0x01	; 1
    3722:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_POWERONRESET;
    3726:	82 e0       	ldi	r24, 0x02	; 2
    3728:	08 95       	ret
	 }
	 // debugger reset ?
	 else if( RST.STATUS & RST_PDIRF_bm)
    372a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    372e:	84 ff       	sbrs	r24, 4
    3730:	05 c0       	rjmp	.+10     	; 0x373c <getResetReason+0x36>
	 {
		 // reset this bit
		 RST.STATUS = RST_PDIRF_bm;
    3732:	80 e1       	ldi	r24, 0x10	; 16
    3734:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_DEBUGGERRESET;
    3738:	83 e0       	ldi	r24, 0x03	; 3
    373a:	08 95       	ret
	 }
	 // external reset ?
	 else if( RST.STATUS & RST_EXTRF_bm)
    373c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3740:	81 ff       	sbrs	r24, 1
    3742:	05 c0       	rjmp	.+10     	; 0x374e <getResetReason+0x48>
	 {
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
    3744:	82 e0       	ldi	r24, 0x02	; 2
    3746:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_EXTERNALRESET;
    374a:	84 e0       	ldi	r24, 0x04	; 4
    374c:	08 95       	ret
 */ 
 #include "avr_compiler.h"
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
    374e:	82 e0       	ldi	r24, 0x02	; 2
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
		 returnValue = RESETREASON_EXTERNALRESET;
	 }
	 return returnValue;
    3750:	08 95       	ret

00003752 <__subsf3>:
    3752:	50 58       	subi	r21, 0x80	; 128

00003754 <__addsf3>:
    3754:	bb 27       	eor	r27, r27
    3756:	aa 27       	eor	r26, r26
    3758:	0e 94 c1 1b 	call	0x3782	; 0x3782 <__addsf3x>
    375c:	0c 94 3b 1d 	jmp	0x3a76	; 0x3a76 <__fp_round>
    3760:	0e 94 2d 1d 	call	0x3a5a	; 0x3a5a <__fp_pscA>
    3764:	38 f0       	brcs	.+14     	; 0x3774 <__addsf3+0x20>
    3766:	0e 94 34 1d 	call	0x3a68	; 0x3a68 <__fp_pscB>
    376a:	20 f0       	brcs	.+8      	; 0x3774 <__addsf3+0x20>
    376c:	39 f4       	brne	.+14     	; 0x377c <__addsf3+0x28>
    376e:	9f 3f       	cpi	r25, 0xFF	; 255
    3770:	19 f4       	brne	.+6      	; 0x3778 <__addsf3+0x24>
    3772:	26 f4       	brtc	.+8      	; 0x377c <__addsf3+0x28>
    3774:	0c 94 2a 1d 	jmp	0x3a54	; 0x3a54 <__fp_nan>
    3778:	0e f4       	brtc	.+2      	; 0x377c <__addsf3+0x28>
    377a:	e0 95       	com	r30
    377c:	e7 fb       	bst	r30, 7
    377e:	0c 94 24 1d 	jmp	0x3a48	; 0x3a48 <__fp_inf>

00003782 <__addsf3x>:
    3782:	e9 2f       	mov	r30, r25
    3784:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <__fp_split3>
    3788:	58 f3       	brcs	.-42     	; 0x3760 <__addsf3+0xc>
    378a:	ba 17       	cp	r27, r26
    378c:	62 07       	cpc	r22, r18
    378e:	73 07       	cpc	r23, r19
    3790:	84 07       	cpc	r24, r20
    3792:	95 07       	cpc	r25, r21
    3794:	20 f0       	brcs	.+8      	; 0x379e <__addsf3x+0x1c>
    3796:	79 f4       	brne	.+30     	; 0x37b6 <__addsf3x+0x34>
    3798:	a6 f5       	brtc	.+104    	; 0x3802 <__addsf3x+0x80>
    379a:	0c 94 6e 1d 	jmp	0x3adc	; 0x3adc <__fp_zero>
    379e:	0e f4       	brtc	.+2      	; 0x37a2 <__addsf3x+0x20>
    37a0:	e0 95       	com	r30
    37a2:	0b 2e       	mov	r0, r27
    37a4:	ba 2f       	mov	r27, r26
    37a6:	a0 2d       	mov	r26, r0
    37a8:	0b 01       	movw	r0, r22
    37aa:	b9 01       	movw	r22, r18
    37ac:	90 01       	movw	r18, r0
    37ae:	0c 01       	movw	r0, r24
    37b0:	ca 01       	movw	r24, r20
    37b2:	a0 01       	movw	r20, r0
    37b4:	11 24       	eor	r1, r1
    37b6:	ff 27       	eor	r31, r31
    37b8:	59 1b       	sub	r21, r25
    37ba:	99 f0       	breq	.+38     	; 0x37e2 <__addsf3x+0x60>
    37bc:	59 3f       	cpi	r21, 0xF9	; 249
    37be:	50 f4       	brcc	.+20     	; 0x37d4 <__addsf3x+0x52>
    37c0:	50 3e       	cpi	r21, 0xE0	; 224
    37c2:	68 f1       	brcs	.+90     	; 0x381e <__addsf3x+0x9c>
    37c4:	1a 16       	cp	r1, r26
    37c6:	f0 40       	sbci	r31, 0x00	; 0
    37c8:	a2 2f       	mov	r26, r18
    37ca:	23 2f       	mov	r18, r19
    37cc:	34 2f       	mov	r19, r20
    37ce:	44 27       	eor	r20, r20
    37d0:	58 5f       	subi	r21, 0xF8	; 248
    37d2:	f3 cf       	rjmp	.-26     	; 0x37ba <__addsf3x+0x38>
    37d4:	46 95       	lsr	r20
    37d6:	37 95       	ror	r19
    37d8:	27 95       	ror	r18
    37da:	a7 95       	ror	r26
    37dc:	f0 40       	sbci	r31, 0x00	; 0
    37de:	53 95       	inc	r21
    37e0:	c9 f7       	brne	.-14     	; 0x37d4 <__addsf3x+0x52>
    37e2:	7e f4       	brtc	.+30     	; 0x3802 <__addsf3x+0x80>
    37e4:	1f 16       	cp	r1, r31
    37e6:	ba 0b       	sbc	r27, r26
    37e8:	62 0b       	sbc	r22, r18
    37ea:	73 0b       	sbc	r23, r19
    37ec:	84 0b       	sbc	r24, r20
    37ee:	ba f0       	brmi	.+46     	; 0x381e <__addsf3x+0x9c>
    37f0:	91 50       	subi	r25, 0x01	; 1
    37f2:	a1 f0       	breq	.+40     	; 0x381c <__addsf3x+0x9a>
    37f4:	ff 0f       	add	r31, r31
    37f6:	bb 1f       	adc	r27, r27
    37f8:	66 1f       	adc	r22, r22
    37fa:	77 1f       	adc	r23, r23
    37fc:	88 1f       	adc	r24, r24
    37fe:	c2 f7       	brpl	.-16     	; 0x37f0 <__addsf3x+0x6e>
    3800:	0e c0       	rjmp	.+28     	; 0x381e <__addsf3x+0x9c>
    3802:	ba 0f       	add	r27, r26
    3804:	62 1f       	adc	r22, r18
    3806:	73 1f       	adc	r23, r19
    3808:	84 1f       	adc	r24, r20
    380a:	48 f4       	brcc	.+18     	; 0x381e <__addsf3x+0x9c>
    380c:	87 95       	ror	r24
    380e:	77 95       	ror	r23
    3810:	67 95       	ror	r22
    3812:	b7 95       	ror	r27
    3814:	f7 95       	ror	r31
    3816:	9e 3f       	cpi	r25, 0xFE	; 254
    3818:	08 f0       	brcs	.+2      	; 0x381c <__addsf3x+0x9a>
    381a:	b0 cf       	rjmp	.-160    	; 0x377c <__addsf3+0x28>
    381c:	93 95       	inc	r25
    381e:	88 0f       	add	r24, r24
    3820:	08 f0       	brcs	.+2      	; 0x3824 <__addsf3x+0xa2>
    3822:	99 27       	eor	r25, r25
    3824:	ee 0f       	add	r30, r30
    3826:	97 95       	ror	r25
    3828:	87 95       	ror	r24
    382a:	08 95       	ret

0000382c <__cmpsf2>:
    382c:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <__fp_cmp>
    3830:	08 f4       	brcc	.+2      	; 0x3834 <__cmpsf2+0x8>
    3832:	81 e0       	ldi	r24, 0x01	; 1
    3834:	08 95       	ret

00003836 <__divsf3>:
    3836:	0e 94 2f 1c 	call	0x385e	; 0x385e <__divsf3x>
    383a:	0c 94 3b 1d 	jmp	0x3a76	; 0x3a76 <__fp_round>
    383e:	0e 94 34 1d 	call	0x3a68	; 0x3a68 <__fp_pscB>
    3842:	58 f0       	brcs	.+22     	; 0x385a <__divsf3+0x24>
    3844:	0e 94 2d 1d 	call	0x3a5a	; 0x3a5a <__fp_pscA>
    3848:	40 f0       	brcs	.+16     	; 0x385a <__divsf3+0x24>
    384a:	29 f4       	brne	.+10     	; 0x3856 <__divsf3+0x20>
    384c:	5f 3f       	cpi	r21, 0xFF	; 255
    384e:	29 f0       	breq	.+10     	; 0x385a <__divsf3+0x24>
    3850:	0c 94 24 1d 	jmp	0x3a48	; 0x3a48 <__fp_inf>
    3854:	51 11       	cpse	r21, r1
    3856:	0c 94 6f 1d 	jmp	0x3ade	; 0x3ade <__fp_szero>
    385a:	0c 94 2a 1d 	jmp	0x3a54	; 0x3a54 <__fp_nan>

0000385e <__divsf3x>:
    385e:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <__fp_split3>
    3862:	68 f3       	brcs	.-38     	; 0x383e <__divsf3+0x8>

00003864 <__divsf3_pse>:
    3864:	99 23       	and	r25, r25
    3866:	b1 f3       	breq	.-20     	; 0x3854 <__divsf3+0x1e>
    3868:	55 23       	and	r21, r21
    386a:	91 f3       	breq	.-28     	; 0x3850 <__divsf3+0x1a>
    386c:	95 1b       	sub	r25, r21
    386e:	55 0b       	sbc	r21, r21
    3870:	bb 27       	eor	r27, r27
    3872:	aa 27       	eor	r26, r26
    3874:	62 17       	cp	r22, r18
    3876:	73 07       	cpc	r23, r19
    3878:	84 07       	cpc	r24, r20
    387a:	38 f0       	brcs	.+14     	; 0x388a <__divsf3_pse+0x26>
    387c:	9f 5f       	subi	r25, 0xFF	; 255
    387e:	5f 4f       	sbci	r21, 0xFF	; 255
    3880:	22 0f       	add	r18, r18
    3882:	33 1f       	adc	r19, r19
    3884:	44 1f       	adc	r20, r20
    3886:	aa 1f       	adc	r26, r26
    3888:	a9 f3       	breq	.-22     	; 0x3874 <__divsf3_pse+0x10>
    388a:	35 d0       	rcall	.+106    	; 0x38f6 <__divsf3_pse+0x92>
    388c:	0e 2e       	mov	r0, r30
    388e:	3a f0       	brmi	.+14     	; 0x389e <__divsf3_pse+0x3a>
    3890:	e0 e8       	ldi	r30, 0x80	; 128
    3892:	32 d0       	rcall	.+100    	; 0x38f8 <__divsf3_pse+0x94>
    3894:	91 50       	subi	r25, 0x01	; 1
    3896:	50 40       	sbci	r21, 0x00	; 0
    3898:	e6 95       	lsr	r30
    389a:	00 1c       	adc	r0, r0
    389c:	ca f7       	brpl	.-14     	; 0x3890 <__divsf3_pse+0x2c>
    389e:	2b d0       	rcall	.+86     	; 0x38f6 <__divsf3_pse+0x92>
    38a0:	fe 2f       	mov	r31, r30
    38a2:	29 d0       	rcall	.+82     	; 0x38f6 <__divsf3_pse+0x92>
    38a4:	66 0f       	add	r22, r22
    38a6:	77 1f       	adc	r23, r23
    38a8:	88 1f       	adc	r24, r24
    38aa:	bb 1f       	adc	r27, r27
    38ac:	26 17       	cp	r18, r22
    38ae:	37 07       	cpc	r19, r23
    38b0:	48 07       	cpc	r20, r24
    38b2:	ab 07       	cpc	r26, r27
    38b4:	b0 e8       	ldi	r27, 0x80	; 128
    38b6:	09 f0       	breq	.+2      	; 0x38ba <__divsf3_pse+0x56>
    38b8:	bb 0b       	sbc	r27, r27
    38ba:	80 2d       	mov	r24, r0
    38bc:	bf 01       	movw	r22, r30
    38be:	ff 27       	eor	r31, r31
    38c0:	93 58       	subi	r25, 0x83	; 131
    38c2:	5f 4f       	sbci	r21, 0xFF	; 255
    38c4:	3a f0       	brmi	.+14     	; 0x38d4 <__divsf3_pse+0x70>
    38c6:	9e 3f       	cpi	r25, 0xFE	; 254
    38c8:	51 05       	cpc	r21, r1
    38ca:	78 f0       	brcs	.+30     	; 0x38ea <__divsf3_pse+0x86>
    38cc:	0c 94 24 1d 	jmp	0x3a48	; 0x3a48 <__fp_inf>
    38d0:	0c 94 6f 1d 	jmp	0x3ade	; 0x3ade <__fp_szero>
    38d4:	5f 3f       	cpi	r21, 0xFF	; 255
    38d6:	e4 f3       	brlt	.-8      	; 0x38d0 <__divsf3_pse+0x6c>
    38d8:	98 3e       	cpi	r25, 0xE8	; 232
    38da:	d4 f3       	brlt	.-12     	; 0x38d0 <__divsf3_pse+0x6c>
    38dc:	86 95       	lsr	r24
    38de:	77 95       	ror	r23
    38e0:	67 95       	ror	r22
    38e2:	b7 95       	ror	r27
    38e4:	f7 95       	ror	r31
    38e6:	9f 5f       	subi	r25, 0xFF	; 255
    38e8:	c9 f7       	brne	.-14     	; 0x38dc <__divsf3_pse+0x78>
    38ea:	88 0f       	add	r24, r24
    38ec:	91 1d       	adc	r25, r1
    38ee:	96 95       	lsr	r25
    38f0:	87 95       	ror	r24
    38f2:	97 f9       	bld	r25, 7
    38f4:	08 95       	ret
    38f6:	e1 e0       	ldi	r30, 0x01	; 1
    38f8:	66 0f       	add	r22, r22
    38fa:	77 1f       	adc	r23, r23
    38fc:	88 1f       	adc	r24, r24
    38fe:	bb 1f       	adc	r27, r27
    3900:	62 17       	cp	r22, r18
    3902:	73 07       	cpc	r23, r19
    3904:	84 07       	cpc	r24, r20
    3906:	ba 07       	cpc	r27, r26
    3908:	20 f0       	brcs	.+8      	; 0x3912 <__divsf3_pse+0xae>
    390a:	62 1b       	sub	r22, r18
    390c:	73 0b       	sbc	r23, r19
    390e:	84 0b       	sbc	r24, r20
    3910:	ba 0b       	sbc	r27, r26
    3912:	ee 1f       	adc	r30, r30
    3914:	88 f7       	brcc	.-30     	; 0x38f8 <__divsf3_pse+0x94>
    3916:	e0 95       	com	r30
    3918:	08 95       	ret

0000391a <__fixsfsi>:
    391a:	0e 94 94 1c 	call	0x3928	; 0x3928 <__fixunssfsi>
    391e:	68 94       	set
    3920:	b1 11       	cpse	r27, r1
    3922:	0c 94 6f 1d 	jmp	0x3ade	; 0x3ade <__fp_szero>
    3926:	08 95       	ret

00003928 <__fixunssfsi>:
    3928:	0e 94 54 1d 	call	0x3aa8	; 0x3aa8 <__fp_splitA>
    392c:	88 f0       	brcs	.+34     	; 0x3950 <__fixunssfsi+0x28>
    392e:	9f 57       	subi	r25, 0x7F	; 127
    3930:	98 f0       	brcs	.+38     	; 0x3958 <__fixunssfsi+0x30>
    3932:	b9 2f       	mov	r27, r25
    3934:	99 27       	eor	r25, r25
    3936:	b7 51       	subi	r27, 0x17	; 23
    3938:	b0 f0       	brcs	.+44     	; 0x3966 <__fixunssfsi+0x3e>
    393a:	e1 f0       	breq	.+56     	; 0x3974 <__fixunssfsi+0x4c>
    393c:	66 0f       	add	r22, r22
    393e:	77 1f       	adc	r23, r23
    3940:	88 1f       	adc	r24, r24
    3942:	99 1f       	adc	r25, r25
    3944:	1a f0       	brmi	.+6      	; 0x394c <__fixunssfsi+0x24>
    3946:	ba 95       	dec	r27
    3948:	c9 f7       	brne	.-14     	; 0x393c <__fixunssfsi+0x14>
    394a:	14 c0       	rjmp	.+40     	; 0x3974 <__fixunssfsi+0x4c>
    394c:	b1 30       	cpi	r27, 0x01	; 1
    394e:	91 f0       	breq	.+36     	; 0x3974 <__fixunssfsi+0x4c>
    3950:	0e 94 6e 1d 	call	0x3adc	; 0x3adc <__fp_zero>
    3954:	b1 e0       	ldi	r27, 0x01	; 1
    3956:	08 95       	ret
    3958:	0c 94 6e 1d 	jmp	0x3adc	; 0x3adc <__fp_zero>
    395c:	67 2f       	mov	r22, r23
    395e:	78 2f       	mov	r23, r24
    3960:	88 27       	eor	r24, r24
    3962:	b8 5f       	subi	r27, 0xF8	; 248
    3964:	39 f0       	breq	.+14     	; 0x3974 <__fixunssfsi+0x4c>
    3966:	b9 3f       	cpi	r27, 0xF9	; 249
    3968:	cc f3       	brlt	.-14     	; 0x395c <__fixunssfsi+0x34>
    396a:	86 95       	lsr	r24
    396c:	77 95       	ror	r23
    396e:	67 95       	ror	r22
    3970:	b3 95       	inc	r27
    3972:	d9 f7       	brne	.-10     	; 0x396a <__fixunssfsi+0x42>
    3974:	3e f4       	brtc	.+14     	; 0x3984 <__fixunssfsi+0x5c>
    3976:	90 95       	com	r25
    3978:	80 95       	com	r24
    397a:	70 95       	com	r23
    397c:	61 95       	neg	r22
    397e:	7f 4f       	sbci	r23, 0xFF	; 255
    3980:	8f 4f       	sbci	r24, 0xFF	; 255
    3982:	9f 4f       	sbci	r25, 0xFF	; 255
    3984:	08 95       	ret

00003986 <__floatunsisf>:
    3986:	e8 94       	clt
    3988:	09 c0       	rjmp	.+18     	; 0x399c <__floatsisf+0x12>

0000398a <__floatsisf>:
    398a:	97 fb       	bst	r25, 7
    398c:	3e f4       	brtc	.+14     	; 0x399c <__floatsisf+0x12>
    398e:	90 95       	com	r25
    3990:	80 95       	com	r24
    3992:	70 95       	com	r23
    3994:	61 95       	neg	r22
    3996:	7f 4f       	sbci	r23, 0xFF	; 255
    3998:	8f 4f       	sbci	r24, 0xFF	; 255
    399a:	9f 4f       	sbci	r25, 0xFF	; 255
    399c:	99 23       	and	r25, r25
    399e:	a9 f0       	breq	.+42     	; 0x39ca <__floatsisf+0x40>
    39a0:	f9 2f       	mov	r31, r25
    39a2:	96 e9       	ldi	r25, 0x96	; 150
    39a4:	bb 27       	eor	r27, r27
    39a6:	93 95       	inc	r25
    39a8:	f6 95       	lsr	r31
    39aa:	87 95       	ror	r24
    39ac:	77 95       	ror	r23
    39ae:	67 95       	ror	r22
    39b0:	b7 95       	ror	r27
    39b2:	f1 11       	cpse	r31, r1
    39b4:	f8 cf       	rjmp	.-16     	; 0x39a6 <__floatsisf+0x1c>
    39b6:	fa f4       	brpl	.+62     	; 0x39f6 <__floatsisf+0x6c>
    39b8:	bb 0f       	add	r27, r27
    39ba:	11 f4       	brne	.+4      	; 0x39c0 <__floatsisf+0x36>
    39bc:	60 ff       	sbrs	r22, 0
    39be:	1b c0       	rjmp	.+54     	; 0x39f6 <__floatsisf+0x6c>
    39c0:	6f 5f       	subi	r22, 0xFF	; 255
    39c2:	7f 4f       	sbci	r23, 0xFF	; 255
    39c4:	8f 4f       	sbci	r24, 0xFF	; 255
    39c6:	9f 4f       	sbci	r25, 0xFF	; 255
    39c8:	16 c0       	rjmp	.+44     	; 0x39f6 <__floatsisf+0x6c>
    39ca:	88 23       	and	r24, r24
    39cc:	11 f0       	breq	.+4      	; 0x39d2 <__floatsisf+0x48>
    39ce:	96 e9       	ldi	r25, 0x96	; 150
    39d0:	11 c0       	rjmp	.+34     	; 0x39f4 <__floatsisf+0x6a>
    39d2:	77 23       	and	r23, r23
    39d4:	21 f0       	breq	.+8      	; 0x39de <__floatsisf+0x54>
    39d6:	9e e8       	ldi	r25, 0x8E	; 142
    39d8:	87 2f       	mov	r24, r23
    39da:	76 2f       	mov	r23, r22
    39dc:	05 c0       	rjmp	.+10     	; 0x39e8 <__floatsisf+0x5e>
    39de:	66 23       	and	r22, r22
    39e0:	71 f0       	breq	.+28     	; 0x39fe <__floatsisf+0x74>
    39e2:	96 e8       	ldi	r25, 0x86	; 134
    39e4:	86 2f       	mov	r24, r22
    39e6:	70 e0       	ldi	r23, 0x00	; 0
    39e8:	60 e0       	ldi	r22, 0x00	; 0
    39ea:	2a f0       	brmi	.+10     	; 0x39f6 <__floatsisf+0x6c>
    39ec:	9a 95       	dec	r25
    39ee:	66 0f       	add	r22, r22
    39f0:	77 1f       	adc	r23, r23
    39f2:	88 1f       	adc	r24, r24
    39f4:	da f7       	brpl	.-10     	; 0x39ec <__floatsisf+0x62>
    39f6:	88 0f       	add	r24, r24
    39f8:	96 95       	lsr	r25
    39fa:	87 95       	ror	r24
    39fc:	97 f9       	bld	r25, 7
    39fe:	08 95       	ret

00003a00 <__fp_cmp>:
    3a00:	99 0f       	add	r25, r25
    3a02:	00 08       	sbc	r0, r0
    3a04:	55 0f       	add	r21, r21
    3a06:	aa 0b       	sbc	r26, r26
    3a08:	e0 e8       	ldi	r30, 0x80	; 128
    3a0a:	fe ef       	ldi	r31, 0xFE	; 254
    3a0c:	16 16       	cp	r1, r22
    3a0e:	17 06       	cpc	r1, r23
    3a10:	e8 07       	cpc	r30, r24
    3a12:	f9 07       	cpc	r31, r25
    3a14:	c0 f0       	brcs	.+48     	; 0x3a46 <__fp_cmp+0x46>
    3a16:	12 16       	cp	r1, r18
    3a18:	13 06       	cpc	r1, r19
    3a1a:	e4 07       	cpc	r30, r20
    3a1c:	f5 07       	cpc	r31, r21
    3a1e:	98 f0       	brcs	.+38     	; 0x3a46 <__fp_cmp+0x46>
    3a20:	62 1b       	sub	r22, r18
    3a22:	73 0b       	sbc	r23, r19
    3a24:	84 0b       	sbc	r24, r20
    3a26:	95 0b       	sbc	r25, r21
    3a28:	39 f4       	brne	.+14     	; 0x3a38 <__fp_cmp+0x38>
    3a2a:	0a 26       	eor	r0, r26
    3a2c:	61 f0       	breq	.+24     	; 0x3a46 <__fp_cmp+0x46>
    3a2e:	23 2b       	or	r18, r19
    3a30:	24 2b       	or	r18, r20
    3a32:	25 2b       	or	r18, r21
    3a34:	21 f4       	brne	.+8      	; 0x3a3e <__fp_cmp+0x3e>
    3a36:	08 95       	ret
    3a38:	0a 26       	eor	r0, r26
    3a3a:	09 f4       	brne	.+2      	; 0x3a3e <__fp_cmp+0x3e>
    3a3c:	a1 40       	sbci	r26, 0x01	; 1
    3a3e:	a6 95       	lsr	r26
    3a40:	8f ef       	ldi	r24, 0xFF	; 255
    3a42:	81 1d       	adc	r24, r1
    3a44:	81 1d       	adc	r24, r1
    3a46:	08 95       	ret

00003a48 <__fp_inf>:
    3a48:	97 f9       	bld	r25, 7
    3a4a:	9f 67       	ori	r25, 0x7F	; 127
    3a4c:	80 e8       	ldi	r24, 0x80	; 128
    3a4e:	70 e0       	ldi	r23, 0x00	; 0
    3a50:	60 e0       	ldi	r22, 0x00	; 0
    3a52:	08 95       	ret

00003a54 <__fp_nan>:
    3a54:	9f ef       	ldi	r25, 0xFF	; 255
    3a56:	80 ec       	ldi	r24, 0xC0	; 192
    3a58:	08 95       	ret

00003a5a <__fp_pscA>:
    3a5a:	00 24       	eor	r0, r0
    3a5c:	0a 94       	dec	r0
    3a5e:	16 16       	cp	r1, r22
    3a60:	17 06       	cpc	r1, r23
    3a62:	18 06       	cpc	r1, r24
    3a64:	09 06       	cpc	r0, r25
    3a66:	08 95       	ret

00003a68 <__fp_pscB>:
    3a68:	00 24       	eor	r0, r0
    3a6a:	0a 94       	dec	r0
    3a6c:	12 16       	cp	r1, r18
    3a6e:	13 06       	cpc	r1, r19
    3a70:	14 06       	cpc	r1, r20
    3a72:	05 06       	cpc	r0, r21
    3a74:	08 95       	ret

00003a76 <__fp_round>:
    3a76:	09 2e       	mov	r0, r25
    3a78:	03 94       	inc	r0
    3a7a:	00 0c       	add	r0, r0
    3a7c:	11 f4       	brne	.+4      	; 0x3a82 <__fp_round+0xc>
    3a7e:	88 23       	and	r24, r24
    3a80:	52 f0       	brmi	.+20     	; 0x3a96 <__fp_round+0x20>
    3a82:	bb 0f       	add	r27, r27
    3a84:	40 f4       	brcc	.+16     	; 0x3a96 <__fp_round+0x20>
    3a86:	bf 2b       	or	r27, r31
    3a88:	11 f4       	brne	.+4      	; 0x3a8e <__fp_round+0x18>
    3a8a:	60 ff       	sbrs	r22, 0
    3a8c:	04 c0       	rjmp	.+8      	; 0x3a96 <__fp_round+0x20>
    3a8e:	6f 5f       	subi	r22, 0xFF	; 255
    3a90:	7f 4f       	sbci	r23, 0xFF	; 255
    3a92:	8f 4f       	sbci	r24, 0xFF	; 255
    3a94:	9f 4f       	sbci	r25, 0xFF	; 255
    3a96:	08 95       	ret

00003a98 <__fp_split3>:
    3a98:	57 fd       	sbrc	r21, 7
    3a9a:	90 58       	subi	r25, 0x80	; 128
    3a9c:	44 0f       	add	r20, r20
    3a9e:	55 1f       	adc	r21, r21
    3aa0:	59 f0       	breq	.+22     	; 0x3ab8 <__fp_splitA+0x10>
    3aa2:	5f 3f       	cpi	r21, 0xFF	; 255
    3aa4:	71 f0       	breq	.+28     	; 0x3ac2 <__fp_splitA+0x1a>
    3aa6:	47 95       	ror	r20

00003aa8 <__fp_splitA>:
    3aa8:	88 0f       	add	r24, r24
    3aaa:	97 fb       	bst	r25, 7
    3aac:	99 1f       	adc	r25, r25
    3aae:	61 f0       	breq	.+24     	; 0x3ac8 <__fp_splitA+0x20>
    3ab0:	9f 3f       	cpi	r25, 0xFF	; 255
    3ab2:	79 f0       	breq	.+30     	; 0x3ad2 <__fp_splitA+0x2a>
    3ab4:	87 95       	ror	r24
    3ab6:	08 95       	ret
    3ab8:	12 16       	cp	r1, r18
    3aba:	13 06       	cpc	r1, r19
    3abc:	14 06       	cpc	r1, r20
    3abe:	55 1f       	adc	r21, r21
    3ac0:	f2 cf       	rjmp	.-28     	; 0x3aa6 <__fp_split3+0xe>
    3ac2:	46 95       	lsr	r20
    3ac4:	f1 df       	rcall	.-30     	; 0x3aa8 <__fp_splitA>
    3ac6:	08 c0       	rjmp	.+16     	; 0x3ad8 <__fp_splitA+0x30>
    3ac8:	16 16       	cp	r1, r22
    3aca:	17 06       	cpc	r1, r23
    3acc:	18 06       	cpc	r1, r24
    3ace:	99 1f       	adc	r25, r25
    3ad0:	f1 cf       	rjmp	.-30     	; 0x3ab4 <__fp_splitA+0xc>
    3ad2:	86 95       	lsr	r24
    3ad4:	71 05       	cpc	r23, r1
    3ad6:	61 05       	cpc	r22, r1
    3ad8:	08 94       	sec
    3ada:	08 95       	ret

00003adc <__fp_zero>:
    3adc:	e8 94       	clt

00003ade <__fp_szero>:
    3ade:	bb 27       	eor	r27, r27
    3ae0:	66 27       	eor	r22, r22
    3ae2:	77 27       	eor	r23, r23
    3ae4:	cb 01       	movw	r24, r22
    3ae6:	97 f9       	bld	r25, 7
    3ae8:	08 95       	ret

00003aea <__gesf2>:
    3aea:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <__fp_cmp>
    3aee:	08 f4       	brcc	.+2      	; 0x3af2 <__gesf2+0x8>
    3af0:	8f ef       	ldi	r24, 0xFF	; 255
    3af2:	08 95       	ret

00003af4 <__mulsf3>:
    3af4:	0e 94 8d 1d 	call	0x3b1a	; 0x3b1a <__mulsf3x>
    3af8:	0c 94 3b 1d 	jmp	0x3a76	; 0x3a76 <__fp_round>
    3afc:	0e 94 2d 1d 	call	0x3a5a	; 0x3a5a <__fp_pscA>
    3b00:	38 f0       	brcs	.+14     	; 0x3b10 <__mulsf3+0x1c>
    3b02:	0e 94 34 1d 	call	0x3a68	; 0x3a68 <__fp_pscB>
    3b06:	20 f0       	brcs	.+8      	; 0x3b10 <__mulsf3+0x1c>
    3b08:	95 23       	and	r25, r21
    3b0a:	11 f0       	breq	.+4      	; 0x3b10 <__mulsf3+0x1c>
    3b0c:	0c 94 24 1d 	jmp	0x3a48	; 0x3a48 <__fp_inf>
    3b10:	0c 94 2a 1d 	jmp	0x3a54	; 0x3a54 <__fp_nan>
    3b14:	11 24       	eor	r1, r1
    3b16:	0c 94 6f 1d 	jmp	0x3ade	; 0x3ade <__fp_szero>

00003b1a <__mulsf3x>:
    3b1a:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <__fp_split3>
    3b1e:	70 f3       	brcs	.-36     	; 0x3afc <__mulsf3+0x8>

00003b20 <__mulsf3_pse>:
    3b20:	95 9f       	mul	r25, r21
    3b22:	c1 f3       	breq	.-16     	; 0x3b14 <__mulsf3+0x20>
    3b24:	95 0f       	add	r25, r21
    3b26:	50 e0       	ldi	r21, 0x00	; 0
    3b28:	55 1f       	adc	r21, r21
    3b2a:	62 9f       	mul	r22, r18
    3b2c:	f0 01       	movw	r30, r0
    3b2e:	72 9f       	mul	r23, r18
    3b30:	bb 27       	eor	r27, r27
    3b32:	f0 0d       	add	r31, r0
    3b34:	b1 1d       	adc	r27, r1
    3b36:	63 9f       	mul	r22, r19
    3b38:	aa 27       	eor	r26, r26
    3b3a:	f0 0d       	add	r31, r0
    3b3c:	b1 1d       	adc	r27, r1
    3b3e:	aa 1f       	adc	r26, r26
    3b40:	64 9f       	mul	r22, r20
    3b42:	66 27       	eor	r22, r22
    3b44:	b0 0d       	add	r27, r0
    3b46:	a1 1d       	adc	r26, r1
    3b48:	66 1f       	adc	r22, r22
    3b4a:	82 9f       	mul	r24, r18
    3b4c:	22 27       	eor	r18, r18
    3b4e:	b0 0d       	add	r27, r0
    3b50:	a1 1d       	adc	r26, r1
    3b52:	62 1f       	adc	r22, r18
    3b54:	73 9f       	mul	r23, r19
    3b56:	b0 0d       	add	r27, r0
    3b58:	a1 1d       	adc	r26, r1
    3b5a:	62 1f       	adc	r22, r18
    3b5c:	83 9f       	mul	r24, r19
    3b5e:	a0 0d       	add	r26, r0
    3b60:	61 1d       	adc	r22, r1
    3b62:	22 1f       	adc	r18, r18
    3b64:	74 9f       	mul	r23, r20
    3b66:	33 27       	eor	r19, r19
    3b68:	a0 0d       	add	r26, r0
    3b6a:	61 1d       	adc	r22, r1
    3b6c:	23 1f       	adc	r18, r19
    3b6e:	84 9f       	mul	r24, r20
    3b70:	60 0d       	add	r22, r0
    3b72:	21 1d       	adc	r18, r1
    3b74:	82 2f       	mov	r24, r18
    3b76:	76 2f       	mov	r23, r22
    3b78:	6a 2f       	mov	r22, r26
    3b7a:	11 24       	eor	r1, r1
    3b7c:	9f 57       	subi	r25, 0x7F	; 127
    3b7e:	50 40       	sbci	r21, 0x00	; 0
    3b80:	9a f0       	brmi	.+38     	; 0x3ba8 <__mulsf3_pse+0x88>
    3b82:	f1 f0       	breq	.+60     	; 0x3bc0 <__mulsf3_pse+0xa0>
    3b84:	88 23       	and	r24, r24
    3b86:	4a f0       	brmi	.+18     	; 0x3b9a <__mulsf3_pse+0x7a>
    3b88:	ee 0f       	add	r30, r30
    3b8a:	ff 1f       	adc	r31, r31
    3b8c:	bb 1f       	adc	r27, r27
    3b8e:	66 1f       	adc	r22, r22
    3b90:	77 1f       	adc	r23, r23
    3b92:	88 1f       	adc	r24, r24
    3b94:	91 50       	subi	r25, 0x01	; 1
    3b96:	50 40       	sbci	r21, 0x00	; 0
    3b98:	a9 f7       	brne	.-22     	; 0x3b84 <__mulsf3_pse+0x64>
    3b9a:	9e 3f       	cpi	r25, 0xFE	; 254
    3b9c:	51 05       	cpc	r21, r1
    3b9e:	80 f0       	brcs	.+32     	; 0x3bc0 <__mulsf3_pse+0xa0>
    3ba0:	0c 94 24 1d 	jmp	0x3a48	; 0x3a48 <__fp_inf>
    3ba4:	0c 94 6f 1d 	jmp	0x3ade	; 0x3ade <__fp_szero>
    3ba8:	5f 3f       	cpi	r21, 0xFF	; 255
    3baa:	e4 f3       	brlt	.-8      	; 0x3ba4 <__mulsf3_pse+0x84>
    3bac:	98 3e       	cpi	r25, 0xE8	; 232
    3bae:	d4 f3       	brlt	.-12     	; 0x3ba4 <__mulsf3_pse+0x84>
    3bb0:	86 95       	lsr	r24
    3bb2:	77 95       	ror	r23
    3bb4:	67 95       	ror	r22
    3bb6:	b7 95       	ror	r27
    3bb8:	f7 95       	ror	r31
    3bba:	e7 95       	ror	r30
    3bbc:	9f 5f       	subi	r25, 0xFF	; 255
    3bbe:	c1 f7       	brne	.-16     	; 0x3bb0 <__mulsf3_pse+0x90>
    3bc0:	fe 2b       	or	r31, r30
    3bc2:	88 0f       	add	r24, r24
    3bc4:	91 1d       	adc	r25, r1
    3bc6:	96 95       	lsr	r25
    3bc8:	87 95       	ror	r24
    3bca:	97 f9       	bld	r25, 7
    3bcc:	08 95       	ret

00003bce <__tablejump2__>:
    3bce:	ee 0f       	add	r30, r30
    3bd0:	ff 1f       	adc	r31, r31
    3bd2:	88 1f       	adc	r24, r24
    3bd4:	8b bf       	out	0x3b, r24	; 59
    3bd6:	07 90       	elpm	r0, Z+
    3bd8:	f6 91       	elpm	r31, Z
    3bda:	e0 2d       	mov	r30, r0
    3bdc:	19 94       	eijmp

00003bde <memcpy>:
    3bde:	fb 01       	movw	r30, r22
    3be0:	dc 01       	movw	r26, r24
    3be2:	02 c0       	rjmp	.+4      	; 0x3be8 <memcpy+0xa>
    3be4:	01 90       	ld	r0, Z+
    3be6:	0d 92       	st	X+, r0
    3be8:	41 50       	subi	r20, 0x01	; 1
    3bea:	50 40       	sbci	r21, 0x00	; 0
    3bec:	d8 f7       	brcc	.-10     	; 0x3be4 <memcpy+0x6>
    3bee:	08 95       	ret

00003bf0 <memset>:
    3bf0:	dc 01       	movw	r26, r24
    3bf2:	01 c0       	rjmp	.+2      	; 0x3bf6 <memset+0x6>
    3bf4:	6d 93       	st	X+, r22
    3bf6:	41 50       	subi	r20, 0x01	; 1
    3bf8:	50 40       	sbci	r21, 0x00	; 0
    3bfa:	e0 f7       	brcc	.-8      	; 0x3bf4 <memset+0x4>
    3bfc:	08 95       	ret

00003bfe <__itoa_ncheck>:
    3bfe:	bb 27       	eor	r27, r27
    3c00:	4a 30       	cpi	r20, 0x0A	; 10
    3c02:	31 f4       	brne	.+12     	; 0x3c10 <__itoa_ncheck+0x12>
    3c04:	99 23       	and	r25, r25
    3c06:	22 f4       	brpl	.+8      	; 0x3c10 <__itoa_ncheck+0x12>
    3c08:	bd e2       	ldi	r27, 0x2D	; 45
    3c0a:	90 95       	com	r25
    3c0c:	81 95       	neg	r24
    3c0e:	9f 4f       	sbci	r25, 0xFF	; 255
    3c10:	0c 94 0b 1e 	jmp	0x3c16	; 0x3c16 <__utoa_common>

00003c14 <__utoa_ncheck>:
    3c14:	bb 27       	eor	r27, r27

00003c16 <__utoa_common>:
    3c16:	fb 01       	movw	r30, r22
    3c18:	55 27       	eor	r21, r21
    3c1a:	aa 27       	eor	r26, r26
    3c1c:	88 0f       	add	r24, r24
    3c1e:	99 1f       	adc	r25, r25
    3c20:	aa 1f       	adc	r26, r26
    3c22:	a4 17       	cp	r26, r20
    3c24:	10 f0       	brcs	.+4      	; 0x3c2a <__utoa_common+0x14>
    3c26:	a4 1b       	sub	r26, r20
    3c28:	83 95       	inc	r24
    3c2a:	50 51       	subi	r21, 0x10	; 16
    3c2c:	b9 f7       	brne	.-18     	; 0x3c1c <__utoa_common+0x6>
    3c2e:	a0 5d       	subi	r26, 0xD0	; 208
    3c30:	aa 33       	cpi	r26, 0x3A	; 58
    3c32:	08 f0       	brcs	.+2      	; 0x3c36 <__utoa_common+0x20>
    3c34:	a9 5d       	subi	r26, 0xD9	; 217
    3c36:	a1 93       	st	Z+, r26
    3c38:	00 97       	sbiw	r24, 0x00	; 0
    3c3a:	79 f7       	brne	.-34     	; 0x3c1a <__utoa_common+0x4>
    3c3c:	b1 11       	cpse	r27, r1
    3c3e:	b1 93       	st	Z+, r27
    3c40:	11 92       	st	Z+, r1
    3c42:	cb 01       	movw	r24, r22
    3c44:	0c 94 24 1e 	jmp	0x3c48	; 0x3c48 <strrev>

00003c48 <strrev>:
    3c48:	dc 01       	movw	r26, r24
    3c4a:	fc 01       	movw	r30, r24
    3c4c:	67 2f       	mov	r22, r23
    3c4e:	71 91       	ld	r23, Z+
    3c50:	77 23       	and	r23, r23
    3c52:	e1 f7       	brne	.-8      	; 0x3c4c <strrev+0x4>
    3c54:	32 97       	sbiw	r30, 0x02	; 2
    3c56:	04 c0       	rjmp	.+8      	; 0x3c60 <strrev+0x18>
    3c58:	7c 91       	ld	r23, X
    3c5a:	6d 93       	st	X+, r22
    3c5c:	70 83       	st	Z, r23
    3c5e:	62 91       	ld	r22, -Z
    3c60:	ae 17       	cp	r26, r30
    3c62:	bf 07       	cpc	r27, r31
    3c64:	c8 f3       	brcs	.-14     	; 0x3c58 <strrev+0x10>
    3c66:	08 95       	ret

00003c68 <_exit>:
    3c68:	f8 94       	cli

00003c6a <__stop_program>:
    3c6a:	ff cf       	rjmp	.-2      	; 0x3c6a <__stop_program>
