
QAMDecFS2019.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004024  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000212  00802000  00004024  000040b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000101f  00802212  00802212  000042ca  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000042ca  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000042fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007c8  00000000  00000000  0000433c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010800  00000000  00000000  00004b04  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000053a6  00000000  00000000  00015304  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000055e1  00000000  00000000  0001a6aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001934  00000000  00000000  0001fc8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000789b  00000000  00000000  000215c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000099bf  00000000  00000000  00028e5b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000838  00000000  00000000  0003281a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 22 01 	jmp	0x244	; 0x244 <__ctors_end>
       4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      10:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      14:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      18:	0c 94 b9 01 	jmp	0x372	; 0x372 <__vector_6>
      1c:	0c 94 ff 01 	jmp	0x3fe	; 0x3fe <__vector_7>
      20:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      24:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      28:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      2c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      30:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      34:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      38:	0c 94 02 07 	jmp	0xe04	; 0xe04 <__vector_14>
      3c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      40:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      44:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      48:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      4c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      50:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      54:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      58:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      5c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      60:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      64:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      68:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      6c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      70:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      74:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      78:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      7c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      80:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      84:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      88:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      8c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      90:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      94:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      98:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      9c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      ac:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      bc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      cc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      dc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      ec:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      fc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     100:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     104:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     108:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     10c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     110:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     114:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     118:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     11c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     120:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     124:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     128:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     12c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     130:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     134:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     138:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     13c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     140:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     144:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     148:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     14c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     150:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     154:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     158:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     15c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     160:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     164:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     168:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     16c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     170:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     174:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     178:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     17c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     180:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     184:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     188:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     18c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     190:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     194:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     198:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     19c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1ac:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1b0:	0c 94 0e 14 	jmp	0x281c	; 0x281c <__vector_108>
     1b4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1b8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1bc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1cc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1dc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1ec:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1fc:	4a 12       	cpse	r4, r26
     1fe:	4a 12       	cpse	r4, r26
     200:	4a 12       	cpse	r4, r26
     202:	97 12       	cpse	r9, r23
     204:	7f 12       	cpse	r7, r31
     206:	94 12       	cpse	r9, r20
     208:	4a 12       	cpse	r4, r26
     20a:	4a 12       	cpse	r4, r26
     20c:	97 12       	cpse	r9, r23
     20e:	7f 12       	cpse	r7, r31

00000210 <__trampolines_start>:
     210:	0c 94 94 12 	jmp	0x2528	; 0x2528 <prvTimerTask+0x20c>
     214:	0c 94 f6 1a 	jmp	0x35ec	; 0x35ec <vRead_Peaks>
     218:	0c 94 2c 13 	jmp	0x2658	; 0x2658 <vWrite_Display>
     21c:	0c 94 39 1a 	jmp	0x3472	; 0x3472 <vPhase_Detection>
     220:	0c 94 ad 15 	jmp	0x2b5a	; 0x2b5a <vDisplayUpdateTask>
     224:	0c 94 1b 13 	jmp	0x2636	; 0x2636 <vLedBlink>
     228:	0c 94 7f 12 	jmp	0x24fe	; 0x24fe <prvTimerTask+0x1e2>
     22c:	0c 94 8e 11 	jmp	0x231c	; 0x231c <prvTimerTask>
     230:	0c 94 17 0b 	jmp	0x162e	; 0x162e <prvIdleTask>
     234:	0c 94 ed 04 	jmp	0x9da	; 0x9da <vEventGroupSetBitsCallback>
     238:	0c 94 97 12 	jmp	0x252e	; 0x252e <prvTimerTask+0x212>
     23c:	0c 94 4a 12 	jmp	0x2494	; 0x2494 <prvTimerTask+0x178>
     240:	0c 94 45 02 	jmp	0x48a	; 0x48a <vTask_DMAHandler>

00000244 <__ctors_end>:
     244:	11 24       	eor	r1, r1
     246:	1f be       	out	0x3f, r1	; 63
     248:	cf ef       	ldi	r28, 0xFF	; 255
     24a:	cd bf       	out	0x3d, r28	; 61
     24c:	df e3       	ldi	r29, 0x3F	; 63
     24e:	de bf       	out	0x3e, r29	; 62
     250:	00 e0       	ldi	r16, 0x00	; 0
     252:	0c bf       	out	0x3c, r16	; 60

00000254 <init_mem>:
// !!! Never call this function, it is part of .init-Code
void __attribute__ ((naked, section(".init3"))) init_mem (void);
void init_mem (void)
{
   //  Use inline assembler so it works even with optimization turned off
   __asm volatile (
     254:	e1 e3       	ldi	r30, 0x31	; 49
     256:	f2 e3       	ldi	r31, 0x32	; 50
     258:	8a ea       	ldi	r24, 0xAA	; 170
     25a:	90 e4       	ldi	r25, 0x40	; 64
     25c:	81 93       	st	Z+, r24
     25e:	e0 30       	cpi	r30, 0x00	; 0
     260:	f9 07       	cpc	r31, r25
     262:	e0 f3       	brcs	.-8      	; 0x25c <init_mem+0x8>

00000264 <__do_copy_data>:
     264:	12 e2       	ldi	r17, 0x22	; 34
     266:	a0 e0       	ldi	r26, 0x00	; 0
     268:	b0 e2       	ldi	r27, 0x20	; 32
     26a:	e4 e2       	ldi	r30, 0x24	; 36
     26c:	f0 e4       	ldi	r31, 0x40	; 64
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	0b bf       	out	0x3b, r16	; 59
     272:	02 c0       	rjmp	.+4      	; 0x278 <__do_copy_data+0x14>
     274:	07 90       	elpm	r0, Z+
     276:	0d 92       	st	X+, r0
     278:	a2 31       	cpi	r26, 0x12	; 18
     27a:	b1 07       	cpc	r27, r17
     27c:	d9 f7       	brne	.-10     	; 0x274 <__do_copy_data+0x10>

0000027e <__do_clear_bss>:
     27e:	22 e3       	ldi	r18, 0x32	; 50
     280:	a2 e1       	ldi	r26, 0x12	; 18
     282:	b2 e2       	ldi	r27, 0x22	; 34
     284:	01 c0       	rjmp	.+2      	; 0x288 <.do_clear_bss_start>

00000286 <.do_clear_bss_loop>:
     286:	1d 92       	st	X+, r1

00000288 <.do_clear_bss_start>:
     288:	a1 33       	cpi	r26, 0x31	; 49
     28a:	b2 07       	cpc	r27, r18
     28c:	e1 f7       	brne	.-8      	; 0x286 <.do_clear_bss_loop>
     28e:	0e 94 67 13 	call	0x26ce	; 0x26ce <main>
     292:	0c 94 10 20 	jmp	0x4020	; 0x4020 <_exit>

00000296 <__bad_interrupt>:
     296:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000029a <sys_InitADC>:
void sys_InitADC(void)
{
	
	// Free Running mode: On
	// Conversion mode: Unsigned, 8Bit
	ADCB.CTRLB=(ADCB.CTRLB & (~(ADC_CONMODE_bm | ADC_FREERUN_bm | ADC_RESOLUTION_gm))) | ADC_RESOLUTION_8BIT_gc | ADC_FREERUN_bm;
     29a:	e0 e4       	ldi	r30, 0x40	; 64
     29c:	f2 e0       	ldi	r31, 0x02	; 2
     29e:	81 81       	ldd	r24, Z+1	; 0x01
     2a0:	81 7e       	andi	r24, 0xE1	; 225
     2a2:	8c 60       	ori	r24, 0x0C	; 12
     2a4:	81 83       	std	Z+1, r24	; 0x01
	// Reference 1V and configuration of prescaler to 256
	ADCB.PRESCALER=(ADCB.PRESCALER & (~ADC_PRESCALER_gm)) | ADC_PRESCALER_DIV256_gc; //?????
     2a6:	84 81       	ldd	r24, Z+4	; 0x04
     2a8:	88 7f       	andi	r24, 0xF8	; 248
     2aa:	86 60       	ori	r24, 0x06	; 6
     2ac:	84 83       	std	Z+4, r24	; 0x04
	ADCB.REFCTRL = ADC_REFSEL_INT1V_gc | ADC_TEMPREF_bm;;			//internal 1V
     2ae:	81 e0       	ldi	r24, 0x01	; 1
     2b0:	82 83       	std	Z+2, r24	; 0x02

	// Read and save the ADC offset using channel 0
	ADCB.CH0.CTRL=(ADCB.CH0.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2b2:	80 a1       	ldd	r24, Z+32	; 0x20
     2b4:	80 76       	andi	r24, 0x60	; 96
     2b6:	81 60       	ori	r24, 0x01	; 1
     2b8:	80 a3       	std	Z+32, r24	; 0x20
	ADCB.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN0_gc ;	// PORTB:0
     2ba:	11 a2       	std	Z+33, r1	; 0x21
	
	ADCB.CH1.CTRL=(ADCB.CH1.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2bc:	80 a5       	ldd	r24, Z+40	; 0x28
     2be:	80 76       	andi	r24, 0x60	; 96
     2c0:	81 60       	ori	r24, 0x01	; 1
     2c2:	80 a7       	std	Z+40, r24	; 0x28
	ADCB.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc ;	// PORTB:1	
     2c4:	88 e0       	ldi	r24, 0x08	; 8
     2c6:	81 a7       	std	Z+41, r24	; 0x29
	
	ADCB.CH2.CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_INTERNAL_gc;
     2c8:	10 aa       	std	Z+48, r1	; 0x30
	ADCB.CH2.MUXCTRL = ADC_CH_MUXINT_TEMP_gc;  //Temp Mux
     2ca:	11 aa       	std	Z+49, r1	; 0x31
	
	ADCB.EVCTRL = ADC_SWEEP_012_gc;
     2cc:	80 e8       	ldi	r24, 0x80	; 128
     2ce:	83 83       	std	Z+3, r24	; 0x03
	
	// Enable the ADC in order to read the offset
	ADCB.CTRLA|=ADC_ENABLE_bm;
     2d0:	80 81       	ld	r24, Z
     2d2:	81 60       	ori	r24, 0x01	; 1
     2d4:	80 83       	st	Z, r24
     2d6:	08 95       	ret

000002d8 <vInitDMA>:
}

void vInitDMA()
{
	//ADC8 PB0 Input
	PORTB.DIRCLR = PIN0_bm;
     2d8:	e0 e2       	ldi	r30, 0x20	; 32
     2da:	f6 e0       	ldi	r31, 0x06	; 6
     2dc:	81 e0       	ldi	r24, 0x01	; 1
     2de:	82 83       	std	Z+2, r24	; 0x02
	PORTB.DIRCLR = PIN1_bm;
     2e0:	82 e0       	ldi	r24, 0x02	; 2
     2e2:	82 83       	std	Z+2, r24	; 0x02
	
	sys_InitADC();
     2e4:	0e 94 4d 01 	call	0x29a	; 0x29a <sys_InitADC>

	// set TCC1 to 11024Hz overflow, actually 11019.2838Hz (-0.052% error)
	TCC1.CTRLA = 0; // stop if running
     2e8:	e0 e4       	ldi	r30, 0x40	; 64
     2ea:	f8 e0       	ldi	r31, 0x08	; 8
     2ec:	10 82       	st	Z, r1
	TCC1.CNT = 0;
     2ee:	10 a2       	std	Z+32, r1	; 0x20
     2f0:	11 a2       	std	Z+33, r1	; 0x21
	TCC1.PER = 0x0FFF;
     2f2:	8f ef       	ldi	r24, 0xFF	; 255
     2f4:	9f e0       	ldi	r25, 0x0F	; 15
     2f6:	86 a3       	std	Z+38, r24	; 0x26
     2f8:	97 a3       	std	Z+39, r25	; 0x27

	EVSYS.CH0MUX = EVSYS_CHMUX_TCC1_OVF_gc; // trigger on timer overflow
     2fa:	88 ec       	ldi	r24, 0xC8	; 200
     2fc:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>


	// reset DMA controller
	DMA.CTRL = 0;
     300:	e0 e0       	ldi	r30, 0x00	; 0
     302:	f1 e0       	ldi	r31, 0x01	; 1
     304:	10 82       	st	Z, r1
	DMA.CTRL = DMA_RESET_bm;
     306:	80 e4       	ldi	r24, 0x40	; 64
     308:	80 83       	st	Z, r24
	while ((DMA.CTRL & DMA_RESET_bm) != 0);
     30a:	80 81       	ld	r24, Z
     30c:	86 fd       	sbrc	r24, 6
     30e:	fd cf       	rjmp	.-6      	; 0x30a <vInitDMA+0x32>
	
	DMA.CTRL			= DMA_CH_ENABLE_bm | DMA_DBUFMODE_CH01_gc; // double buffered with channels 0 and 1
     310:	e0 e0       	ldi	r30, 0x00	; 0
     312:	f1 e0       	ldi	r31, 0x01	; 1
     314:	84 e8       	ldi	r24, 0x84	; 132
     316:	80 83       	st	Z, r24
	//Bei Double Buffering wird automatisch aus Channel 0 und 1 ein "Pair" gebildet. 
	//Siehe dazu AVR1304.P8
	
	// channel 0
	// **** TODO: reset dma channels
	DMA.CH0.REPCNT		= 0;
     318:	16 8a       	std	Z+22, r1	; 0x16
	DMA.CH0.CTRLA		=  DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 1 byte (8 bit word)
     31a:	74 e2       	ldi	r23, 0x24	; 36
     31c:	70 8b       	std	Z+16, r23	; 0x10
	DMA.CH0.CTRLB		= 0x1;
     31e:	61 e0       	ldi	r22, 0x01	; 1
     320:	61 8b       	std	Z+17, r22	; 0x11
	DMA.CH0.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     322:	5d e9       	ldi	r21, 0x9D	; 157
     324:	52 8b       	std	Z+18, r21	; 0x12
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH0.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc;	//DMA0 gets synched by TCC1
     326:	46 e4       	ldi	r20, 0x46	; 70
     328:	43 8b       	std	Z+19, r20	; 0x13
	DMA.CH0.TRFCNT		= 64; // always the number of bytes, even if burst length > 1
     32a:	20 e4       	ldi	r18, 0x40	; 64
     32c:	30 e0       	ldi	r19, 0x00	; 0
     32e:	24 8b       	std	Z+20, r18	; 0x14
     330:	35 8b       	std	Z+21, r19	; 0x15
	DMA.CH0.DESTADDR0	= (( (uint16_t) buffer_a) >> 0) & 0xFF;
     332:	80 ee       	ldi	r24, 0xE0	; 224
     334:	90 e3       	ldi	r25, 0x30	; 48
     336:	84 8f       	std	Z+28, r24	; 0x1c
	DMA.CH0.DESTADDR1	= (( (uint16_t) buffer_a) >> 8) & 0xFF;
     338:	95 8f       	std	Z+29, r25	; 0x1d
	DMA.CH0.DESTADDR2	= 0;
     33a:	16 8e       	std	Z+30, r1	; 0x1e
	DMA.CH0.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     33c:	9c e6       	ldi	r25, 0x6C	; 108
     33e:	90 8f       	std	Z+24, r25	; 0x18
	DMA.CH0.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     340:	82 e0       	ldi	r24, 0x02	; 2
     342:	81 8f       	std	Z+25, r24	; 0x19
	DMA.CH0.SRCADDR2	= 0;
     344:	12 8e       	std	Z+26, r1	; 0x1a

	// channel 1
	DMA.CH1.REPCNT		= 0;
     346:	16 a2       	std	Z+38, r1	; 0x26
	DMA.CH1.CTRLA		= DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 1 byte (8 bit word)
     348:	70 a3       	std	Z+32, r23	; 0x20
	DMA.CH1.CTRLB		= 0x1;
     34a:	61 a3       	std	Z+33, r22	; 0x21
	DMA.CH1.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     34c:	52 a3       	std	Z+34, r21	; 0x22
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH1.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc; //DMA1 gets synched by TCC1
     34e:	43 a3       	std	Z+35, r20	; 0x23
	DMA.CH1.TRFCNT		= 64; // always the number of bytes, even if burst length > 1
     350:	24 a3       	std	Z+36, r18	; 0x24
     352:	35 a3       	std	Z+37, r19	; 0x25
	DMA.CH1.DESTADDR0	= (( (uint16_t) buffer_b) >> 0) & 0xFF;
     354:	20 ea       	ldi	r18, 0xA0	; 160
     356:	30 e3       	ldi	r19, 0x30	; 48
     358:	24 a7       	std	Z+44, r18	; 0x2c
	DMA.CH1.DESTADDR1	= (( (uint16_t) buffer_b) >> 8) & 0xFF;
     35a:	35 a7       	std	Z+45, r19	; 0x2d
	DMA.CH1.DESTADDR2	= 0;
     35c:	16 a6       	std	Z+46, r1	; 0x2e
	DMA.CH1.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     35e:	90 a7       	std	Z+40, r25	; 0x28
	DMA.CH1.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     360:	81 a7       	std	Z+41, r24	; 0x29
	DMA.CH1.SRCADDR2	= 0;
     362:	12 a6       	std	Z+42, r1	; 0x2a

	DMA.CH0.CTRLA		|= DMA_CH_ENABLE_bm;
     364:	80 89       	ldd	r24, Z+16	; 0x10
     366:	80 68       	ori	r24, 0x80	; 128
     368:	80 8b       	std	Z+16, r24	; 0x10
	TCC1.CTRLA			= TC_CLKSEL_DIV1024_gc; // start timer, and in turn ADC
     36a:	87 e0       	ldi	r24, 0x07	; 7
     36c:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
     370:	08 95       	ret

00000372 <__vector_6>:
// 		DMA.INTFLAGS = DMA_CH0TRNIF_bm;

}

ISR(DMA_CH0_vect)
{
     372:	1f 92       	push	r1
     374:	0f 92       	push	r0
     376:	0f b6       	in	r0, 0x3f	; 63
     378:	0f 92       	push	r0
     37a:	11 24       	eor	r1, r1
     37c:	0b b6       	in	r0, 0x3b	; 59
     37e:	0f 92       	push	r0
     380:	2f 93       	push	r18
     382:	3f 93       	push	r19
     384:	4f 93       	push	r20
     386:	5f 93       	push	r21
     388:	6f 93       	push	r22
     38a:	7f 93       	push	r23
     38c:	8f 93       	push	r24
     38e:	9f 93       	push	r25
     390:	af 93       	push	r26
     392:	bf 93       	push	r27
     394:	ef 93       	push	r30
     396:	ff 93       	push	r31
     398:	cf 93       	push	r28
     39a:	df 93       	push	r29
     39c:	1f 92       	push	r1
     39e:	cd b7       	in	r28, 0x3d	; 61
     3a0:	de b7       	in	r29, 0x3e	; 62
	
	//Interrupt quittieren
	DMA.CH0.CTRLB |= 0x10;
     3a2:	e0 e0       	ldi	r30, 0x00	; 0
     3a4:	f1 e0       	ldi	r31, 0x01	; 1
     3a6:	81 89       	ldd	r24, Z+17	; 0x11
     3a8:	80 61       	ori	r24, 0x10	; 16
     3aa:	81 8b       	std	Z+17, r24	; 0x11
	TCC1.INTFLAGS |= 0x01;
     3ac:	e0 e4       	ldi	r30, 0x40	; 64
     3ae:	f8 e0       	ldi	r31, 0x08	; 8
     3b0:	84 85       	ldd	r24, Z+12	; 0x0c
     3b2:	81 60       	ori	r24, 0x01	; 1
     3b4:	84 87       	std	Z+12, r24	; 0x0c
	//PORTF.OUTTGL = 0x01;
		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     3b6:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     3b8:	9e 01       	movw	r18, r28
     3ba:	2f 5f       	subi	r18, 0xFF	; 255
     3bc:	3f 4f       	sbci	r19, 0xFF	; 255
     3be:	41 e0       	ldi	r20, 0x01	; 1
     3c0:	50 e0       	ldi	r21, 0x00	; 0
     3c2:	60 e0       	ldi	r22, 0x00	; 0
     3c4:	70 e0       	ldi	r23, 0x00	; 0
     3c6:	80 91 a8 2e 	lds	r24, 0x2EA8	; 0x802ea8 <xDMAProcessEventGroup>
     3ca:	90 91 a9 2e 	lds	r25, 0x2EA9	; 0x802ea9 <xDMAProcessEventGroup+0x1>
     3ce:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     3d2:	0f 90       	pop	r0
     3d4:	df 91       	pop	r29
     3d6:	cf 91       	pop	r28
     3d8:	ff 91       	pop	r31
     3da:	ef 91       	pop	r30
     3dc:	bf 91       	pop	r27
     3de:	af 91       	pop	r26
     3e0:	9f 91       	pop	r25
     3e2:	8f 91       	pop	r24
     3e4:	7f 91       	pop	r23
     3e6:	6f 91       	pop	r22
     3e8:	5f 91       	pop	r21
     3ea:	4f 91       	pop	r20
     3ec:	3f 91       	pop	r19
     3ee:	2f 91       	pop	r18
     3f0:	0f 90       	pop	r0
     3f2:	0b be       	out	0x3b, r0	; 59
     3f4:	0f 90       	pop	r0
     3f6:	0f be       	out	0x3f, r0	; 63
     3f8:	0f 90       	pop	r0
     3fa:	1f 90       	pop	r1
     3fc:	18 95       	reti

000003fe <__vector_7>:

ISR(DMA_CH1_vect)
{
     3fe:	1f 92       	push	r1
     400:	0f 92       	push	r0
     402:	0f b6       	in	r0, 0x3f	; 63
     404:	0f 92       	push	r0
     406:	11 24       	eor	r1, r1
     408:	0b b6       	in	r0, 0x3b	; 59
     40a:	0f 92       	push	r0
     40c:	2f 93       	push	r18
     40e:	3f 93       	push	r19
     410:	4f 93       	push	r20
     412:	5f 93       	push	r21
     414:	6f 93       	push	r22
     416:	7f 93       	push	r23
     418:	8f 93       	push	r24
     41a:	9f 93       	push	r25
     41c:	af 93       	push	r26
     41e:	bf 93       	push	r27
     420:	ef 93       	push	r30
     422:	ff 93       	push	r31
     424:	cf 93       	push	r28
     426:	df 93       	push	r29
     428:	1f 92       	push	r1
     42a:	cd b7       	in	r28, 0x3d	; 61
     42c:	de b7       	in	r29, 0x3e	; 62
	//Interrupt quittieren
	DMA.CH1.CTRLB |= 0x10;
     42e:	e0 e0       	ldi	r30, 0x00	; 0
     430:	f1 e0       	ldi	r31, 0x01	; 1
     432:	81 a1       	ldd	r24, Z+33	; 0x21
     434:	80 61       	ori	r24, 0x10	; 16
     436:	81 a3       	std	Z+33, r24	; 0x21
	TCC1.INTFLAGS |= 0x01;
     438:	e0 e4       	ldi	r30, 0x40	; 64
     43a:	f8 e0       	ldi	r31, 0x08	; 8
     43c:	84 85       	ldd	r24, Z+12	; 0x0c
     43e:	81 60       	ori	r24, 0x01	; 1
     440:	84 87       	std	Z+12, r24	; 0x0c

		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     442:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     444:	9e 01       	movw	r18, r28
     446:	2f 5f       	subi	r18, 0xFF	; 255
     448:	3f 4f       	sbci	r19, 0xFF	; 255
     44a:	42 e0       	ldi	r20, 0x02	; 2
     44c:	50 e0       	ldi	r21, 0x00	; 0
     44e:	60 e0       	ldi	r22, 0x00	; 0
     450:	70 e0       	ldi	r23, 0x00	; 0
     452:	80 91 a8 2e 	lds	r24, 0x2EA8	; 0x802ea8 <xDMAProcessEventGroup>
     456:	90 91 a9 2e 	lds	r25, 0x2EA9	; 0x802ea9 <xDMAProcessEventGroup+0x1>
     45a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     45e:	0f 90       	pop	r0
     460:	df 91       	pop	r29
     462:	cf 91       	pop	r28
     464:	ff 91       	pop	r31
     466:	ef 91       	pop	r30
     468:	bf 91       	pop	r27
     46a:	af 91       	pop	r26
     46c:	9f 91       	pop	r25
     46e:	8f 91       	pop	r24
     470:	7f 91       	pop	r23
     472:	6f 91       	pop	r22
     474:	5f 91       	pop	r21
     476:	4f 91       	pop	r20
     478:	3f 91       	pop	r19
     47a:	2f 91       	pop	r18
     47c:	0f 90       	pop	r0
     47e:	0b be       	out	0x3b, r0	; 59
     480:	0f 90       	pop	r0
     482:	0f be       	out	0x3f, r0	; 63
     484:	0f 90       	pop	r0
     486:	1f 90       	pop	r1
     488:	18 95       	reti

0000048a <vTask_DMAHandler>:


void vTask_DMAHandler(void *pvParameters) 
{
	//Do things and Stuff with DMA!
	xDMAProcessEventGroup = xEventGroupCreate();
     48a:	0e 94 60 03 	call	0x6c0	; 0x6c0 <xEventGroupCreate>
     48e:	80 93 a8 2e 	sts	0x2EA8, r24	; 0x802ea8 <xDMAProcessEventGroup>
     492:	90 93 a9 2e 	sts	0x2EA9, r25	; 0x802ea9 <xDMAProcessEventGroup+0x1>
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,no_signal_counter = 0;
	PORTF.DIRSET = PIN1_bm; /*LED1*/
     496:	e0 ea       	ldi	r30, 0xA0	; 160
     498:	f6 e0       	ldi	r31, 0x06	; 6
     49a:	82 e0       	ldi	r24, 0x02	; 2
     49c:	81 83       	std	Z+1, r24	; 0x01
	PORTF.DIRSET = PIN2_bm; /*LED2*/
     49e:	94 e0       	ldi	r25, 0x04	; 4
     4a0:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN0_bm;
     4a2:	e0 e8       	ldi	r30, 0x80	; 128
     4a4:	f6 e0       	ldi	r31, 0x06	; 6
     4a6:	91 e0       	ldi	r25, 0x01	; 1
     4a8:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN1_bm;
     4aa:	81 83       	std	Z+1, r24	; 0x01
{
	//Do things and Stuff with DMA!
	xDMAProcessEventGroup = xEventGroupCreate();
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,no_signal_counter = 0;
     4ac:	81 2c       	mov	r8, r1
     4ae:	91 2c       	mov	r9, r1
				}
			}
			count_buffer_a++;
			
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x02));
     4b0:	0f 2e       	mov	r0, r31
     4b2:	f0 ea       	ldi	r31, 0xA0	; 160
     4b4:	af 2e       	mov	r10, r31
     4b6:	f6 e0       	ldi	r31, 0x06	; 6
     4b8:	bf 2e       	mov	r11, r31
     4ba:	f0 2d       	mov	r31, r0
	PORTE.DIRSET = PIN1_bm;

	
	while(1)
	{
		uxBits = xEventGroupWaitBits(
     4bc:	cc 24       	eor	r12, r12
     4be:	ca 94       	dec	r12
     4c0:	dc 2c       	mov	r13, r12
     4c2:	76 01       	movw	r14, r12
     4c4:	00 e0       	ldi	r16, 0x00	; 0
     4c6:	21 e0       	ldi	r18, 0x01	; 1
     4c8:	43 e0       	ldi	r20, 0x03	; 3
     4ca:	50 e0       	ldi	r21, 0x00	; 0
     4cc:	60 e0       	ldi	r22, 0x00	; 0
     4ce:	70 e0       	ldi	r23, 0x00	; 0
     4d0:	80 91 a8 2e 	lds	r24, 0x2EA8	; 0x802ea8 <xDMAProcessEventGroup>
     4d4:	90 91 a9 2e 	lds	r25, 0x2EA9	; 0x802ea9 <xDMAProcessEventGroup+0x1>
     4d8:	0e 94 75 03 	call	0x6ea	; 0x6ea <xEventGroupWaitBits>
		pdTRUE,        /* Bits should be cleared before returning. */
		pdFALSE,       /* Don't wait for both bits, either bit will do. */
		portMAX_DELAY );/* Wait a maximum for either bit to be set. */
			
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
     4dc:	60 fd       	sbrc	r22, 0
     4de:	05 c0       	rjmp	.+10     	; 0x4ea <vTask_DMAHandler+0x60>
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			for (i=0;i<buffer_length;i++)
     4e0:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     4e4:	81 11       	cpse	r24, r1
     4e6:	43 c0       	rjmp	.+134    	; 0x56e <vTask_DMAHandler+0xe4>
     4e8:	73 c0       	rjmp	.+230    	; 0x5d0 <vTask_DMAHandler+0x146>
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
		{
			//Do stuff with BufferA
			//buffer_a ....
			for (i=0;i<buffer_length;i++)//Detect signal 
     4ea:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     4ee:	88 23       	and	r24, r24
     4f0:	89 f1       	breq	.+98     	; 0x554 <vTask_DMAHandler+0xca>
     4f2:	c0 e0       	ldi	r28, 0x00	; 0
     4f4:	d0 e0       	ldi	r29, 0x00	; 0
			{
				if ((xtest_array_length < 135)&(xtest_array_length > 120))		/*after testing variable is buffer_a				// if value is under threshold, it shall stop calculating the signal*/
     4f6:	80 91 81 21 	lds	r24, 0x2181	; 0x802181 <xtest_array_length>
     4fa:	90 91 82 21 	lds	r25, 0x2182	; 0x802182 <xtest_array_length+0x1>
     4fe:	89 57       	subi	r24, 0x79	; 121
     500:	91 09       	sbc	r25, r1
     502:	0e 97       	sbiw	r24, 0x0e	; 14
     504:	98 f4       	brcc	.+38     	; 0x52c <vTask_DMAHandler+0xa2>
				{
					no_signal_counter++;							// wait 100 counts to make sure that signal has stopped
     506:	8f ef       	ldi	r24, 0xFF	; 255
     508:	88 1a       	sub	r8, r24
     50a:	98 0a       	sbc	r9, r24
					if (no_signal_counter >=100)					// no signal stop calculating -> set event bits to 0
     50c:	e4 e6       	ldi	r30, 0x64	; 100
     50e:	8e 16       	cp	r8, r30
     510:	91 04       	cpc	r9, r1
     512:	cc f0       	brlt	.+50     	; 0x546 <vTask_DMAHandler+0xbc>
					{											// no signal stop calculating -> set event bits to 0
						xResult = xEventGroupClearBits(			// clear event bits
     514:	43 e0       	ldi	r20, 0x03	; 3
     516:	50 e0       	ldi	r21, 0x00	; 0
     518:	60 e0       	ldi	r22, 0x00	; 0
     51a:	70 e0       	ldi	r23, 0x00	; 0
     51c:	80 91 a4 2f 	lds	r24, 0x2FA4	; 0x802fa4 <xSignalProcessEventGroup>
     520:	90 91 a5 2f 	lds	r25, 0x2FA5	; 0x802fa5 <xSignalProcessEventGroup+0x1>
     524:	0e 94 3a 04 	call	0x874	; 0x874 <xEventGroupClearBits>
     528:	16 2f       	mov	r17, r22
     52a:	0d c0       	rjmp	.+26     	; 0x546 <vTask_DMAHandler+0xbc>
											);												
					}
				}
				else
				{
					xResult = xEventGroupSetBits(
     52c:	42 e0       	ldi	r20, 0x02	; 2
     52e:	50 e0       	ldi	r21, 0x00	; 0
     530:	60 e0       	ldi	r22, 0x00	; 0
     532:	70 e0       	ldi	r23, 0x00	; 0
     534:	80 91 a4 2f 	lds	r24, 0x2FA4	; 0x802fa4 <xSignalProcessEventGroup>
     538:	90 91 a5 2f 	lds	r25, 0x2FA5	; 0x802fa5 <xSignalProcessEventGroup+0x1>
     53c:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <xEventGroupSetBits>
     540:	16 2f       	mov	r17, r22
					);
					if( xResult & Process_Signal_BufferB )		//test if Eventgroup bit is set
					{
						//count_array_a++;
					}
					no_signal_counter = 0;
     542:	81 2c       	mov	r8, r1
     544:	91 2c       	mov	r9, r1
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
		{
			//Do stuff with BufferA
			//buffer_a ....
			for (i=0;i<buffer_length;i++)//Detect signal 
     546:	21 96       	adiw	r28, 0x01	; 1
     548:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	c8 17       	cp	r28, r24
     550:	d9 07       	cpc	r29, r25
     552:	8c f2       	brlt	.-94     	; 0x4f6 <vTask_DMAHandler+0x6c>
						//count_array_a++;
					}
					no_signal_counter = 0;
				}
			}
			count_buffer_a++;
     554:	80 91 13 22 	lds	r24, 0x2213	; 0x802213 <count_buffer_a>
     558:	8f 5f       	subi	r24, 0xFF	; 255
     55a:	80 93 13 22 	sts	0x2213, r24	; 0x802213 <count_buffer_a>
			
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x02));
     55e:	f5 01       	movw	r30, r10
     560:	84 81       	ldd	r24, Z+4	; 0x04
     562:	8d 7f       	andi	r24, 0xFD	; 253
     564:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x04;	
     566:	84 81       	ldd	r24, Z+4	; 0x04
     568:	84 60       	ori	r24, 0x04	; 4
     56a:	84 83       	std	Z+4, r24	; 0x04
     56c:	3d c0       	rjmp	.+122    	; 0x5e8 <vTask_DMAHandler+0x15e>
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			for (i=0;i<buffer_length;i++)
     56e:	c0 e0       	ldi	r28, 0x00	; 0
     570:	d0 e0       	ldi	r29, 0x00	; 0
			{				
				if (buffer_b[i] >= 20)
     572:	fe 01       	movw	r30, r28
     574:	e0 56       	subi	r30, 0x60	; 96
     576:	ff 4c       	sbci	r31, 0xCF	; 207
     578:	80 81       	ld	r24, Z
     57a:	84 31       	cpi	r24, 0x14	; 20
     57c:	58 f0       	brcs	.+22     	; 0x594 <vTask_DMAHandler+0x10a>
				{
				xResult = xEventGroupSetBits(
     57e:	41 e0       	ldi	r20, 0x01	; 1
     580:	50 e0       	ldi	r21, 0x00	; 0
     582:	60 e0       	ldi	r22, 0x00	; 0
     584:	70 e0       	ldi	r23, 0x00	; 0
     586:	80 91 a4 2f 	lds	r24, 0x2FA4	; 0x802fa4 <xSignalProcessEventGroup>
     58a:	90 91 a5 2f 	lds	r25, 0x2FA5	; 0x802fa5 <xSignalProcessEventGroup+0x1>
     58e:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <xEventGroupSetBits>
     592:	16 2f       	mov	r17, r22
									xSignalProcessEventGroup,   /* The event group being updated. */
									Process_Signal_BufferA		/* The bits being set. */
									);	
				}
				if(xResult & Process_Signal_BufferA)			//test if Eventgroup bit is set
     594:	10 ff       	sbrs	r17, 0
     596:	03 c0       	rjmp	.+6      	; 0x59e <vTask_DMAHandler+0x114>
				{
					{
						//count_array_b++;
					}
					count_buffer_a = 0;
     598:	10 92 13 22 	sts	0x2213, r1	; 0x802213 <count_buffer_a>
     59c:	12 c0       	rjmp	.+36     	; 0x5c2 <vTask_DMAHandler+0x138>
				}
				else											// if value is under threshold, it shall stop calculating the signal
				{
					no_signal_counter++;					
     59e:	ff ef       	ldi	r31, 0xFF	; 255
     5a0:	8f 1a       	sub	r8, r31
     5a2:	9f 0a       	sbc	r9, r31
					if (no_signal_counter >=100)					// wait 100 counts to make sure that signal has stopped
     5a4:	84 e6       	ldi	r24, 0x64	; 100
     5a6:	88 16       	cp	r8, r24
     5a8:	91 04       	cpc	r9, r1
     5aa:	5c f0       	brlt	.+22     	; 0x5c2 <vTask_DMAHandler+0x138>
					{									
						xResult = xEventGroupClearBits(			// clear event bits
     5ac:	43 e0       	ldi	r20, 0x03	; 3
     5ae:	50 e0       	ldi	r21, 0x00	; 0
     5b0:	60 e0       	ldi	r22, 0x00	; 0
     5b2:	70 e0       	ldi	r23, 0x00	; 0
     5b4:	80 91 a4 2f 	lds	r24, 0x2FA4	; 0x802fa4 <xSignalProcessEventGroup>
     5b8:	90 91 a5 2f 	lds	r25, 0x2FA5	; 0x802fa5 <xSignalProcessEventGroup+0x1>
     5bc:	0e 94 3a 04 	call	0x874	; 0x874 <xEventGroupClearBits>
     5c0:	16 2f       	mov	r17, r22
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			for (i=0;i<buffer_length;i++)
     5c2:	21 96       	adiw	r28, 0x01	; 1
     5c4:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	c8 17       	cp	r28, r24
     5cc:	d9 07       	cpc	r29, r25
     5ce:	8c f2       	brlt	.-94     	; 0x572 <vTask_DMAHandler+0xe8>
												Process_Signal_BufferA|Process_Signal_BufferB
												);										// no signal stop calculating -> set event bits to 0
						}
				}
			}
			count_buffer_b++;
     5d0:	80 91 12 22 	lds	r24, 0x2212	; 0x802212 <__data_end>
     5d4:	8f 5f       	subi	r24, 0xFF	; 255
     5d6:	80 93 12 22 	sts	0x2212, r24	; 0x802212 <__data_end>
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x04));
     5da:	f5 01       	movw	r30, r10
     5dc:	84 81       	ldd	r24, Z+4	; 0x04
     5de:	8b 7f       	andi	r24, 0xFB	; 251
     5e0:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x02;
     5e2:	84 81       	ldd	r24, Z+4	; 0x04
     5e4:	82 60       	ori	r24, 0x02	; 2
     5e6:	84 83       	std	Z+4, r24	; 0x04
		}
	vTaskDelay(100 / portTICK_RATE_MS);
     5e8:	64 e6       	ldi	r22, 0x64	; 100
     5ea:	70 e0       	ldi	r23, 0x00	; 0
     5ec:	80 e0       	ldi	r24, 0x00	; 0
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vTaskDelay>
	}
     5f4:	63 cf       	rjmp	.-314    	; 0x4bc <vTask_DMAHandler+0x32>

000005f6 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     5f6:	0f 93       	push	r16
     5f8:	cf 93       	push	r28
     5fa:	df 93       	push	r29
     5fc:	1f 92       	push	r1
     5fe:	cd b7       	in	r28, 0x3d	; 61
     600:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     602:	2f b7       	in	r18, 0x3f	; 63
     604:	29 83       	std	Y+1, r18	; 0x01
     606:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     608:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     60a:	fc 01       	movw	r30, r24
     60c:	08 ed       	ldi	r16, 0xD8	; 216
     60e:	04 bf       	out	0x34, r16	; 52
     610:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     612:	89 81       	ldd	r24, Y+1	; 0x01
     614:	8f bf       	out	0x3f, r24	; 63
#endif
}
     616:	0f 90       	pop	r0
     618:	df 91       	pop	r29
     61a:	cf 91       	pop	r28
     61c:	0f 91       	pop	r16
     61e:	08 95       	ret

00000620 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     620:	61 11       	cpse	r22, r1
     622:	02 c0       	rjmp	.+4      	; 0x628 <CLKSYS_XOSC_Config+0x8>
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	01 c0       	rjmp	.+2      	; 0x62a <CLKSYS_XOSC_Config+0xa>
     628:	90 e2       	ldi	r25, 0x20	; 32
     62a:	84 2b       	or	r24, r20
     62c:	89 2b       	or	r24, r25
     62e:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
     632:	08 95       	ret

00000634 <CLKSYS_PLL_Config>:
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     634:	6f 71       	andi	r22, 0x1F	; 31
     636:	86 2b       	or	r24, r22
     638:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
     63c:	08 95       	ret

0000063e <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     63e:	e0 e5       	ldi	r30, 0x50	; 80
     640:	f0 e0       	ldi	r31, 0x00	; 0
     642:	90 81       	ld	r25, Z
     644:	28 2f       	mov	r18, r24
     646:	20 95       	com	r18
     648:	92 23       	and	r25, r18
     64a:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     64c:	90 81       	ld	r25, Z
	return clkEnabled;
}
     64e:	89 23       	and	r24, r25
     650:	08 95       	ret

00000652 <CLKSYS_Prescalers_Config>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
     652:	68 2b       	or	r22, r24
     654:	81 e4       	ldi	r24, 0x41	; 65
     656:	90 e0       	ldi	r25, 0x00	; 0
     658:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <CCPWrite>
     65c:	08 95       	ret

0000065e <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     65e:	0f 93       	push	r16
     660:	1f 93       	push	r17
     662:	cf 93       	push	r28
     664:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     666:	00 e4       	ldi	r16, 0x40	; 64
     668:	10 e0       	ldi	r17, 0x00	; 0
     66a:	f8 01       	movw	r30, r16
     66c:	60 81       	ld	r22, Z
	CCPWrite( &CLK.CTRL, clkCtrl );
     66e:	68 7f       	andi	r22, 0xF8	; 248
     670:	68 2b       	or	r22, r24
     672:	80 e4       	ldi	r24, 0x40	; 64
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     67a:	f8 01       	movw	r30, r16
     67c:	80 81       	ld	r24, Z
	return clkCtrl;
}
     67e:	8c 23       	and	r24, r28
     680:	cf 91       	pop	r28
     682:	1f 91       	pop	r17
     684:	0f 91       	pop	r16
     686:	08 95       	ret

00000688 <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
     688:	fc 01       	movw	r30, r24
     68a:	90 81       	ld	r25, Z
     68c:	90 7f       	andi	r25, 0xF0	; 240
     68e:	69 2b       	or	r22, r25
     690:	60 83       	st	Z, r22
     692:	08 95       	ret

00000694 <TC0_ConfigWGM>:
     694:	fc 01       	movw	r30, r24
     696:	91 81       	ldd	r25, Z+1	; 0x01
     698:	98 7f       	andi	r25, 0xF8	; 248
     69a:	69 2b       	or	r22, r25
     69c:	61 83       	std	Z+1, r22	; 0x01
     69e:	08 95       	ret

000006a0 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
     6a0:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     6a2:	96 81       	ldd	r25, Z+6	; 0x06
     6a4:	9c 7f       	andi	r25, 0xFC	; 252
     6a6:	69 2b       	or	r22, r25
     6a8:	66 83       	std	Z+6, r22	; 0x06
     6aa:	08 95       	ret

000006ac <software_reset>:
	 // TODO from here:
	 //
	 // - log the occurance of any error in flash mem (inc counter)
	 // - print a message

	 software_reset();
     6ac:	00 00       	nop
     6ae:	88 ed       	ldi	r24, 0xD8	; 216
     6b0:	84 bf       	out	0x34, r24	; 52
     6b2:	81 e0       	ldi	r24, 0x01	; 1
     6b4:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     6b8:	08 95       	ret

000006ba <vApplicationStackOverflowHook>:
     6ba:	0e 94 56 03 	call	0x6ac	; 0x6ac <software_reset>
     6be:	08 95       	ret

000006c0 <xEventGroupCreate>:
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
}
     6c0:	cf 93       	push	r28
     6c2:	df 93       	push	r29
     6c4:	80 e1       	ldi	r24, 0x10	; 16
     6c6:	90 e0       	ldi	r25, 0x00	; 0
     6c8:	0e 94 fd 04 	call	0x9fa	; 0x9fa <pvPortMalloc>
     6cc:	ec 01       	movw	r28, r24
     6ce:	00 97       	sbiw	r24, 0x00	; 0
     6d0:	41 f0       	breq	.+16     	; 0x6e2 <xEventGroupCreate+0x22>
     6d2:	fc 01       	movw	r30, r24
     6d4:	11 92       	st	Z+, r1
     6d6:	11 92       	st	Z+, r1
     6d8:	11 92       	st	Z+, r1
     6da:	11 92       	st	Z+, r1
     6dc:	cf 01       	movw	r24, r30
     6de:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
     6e2:	ce 01       	movw	r24, r28
     6e4:	df 91       	pop	r29
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <xEventGroupWaitBits>:
     6ea:	2f 92       	push	r2
     6ec:	3f 92       	push	r3
     6ee:	4f 92       	push	r4
     6f0:	5f 92       	push	r5
     6f2:	6f 92       	push	r6
     6f4:	7f 92       	push	r7
     6f6:	8f 92       	push	r8
     6f8:	9f 92       	push	r9
     6fa:	af 92       	push	r10
     6fc:	bf 92       	push	r11
     6fe:	cf 92       	push	r12
     700:	df 92       	push	r13
     702:	ef 92       	push	r14
     704:	ff 92       	push	r15
     706:	0f 93       	push	r16
     708:	1f 93       	push	r17
     70a:	cf 93       	push	r28
     70c:	df 93       	push	r29
     70e:	ec 01       	movw	r28, r24
     710:	4a 01       	movw	r8, r20
     712:	5b 01       	movw	r10, r22
     714:	62 2e       	mov	r6, r18
     716:	70 2e       	mov	r7, r16
     718:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vTaskSuspendAll>
     71c:	28 80       	ld	r2, Y
     71e:	39 80       	ldd	r3, Y+1	; 0x01
     720:	4a 80       	ldd	r4, Y+2	; 0x02
     722:	5b 80       	ldd	r5, Y+3	; 0x03
     724:	01 11       	cpse	r16, r1
     726:	0d c0       	rjmp	.+26     	; 0x742 <xEventGroupWaitBits+0x58>
     728:	81 e0       	ldi	r24, 0x01	; 1
     72a:	b2 01       	movw	r22, r4
     72c:	a1 01       	movw	r20, r2
     72e:	48 21       	and	r20, r8
     730:	59 21       	and	r21, r9
     732:	6a 21       	and	r22, r10
     734:	7b 21       	and	r23, r11
     736:	45 2b       	or	r20, r21
     738:	46 2b       	or	r20, r22
     73a:	47 2b       	or	r20, r23
     73c:	79 f4       	brne	.+30     	; 0x75c <xEventGroupWaitBits+0x72>
     73e:	80 e0       	ldi	r24, 0x00	; 0
     740:	0d c0       	rjmp	.+26     	; 0x75c <xEventGroupWaitBits+0x72>
     742:	81 e0       	ldi	r24, 0x01	; 1
     744:	b2 01       	movw	r22, r4
     746:	a1 01       	movw	r20, r2
     748:	48 21       	and	r20, r8
     74a:	59 21       	and	r21, r9
     74c:	6a 21       	and	r22, r10
     74e:	7b 21       	and	r23, r11
     750:	48 15       	cp	r20, r8
     752:	59 05       	cpc	r21, r9
     754:	6a 05       	cpc	r22, r10
     756:	7b 05       	cpc	r23, r11
     758:	09 f0       	breq	.+2      	; 0x75c <xEventGroupWaitBits+0x72>
     75a:	80 e0       	ldi	r24, 0x00	; 0
     75c:	88 23       	and	r24, r24
     75e:	81 f0       	breq	.+32     	; 0x780 <xEventGroupWaitBits+0x96>
     760:	66 20       	and	r6, r6
     762:	09 f4       	brne	.+2      	; 0x766 <xEventGroupWaitBits+0x7c>
     764:	70 c0       	rjmp	.+224    	; 0x846 <xEventGroupWaitBits+0x15c>
     766:	80 94       	com	r8
     768:	90 94       	com	r9
     76a:	a0 94       	com	r10
     76c:	b0 94       	com	r11
     76e:	82 20       	and	r8, r2
     770:	93 20       	and	r9, r3
     772:	a4 20       	and	r10, r4
     774:	b5 20       	and	r11, r5
     776:	88 82       	st	Y, r8
     778:	99 82       	std	Y+1, r9	; 0x01
     77a:	aa 82       	std	Y+2, r10	; 0x02
     77c:	bb 82       	std	Y+3, r11	; 0x03
     77e:	63 c0       	rjmp	.+198    	; 0x846 <xEventGroupWaitBits+0x15c>
     780:	c1 14       	cp	r12, r1
     782:	d1 04       	cpc	r13, r1
     784:	e1 04       	cpc	r14, r1
     786:	f1 04       	cpc	r15, r1
     788:	09 f4       	brne	.+2      	; 0x78c <xEventGroupWaitBits+0xa2>
     78a:	5d c0       	rjmp	.+186    	; 0x846 <xEventGroupWaitBits+0x15c>
     78c:	66 20       	and	r6, r6
     78e:	29 f0       	breq	.+10     	; 0x79a <xEventGroupWaitBits+0xb0>
     790:	40 e0       	ldi	r20, 0x00	; 0
     792:	50 e0       	ldi	r21, 0x00	; 0
     794:	60 e0       	ldi	r22, 0x00	; 0
     796:	71 e0       	ldi	r23, 0x01	; 1
     798:	03 c0       	rjmp	.+6      	; 0x7a0 <xEventGroupWaitBits+0xb6>
     79a:	40 e0       	ldi	r20, 0x00	; 0
     79c:	50 e0       	ldi	r21, 0x00	; 0
     79e:	ba 01       	movw	r22, r20
     7a0:	71 10       	cpse	r7, r1
     7a2:	74 60       	ori	r23, 0x04	; 4
     7a4:	48 29       	or	r20, r8
     7a6:	59 29       	or	r21, r9
     7a8:	6a 29       	or	r22, r10
     7aa:	7b 29       	or	r23, r11
     7ac:	97 01       	movw	r18, r14
     7ae:	86 01       	movw	r16, r12
     7b0:	ce 01       	movw	r24, r28
     7b2:	04 96       	adiw	r24, 0x04	; 4
     7b4:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <vTaskPlaceOnUnorderedEventList>
     7b8:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
     7bc:	81 11       	cpse	r24, r1
     7be:	02 c0       	rjmp	.+4      	; 0x7c4 <xEventGroupWaitBits+0xda>
     7c0:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
     7c4:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <uxTaskResetEventItemValue>
     7c8:	91 fd       	sbrc	r25, 1
     7ca:	39 c0       	rjmp	.+114    	; 0x83e <xEventGroupWaitBits+0x154>
     7cc:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     7d0:	ff 93       	push	r31
     7d2:	f8 7f       	andi	r31, 0xF8	; 248
     7d4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     7d8:	68 81       	ld	r22, Y
     7da:	79 81       	ldd	r23, Y+1	; 0x01
     7dc:	8a 81       	ldd	r24, Y+2	; 0x02
     7de:	9b 81       	ldd	r25, Y+3	; 0x03
     7e0:	71 10       	cpse	r7, r1
     7e2:	0d c0       	rjmp	.+26     	; 0x7fe <xEventGroupWaitBits+0x114>
     7e4:	21 e0       	ldi	r18, 0x01	; 1
     7e6:	75 01       	movw	r14, r10
     7e8:	64 01       	movw	r12, r8
     7ea:	c6 22       	and	r12, r22
     7ec:	d7 22       	and	r13, r23
     7ee:	e8 22       	and	r14, r24
     7f0:	f9 22       	and	r15, r25
     7f2:	cd 28       	or	r12, r13
     7f4:	ce 28       	or	r12, r14
     7f6:	cf 28       	or	r12, r15
     7f8:	79 f4       	brne	.+30     	; 0x818 <xEventGroupWaitBits+0x12e>
     7fa:	20 e0       	ldi	r18, 0x00	; 0
     7fc:	0d c0       	rjmp	.+26     	; 0x818 <xEventGroupWaitBits+0x12e>
     7fe:	21 e0       	ldi	r18, 0x01	; 1
     800:	75 01       	movw	r14, r10
     802:	64 01       	movw	r12, r8
     804:	c6 22       	and	r12, r22
     806:	d7 22       	and	r13, r23
     808:	e8 22       	and	r14, r24
     80a:	f9 22       	and	r15, r25
     80c:	c8 14       	cp	r12, r8
     80e:	d9 04       	cpc	r13, r9
     810:	ea 04       	cpc	r14, r10
     812:	fb 04       	cpc	r15, r11
     814:	09 f0       	breq	.+2      	; 0x818 <xEventGroupWaitBits+0x12e>
     816:	20 e0       	ldi	r18, 0x00	; 0
     818:	22 23       	and	r18, r18
     81a:	71 f0       	breq	.+28     	; 0x838 <xEventGroupWaitBits+0x14e>
     81c:	66 20       	and	r6, r6
     81e:	61 f0       	breq	.+24     	; 0x838 <xEventGroupWaitBits+0x14e>
     820:	80 94       	com	r8
     822:	90 94       	com	r9
     824:	a0 94       	com	r10
     826:	b0 94       	com	r11
     828:	86 22       	and	r8, r22
     82a:	97 22       	and	r9, r23
     82c:	a8 22       	and	r10, r24
     82e:	b9 22       	and	r11, r25
     830:	88 82       	st	Y, r8
     832:	99 82       	std	Y+1, r9	; 0x01
     834:	aa 82       	std	Y+2, r10	; 0x02
     836:	bb 82       	std	Y+3, r11	; 0x03
     838:	ff 91       	pop	r31
     83a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     83e:	1b 01       	movw	r2, r22
     840:	2c 01       	movw	r4, r24
     842:	55 24       	eor	r5, r5
     844:	02 c0       	rjmp	.+4      	; 0x84a <xEventGroupWaitBits+0x160>
     846:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
     84a:	c2 01       	movw	r24, r4
     84c:	b1 01       	movw	r22, r2
     84e:	df 91       	pop	r29
     850:	cf 91       	pop	r28
     852:	1f 91       	pop	r17
     854:	0f 91       	pop	r16
     856:	ff 90       	pop	r15
     858:	ef 90       	pop	r14
     85a:	df 90       	pop	r13
     85c:	cf 90       	pop	r12
     85e:	bf 90       	pop	r11
     860:	af 90       	pop	r10
     862:	9f 90       	pop	r9
     864:	8f 90       	pop	r8
     866:	7f 90       	pop	r7
     868:	6f 90       	pop	r6
     86a:	5f 90       	pop	r5
     86c:	4f 90       	pop	r4
     86e:	3f 90       	pop	r3
     870:	2f 90       	pop	r2
     872:	08 95       	ret

00000874 <xEventGroupClearBits>:
     874:	0f 93       	push	r16
     876:	1f 93       	push	r17
     878:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     87c:	ff 93       	push	r31
     87e:	f8 7f       	andi	r31, 0xF8	; 248
     880:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     884:	fc 01       	movw	r30, r24
     886:	00 81       	ld	r16, Z
     888:	11 81       	ldd	r17, Z+1	; 0x01
     88a:	22 81       	ldd	r18, Z+2	; 0x02
     88c:	33 81       	ldd	r19, Z+3	; 0x03
     88e:	40 95       	com	r20
     890:	50 95       	com	r21
     892:	60 95       	com	r22
     894:	70 95       	com	r23
     896:	40 23       	and	r20, r16
     898:	51 23       	and	r21, r17
     89a:	62 23       	and	r22, r18
     89c:	73 23       	and	r23, r19
     89e:	40 83       	st	Z, r20
     8a0:	51 83       	std	Z+1, r21	; 0x01
     8a2:	62 83       	std	Z+2, r22	; 0x02
     8a4:	73 83       	std	Z+3, r23	; 0x03
     8a6:	ff 91       	pop	r31
     8a8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     8ac:	c9 01       	movw	r24, r18
     8ae:	b8 01       	movw	r22, r16
     8b0:	1f 91       	pop	r17
     8b2:	0f 91       	pop	r16
     8b4:	08 95       	ret

000008b6 <xEventGroupSetBits>:
     8b6:	4f 92       	push	r4
     8b8:	5f 92       	push	r5
     8ba:	6f 92       	push	r6
     8bc:	7f 92       	push	r7
     8be:	af 92       	push	r10
     8c0:	bf 92       	push	r11
     8c2:	cf 92       	push	r12
     8c4:	df 92       	push	r13
     8c6:	ef 92       	push	r14
     8c8:	ff 92       	push	r15
     8ca:	0f 93       	push	r16
     8cc:	1f 93       	push	r17
     8ce:	cf 93       	push	r28
     8d0:	df 93       	push	r29
     8d2:	ec 01       	movw	r28, r24
     8d4:	6a 01       	movw	r12, r20
     8d6:	7b 01       	movw	r14, r22
     8d8:	8c 01       	movw	r16, r24
     8da:	09 5f       	subi	r16, 0xF9	; 249
     8dc:	1f 4f       	sbci	r17, 0xFF	; 255
     8de:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vTaskSuspendAll>
     8e2:	eb 85       	ldd	r30, Y+11	; 0x0b
     8e4:	fc 85       	ldd	r31, Y+12	; 0x0c
     8e6:	88 81       	ld	r24, Y
     8e8:	99 81       	ldd	r25, Y+1	; 0x01
     8ea:	aa 81       	ldd	r26, Y+2	; 0x02
     8ec:	bb 81       	ldd	r27, Y+3	; 0x03
     8ee:	c8 2a       	or	r12, r24
     8f0:	d9 2a       	or	r13, r25
     8f2:	ea 2a       	or	r14, r26
     8f4:	fb 2a       	or	r15, r27
     8f6:	c8 82       	st	Y, r12
     8f8:	d9 82       	std	Y+1, r13	; 0x01
     8fa:	ea 82       	std	Y+2, r14	; 0x02
     8fc:	fb 82       	std	Y+3, r15	; 0x03
     8fe:	0e 17       	cp	r16, r30
     900:	1f 07       	cpc	r17, r31
     902:	09 f4       	brne	.+2      	; 0x906 <xEventGroupSetBits+0x50>
     904:	42 c0       	rjmp	.+132    	; 0x98a <xEventGroupSetBits+0xd4>
     906:	c1 2c       	mov	r12, r1
     908:	d1 2c       	mov	r13, r1
     90a:	76 01       	movw	r14, r12
     90c:	a4 80       	ldd	r10, Z+4	; 0x04
     90e:	b5 80       	ldd	r11, Z+5	; 0x05
     910:	80 81       	ld	r24, Z
     912:	91 81       	ldd	r25, Z+1	; 0x01
     914:	a2 81       	ldd	r26, Z+2	; 0x02
     916:	b3 81       	ldd	r27, Z+3	; 0x03
     918:	ac 01       	movw	r20, r24
     91a:	bd 01       	movw	r22, r26
     91c:	77 27       	eor	r23, r23
     91e:	b2 fd       	sbrc	r27, 2
     920:	0f c0       	rjmp	.+30     	; 0x940 <xEventGroupSetBits+0x8a>
     922:	48 80       	ld	r4, Y
     924:	59 80       	ldd	r5, Y+1	; 0x01
     926:	6a 80       	ldd	r6, Y+2	; 0x02
     928:	7b 80       	ldd	r7, Y+3	; 0x03
     92a:	44 22       	and	r4, r20
     92c:	55 22       	and	r5, r21
     92e:	66 22       	and	r6, r22
     930:	77 22       	and	r7, r23
     932:	21 e0       	ldi	r18, 0x01	; 1
     934:	45 28       	or	r4, r5
     936:	46 28       	or	r4, r6
     938:	47 28       	or	r4, r7
     93a:	89 f4       	brne	.+34     	; 0x95e <xEventGroupSetBits+0xa8>
     93c:	20 e0       	ldi	r18, 0x00	; 0
     93e:	0f c0       	rjmp	.+30     	; 0x95e <xEventGroupSetBits+0xa8>
     940:	48 80       	ld	r4, Y
     942:	59 80       	ldd	r5, Y+1	; 0x01
     944:	6a 80       	ldd	r6, Y+2	; 0x02
     946:	7b 80       	ldd	r7, Y+3	; 0x03
     948:	44 22       	and	r4, r20
     94a:	55 22       	and	r5, r21
     94c:	66 22       	and	r6, r22
     94e:	77 22       	and	r7, r23
     950:	21 e0       	ldi	r18, 0x01	; 1
     952:	44 16       	cp	r4, r20
     954:	55 06       	cpc	r5, r21
     956:	66 06       	cpc	r6, r22
     958:	77 06       	cpc	r7, r23
     95a:	09 f0       	breq	.+2      	; 0x95e <xEventGroupSetBits+0xa8>
     95c:	20 e0       	ldi	r18, 0x00	; 0
     95e:	22 23       	and	r18, r18
     960:	71 f0       	breq	.+28     	; 0x97e <xEventGroupSetBits+0xc8>
     962:	b0 ff       	sbrs	r27, 0
     964:	04 c0       	rjmp	.+8      	; 0x96e <xEventGroupSetBits+0xb8>
     966:	c4 2a       	or	r12, r20
     968:	d5 2a       	or	r13, r21
     96a:	e6 2a       	or	r14, r22
     96c:	f7 2a       	or	r15, r23
     96e:	48 81       	ld	r20, Y
     970:	59 81       	ldd	r21, Y+1	; 0x01
     972:	6a 81       	ldd	r22, Y+2	; 0x02
     974:	7b 81       	ldd	r23, Y+3	; 0x03
     976:	72 60       	ori	r23, 0x02	; 2
     978:	cf 01       	movw	r24, r30
     97a:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vTaskRemoveFromUnorderedEventList>
     97e:	ea 2d       	mov	r30, r10
     980:	fb 2d       	mov	r31, r11
     982:	0e 17       	cp	r16, r30
     984:	1f 07       	cpc	r17, r31
     986:	11 f6       	brne	.-124    	; 0x90c <xEventGroupSetBits+0x56>
     988:	03 c0       	rjmp	.+6      	; 0x990 <xEventGroupSetBits+0xda>
     98a:	c1 2c       	mov	r12, r1
     98c:	d1 2c       	mov	r13, r1
     98e:	76 01       	movw	r14, r12
     990:	c0 94       	com	r12
     992:	d0 94       	com	r13
     994:	e0 94       	com	r14
     996:	f0 94       	com	r15
     998:	88 81       	ld	r24, Y
     99a:	99 81       	ldd	r25, Y+1	; 0x01
     99c:	aa 81       	ldd	r26, Y+2	; 0x02
     99e:	bb 81       	ldd	r27, Y+3	; 0x03
     9a0:	c8 22       	and	r12, r24
     9a2:	d9 22       	and	r13, r25
     9a4:	ea 22       	and	r14, r26
     9a6:	fb 22       	and	r15, r27
     9a8:	c8 82       	st	Y, r12
     9aa:	d9 82       	std	Y+1, r13	; 0x01
     9ac:	ea 82       	std	Y+2, r14	; 0x02
     9ae:	fb 82       	std	Y+3, r15	; 0x03
     9b0:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
     9b4:	68 81       	ld	r22, Y
     9b6:	79 81       	ldd	r23, Y+1	; 0x01
     9b8:	8a 81       	ldd	r24, Y+2	; 0x02
     9ba:	9b 81       	ldd	r25, Y+3	; 0x03
     9bc:	df 91       	pop	r29
     9be:	cf 91       	pop	r28
     9c0:	1f 91       	pop	r17
     9c2:	0f 91       	pop	r16
     9c4:	ff 90       	pop	r15
     9c6:	ef 90       	pop	r14
     9c8:	df 90       	pop	r13
     9ca:	cf 90       	pop	r12
     9cc:	bf 90       	pop	r11
     9ce:	af 90       	pop	r10
     9d0:	7f 90       	pop	r7
     9d2:	6f 90       	pop	r6
     9d4:	5f 90       	pop	r5
     9d6:	4f 90       	pop	r4
     9d8:	08 95       	ret

000009da <vEventGroupSetBitsCallback>:
     9da:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <xEventGroupSetBits>
     9de:	08 95       	ret

000009e0 <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
     9e0:	0f 93       	push	r16
     9e2:	1f 93       	push	r17
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
     9e4:	89 01       	movw	r16, r18
     9e6:	9a 01       	movw	r18, r20
     9e8:	ab 01       	movw	r20, r22
     9ea:	bc 01       	movw	r22, r24
     9ec:	8d ee       	ldi	r24, 0xED	; 237
     9ee:	94 e0       	ldi	r25, 0x04	; 4
     9f0:	0e 94 bd 12 	call	0x257a	; 0x257a <xTimerPendFunctionCallFromISR>

		return xReturn;
	}
     9f4:	1f 91       	pop	r17
     9f6:	0f 91       	pop	r16
     9f8:	08 95       	ret

000009fa <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
     9fe:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     a00:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     a04:	20 91 14 22 	lds	r18, 0x2214	; 0x802214 <xNextFreeByte>
     a08:	30 91 15 22 	lds	r19, 0x2215	; 0x802215 <xNextFreeByte+0x1>
     a0c:	c9 01       	movw	r24, r18
     a0e:	8c 0f       	add	r24, r28
     a10:	9d 1f       	adc	r25, r29
     a12:	88 3b       	cpi	r24, 0xB8	; 184
     a14:	4b e0       	ldi	r20, 0x0B	; 11
     a16:	94 07       	cpc	r25, r20
     a18:	58 f4       	brcc	.+22     	; 0xa30 <pvPortMalloc+0x36>
     a1a:	28 17       	cp	r18, r24
     a1c:	39 07       	cpc	r19, r25
     a1e:	58 f4       	brcc	.+22     	; 0xa36 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     a20:	e9 01       	movw	r28, r18
     a22:	ca 5e       	subi	r28, 0xEA	; 234
     a24:	dd 4d       	sbci	r29, 0xDD	; 221
			xNextFreeByte += xWantedSize;			
     a26:	80 93 14 22 	sts	0x2214, r24	; 0x802214 <xNextFreeByte>
     a2a:	90 93 15 22 	sts	0x2215, r25	; 0x802215 <xNextFreeByte+0x1>
     a2e:	05 c0       	rjmp	.+10     	; 0xa3a <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     a30:	c0 e0       	ldi	r28, 0x00	; 0
     a32:	d0 e0       	ldi	r29, 0x00	; 0
     a34:	02 c0       	rjmp	.+4      	; 0xa3a <pvPortMalloc+0x40>
     a36:	c0 e0       	ldi	r28, 0x00	; 0
     a38:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     a3a:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     a3e:	ce 01       	movw	r24, r28
     a40:	df 91       	pop	r29
     a42:	cf 91       	pop	r28
     a44:	08 95       	ret

00000a46 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     a46:	08 95       	ret

00000a48 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     a48:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a4a:	03 96       	adiw	r24, 0x03	; 3
     a4c:	81 83       	std	Z+1, r24	; 0x01
     a4e:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     a50:	4f ef       	ldi	r20, 0xFF	; 255
     a52:	5f ef       	ldi	r21, 0xFF	; 255
     a54:	ba 01       	movw	r22, r20
     a56:	43 83       	std	Z+3, r20	; 0x03
     a58:	54 83       	std	Z+4, r21	; 0x04
     a5a:	65 83       	std	Z+5, r22	; 0x05
     a5c:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a5e:	87 83       	std	Z+7, r24	; 0x07
     a60:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a62:	81 87       	std	Z+9, r24	; 0x09
     a64:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     a66:	10 82       	st	Z, r1
     a68:	08 95       	ret

00000a6a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     a6a:	fc 01       	movw	r30, r24
     a6c:	12 86       	std	Z+10, r1	; 0x0a
     a6e:	13 86       	std	Z+11, r1	; 0x0b
     a70:	08 95       	ret

00000a72 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a72:	cf 93       	push	r28
     a74:	df 93       	push	r29
     a76:	9c 01       	movw	r18, r24
     a78:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     a7a:	dc 01       	movw	r26, r24
     a7c:	11 96       	adiw	r26, 0x01	; 1
     a7e:	cd 91       	ld	r28, X+
     a80:	dc 91       	ld	r29, X
     a82:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     a84:	c4 83       	std	Z+4, r28	; 0x04
     a86:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     a88:	8e 81       	ldd	r24, Y+6	; 0x06
     a8a:	9f 81       	ldd	r25, Y+7	; 0x07
     a8c:	86 83       	std	Z+6, r24	; 0x06
     a8e:	97 83       	std	Z+7, r25	; 0x07

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     a90:	8e 81       	ldd	r24, Y+6	; 0x06
     a92:	9f 81       	ldd	r25, Y+7	; 0x07
     a94:	dc 01       	movw	r26, r24
     a96:	14 96       	adiw	r26, 0x04	; 4
     a98:	6d 93       	st	X+, r22
     a9a:	7c 93       	st	X, r23
     a9c:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxPrevious = pxNewListItem;
     a9e:	6e 83       	std	Y+6, r22	; 0x06
     aa0:	7f 83       	std	Y+7, r23	; 0x07

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     aa2:	22 87       	std	Z+10, r18	; 0x0a
     aa4:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     aa6:	f9 01       	movw	r30, r18
     aa8:	80 81       	ld	r24, Z
     aaa:	8f 5f       	subi	r24, 0xFF	; 255
     aac:	80 83       	st	Z, r24
}
     aae:	df 91       	pop	r29
     ab0:	cf 91       	pop	r28
     ab2:	08 95       	ret

00000ab4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     ab4:	0f 93       	push	r16
     ab6:	1f 93       	push	r17
     ab8:	cf 93       	push	r28
     aba:	df 93       	push	r29
     abc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     abe:	08 81       	ld	r16, Y
     ac0:	19 81       	ldd	r17, Y+1	; 0x01
     ac2:	2a 81       	ldd	r18, Y+2	; 0x02
     ac4:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     ac6:	0f 3f       	cpi	r16, 0xFF	; 255
     ac8:	4f ef       	ldi	r20, 0xFF	; 255
     aca:	14 07       	cpc	r17, r20
     acc:	24 07       	cpc	r18, r20
     ace:	34 07       	cpc	r19, r20
     ad0:	21 f4       	brne	.+8      	; 0xada <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     ad2:	fc 01       	movw	r30, r24
     ad4:	a1 85       	ldd	r26, Z+9	; 0x09
     ad6:	b2 85       	ldd	r27, Z+10	; 0x0a
     ad8:	11 c0       	rjmp	.+34     	; 0xafc <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ada:	dc 01       	movw	r26, r24
     adc:	13 96       	adiw	r26, 0x03	; 3
     ade:	01 c0       	rjmp	.+2      	; 0xae2 <vListInsert+0x2e>
     ae0:	df 01       	movw	r26, r30
     ae2:	14 96       	adiw	r26, 0x04	; 4
     ae4:	ed 91       	ld	r30, X+
     ae6:	fc 91       	ld	r31, X
     ae8:	15 97       	sbiw	r26, 0x05	; 5
     aea:	40 81       	ld	r20, Z
     aec:	51 81       	ldd	r21, Z+1	; 0x01
     aee:	62 81       	ldd	r22, Z+2	; 0x02
     af0:	73 81       	ldd	r23, Z+3	; 0x03
     af2:	04 17       	cp	r16, r20
     af4:	15 07       	cpc	r17, r21
     af6:	26 07       	cpc	r18, r22
     af8:	37 07       	cpc	r19, r23
     afa:	90 f7       	brcc	.-28     	; 0xae0 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     afc:	14 96       	adiw	r26, 0x04	; 4
     afe:	ed 91       	ld	r30, X+
     b00:	fc 91       	ld	r31, X
     b02:	15 97       	sbiw	r26, 0x05	; 5
     b04:	ec 83       	std	Y+4, r30	; 0x04
     b06:	fd 83       	std	Y+5, r31	; 0x05
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     b08:	c6 83       	std	Z+6, r28	; 0x06
     b0a:	d7 83       	std	Z+7, r29	; 0x07
	pxNewListItem->pxPrevious = pxIterator;
     b0c:	ae 83       	std	Y+6, r26	; 0x06
     b0e:	bf 83       	std	Y+7, r27	; 0x07
	pxIterator->pxNext = pxNewListItem;
     b10:	14 96       	adiw	r26, 0x04	; 4
     b12:	cd 93       	st	X+, r28
     b14:	dc 93       	st	X, r29
     b16:	15 97       	sbiw	r26, 0x05	; 5

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b18:	8a 87       	std	Y+10, r24	; 0x0a
     b1a:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     b1c:	fc 01       	movw	r30, r24
     b1e:	20 81       	ld	r18, Z
     b20:	2f 5f       	subi	r18, 0xFF	; 255
     b22:	20 83       	st	Z, r18
}
     b24:	df 91       	pop	r29
     b26:	cf 91       	pop	r28
     b28:	1f 91       	pop	r17
     b2a:	0f 91       	pop	r16
     b2c:	08 95       	ret

00000b2e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     b2e:	cf 93       	push	r28
     b30:	df 93       	push	r29
     b32:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     b34:	a2 85       	ldd	r26, Z+10	; 0x0a
     b36:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     b38:	c4 81       	ldd	r28, Z+4	; 0x04
     b3a:	d5 81       	ldd	r29, Z+5	; 0x05
     b3c:	86 81       	ldd	r24, Z+6	; 0x06
     b3e:	97 81       	ldd	r25, Z+7	; 0x07
     b40:	8e 83       	std	Y+6, r24	; 0x06
     b42:	9f 83       	std	Y+7, r25	; 0x07
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     b44:	c6 81       	ldd	r28, Z+6	; 0x06
     b46:	d7 81       	ldd	r29, Z+7	; 0x07
     b48:	84 81       	ldd	r24, Z+4	; 0x04
     b4a:	95 81       	ldd	r25, Z+5	; 0x05
     b4c:	8c 83       	std	Y+4, r24	; 0x04
     b4e:	9d 83       	std	Y+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     b50:	11 96       	adiw	r26, 0x01	; 1
     b52:	8d 91       	ld	r24, X+
     b54:	9c 91       	ld	r25, X
     b56:	12 97       	sbiw	r26, 0x02	; 2
     b58:	e8 17       	cp	r30, r24
     b5a:	f9 07       	cpc	r31, r25
     b5c:	31 f4       	brne	.+12     	; 0xb6a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     b5e:	86 81       	ldd	r24, Z+6	; 0x06
     b60:	97 81       	ldd	r25, Z+7	; 0x07
     b62:	11 96       	adiw	r26, 0x01	; 1
     b64:	8d 93       	st	X+, r24
     b66:	9c 93       	st	X, r25
     b68:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     b6a:	12 86       	std	Z+10, r1	; 0x0a
     b6c:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     b6e:	8c 91       	ld	r24, X
     b70:	81 50       	subi	r24, 0x01	; 1
     b72:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     b74:	8c 91       	ld	r24, X
}
     b76:	df 91       	pop	r29
     b78:	cf 91       	pop	r28
     b7a:	08 95       	ret

00000b7c <_portSetInterruptMaskFromIsr>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     b7c:	e0 ea       	ldi	r30, 0xA0	; 160
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	82 81       	ldd	r24, Z+2	; 0x02
     b82:	92 81       	ldd	r25, Z+2	; 0x02
     b84:	98 7f       	andi	r25, 0xF8	; 248
     b86:	92 83       	std	Z+2, r25	; 0x02
     b88:	08 95       	ret

00000b8a <pxPortInitialiseStack>:
     b8a:	cf 92       	push	r12
     b8c:	df 92       	push	r13
     b8e:	ef 92       	push	r14
     b90:	ff 92       	push	r15
     b92:	31 e1       	ldi	r19, 0x11	; 17
     b94:	fc 01       	movw	r30, r24
     b96:	30 83       	st	Z, r19
     b98:	31 97       	sbiw	r30, 0x01	; 1
     b9a:	22 e2       	ldi	r18, 0x22	; 34
     b9c:	20 83       	st	Z, r18
     b9e:	31 97       	sbiw	r30, 0x01	; 1
     ba0:	a3 e3       	ldi	r26, 0x33	; 51
     ba2:	a0 83       	st	Z, r26
     ba4:	6b 01       	movw	r12, r22
     ba6:	e1 2c       	mov	r14, r1
     ba8:	f1 2c       	mov	r15, r1
     baa:	31 97       	sbiw	r30, 0x01	; 1
     bac:	60 83       	st	Z, r22
     bae:	31 97       	sbiw	r30, 0x01	; 1
     bb0:	d0 82       	st	Z, r13
     bb2:	31 97       	sbiw	r30, 0x01	; 1
     bb4:	e0 82       	st	Z, r14
     bb6:	31 97       	sbiw	r30, 0x01	; 1
     bb8:	61 e3       	ldi	r22, 0x31	; 49
     bba:	60 83       	st	Z, r22
     bbc:	31 97       	sbiw	r30, 0x01	; 1
     bbe:	60 e8       	ldi	r22, 0x80	; 128
     bc0:	60 83       	st	Z, r22
     bc2:	31 97       	sbiw	r30, 0x01	; 1
     bc4:	67 e8       	ldi	r22, 0x87	; 135
     bc6:	60 83       	st	Z, r22
     bc8:	31 97       	sbiw	r30, 0x01	; 1
     bca:	10 82       	st	Z, r1
     bcc:	31 97       	sbiw	r30, 0x01	; 1
     bce:	10 82       	st	Z, r1
     bd0:	31 97       	sbiw	r30, 0x01	; 1
     bd2:	62 e0       	ldi	r22, 0x02	; 2
     bd4:	60 83       	st	Z, r22
     bd6:	31 97       	sbiw	r30, 0x01	; 1
     bd8:	63 e0       	ldi	r22, 0x03	; 3
     bda:	60 83       	st	Z, r22
     bdc:	31 97       	sbiw	r30, 0x01	; 1
     bde:	64 e0       	ldi	r22, 0x04	; 4
     be0:	60 83       	st	Z, r22
     be2:	31 97       	sbiw	r30, 0x01	; 1
     be4:	65 e0       	ldi	r22, 0x05	; 5
     be6:	60 83       	st	Z, r22
     be8:	31 97       	sbiw	r30, 0x01	; 1
     bea:	66 e0       	ldi	r22, 0x06	; 6
     bec:	60 83       	st	Z, r22
     bee:	31 97       	sbiw	r30, 0x01	; 1
     bf0:	67 e0       	ldi	r22, 0x07	; 7
     bf2:	60 83       	st	Z, r22
     bf4:	31 97       	sbiw	r30, 0x01	; 1
     bf6:	68 e0       	ldi	r22, 0x08	; 8
     bf8:	60 83       	st	Z, r22
     bfa:	31 97       	sbiw	r30, 0x01	; 1
     bfc:	69 e0       	ldi	r22, 0x09	; 9
     bfe:	60 83       	st	Z, r22
     c00:	31 97       	sbiw	r30, 0x01	; 1
     c02:	60 e1       	ldi	r22, 0x10	; 16
     c04:	60 83       	st	Z, r22
     c06:	31 97       	sbiw	r30, 0x01	; 1
     c08:	30 83       	st	Z, r19
     c0a:	31 97       	sbiw	r30, 0x01	; 1
     c0c:	32 e1       	ldi	r19, 0x12	; 18
     c0e:	30 83       	st	Z, r19
     c10:	31 97       	sbiw	r30, 0x01	; 1
     c12:	33 e1       	ldi	r19, 0x13	; 19
     c14:	30 83       	st	Z, r19
     c16:	31 97       	sbiw	r30, 0x01	; 1
     c18:	34 e1       	ldi	r19, 0x14	; 20
     c1a:	30 83       	st	Z, r19
     c1c:	31 97       	sbiw	r30, 0x01	; 1
     c1e:	35 e1       	ldi	r19, 0x15	; 21
     c20:	30 83       	st	Z, r19
     c22:	31 97       	sbiw	r30, 0x01	; 1
     c24:	36 e1       	ldi	r19, 0x16	; 22
     c26:	30 83       	st	Z, r19
     c28:	31 97       	sbiw	r30, 0x01	; 1
     c2a:	37 e1       	ldi	r19, 0x17	; 23
     c2c:	30 83       	st	Z, r19
     c2e:	31 97       	sbiw	r30, 0x01	; 1
     c30:	38 e1       	ldi	r19, 0x18	; 24
     c32:	30 83       	st	Z, r19
     c34:	31 97       	sbiw	r30, 0x01	; 1
     c36:	39 e1       	ldi	r19, 0x19	; 25
     c38:	30 83       	st	Z, r19
     c3a:	31 97       	sbiw	r30, 0x01	; 1
     c3c:	30 e2       	ldi	r19, 0x20	; 32
     c3e:	30 83       	st	Z, r19
     c40:	31 97       	sbiw	r30, 0x01	; 1
     c42:	31 e2       	ldi	r19, 0x21	; 33
     c44:	30 83       	st	Z, r19
     c46:	31 97       	sbiw	r30, 0x01	; 1
     c48:	20 83       	st	Z, r18
     c4a:	31 97       	sbiw	r30, 0x01	; 1
     c4c:	23 e2       	ldi	r18, 0x23	; 35
     c4e:	20 83       	st	Z, r18
     c50:	6a 01       	movw	r12, r20
     c52:	31 97       	sbiw	r30, 0x01	; 1
     c54:	40 83       	st	Z, r20
     c56:	31 97       	sbiw	r30, 0x01	; 1
     c58:	d0 82       	st	Z, r13
     c5a:	31 97       	sbiw	r30, 0x01	; 1
     c5c:	26 e2       	ldi	r18, 0x26	; 38
     c5e:	20 83       	st	Z, r18
     c60:	31 97       	sbiw	r30, 0x01	; 1
     c62:	27 e2       	ldi	r18, 0x27	; 39
     c64:	20 83       	st	Z, r18
     c66:	31 97       	sbiw	r30, 0x01	; 1
     c68:	28 e2       	ldi	r18, 0x28	; 40
     c6a:	20 83       	st	Z, r18
     c6c:	31 97       	sbiw	r30, 0x01	; 1
     c6e:	29 e2       	ldi	r18, 0x29	; 41
     c70:	20 83       	st	Z, r18
     c72:	31 97       	sbiw	r30, 0x01	; 1
     c74:	20 e3       	ldi	r18, 0x30	; 48
     c76:	20 83       	st	Z, r18
     c78:	88 97       	sbiw	r24, 0x28	; 40
     c7a:	ff 90       	pop	r15
     c7c:	ef 90       	pop	r14
     c7e:	df 90       	pop	r13
     c80:	cf 90       	pop	r12
     c82:	08 95       	ret

00000c84 <xPortStartScheduler>:
     c84:	83 ef       	ldi	r24, 0xF3	; 243
     c86:	91 e0       	ldi	r25, 0x01	; 1
     c88:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     c8c:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
     c90:	65 e0       	ldi	r22, 0x05	; 5
     c92:	80 e0       	ldi	r24, 0x00	; 0
     c94:	98 e0       	ldi	r25, 0x08	; 8
     c96:	0e 94 44 03 	call	0x688	; 0x688 <TC0_ConfigClockSource>
     c9a:	61 e0       	ldi	r22, 0x01	; 1
     c9c:	80 e0       	ldi	r24, 0x00	; 0
     c9e:	98 e0       	ldi	r25, 0x08	; 8
     ca0:	0e 94 50 03 	call	0x6a0	; 0x6a0 <TC0_SetOverflowIntLevel>
     ca4:	a0 91 3c 2e 	lds	r26, 0x2E3C	; 0x802e3c <pxCurrentTCB>
     ca8:	b0 91 3d 2e 	lds	r27, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
     cac:	0d 90       	ld	r0, X+
     cae:	0d be       	out	0x3d, r0	; 61
     cb0:	0d 90       	ld	r0, X+
     cb2:	0e be       	out	0x3e, r0	; 62
     cb4:	ef 91       	pop	r30
     cb6:	df 91       	pop	r29
     cb8:	cf 91       	pop	r28
     cba:	bf 91       	pop	r27
     cbc:	af 91       	pop	r26
     cbe:	9f 91       	pop	r25
     cc0:	8f 91       	pop	r24
     cc2:	7f 91       	pop	r23
     cc4:	6f 91       	pop	r22
     cc6:	5f 91       	pop	r21
     cc8:	4f 91       	pop	r20
     cca:	3f 91       	pop	r19
     ccc:	2f 91       	pop	r18
     cce:	1f 91       	pop	r17
     cd0:	0f 91       	pop	r16
     cd2:	ff 90       	pop	r15
     cd4:	ef 90       	pop	r14
     cd6:	df 90       	pop	r13
     cd8:	cf 90       	pop	r12
     cda:	bf 90       	pop	r11
     cdc:	af 90       	pop	r10
     cde:	9f 90       	pop	r9
     ce0:	8f 90       	pop	r8
     ce2:	7f 90       	pop	r7
     ce4:	6f 90       	pop	r6
     ce6:	5f 90       	pop	r5
     ce8:	4f 90       	pop	r4
     cea:	3f 90       	pop	r3
     cec:	2f 90       	pop	r2
     cee:	1f 90       	pop	r1
     cf0:	0f 90       	pop	r0
     cf2:	ff 91       	pop	r31
     cf4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     cf8:	ff 91       	pop	r31
     cfa:	ff bf       	out	0x3f, r31	; 63
     cfc:	ff 91       	pop	r31
     cfe:	08 95       	ret
     d00:	81 e0       	ldi	r24, 0x01	; 1
     d02:	08 95       	ret

00000d04 <vPortYield>:
// 
//
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     d04:	ff 93       	push	r31
     d06:	ff b7       	in	r31, 0x3f	; 63
     d08:	ff 93       	push	r31
     d0a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d0e:	ff 93       	push	r31
     d10:	f8 7f       	andi	r31, 0xF8	; 248
     d12:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d16:	0f 92       	push	r0
     d18:	1f 92       	push	r1
     d1a:	11 24       	eor	r1, r1
     d1c:	2f 92       	push	r2
     d1e:	3f 92       	push	r3
     d20:	4f 92       	push	r4
     d22:	5f 92       	push	r5
     d24:	6f 92       	push	r6
     d26:	7f 92       	push	r7
     d28:	8f 92       	push	r8
     d2a:	9f 92       	push	r9
     d2c:	af 92       	push	r10
     d2e:	bf 92       	push	r11
     d30:	cf 92       	push	r12
     d32:	df 92       	push	r13
     d34:	ef 92       	push	r14
     d36:	ff 92       	push	r15
     d38:	0f 93       	push	r16
     d3a:	1f 93       	push	r17
     d3c:	2f 93       	push	r18
     d3e:	3f 93       	push	r19
     d40:	4f 93       	push	r20
     d42:	5f 93       	push	r21
     d44:	6f 93       	push	r22
     d46:	7f 93       	push	r23
     d48:	8f 93       	push	r24
     d4a:	9f 93       	push	r25
     d4c:	af 93       	push	r26
     d4e:	bf 93       	push	r27
     d50:	cf 93       	push	r28
     d52:	df 93       	push	r29
     d54:	ef 93       	push	r30
     d56:	a0 91 3c 2e 	lds	r26, 0x2E3C	; 0x802e3c <pxCurrentTCB>
     d5a:	b0 91 3d 2e 	lds	r27, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
     d5e:	0d b6       	in	r0, 0x3d	; 61
     d60:	0d 92       	st	X+, r0
     d62:	0e b6       	in	r0, 0x3e	; 62
     d64:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     d66:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     d6a:	a0 91 3c 2e 	lds	r26, 0x2E3C	; 0x802e3c <pxCurrentTCB>
     d6e:	b0 91 3d 2e 	lds	r27, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
     d72:	0d 90       	ld	r0, X+
     d74:	0d be       	out	0x3d, r0	; 61
     d76:	0d 90       	ld	r0, X+
     d78:	0e be       	out	0x3e, r0	; 62
     d7a:	ef 91       	pop	r30
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	bf 91       	pop	r27
     d82:	af 91       	pop	r26
     d84:	9f 91       	pop	r25
     d86:	8f 91       	pop	r24
     d88:	7f 91       	pop	r23
     d8a:	6f 91       	pop	r22
     d8c:	5f 91       	pop	r21
     d8e:	4f 91       	pop	r20
     d90:	3f 91       	pop	r19
     d92:	2f 91       	pop	r18
     d94:	1f 91       	pop	r17
     d96:	0f 91       	pop	r16
     d98:	ff 90       	pop	r15
     d9a:	ef 90       	pop	r14
     d9c:	df 90       	pop	r13
     d9e:	cf 90       	pop	r12
     da0:	bf 90       	pop	r11
     da2:	af 90       	pop	r10
     da4:	9f 90       	pop	r9
     da6:	8f 90       	pop	r8
     da8:	7f 90       	pop	r7
     daa:	6f 90       	pop	r6
     dac:	5f 90       	pop	r5
     dae:	4f 90       	pop	r4
     db0:	3f 90       	pop	r3
     db2:	2f 90       	pop	r2
     db4:	1f 90       	pop	r1
     db6:	0f 90       	pop	r0
     db8:	ff 91       	pop	r31
     dba:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     dbe:	ff 91       	pop	r31
     dc0:	ff bf       	out	0x3f, r31	; 63
     dc2:	ff 91       	pop	r31
	asm volatile ( "ret" );
     dc4:	08 95       	ret

00000dc6 <portTaskSwitchContext>:
	//-----------------------------------------------------------
	//
	// The task switch is deferred until there is no more nesting.
	//
	void portTaskSwitchContext(signed portBASE_TYPE xSwitchRequired)
	{
     dc6:	cf 93       	push	r28
		intTaskSwitchPending |= xSwitchRequired;					
     dc8:	90 91 20 31 	lds	r25, 0x3120	; 0x803120 <intTaskSwitchPending>
     dcc:	89 2b       	or	r24, r25
     dce:	80 93 20 31 	sts	0x3120, r24	; 0x803120 <intTaskSwitchPending>
																
		if(NOT_NESTING() && intTaskSwitchPending)					
     dd2:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     dd6:	91 30       	cpi	r25, 0x01	; 1
     dd8:	41 f0       	breq	.+16     	; 0xdea <portTaskSwitchContext+0x24>
     dda:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     dde:	92 30       	cpi	r25, 0x02	; 2
     de0:	21 f0       	breq	.+8      	; 0xdea <portTaskSwitchContext+0x24>
     de2:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     de6:	94 30       	cpi	r25, 0x04	; 4
     de8:	59 f4       	brne	.+22     	; 0xe00 <portTaskSwitchContext+0x3a>
     dea:	88 23       	and	r24, r24
     dec:	49 f0       	breq	.+18     	; 0xe00 <portTaskSwitchContext+0x3a>
		{															
			register unsigned portBASE_TYPE uxSavedPmicCtrlReg; 				
			extern void vTaskSwitchContext(void);   				
																
			// Critical section used, because vTaskSwitchContext handles FreeRTOS internal data structures.
 			uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR(); 
     dee:	0e 94 be 05 	call	0xb7c	; 0xb7c <_portSetInterruptMaskFromIsr>
     df2:	c8 2f       	mov	r28, r24
			intTaskSwitchPending = 0;								
     df4:	10 92 20 31 	sts	0x3120, r1	; 0x803120 <intTaskSwitchPending>
			vTaskSwitchContext();                   				
     df8:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vTaskSwitchContext>
			portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedPmicCtrlReg);
     dfc:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		}                                          					
	}
     e00:	cf 91       	pop	r28
     e02:	08 95       	ret

00000e04 <__vector_14>:
	// the context is saved at the start of vPortYieldFromTick().  The tick
	// count is incremented after the context is saved.
	//
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
     e04:	ff 93       	push	r31
     e06:	ff b7       	in	r31, 0x3f	; 63
     e08:	ff 93       	push	r31
     e0a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e0e:	ff 93       	push	r31
     e10:	f8 7f       	andi	r31, 0xF8	; 248
     e12:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e16:	0f 92       	push	r0
     e18:	1f 92       	push	r1
     e1a:	11 24       	eor	r1, r1
     e1c:	2f 92       	push	r2
     e1e:	3f 92       	push	r3
     e20:	4f 92       	push	r4
     e22:	5f 92       	push	r5
     e24:	6f 92       	push	r6
     e26:	7f 92       	push	r7
     e28:	8f 92       	push	r8
     e2a:	9f 92       	push	r9
     e2c:	af 92       	push	r10
     e2e:	bf 92       	push	r11
     e30:	cf 92       	push	r12
     e32:	df 92       	push	r13
     e34:	ef 92       	push	r14
     e36:	ff 92       	push	r15
     e38:	0f 93       	push	r16
     e3a:	1f 93       	push	r17
     e3c:	2f 93       	push	r18
     e3e:	3f 93       	push	r19
     e40:	4f 93       	push	r20
     e42:	5f 93       	push	r21
     e44:	6f 93       	push	r22
     e46:	7f 93       	push	r23
     e48:	8f 93       	push	r24
     e4a:	9f 93       	push	r25
     e4c:	af 93       	push	r26
     e4e:	bf 93       	push	r27
     e50:	cf 93       	push	r28
     e52:	df 93       	push	r29
     e54:	ef 93       	push	r30
     e56:	a0 91 3c 2e 	lds	r26, 0x2E3C	; 0x802e3c <pxCurrentTCB>
     e5a:	b0 91 3d 2e 	lds	r27, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
     e5e:	0d b6       	in	r0, 0x3d	; 61
     e60:	0d 92       	st	X+, r0
     e62:	0e b6       	in	r0, 0x3e	; 62
     e64:	0d 92       	st	X+, r0
	//
	static void portTaskIncrementTick( void )
	{
		register unsigned portBASE_TYPE uxSavedPmicCtrlReg;

 		uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR();
     e66:	0e 94 be 05 	call	0xb7c	; 0xb7c <_portSetInterruptMaskFromIsr>
     e6a:	c8 2f       	mov	r28, r24
		xTaskIncrementTick();
     e6c:	0e 94 89 0c 	call	0x1912	; 0x1912 <xTaskIncrementTick>
 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedPmicCtrlReg );
     e70:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
		portTaskIncrementTick();
		//always try a task switch, but only if on kernel interrupt level
		portEND_SWITCHING_ISR(pdTRUE); 
     e74:	81 e0       	ldi	r24, 0x01	; 1
     e76:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <portTaskSwitchContext>
     e7a:	a0 91 3c 2e 	lds	r26, 0x2E3C	; 0x802e3c <pxCurrentTCB>
     e7e:	b0 91 3d 2e 	lds	r27, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
     e82:	0d 90       	ld	r0, X+
     e84:	0d be       	out	0x3d, r0	; 61
     e86:	0d 90       	ld	r0, X+
     e88:	0e be       	out	0x3e, r0	; 62
     e8a:	ef 91       	pop	r30
     e8c:	df 91       	pop	r29
     e8e:	cf 91       	pop	r28
     e90:	bf 91       	pop	r27
     e92:	af 91       	pop	r26
     e94:	9f 91       	pop	r25
     e96:	8f 91       	pop	r24
     e98:	7f 91       	pop	r23
     e9a:	6f 91       	pop	r22
     e9c:	5f 91       	pop	r21
     e9e:	4f 91       	pop	r20
     ea0:	3f 91       	pop	r19
     ea2:	2f 91       	pop	r18
     ea4:	1f 91       	pop	r17
     ea6:	0f 91       	pop	r16
     ea8:	ff 90       	pop	r15
     eaa:	ef 90       	pop	r14
     eac:	df 90       	pop	r13
     eae:	cf 90       	pop	r12
     eb0:	bf 90       	pop	r11
     eb2:	af 90       	pop	r10
     eb4:	9f 90       	pop	r9
     eb6:	8f 90       	pop	r8
     eb8:	7f 90       	pop	r7
     eba:	6f 90       	pop	r6
     ebc:	5f 90       	pop	r5
     ebe:	4f 90       	pop	r4
     ec0:	3f 90       	pop	r3
     ec2:	2f 90       	pop	r2
     ec4:	1f 90       	pop	r1
     ec6:	0f 90       	pop	r0
     ec8:	ff 91       	pop	r31
     eca:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ece:	ff 91       	pop	r31
     ed0:	ff bf       	out	0x3f, r31	; 63
     ed2:	ff 91       	pop	r31
     ed4:	18 95       	reti

00000ed6 <prvIsQueueEmpty>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
     ed6:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     eda:	ff 93       	push	r31
     edc:	f8 7f       	andi	r31, 0xF8	; 248
     ede:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ee2:	fc 01       	movw	r30, r24
     ee4:	96 8d       	ldd	r25, Z+30	; 0x1e
     ee6:	ff 91       	pop	r31
     ee8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     eec:	81 e0       	ldi	r24, 0x01	; 1
     eee:	91 11       	cpse	r25, r1
     ef0:	80 e0       	ldi	r24, 0x00	; 0
     ef2:	08 95       	ret

00000ef4 <prvIsQueueFull>:
     ef4:	dc 01       	movw	r26, r24
     ef6:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     efa:	ff 93       	push	r31
     efc:	f8 7f       	andi	r31, 0xF8	; 248
     efe:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f02:	5e 96       	adiw	r26, 0x1e	; 30
     f04:	9c 91       	ld	r25, X
     f06:	5e 97       	sbiw	r26, 0x1e	; 30
     f08:	ff 91       	pop	r31
     f0a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f0e:	81 e0       	ldi	r24, 0x01	; 1
     f10:	5f 96       	adiw	r26, 0x1f	; 31
     f12:	2c 91       	ld	r18, X
     f14:	29 13       	cpse	r18, r25
     f16:	80 e0       	ldi	r24, 0x00	; 0
     f18:	08 95       	ret

00000f1a <prvCopyDataToQueue>:
     f1a:	0f 93       	push	r16
     f1c:	1f 93       	push	r17
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	ec 01       	movw	r28, r24
     f24:	04 2f       	mov	r16, r20
     f26:	1e 8d       	ldd	r17, Y+30	; 0x1e
     f28:	48 a1       	ldd	r20, Y+32	; 0x20
     f2a:	44 23       	and	r20, r20
     f2c:	b9 f1       	breq	.+110    	; 0xf9c <prvCopyDataToQueue+0x82>
     f2e:	01 11       	cpse	r16, r1
     f30:	16 c0       	rjmp	.+44     	; 0xf5e <prvCopyDataToQueue+0x44>
     f32:	50 e0       	ldi	r21, 0x00	; 0
     f34:	8c 81       	ldd	r24, Y+4	; 0x04
     f36:	9d 81       	ldd	r25, Y+5	; 0x05
     f38:	0e 94 cb 1f 	call	0x3f96	; 0x3f96 <memcpy>
     f3c:	28 a1       	ldd	r18, Y+32	; 0x20
     f3e:	8c 81       	ldd	r24, Y+4	; 0x04
     f40:	9d 81       	ldd	r25, Y+5	; 0x05
     f42:	82 0f       	add	r24, r18
     f44:	91 1d       	adc	r25, r1
     f46:	8c 83       	std	Y+4, r24	; 0x04
     f48:	9d 83       	std	Y+5, r25	; 0x05
     f4a:	2a 81       	ldd	r18, Y+2	; 0x02
     f4c:	3b 81       	ldd	r19, Y+3	; 0x03
     f4e:	82 17       	cp	r24, r18
     f50:	93 07       	cpc	r25, r19
     f52:	20 f1       	brcs	.+72     	; 0xf9c <prvCopyDataToQueue+0x82>
     f54:	88 81       	ld	r24, Y
     f56:	99 81       	ldd	r25, Y+1	; 0x01
     f58:	8c 83       	std	Y+4, r24	; 0x04
     f5a:	9d 83       	std	Y+5, r25	; 0x05
     f5c:	1f c0       	rjmp	.+62     	; 0xf9c <prvCopyDataToQueue+0x82>
     f5e:	50 e0       	ldi	r21, 0x00	; 0
     f60:	8e 81       	ldd	r24, Y+6	; 0x06
     f62:	9f 81       	ldd	r25, Y+7	; 0x07
     f64:	0e 94 cb 1f 	call	0x3f96	; 0x3f96 <memcpy>
     f68:	88 a1       	ldd	r24, Y+32	; 0x20
     f6a:	90 e0       	ldi	r25, 0x00	; 0
     f6c:	91 95       	neg	r25
     f6e:	81 95       	neg	r24
     f70:	91 09       	sbc	r25, r1
     f72:	2e 81       	ldd	r18, Y+6	; 0x06
     f74:	3f 81       	ldd	r19, Y+7	; 0x07
     f76:	28 0f       	add	r18, r24
     f78:	39 1f       	adc	r19, r25
     f7a:	2e 83       	std	Y+6, r18	; 0x06
     f7c:	3f 83       	std	Y+7, r19	; 0x07
     f7e:	48 81       	ld	r20, Y
     f80:	59 81       	ldd	r21, Y+1	; 0x01
     f82:	24 17       	cp	r18, r20
     f84:	35 07       	cpc	r19, r21
     f86:	30 f4       	brcc	.+12     	; 0xf94 <prvCopyDataToQueue+0x7a>
     f88:	2a 81       	ldd	r18, Y+2	; 0x02
     f8a:	3b 81       	ldd	r19, Y+3	; 0x03
     f8c:	82 0f       	add	r24, r18
     f8e:	93 1f       	adc	r25, r19
     f90:	8e 83       	std	Y+6, r24	; 0x06
     f92:	9f 83       	std	Y+7, r25	; 0x07
     f94:	02 30       	cpi	r16, 0x02	; 2
     f96:	11 f4       	brne	.+4      	; 0xf9c <prvCopyDataToQueue+0x82>
     f98:	11 11       	cpse	r17, r1
     f9a:	11 50       	subi	r17, 0x01	; 1
     f9c:	1f 5f       	subi	r17, 0xFF	; 255
     f9e:	1e 8f       	std	Y+30, r17	; 0x1e
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	df 91       	pop	r29
     fa4:	cf 91       	pop	r28
     fa6:	1f 91       	pop	r17
     fa8:	0f 91       	pop	r16
     faa:	08 95       	ret

00000fac <prvCopyDataFromQueue>:
     fac:	fc 01       	movw	r30, r24
     fae:	40 a1       	ldd	r20, Z+32	; 0x20
     fb0:	44 23       	and	r20, r20
     fb2:	a9 f0       	breq	.+42     	; 0xfde <prvCopyDataFromQueue+0x32>
     fb4:	50 e0       	ldi	r21, 0x00	; 0
     fb6:	26 81       	ldd	r18, Z+6	; 0x06
     fb8:	37 81       	ldd	r19, Z+7	; 0x07
     fba:	24 0f       	add	r18, r20
     fbc:	35 1f       	adc	r19, r21
     fbe:	26 83       	std	Z+6, r18	; 0x06
     fc0:	37 83       	std	Z+7, r19	; 0x07
     fc2:	82 81       	ldd	r24, Z+2	; 0x02
     fc4:	93 81       	ldd	r25, Z+3	; 0x03
     fc6:	28 17       	cp	r18, r24
     fc8:	39 07       	cpc	r19, r25
     fca:	20 f0       	brcs	.+8      	; 0xfd4 <prvCopyDataFromQueue+0x28>
     fcc:	80 81       	ld	r24, Z
     fce:	91 81       	ldd	r25, Z+1	; 0x01
     fd0:	86 83       	std	Z+6, r24	; 0x06
     fd2:	97 83       	std	Z+7, r25	; 0x07
     fd4:	cb 01       	movw	r24, r22
     fd6:	66 81       	ldd	r22, Z+6	; 0x06
     fd8:	77 81       	ldd	r23, Z+7	; 0x07
     fda:	0e 94 cb 1f 	call	0x3f96	; 0x3f96 <memcpy>
     fde:	08 95       	ret

00000fe0 <prvUnlockQueue>:
     fe0:	ef 92       	push	r14
     fe2:	ff 92       	push	r15
     fe4:	0f 93       	push	r16
     fe6:	1f 93       	push	r17
     fe8:	cf 93       	push	r28
     fea:	8c 01       	movw	r16, r24
     fec:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ff0:	ff 93       	push	r31
     ff2:	f8 7f       	andi	r31, 0xF8	; 248
     ff4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ff8:	fc 01       	movw	r30, r24
     ffa:	c2 a1       	ldd	r28, Z+34	; 0x22
     ffc:	1c 16       	cp	r1, r28
     ffe:	ac f4       	brge	.+42     	; 0x102a <prvUnlockQueue+0x4a>
    1000:	83 89       	ldd	r24, Z+19	; 0x13
    1002:	81 11       	cpse	r24, r1
    1004:	06 c0       	rjmp	.+12     	; 0x1012 <prvUnlockQueue+0x32>
    1006:	11 c0       	rjmp	.+34     	; 0x102a <prvUnlockQueue+0x4a>
    1008:	f8 01       	movw	r30, r16
    100a:	83 89       	ldd	r24, Z+19	; 0x13
    100c:	81 11       	cpse	r24, r1
    100e:	05 c0       	rjmp	.+10     	; 0x101a <prvUnlockQueue+0x3a>
    1010:	0c c0       	rjmp	.+24     	; 0x102a <prvUnlockQueue+0x4a>
    1012:	78 01       	movw	r14, r16
    1014:	f3 e1       	ldi	r31, 0x13	; 19
    1016:	ef 0e       	add	r14, r31
    1018:	f1 1c       	adc	r15, r1
    101a:	c7 01       	movw	r24, r14
    101c:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <xTaskRemoveFromEventList>
    1020:	81 11       	cpse	r24, r1
    1022:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <vTaskMissedYield>
    1026:	c1 50       	subi	r28, 0x01	; 1
    1028:	79 f7       	brne	.-34     	; 0x1008 <prvUnlockQueue+0x28>
    102a:	8f ef       	ldi	r24, 0xFF	; 255
    102c:	f8 01       	movw	r30, r16
    102e:	82 a3       	std	Z+34, r24	; 0x22
    1030:	ff 91       	pop	r31
    1032:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1036:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    103a:	ff 93       	push	r31
    103c:	f8 7f       	andi	r31, 0xF8	; 248
    103e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1042:	f8 01       	movw	r30, r16
    1044:	c1 a1       	ldd	r28, Z+33	; 0x21
    1046:	1c 16       	cp	r1, r28
    1048:	ac f4       	brge	.+42     	; 0x1074 <prvUnlockQueue+0x94>
    104a:	80 85       	ldd	r24, Z+8	; 0x08
    104c:	81 11       	cpse	r24, r1
    104e:	06 c0       	rjmp	.+12     	; 0x105c <prvUnlockQueue+0x7c>
    1050:	11 c0       	rjmp	.+34     	; 0x1074 <prvUnlockQueue+0x94>
    1052:	f8 01       	movw	r30, r16
    1054:	80 85       	ldd	r24, Z+8	; 0x08
    1056:	81 11       	cpse	r24, r1
    1058:	05 c0       	rjmp	.+10     	; 0x1064 <prvUnlockQueue+0x84>
    105a:	0c c0       	rjmp	.+24     	; 0x1074 <prvUnlockQueue+0x94>
    105c:	78 01       	movw	r14, r16
    105e:	f8 e0       	ldi	r31, 0x08	; 8
    1060:	ef 0e       	add	r14, r31
    1062:	f1 1c       	adc	r15, r1
    1064:	c7 01       	movw	r24, r14
    1066:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <xTaskRemoveFromEventList>
    106a:	81 11       	cpse	r24, r1
    106c:	0e 94 cb 0f 	call	0x1f96	; 0x1f96 <vTaskMissedYield>
    1070:	c1 50       	subi	r28, 0x01	; 1
    1072:	79 f7       	brne	.-34     	; 0x1052 <prvUnlockQueue+0x72>
    1074:	8f ef       	ldi	r24, 0xFF	; 255
    1076:	f8 01       	movw	r30, r16
    1078:	81 a3       	std	Z+33, r24	; 0x21
    107a:	ff 91       	pop	r31
    107c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1080:	cf 91       	pop	r28
    1082:	1f 91       	pop	r17
    1084:	0f 91       	pop	r16
    1086:	ff 90       	pop	r15
    1088:	ef 90       	pop	r14
    108a:	08 95       	ret

0000108c <xQueueGenericReset>:
    108c:	cf 93       	push	r28
    108e:	df 93       	push	r29
    1090:	ec 01       	movw	r28, r24
    1092:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1096:	ff 93       	push	r31
    1098:	f8 7f       	andi	r31, 0xF8	; 248
    109a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    109e:	48 81       	ld	r20, Y
    10a0:	59 81       	ldd	r21, Y+1	; 0x01
    10a2:	28 a1       	ldd	r18, Y+32	; 0x20
    10a4:	30 e0       	ldi	r19, 0x00	; 0
    10a6:	7f 8d       	ldd	r23, Y+31	; 0x1f
    10a8:	72 9f       	mul	r23, r18
    10aa:	c0 01       	movw	r24, r0
    10ac:	73 9f       	mul	r23, r19
    10ae:	90 0d       	add	r25, r0
    10b0:	11 24       	eor	r1, r1
    10b2:	fa 01       	movw	r30, r20
    10b4:	e8 0f       	add	r30, r24
    10b6:	f9 1f       	adc	r31, r25
    10b8:	ea 83       	std	Y+2, r30	; 0x02
    10ba:	fb 83       	std	Y+3, r31	; 0x03
    10bc:	1e 8e       	std	Y+30, r1	; 0x1e
    10be:	4c 83       	std	Y+4, r20	; 0x04
    10c0:	5d 83       	std	Y+5, r21	; 0x05
    10c2:	82 1b       	sub	r24, r18
    10c4:	93 0b       	sbc	r25, r19
    10c6:	84 0f       	add	r24, r20
    10c8:	95 1f       	adc	r25, r21
    10ca:	8e 83       	std	Y+6, r24	; 0x06
    10cc:	9f 83       	std	Y+7, r25	; 0x07
    10ce:	8f ef       	ldi	r24, 0xFF	; 255
    10d0:	89 a3       	std	Y+33, r24	; 0x21
    10d2:	8a a3       	std	Y+34, r24	; 0x22
    10d4:	61 11       	cpse	r22, r1
    10d6:	0c c0       	rjmp	.+24     	; 0x10f0 <xQueueGenericReset+0x64>
    10d8:	88 85       	ldd	r24, Y+8	; 0x08
    10da:	88 23       	and	r24, r24
    10dc:	89 f0       	breq	.+34     	; 0x1100 <xQueueGenericReset+0x74>
    10de:	ce 01       	movw	r24, r28
    10e0:	08 96       	adiw	r24, 0x08	; 8
    10e2:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <xTaskRemoveFromEventList>
    10e6:	88 23       	and	r24, r24
    10e8:	59 f0       	breq	.+22     	; 0x1100 <xQueueGenericReset+0x74>
    10ea:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    10ee:	08 c0       	rjmp	.+16     	; 0x1100 <xQueueGenericReset+0x74>
    10f0:	ce 01       	movw	r24, r28
    10f2:	08 96       	adiw	r24, 0x08	; 8
    10f4:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    10f8:	ce 01       	movw	r24, r28
    10fa:	43 96       	adiw	r24, 0x13	; 19
    10fc:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    1100:	ff 91       	pop	r31
    1102:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	df 91       	pop	r29
    110a:	cf 91       	pop	r28
    110c:	08 95       	ret

0000110e <xQueueGenericCreate>:
    110e:	ff 92       	push	r15
    1110:	0f 93       	push	r16
    1112:	1f 93       	push	r17
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	08 2f       	mov	r16, r24
    111a:	16 2f       	mov	r17, r22
    111c:	f4 2e       	mov	r15, r20
    111e:	66 23       	and	r22, r22
    1120:	c9 f0       	breq	.+50     	; 0x1154 <xQueueGenericCreate+0x46>
    1122:	86 9f       	mul	r24, r22
    1124:	c0 01       	movw	r24, r0
    1126:	11 24       	eor	r1, r1
    1128:	85 96       	adiw	r24, 0x25	; 37
    112a:	0e 94 fd 04 	call	0x9fa	; 0x9fa <pvPortMalloc>
    112e:	ec 01       	movw	r28, r24
    1130:	00 97       	sbiw	r24, 0x00	; 0
    1132:	49 f4       	brne	.+18     	; 0x1146 <xQueueGenericCreate+0x38>
    1134:	16 c0       	rjmp	.+44     	; 0x1162 <xQueueGenericCreate+0x54>
    1136:	0f 8f       	std	Y+31, r16	; 0x1f
    1138:	18 a3       	std	Y+32, r17	; 0x20
    113a:	61 e0       	ldi	r22, 0x01	; 1
    113c:	ce 01       	movw	r24, r28
    113e:	0e 94 46 08 	call	0x108c	; 0x108c <xQueueGenericReset>
    1142:	fc a2       	std	Y+36, r15	; 0x24
    1144:	0e c0       	rjmp	.+28     	; 0x1162 <xQueueGenericCreate+0x54>
    1146:	85 96       	adiw	r24, 0x25	; 37
    1148:	88 83       	st	Y, r24
    114a:	99 83       	std	Y+1, r25	; 0x01
    114c:	f4 cf       	rjmp	.-24     	; 0x1136 <xQueueGenericCreate+0x28>
    114e:	c8 83       	st	Y, r28
    1150:	d9 83       	std	Y+1, r29	; 0x01
    1152:	f1 cf       	rjmp	.-30     	; 0x1136 <xQueueGenericCreate+0x28>
    1154:	85 e2       	ldi	r24, 0x25	; 37
    1156:	90 e0       	ldi	r25, 0x00	; 0
    1158:	0e 94 fd 04 	call	0x9fa	; 0x9fa <pvPortMalloc>
    115c:	ec 01       	movw	r28, r24
    115e:	89 2b       	or	r24, r25
    1160:	b1 f7       	brne	.-20     	; 0x114e <xQueueGenericCreate+0x40>
    1162:	ce 01       	movw	r24, r28
    1164:	df 91       	pop	r29
    1166:	cf 91       	pop	r28
    1168:	1f 91       	pop	r17
    116a:	0f 91       	pop	r16
    116c:	ff 90       	pop	r15
    116e:	08 95       	ret

00001170 <xQueueGenericSend>:
    1170:	af 92       	push	r10
    1172:	bf 92       	push	r11
    1174:	cf 92       	push	r12
    1176:	df 92       	push	r13
    1178:	ef 92       	push	r14
    117a:	ff 92       	push	r15
    117c:	0f 93       	push	r16
    117e:	1f 93       	push	r17
    1180:	cf 93       	push	r28
    1182:	df 93       	push	r29
    1184:	cd b7       	in	r28, 0x3d	; 61
    1186:	de b7       	in	r29, 0x3e	; 62
    1188:	29 97       	sbiw	r28, 0x09	; 9
    118a:	cd bf       	out	0x3d, r28	; 61
    118c:	de bf       	out	0x3e, r29	; 62
    118e:	7c 01       	movw	r14, r24
    1190:	5b 01       	movw	r10, r22
    1192:	2e 83       	std	Y+6, r18	; 0x06
    1194:	3f 83       	std	Y+7, r19	; 0x07
    1196:	48 87       	std	Y+8, r20	; 0x08
    1198:	59 87       	std	Y+9, r21	; 0x09
    119a:	10 e0       	ldi	r17, 0x00	; 0
    119c:	6c 01       	movw	r12, r24
    119e:	88 e0       	ldi	r24, 0x08	; 8
    11a0:	c8 0e       	add	r12, r24
    11a2:	d1 1c       	adc	r13, r1
    11a4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11a8:	ff 93       	push	r31
    11aa:	f8 7f       	andi	r31, 0xF8	; 248
    11ac:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11b0:	f7 01       	movw	r30, r14
    11b2:	96 8d       	ldd	r25, Z+30	; 0x1e
    11b4:	87 8d       	ldd	r24, Z+31	; 0x1f
    11b6:	98 17       	cp	r25, r24
    11b8:	10 f0       	brcs	.+4      	; 0x11be <xQueueGenericSend+0x4e>
    11ba:	02 30       	cpi	r16, 0x02	; 2
    11bc:	d1 f4       	brne	.+52     	; 0x11f2 <xQueueGenericSend+0x82>
    11be:	40 2f       	mov	r20, r16
    11c0:	b5 01       	movw	r22, r10
    11c2:	c7 01       	movw	r24, r14
    11c4:	0e 94 8d 07 	call	0xf1a	; 0xf1a <prvCopyDataToQueue>
    11c8:	f7 01       	movw	r30, r14
    11ca:	93 89       	ldd	r25, Z+19	; 0x13
    11cc:	99 23       	and	r25, r25
    11ce:	49 f0       	breq	.+18     	; 0x11e2 <xQueueGenericSend+0x72>
    11d0:	c7 01       	movw	r24, r14
    11d2:	43 96       	adiw	r24, 0x13	; 19
    11d4:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <xTaskRemoveFromEventList>
    11d8:	88 23       	and	r24, r24
    11da:	31 f0       	breq	.+12     	; 0x11e8 <xQueueGenericSend+0x78>
    11dc:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    11e0:	03 c0       	rjmp	.+6      	; 0x11e8 <xQueueGenericSend+0x78>
    11e2:	81 11       	cpse	r24, r1
    11e4:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    11e8:	ff 91       	pop	r31
    11ea:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11ee:	81 e0       	ldi	r24, 0x01	; 1
    11f0:	57 c0       	rjmp	.+174    	; 0x12a0 <xQueueGenericSend+0x130>
    11f2:	8e 81       	ldd	r24, Y+6	; 0x06
    11f4:	9f 81       	ldd	r25, Y+7	; 0x07
    11f6:	a8 85       	ldd	r26, Y+8	; 0x08
    11f8:	b9 85       	ldd	r27, Y+9	; 0x09
    11fa:	89 2b       	or	r24, r25
    11fc:	8a 2b       	or	r24, r26
    11fe:	8b 2b       	or	r24, r27
    1200:	29 f4       	brne	.+10     	; 0x120c <xQueueGenericSend+0x9c>
    1202:	ff 91       	pop	r31
    1204:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1208:	80 e0       	ldi	r24, 0x00	; 0
    120a:	4a c0       	rjmp	.+148    	; 0x12a0 <xQueueGenericSend+0x130>
    120c:	11 11       	cpse	r17, r1
    120e:	05 c0       	rjmp	.+10     	; 0x121a <xQueueGenericSend+0xaa>
    1210:	ce 01       	movw	r24, r28
    1212:	01 96       	adiw	r24, 0x01	; 1
    1214:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vTaskInternalSetTimeOutState>
    1218:	11 e0       	ldi	r17, 0x01	; 1
    121a:	ff 91       	pop	r31
    121c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1220:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vTaskSuspendAll>
    1224:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1228:	ff 93       	push	r31
    122a:	f8 7f       	andi	r31, 0xF8	; 248
    122c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1230:	f7 01       	movw	r30, r14
    1232:	81 a1       	ldd	r24, Z+33	; 0x21
    1234:	8f 3f       	cpi	r24, 0xFF	; 255
    1236:	09 f4       	brne	.+2      	; 0x123a <xQueueGenericSend+0xca>
    1238:	11 a2       	std	Z+33, r1	; 0x21
    123a:	f7 01       	movw	r30, r14
    123c:	82 a1       	ldd	r24, Z+34	; 0x22
    123e:	8f 3f       	cpi	r24, 0xFF	; 255
    1240:	09 f4       	brne	.+2      	; 0x1244 <xQueueGenericSend+0xd4>
    1242:	12 a2       	std	Z+34, r1	; 0x22
    1244:	ff 91       	pop	r31
    1246:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    124a:	be 01       	movw	r22, r28
    124c:	6a 5f       	subi	r22, 0xFA	; 250
    124e:	7f 4f       	sbci	r23, 0xFF	; 255
    1250:	ce 01       	movw	r24, r28
    1252:	01 96       	adiw	r24, 0x01	; 1
    1254:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <xTaskCheckForTimeOut>
    1258:	81 11       	cpse	r24, r1
    125a:	1c c0       	rjmp	.+56     	; 0x1294 <xQueueGenericSend+0x124>
    125c:	c7 01       	movw	r24, r14
    125e:	0e 94 7a 07 	call	0xef4	; 0xef4 <prvIsQueueFull>
    1262:	88 23       	and	r24, r24
    1264:	89 f0       	breq	.+34     	; 0x1288 <xQueueGenericSend+0x118>
    1266:	4e 81       	ldd	r20, Y+6	; 0x06
    1268:	5f 81       	ldd	r21, Y+7	; 0x07
    126a:	68 85       	ldd	r22, Y+8	; 0x08
    126c:	79 85       	ldd	r23, Y+9	; 0x09
    126e:	c6 01       	movw	r24, r12
    1270:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <vTaskPlaceOnEventList>
    1274:	c7 01       	movw	r24, r14
    1276:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <prvUnlockQueue>
    127a:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
    127e:	81 11       	cpse	r24, r1
    1280:	91 cf       	rjmp	.-222    	; 0x11a4 <xQueueGenericSend+0x34>
    1282:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    1286:	8e cf       	rjmp	.-228    	; 0x11a4 <xQueueGenericSend+0x34>
    1288:	c7 01       	movw	r24, r14
    128a:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <prvUnlockQueue>
    128e:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
    1292:	88 cf       	rjmp	.-240    	; 0x11a4 <xQueueGenericSend+0x34>
    1294:	c7 01       	movw	r24, r14
    1296:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <prvUnlockQueue>
    129a:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
    129e:	80 e0       	ldi	r24, 0x00	; 0
    12a0:	29 96       	adiw	r28, 0x09	; 9
    12a2:	cd bf       	out	0x3d, r28	; 61
    12a4:	de bf       	out	0x3e, r29	; 62
    12a6:	df 91       	pop	r29
    12a8:	cf 91       	pop	r28
    12aa:	1f 91       	pop	r17
    12ac:	0f 91       	pop	r16
    12ae:	ff 90       	pop	r15
    12b0:	ef 90       	pop	r14
    12b2:	df 90       	pop	r13
    12b4:	cf 90       	pop	r12
    12b6:	bf 90       	pop	r11
    12b8:	af 90       	pop	r10
    12ba:	08 95       	ret

000012bc <xQueueGenericSendFromISR>:
    12bc:	af 92       	push	r10
    12be:	bf 92       	push	r11
    12c0:	cf 92       	push	r12
    12c2:	df 92       	push	r13
    12c4:	ff 92       	push	r15
    12c6:	0f 93       	push	r16
    12c8:	1f 93       	push	r17
    12ca:	cf 93       	push	r28
    12cc:	df 93       	push	r29
    12ce:	ec 01       	movw	r28, r24
    12d0:	6b 01       	movw	r12, r22
    12d2:	5a 01       	movw	r10, r20
    12d4:	02 2f       	mov	r16, r18
    12d6:	0e 94 be 05 	call	0xb7c	; 0xb7c <_portSetInterruptMaskFromIsr>
    12da:	f8 2e       	mov	r15, r24
    12dc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    12de:	8f 8d       	ldd	r24, Y+31	; 0x1f
    12e0:	98 17       	cp	r25, r24
    12e2:	10 f0       	brcs	.+4      	; 0x12e8 <xQueueGenericSendFromISR+0x2c>
    12e4:	02 30       	cpi	r16, 0x02	; 2
    12e6:	e1 f4       	brne	.+56     	; 0x1320 <xQueueGenericSendFromISR+0x64>
    12e8:	1a a1       	ldd	r17, Y+34	; 0x22
    12ea:	40 2f       	mov	r20, r16
    12ec:	b6 01       	movw	r22, r12
    12ee:	ce 01       	movw	r24, r28
    12f0:	0e 94 8d 07 	call	0xf1a	; 0xf1a <prvCopyDataToQueue>
    12f4:	1f 3f       	cpi	r17, 0xFF	; 255
    12f6:	81 f4       	brne	.+32     	; 0x1318 <xQueueGenericSendFromISR+0x5c>
    12f8:	8b 89       	ldd	r24, Y+19	; 0x13
    12fa:	88 23       	and	r24, r24
    12fc:	99 f0       	breq	.+38     	; 0x1324 <xQueueGenericSendFromISR+0x68>
    12fe:	ce 01       	movw	r24, r28
    1300:	43 96       	adiw	r24, 0x13	; 19
    1302:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <xTaskRemoveFromEventList>
    1306:	88 23       	and	r24, r24
    1308:	79 f0       	breq	.+30     	; 0x1328 <xQueueGenericSendFromISR+0x6c>
    130a:	a1 14       	cp	r10, r1
    130c:	b1 04       	cpc	r11, r1
    130e:	71 f0       	breq	.+28     	; 0x132c <xQueueGenericSendFromISR+0x70>
    1310:	81 e0       	ldi	r24, 0x01	; 1
    1312:	f5 01       	movw	r30, r10
    1314:	80 83       	st	Z, r24
    1316:	0b c0       	rjmp	.+22     	; 0x132e <xQueueGenericSendFromISR+0x72>
    1318:	1f 5f       	subi	r17, 0xFF	; 255
    131a:	1a a3       	std	Y+34, r17	; 0x22
    131c:	81 e0       	ldi	r24, 0x01	; 1
    131e:	07 c0       	rjmp	.+14     	; 0x132e <xQueueGenericSendFromISR+0x72>
    1320:	80 e0       	ldi	r24, 0x00	; 0
    1322:	05 c0       	rjmp	.+10     	; 0x132e <xQueueGenericSendFromISR+0x72>
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	03 c0       	rjmp	.+6      	; 0x132e <xQueueGenericSendFromISR+0x72>
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	01 c0       	rjmp	.+2      	; 0x132e <xQueueGenericSendFromISR+0x72>
    132c:	81 e0       	ldi	r24, 0x01	; 1
    132e:	f0 92 a2 00 	sts	0x00A2, r15	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1332:	df 91       	pop	r29
    1334:	cf 91       	pop	r28
    1336:	1f 91       	pop	r17
    1338:	0f 91       	pop	r16
    133a:	ff 90       	pop	r15
    133c:	df 90       	pop	r13
    133e:	cf 90       	pop	r12
    1340:	bf 90       	pop	r11
    1342:	af 90       	pop	r10
    1344:	08 95       	ret

00001346 <xQueueReceive>:
    1346:	af 92       	push	r10
    1348:	bf 92       	push	r11
    134a:	cf 92       	push	r12
    134c:	df 92       	push	r13
    134e:	ef 92       	push	r14
    1350:	ff 92       	push	r15
    1352:	0f 93       	push	r16
    1354:	1f 93       	push	r17
    1356:	cf 93       	push	r28
    1358:	df 93       	push	r29
    135a:	cd b7       	in	r28, 0x3d	; 61
    135c:	de b7       	in	r29, 0x3e	; 62
    135e:	29 97       	sbiw	r28, 0x09	; 9
    1360:	cd bf       	out	0x3d, r28	; 61
    1362:	de bf       	out	0x3e, r29	; 62
    1364:	8c 01       	movw	r16, r24
    1366:	5b 01       	movw	r10, r22
    1368:	2e 83       	std	Y+6, r18	; 0x06
    136a:	3f 83       	std	Y+7, r19	; 0x07
    136c:	48 87       	std	Y+8, r20	; 0x08
    136e:	59 87       	std	Y+9, r21	; 0x09
    1370:	e1 2c       	mov	r14, r1
    1372:	6c 01       	movw	r12, r24
    1374:	83 e1       	ldi	r24, 0x13	; 19
    1376:	c8 0e       	add	r12, r24
    1378:	d1 1c       	adc	r13, r1
    137a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    137e:	ff 93       	push	r31
    1380:	f8 7f       	andi	r31, 0xF8	; 248
    1382:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1386:	f8 01       	movw	r30, r16
    1388:	f6 8c       	ldd	r15, Z+30	; 0x1e
    138a:	ff 20       	and	r15, r15
    138c:	b1 f0       	breq	.+44     	; 0x13ba <xQueueReceive+0x74>
    138e:	b5 01       	movw	r22, r10
    1390:	c8 01       	movw	r24, r16
    1392:	0e 94 d6 07 	call	0xfac	; 0xfac <prvCopyDataFromQueue>
    1396:	fa 94       	dec	r15
    1398:	f8 01       	movw	r30, r16
    139a:	f6 8e       	std	Z+30, r15	; 0x1e
    139c:	80 85       	ldd	r24, Z+8	; 0x08
    139e:	88 23       	and	r24, r24
    13a0:	39 f0       	breq	.+14     	; 0x13b0 <xQueueReceive+0x6a>
    13a2:	c8 01       	movw	r24, r16
    13a4:	08 96       	adiw	r24, 0x08	; 8
    13a6:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <xTaskRemoveFromEventList>
    13aa:	81 11       	cpse	r24, r1
    13ac:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    13b0:	ff 91       	pop	r31
    13b2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	5e c0       	rjmp	.+188    	; 0x1476 <xQueueReceive+0x130>
    13ba:	8e 81       	ldd	r24, Y+6	; 0x06
    13bc:	9f 81       	ldd	r25, Y+7	; 0x07
    13be:	a8 85       	ldd	r26, Y+8	; 0x08
    13c0:	b9 85       	ldd	r27, Y+9	; 0x09
    13c2:	89 2b       	or	r24, r25
    13c4:	8a 2b       	or	r24, r26
    13c6:	8b 2b       	or	r24, r27
    13c8:	29 f4       	brne	.+10     	; 0x13d4 <xQueueReceive+0x8e>
    13ca:	ff 91       	pop	r31
    13cc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13d0:	80 e0       	ldi	r24, 0x00	; 0
    13d2:	51 c0       	rjmp	.+162    	; 0x1476 <xQueueReceive+0x130>
    13d4:	e1 10       	cpse	r14, r1
    13d6:	06 c0       	rjmp	.+12     	; 0x13e4 <xQueueReceive+0x9e>
    13d8:	ce 01       	movw	r24, r28
    13da:	01 96       	adiw	r24, 0x01	; 1
    13dc:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vTaskInternalSetTimeOutState>
    13e0:	ee 24       	eor	r14, r14
    13e2:	e3 94       	inc	r14
    13e4:	ff 91       	pop	r31
    13e6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13ea:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vTaskSuspendAll>
    13ee:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13f2:	ff 93       	push	r31
    13f4:	f8 7f       	andi	r31, 0xF8	; 248
    13f6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    13fa:	f8 01       	movw	r30, r16
    13fc:	81 a1       	ldd	r24, Z+33	; 0x21
    13fe:	8f 3f       	cpi	r24, 0xFF	; 255
    1400:	09 f4       	brne	.+2      	; 0x1404 <xQueueReceive+0xbe>
    1402:	11 a2       	std	Z+33, r1	; 0x21
    1404:	f8 01       	movw	r30, r16
    1406:	82 a1       	ldd	r24, Z+34	; 0x22
    1408:	8f 3f       	cpi	r24, 0xFF	; 255
    140a:	09 f4       	brne	.+2      	; 0x140e <xQueueReceive+0xc8>
    140c:	12 a2       	std	Z+34, r1	; 0x22
    140e:	ff 91       	pop	r31
    1410:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1414:	be 01       	movw	r22, r28
    1416:	6a 5f       	subi	r22, 0xFA	; 250
    1418:	7f 4f       	sbci	r23, 0xFF	; 255
    141a:	ce 01       	movw	r24, r28
    141c:	01 96       	adiw	r24, 0x01	; 1
    141e:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <xTaskCheckForTimeOut>
    1422:	81 11       	cpse	r24, r1
    1424:	1c c0       	rjmp	.+56     	; 0x145e <xQueueReceive+0x118>
    1426:	c8 01       	movw	r24, r16
    1428:	0e 94 6b 07 	call	0xed6	; 0xed6 <prvIsQueueEmpty>
    142c:	88 23       	and	r24, r24
    142e:	89 f0       	breq	.+34     	; 0x1452 <xQueueReceive+0x10c>
    1430:	4e 81       	ldd	r20, Y+6	; 0x06
    1432:	5f 81       	ldd	r21, Y+7	; 0x07
    1434:	68 85       	ldd	r22, Y+8	; 0x08
    1436:	79 85       	ldd	r23, Y+9	; 0x09
    1438:	c6 01       	movw	r24, r12
    143a:	0e 94 88 0e 	call	0x1d10	; 0x1d10 <vTaskPlaceOnEventList>
    143e:	c8 01       	movw	r24, r16
    1440:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <prvUnlockQueue>
    1444:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
    1448:	81 11       	cpse	r24, r1
    144a:	97 cf       	rjmp	.-210    	; 0x137a <xQueueReceive+0x34>
    144c:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    1450:	94 cf       	rjmp	.-216    	; 0x137a <xQueueReceive+0x34>
    1452:	c8 01       	movw	r24, r16
    1454:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <prvUnlockQueue>
    1458:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
    145c:	8e cf       	rjmp	.-228    	; 0x137a <xQueueReceive+0x34>
    145e:	c8 01       	movw	r24, r16
    1460:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <prvUnlockQueue>
    1464:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
    1468:	c8 01       	movw	r24, r16
    146a:	0e 94 6b 07 	call	0xed6	; 0xed6 <prvIsQueueEmpty>
    146e:	88 23       	and	r24, r24
    1470:	09 f4       	brne	.+2      	; 0x1474 <xQueueReceive+0x12e>
    1472:	83 cf       	rjmp	.-250    	; 0x137a <xQueueReceive+0x34>
    1474:	80 e0       	ldi	r24, 0x00	; 0
    1476:	29 96       	adiw	r28, 0x09	; 9
    1478:	cd bf       	out	0x3d, r28	; 61
    147a:	de bf       	out	0x3e, r29	; 62
    147c:	df 91       	pop	r29
    147e:	cf 91       	pop	r28
    1480:	1f 91       	pop	r17
    1482:	0f 91       	pop	r16
    1484:	ff 90       	pop	r15
    1486:	ef 90       	pop	r14
    1488:	df 90       	pop	r13
    148a:	cf 90       	pop	r12
    148c:	bf 90       	pop	r11
    148e:	af 90       	pop	r10
    1490:	08 95       	ret

00001492 <uxQueueMessagesWaiting>:
    1492:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1496:	ff 93       	push	r31
    1498:	f8 7f       	andi	r31, 0xF8	; 248
    149a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    149e:	fc 01       	movw	r30, r24
    14a0:	86 8d       	ldd	r24, Z+30	; 0x1e
    14a2:	ff 91       	pop	r31
    14a4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    14a8:	08 95       	ret

000014aa <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    14aa:	cf 93       	push	r28
    14ac:	df 93       	push	r29
    14ae:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    14b0:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    14b4:	ff 93       	push	r31
    14b6:	f8 7f       	andi	r31, 0xF8	; 248
    14b8:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    14bc:	89 a1       	ldd	r24, Y+33	; 0x21
    14be:	8f 3f       	cpi	r24, 0xFF	; 255
    14c0:	09 f4       	brne	.+2      	; 0x14c4 <vQueueWaitForMessageRestricted+0x1a>
    14c2:	19 a2       	std	Y+33, r1	; 0x21
    14c4:	8a a1       	ldd	r24, Y+34	; 0x22
    14c6:	8f 3f       	cpi	r24, 0xFF	; 255
    14c8:	09 f4       	brne	.+2      	; 0x14cc <vQueueWaitForMessageRestricted+0x22>
    14ca:	1a a2       	std	Y+34, r1	; 0x22
    14cc:	ff 91       	pop	r31
    14ce:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    14d2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14d4:	81 11       	cpse	r24, r1
    14d6:	04 c0       	rjmp	.+8      	; 0x14e0 <vQueueWaitForMessageRestricted+0x36>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    14d8:	ce 01       	movw	r24, r28
    14da:	43 96       	adiw	r24, 0x13	; 19
    14dc:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    14e0:	ce 01       	movw	r24, r28
    14e2:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <prvUnlockQueue>
	}
    14e6:	df 91       	pop	r29
    14e8:	cf 91       	pop	r28
    14ea:	08 95       	ret

000014ec <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
    14ec:	e0 91 f8 2d 	lds	r30, 0x2DF8	; 0x802df8 <pxDelayedTaskList>
    14f0:	f0 91 f9 2d 	lds	r31, 0x2DF9	; 0x802df9 <pxDelayedTaskList+0x1>
    14f4:	80 81       	ld	r24, Z
    14f6:	81 11       	cpse	r24, r1
    14f8:	0c c0       	rjmp	.+24     	; 0x1512 <prvResetNextTaskUnblockTime+0x26>
    14fa:	8f ef       	ldi	r24, 0xFF	; 255
    14fc:	9f ef       	ldi	r25, 0xFF	; 255
    14fe:	dc 01       	movw	r26, r24
    1500:	80 93 d1 2d 	sts	0x2DD1, r24	; 0x802dd1 <xNextTaskUnblockTime>
    1504:	90 93 d2 2d 	sts	0x2DD2, r25	; 0x802dd2 <xNextTaskUnblockTime+0x1>
    1508:	a0 93 d3 2d 	sts	0x2DD3, r26	; 0x802dd3 <xNextTaskUnblockTime+0x2>
    150c:	b0 93 d4 2d 	sts	0x2DD4, r27	; 0x802dd4 <xNextTaskUnblockTime+0x3>
    1510:	08 95       	ret
    1512:	e0 91 f8 2d 	lds	r30, 0x2DF8	; 0x802df8 <pxDelayedTaskList>
    1516:	f0 91 f9 2d 	lds	r31, 0x2DF9	; 0x802df9 <pxDelayedTaskList+0x1>
    151a:	07 80       	ldd	r0, Z+7	; 0x07
    151c:	f0 85       	ldd	r31, Z+8	; 0x08
    151e:	e0 2d       	mov	r30, r0
    1520:	00 84       	ldd	r0, Z+8	; 0x08
    1522:	f1 85       	ldd	r31, Z+9	; 0x09
    1524:	e0 2d       	mov	r30, r0
    1526:	82 81       	ldd	r24, Z+2	; 0x02
    1528:	93 81       	ldd	r25, Z+3	; 0x03
    152a:	a4 81       	ldd	r26, Z+4	; 0x04
    152c:	b5 81       	ldd	r27, Z+5	; 0x05
    152e:	80 93 d1 2d 	sts	0x2DD1, r24	; 0x802dd1 <xNextTaskUnblockTime>
    1532:	90 93 d2 2d 	sts	0x2DD2, r25	; 0x802dd2 <xNextTaskUnblockTime+0x1>
    1536:	a0 93 d3 2d 	sts	0x2DD3, r26	; 0x802dd3 <xNextTaskUnblockTime+0x2>
    153a:	b0 93 d4 2d 	sts	0x2DD4, r27	; 0x802dd4 <xNextTaskUnblockTime+0x3>
    153e:	08 95       	ret

00001540 <prvAddCurrentTaskToDelayedList>:
    1540:	8f 92       	push	r8
    1542:	9f 92       	push	r9
    1544:	af 92       	push	r10
    1546:	bf 92       	push	r11
    1548:	cf 92       	push	r12
    154a:	df 92       	push	r13
    154c:	ef 92       	push	r14
    154e:	ff 92       	push	r15
    1550:	cf 93       	push	r28
    1552:	6b 01       	movw	r12, r22
    1554:	7c 01       	movw	r14, r24
    1556:	c4 2f       	mov	r28, r20
    1558:	80 90 db 2d 	lds	r8, 0x2DDB	; 0x802ddb <xTickCount>
    155c:	90 90 dc 2d 	lds	r9, 0x2DDC	; 0x802ddc <xTickCount+0x1>
    1560:	a0 90 dd 2d 	lds	r10, 0x2DDD	; 0x802ddd <xTickCount+0x2>
    1564:	b0 90 de 2d 	lds	r11, 0x2DDE	; 0x802dde <xTickCount+0x3>
    1568:	80 91 3c 2e 	lds	r24, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    156c:	90 91 3d 2e 	lds	r25, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1570:	02 96       	adiw	r24, 0x02	; 2
    1572:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    1576:	8f ef       	ldi	r24, 0xFF	; 255
    1578:	c8 16       	cp	r12, r24
    157a:	d8 06       	cpc	r13, r24
    157c:	e8 06       	cpc	r14, r24
    157e:	f8 06       	cpc	r15, r24
    1580:	69 f4       	brne	.+26     	; 0x159c <prvAddCurrentTaskToDelayedList+0x5c>
    1582:	cc 23       	and	r28, r28
    1584:	59 f0       	breq	.+22     	; 0x159c <prvAddCurrentTaskToDelayedList+0x5c>
    1586:	60 91 3c 2e 	lds	r22, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    158a:	70 91 3d 2e 	lds	r23, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    158e:	6e 5f       	subi	r22, 0xFE	; 254
    1590:	7f 4f       	sbci	r23, 0xFF	; 255
    1592:	80 ee       	ldi	r24, 0xE0	; 224
    1594:	9d e2       	ldi	r25, 0x2D	; 45
    1596:	0e 94 39 05 	call	0xa72	; 0xa72 <vListInsertEnd>
    159a:	3f c0       	rjmp	.+126    	; 0x161a <prvAddCurrentTaskToDelayedList+0xda>
    159c:	c8 0c       	add	r12, r8
    159e:	d9 1c       	adc	r13, r9
    15a0:	ea 1c       	adc	r14, r10
    15a2:	fb 1c       	adc	r15, r11
    15a4:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    15a8:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    15ac:	c2 82       	std	Z+2, r12	; 0x02
    15ae:	d3 82       	std	Z+3, r13	; 0x03
    15b0:	e4 82       	std	Z+4, r14	; 0x04
    15b2:	f5 82       	std	Z+5, r15	; 0x05
    15b4:	c8 14       	cp	r12, r8
    15b6:	d9 04       	cpc	r13, r9
    15b8:	ea 04       	cpc	r14, r10
    15ba:	fb 04       	cpc	r15, r11
    15bc:	68 f4       	brcc	.+26     	; 0x15d8 <prvAddCurrentTaskToDelayedList+0x98>
    15be:	60 91 3c 2e 	lds	r22, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    15c2:	70 91 3d 2e 	lds	r23, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    15c6:	80 91 f6 2d 	lds	r24, 0x2DF6	; 0x802df6 <pxOverflowDelayedTaskList>
    15ca:	90 91 f7 2d 	lds	r25, 0x2DF7	; 0x802df7 <pxOverflowDelayedTaskList+0x1>
    15ce:	6e 5f       	subi	r22, 0xFE	; 254
    15d0:	7f 4f       	sbci	r23, 0xFF	; 255
    15d2:	0e 94 5a 05 	call	0xab4	; 0xab4 <vListInsert>
    15d6:	21 c0       	rjmp	.+66     	; 0x161a <prvAddCurrentTaskToDelayedList+0xda>
    15d8:	60 91 3c 2e 	lds	r22, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    15dc:	70 91 3d 2e 	lds	r23, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    15e0:	80 91 f8 2d 	lds	r24, 0x2DF8	; 0x802df8 <pxDelayedTaskList>
    15e4:	90 91 f9 2d 	lds	r25, 0x2DF9	; 0x802df9 <pxDelayedTaskList+0x1>
    15e8:	6e 5f       	subi	r22, 0xFE	; 254
    15ea:	7f 4f       	sbci	r23, 0xFF	; 255
    15ec:	0e 94 5a 05 	call	0xab4	; 0xab4 <vListInsert>
    15f0:	80 91 d1 2d 	lds	r24, 0x2DD1	; 0x802dd1 <xNextTaskUnblockTime>
    15f4:	90 91 d2 2d 	lds	r25, 0x2DD2	; 0x802dd2 <xNextTaskUnblockTime+0x1>
    15f8:	a0 91 d3 2d 	lds	r26, 0x2DD3	; 0x802dd3 <xNextTaskUnblockTime+0x2>
    15fc:	b0 91 d4 2d 	lds	r27, 0x2DD4	; 0x802dd4 <xNextTaskUnblockTime+0x3>
    1600:	c8 16       	cp	r12, r24
    1602:	d9 06       	cpc	r13, r25
    1604:	ea 06       	cpc	r14, r26
    1606:	fb 06       	cpc	r15, r27
    1608:	40 f4       	brcc	.+16     	; 0x161a <prvAddCurrentTaskToDelayedList+0xda>
    160a:	c0 92 d1 2d 	sts	0x2DD1, r12	; 0x802dd1 <xNextTaskUnblockTime>
    160e:	d0 92 d2 2d 	sts	0x2DD2, r13	; 0x802dd2 <xNextTaskUnblockTime+0x1>
    1612:	e0 92 d3 2d 	sts	0x2DD3, r14	; 0x802dd3 <xNextTaskUnblockTime+0x2>
    1616:	f0 92 d4 2d 	sts	0x2DD4, r15	; 0x802dd4 <xNextTaskUnblockTime+0x3>
    161a:	cf 91       	pop	r28
    161c:	ff 90       	pop	r15
    161e:	ef 90       	pop	r14
    1620:	df 90       	pop	r13
    1622:	cf 90       	pop	r12
    1624:	bf 90       	pop	r11
    1626:	af 90       	pop	r10
    1628:	9f 90       	pop	r9
    162a:	8f 90       	pop	r8
    162c:	08 95       	ret

0000162e <prvIdleTask>:
    162e:	c0 e1       	ldi	r28, 0x10	; 16
    1630:	de e2       	ldi	r29, 0x2E	; 46
    1632:	88 81       	ld	r24, Y
    1634:	82 30       	cpi	r24, 0x02	; 2
    1636:	10 f0       	brcs	.+4      	; 0x163c <prvIdleTask+0xe>
    1638:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    163c:	0e 94 66 13 	call	0x26cc	; 0x26cc <vApplicationIdleHook>
    1640:	f8 cf       	rjmp	.-16     	; 0x1632 <prvIdleTask+0x4>

00001642 <xTaskCreate>:
    1642:	4f 92       	push	r4
    1644:	5f 92       	push	r5
    1646:	6f 92       	push	r6
    1648:	7f 92       	push	r7
    164a:	8f 92       	push	r8
    164c:	9f 92       	push	r9
    164e:	af 92       	push	r10
    1650:	bf 92       	push	r11
    1652:	cf 92       	push	r12
    1654:	df 92       	push	r13
    1656:	ef 92       	push	r14
    1658:	ff 92       	push	r15
    165a:	0f 93       	push	r16
    165c:	cf 93       	push	r28
    165e:	df 93       	push	r29
    1660:	4c 01       	movw	r8, r24
    1662:	6b 01       	movw	r12, r22
    1664:	5a 01       	movw	r10, r20
    1666:	29 01       	movw	r4, r18
    1668:	ca 01       	movw	r24, r20
    166a:	0e 94 fd 04 	call	0x9fa	; 0x9fa <pvPortMalloc>
    166e:	3c 01       	movw	r6, r24
    1670:	89 2b       	or	r24, r25
    1672:	09 f4       	brne	.+2      	; 0x1676 <xTaskCreate+0x34>
    1674:	ea c0       	rjmp	.+468    	; 0x184a <xTaskCreate+0x208>
    1676:	8c e2       	ldi	r24, 0x2C	; 44
    1678:	90 e0       	ldi	r25, 0x00	; 0
    167a:	0e 94 fd 04 	call	0x9fa	; 0x9fa <pvPortMalloc>
    167e:	ec 01       	movw	r28, r24
    1680:	89 2b       	or	r24, r25
    1682:	b1 f0       	breq	.+44     	; 0x16b0 <xTaskCreate+0x6e>
    1684:	6b 8e       	std	Y+27, r6	; 0x1b
    1686:	7c 8e       	std	Y+28, r7	; 0x1c
    1688:	a5 01       	movw	r20, r10
    168a:	65 ea       	ldi	r22, 0xA5	; 165
    168c:	70 e0       	ldi	r23, 0x00	; 0
    168e:	c3 01       	movw	r24, r6
    1690:	0e 94 d4 1f 	call	0x3fa8	; 0x3fa8 <memset>
    1694:	21 e0       	ldi	r18, 0x01	; 1
    1696:	a2 1a       	sub	r10, r18
    1698:	b1 08       	sbc	r11, r1
    169a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    169c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    169e:	a8 0e       	add	r10, r24
    16a0:	b9 1e       	adc	r11, r25
    16a2:	d6 01       	movw	r26, r12
    16a4:	8c 91       	ld	r24, X
    16a6:	8d 8f       	std	Y+29, r24	; 0x1d
    16a8:	8c 91       	ld	r24, X
    16aa:	81 11       	cpse	r24, r1
    16ac:	05 c0       	rjmp	.+10     	; 0x16b8 <xTaskCreate+0x76>
    16ae:	18 c0       	rjmp	.+48     	; 0x16e0 <xTaskCreate+0x9e>
    16b0:	c3 01       	movw	r24, r6
    16b2:	0e 94 23 05 	call	0xa46	; 0xa46 <vPortFree>
    16b6:	c9 c0       	rjmp	.+402    	; 0x184a <xTaskCreate+0x208>
    16b8:	ae 01       	movw	r20, r28
    16ba:	42 5e       	subi	r20, 0xE2	; 226
    16bc:	5f 4f       	sbci	r21, 0xFF	; 255
    16be:	f6 01       	movw	r30, r12
    16c0:	31 96       	adiw	r30, 0x01	; 1
    16c2:	b8 e0       	ldi	r27, 0x08	; 8
    16c4:	cb 0e       	add	r12, r27
    16c6:	d1 1c       	adc	r13, r1
    16c8:	cf 01       	movw	r24, r30
    16ca:	21 91       	ld	r18, Z+
    16cc:	da 01       	movw	r26, r20
    16ce:	2d 93       	st	X+, r18
    16d0:	ad 01       	movw	r20, r26
    16d2:	dc 01       	movw	r26, r24
    16d4:	8c 91       	ld	r24, X
    16d6:	88 23       	and	r24, r24
    16d8:	19 f0       	breq	.+6      	; 0x16e0 <xTaskCreate+0x9e>
    16da:	ec 15       	cp	r30, r12
    16dc:	fd 05       	cpc	r31, r13
    16de:	a1 f7       	brne	.-24     	; 0x16c8 <xTaskCreate+0x86>
    16e0:	1c a2       	std	Y+36, r1	; 0x24
    16e2:	04 30       	cpi	r16, 0x04	; 4
    16e4:	08 f0       	brcs	.+2      	; 0x16e8 <xTaskCreate+0xa6>
    16e6:	03 e0       	ldi	r16, 0x03	; 3
    16e8:	0a 8f       	std	Y+26, r16	; 0x1a
    16ea:	6e 01       	movw	r12, r28
    16ec:	b2 e0       	ldi	r27, 0x02	; 2
    16ee:	cb 0e       	add	r12, r27
    16f0:	d1 1c       	adc	r13, r1
    16f2:	c6 01       	movw	r24, r12
    16f4:	0e 94 35 05 	call	0xa6a	; 0xa6a <vListInitialiseItem>
    16f8:	ce 01       	movw	r24, r28
    16fa:	0e 96       	adiw	r24, 0x0e	; 14
    16fc:	0e 94 35 05 	call	0xa6a	; 0xa6a <vListInitialiseItem>
    1700:	ca 87       	std	Y+10, r28	; 0x0a
    1702:	db 87       	std	Y+11, r29	; 0x0b
    1704:	84 e0       	ldi	r24, 0x04	; 4
    1706:	90 e0       	ldi	r25, 0x00	; 0
    1708:	a0 e0       	ldi	r26, 0x00	; 0
    170a:	b0 e0       	ldi	r27, 0x00	; 0
    170c:	80 1b       	sub	r24, r16
    170e:	91 09       	sbc	r25, r1
    1710:	a1 09       	sbc	r26, r1
    1712:	b1 09       	sbc	r27, r1
    1714:	8e 87       	std	Y+14, r24	; 0x0e
    1716:	9f 87       	std	Y+15, r25	; 0x0f
    1718:	a8 8b       	std	Y+16, r26	; 0x10
    171a:	b9 8b       	std	Y+17, r27	; 0x11
    171c:	ce 8b       	std	Y+22, r28	; 0x16
    171e:	df 8b       	std	Y+23, r29	; 0x17
    1720:	1f a2       	std	Y+39, r1	; 0x27
    1722:	18 a6       	std	Y+40, r1	; 0x28
    1724:	19 a6       	std	Y+41, r1	; 0x29
    1726:	1a a6       	std	Y+42, r1	; 0x2a
    1728:	1b a6       	std	Y+43, r1	; 0x2b
    172a:	a2 01       	movw	r20, r4
    172c:	b4 01       	movw	r22, r8
    172e:	c5 01       	movw	r24, r10
    1730:	0e 94 c5 05 	call	0xb8a	; 0xb8a <pxPortInitialiseStack>
    1734:	88 83       	st	Y, r24
    1736:	99 83       	std	Y+1, r25	; 0x01
    1738:	e1 14       	cp	r14, r1
    173a:	f1 04       	cpc	r15, r1
    173c:	19 f0       	breq	.+6      	; 0x1744 <xTaskCreate+0x102>
    173e:	f7 01       	movw	r30, r14
    1740:	c0 83       	st	Z, r28
    1742:	d1 83       	std	Z+1, r29	; 0x01
    1744:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1748:	ff 93       	push	r31
    174a:	f8 7f       	andi	r31, 0xF8	; 248
    174c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1750:	80 91 df 2d 	lds	r24, 0x2DDF	; 0x802ddf <uxCurrentNumberOfTasks>
    1754:	8f 5f       	subi	r24, 0xFF	; 255
    1756:	80 93 df 2d 	sts	0x2DDF, r24	; 0x802ddf <uxCurrentNumberOfTasks>
    175a:	80 91 3c 2e 	lds	r24, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    175e:	90 91 3d 2e 	lds	r25, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1762:	89 2b       	or	r24, r25
    1764:	a9 f5       	brne	.+106    	; 0x17d0 <xTaskCreate+0x18e>
    1766:	c0 93 3c 2e 	sts	0x2E3C, r28	; 0x802e3c <pxCurrentTCB>
    176a:	d0 93 3d 2e 	sts	0x2E3D, r29	; 0x802e3d <pxCurrentTCB+0x1>
    176e:	80 91 df 2d 	lds	r24, 0x2DDF	; 0x802ddf <uxCurrentNumberOfTasks>
    1772:	81 30       	cpi	r24, 0x01	; 1
    1774:	e9 f5       	brne	.+122    	; 0x17f0 <xTaskCreate+0x1ae>
    1776:	80 e1       	ldi	r24, 0x10	; 16
    1778:	9e e2       	ldi	r25, 0x2E	; 46
    177a:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    177e:	8b e1       	ldi	r24, 0x1B	; 27
    1780:	9e e2       	ldi	r25, 0x2E	; 46
    1782:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    1786:	86 e2       	ldi	r24, 0x26	; 38
    1788:	9e e2       	ldi	r25, 0x2E	; 46
    178a:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    178e:	81 e3       	ldi	r24, 0x31	; 49
    1790:	9e e2       	ldi	r25, 0x2E	; 46
    1792:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    1796:	85 e0       	ldi	r24, 0x05	; 5
    1798:	9e e2       	ldi	r25, 0x2E	; 46
    179a:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    179e:	8a ef       	ldi	r24, 0xFA	; 250
    17a0:	9d e2       	ldi	r25, 0x2D	; 45
    17a2:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    17a6:	8b ee       	ldi	r24, 0xEB	; 235
    17a8:	9d e2       	ldi	r25, 0x2D	; 45
    17aa:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    17ae:	80 ee       	ldi	r24, 0xE0	; 224
    17b0:	9d e2       	ldi	r25, 0x2D	; 45
    17b2:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    17b6:	85 e0       	ldi	r24, 0x05	; 5
    17b8:	9e e2       	ldi	r25, 0x2E	; 46
    17ba:	80 93 f8 2d 	sts	0x2DF8, r24	; 0x802df8 <pxDelayedTaskList>
    17be:	90 93 f9 2d 	sts	0x2DF9, r25	; 0x802df9 <pxDelayedTaskList+0x1>
    17c2:	8a ef       	ldi	r24, 0xFA	; 250
    17c4:	9d e2       	ldi	r25, 0x2D	; 45
    17c6:	80 93 f6 2d 	sts	0x2DF6, r24	; 0x802df6 <pxOverflowDelayedTaskList>
    17ca:	90 93 f7 2d 	sts	0x2DF7, r25	; 0x802df7 <pxOverflowDelayedTaskList+0x1>
    17ce:	10 c0       	rjmp	.+32     	; 0x17f0 <xTaskCreate+0x1ae>
    17d0:	80 91 d9 2d 	lds	r24, 0x2DD9	; 0x802dd9 <xSchedulerRunning>
    17d4:	81 11       	cpse	r24, r1
    17d6:	0c c0       	rjmp	.+24     	; 0x17f0 <xTaskCreate+0x1ae>
    17d8:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    17dc:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    17e0:	92 8d       	ldd	r25, Z+26	; 0x1a
    17e2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17e4:	89 17       	cp	r24, r25
    17e6:	20 f0       	brcs	.+8      	; 0x17f0 <xTaskCreate+0x1ae>
    17e8:	c0 93 3c 2e 	sts	0x2E3C, r28	; 0x802e3c <pxCurrentTCB>
    17ec:	d0 93 3d 2e 	sts	0x2E3D, r29	; 0x802e3d <pxCurrentTCB+0x1>
    17f0:	80 91 d5 2d 	lds	r24, 0x2DD5	; 0x802dd5 <uxTaskNumber>
    17f4:	8f 5f       	subi	r24, 0xFF	; 255
    17f6:	80 93 d5 2d 	sts	0x2DD5, r24	; 0x802dd5 <uxTaskNumber>
    17fa:	8d a3       	std	Y+37, r24	; 0x25
    17fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    17fe:	90 91 da 2d 	lds	r25, 0x2DDA	; 0x802dda <uxTopReadyPriority>
    1802:	98 17       	cp	r25, r24
    1804:	10 f4       	brcc	.+4      	; 0x180a <xTaskCreate+0x1c8>
    1806:	80 93 da 2d 	sts	0x2DDA, r24	; 0x802dda <uxTopReadyPriority>
    180a:	fb e0       	ldi	r31, 0x0B	; 11
    180c:	8f 9f       	mul	r24, r31
    180e:	c0 01       	movw	r24, r0
    1810:	11 24       	eor	r1, r1
    1812:	b6 01       	movw	r22, r12
    1814:	80 5f       	subi	r24, 0xF0	; 240
    1816:	91 4d       	sbci	r25, 0xD1	; 209
    1818:	0e 94 39 05 	call	0xa72	; 0xa72 <vListInsertEnd>
    181c:	ff 91       	pop	r31
    181e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1822:	80 91 d9 2d 	lds	r24, 0x2DD9	; 0x802dd9 <xSchedulerRunning>
    1826:	88 23       	and	r24, r24
    1828:	61 f0       	breq	.+24     	; 0x1842 <xTaskCreate+0x200>
    182a:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    182e:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1832:	92 8d       	ldd	r25, Z+26	; 0x1a
    1834:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1836:	98 17       	cp	r25, r24
    1838:	30 f4       	brcc	.+12     	; 0x1846 <xTaskCreate+0x204>
    183a:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    183e:	81 e0       	ldi	r24, 0x01	; 1
    1840:	05 c0       	rjmp	.+10     	; 0x184c <xTaskCreate+0x20a>
    1842:	81 e0       	ldi	r24, 0x01	; 1
    1844:	03 c0       	rjmp	.+6      	; 0x184c <xTaskCreate+0x20a>
    1846:	81 e0       	ldi	r24, 0x01	; 1
    1848:	01 c0       	rjmp	.+2      	; 0x184c <xTaskCreate+0x20a>
    184a:	8f ef       	ldi	r24, 0xFF	; 255
    184c:	df 91       	pop	r29
    184e:	cf 91       	pop	r28
    1850:	0f 91       	pop	r16
    1852:	ff 90       	pop	r15
    1854:	ef 90       	pop	r14
    1856:	df 90       	pop	r13
    1858:	cf 90       	pop	r12
    185a:	bf 90       	pop	r11
    185c:	af 90       	pop	r10
    185e:	9f 90       	pop	r9
    1860:	8f 90       	pop	r8
    1862:	7f 90       	pop	r7
    1864:	6f 90       	pop	r6
    1866:	5f 90       	pop	r5
    1868:	4f 90       	pop	r4
    186a:	08 95       	ret

0000186c <vTaskStartScheduler>:
    186c:	ef 92       	push	r14
    186e:	ff 92       	push	r15
    1870:	0f 93       	push	r16
    1872:	0f 2e       	mov	r0, r31
    1874:	ff ec       	ldi	r31, 0xCF	; 207
    1876:	ef 2e       	mov	r14, r31
    1878:	fd e2       	ldi	r31, 0x2D	; 45
    187a:	ff 2e       	mov	r15, r31
    187c:	f0 2d       	mov	r31, r0
    187e:	00 e0       	ldi	r16, 0x00	; 0
    1880:	20 e0       	ldi	r18, 0x00	; 0
    1882:	30 e0       	ldi	r19, 0x00	; 0
    1884:	48 ec       	ldi	r20, 0xC8	; 200
    1886:	50 e0       	ldi	r21, 0x00	; 0
    1888:	63 e8       	ldi	r22, 0x83	; 131
    188a:	71 e2       	ldi	r23, 0x21	; 33
    188c:	87 e1       	ldi	r24, 0x17	; 23
    188e:	9b e0       	ldi	r25, 0x0B	; 11
    1890:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTaskCreate>
    1894:	81 30       	cpi	r24, 0x01	; 1
    1896:	09 f5       	brne	.+66     	; 0x18da <vTaskStartScheduler+0x6e>
    1898:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <xTimerCreateTimerTask>
    189c:	81 30       	cpi	r24, 0x01	; 1
    189e:	e9 f4       	brne	.+58     	; 0x18da <vTaskStartScheduler+0x6e>
    18a0:	e0 ea       	ldi	r30, 0xA0	; 160
    18a2:	f0 e0       	ldi	r31, 0x00	; 0
    18a4:	82 81       	ldd	r24, Z+2	; 0x02
    18a6:	88 7f       	andi	r24, 0xF8	; 248
    18a8:	82 83       	std	Z+2, r24	; 0x02
    18aa:	8f ef       	ldi	r24, 0xFF	; 255
    18ac:	9f ef       	ldi	r25, 0xFF	; 255
    18ae:	dc 01       	movw	r26, r24
    18b0:	80 93 d1 2d 	sts	0x2DD1, r24	; 0x802dd1 <xNextTaskUnblockTime>
    18b4:	90 93 d2 2d 	sts	0x2DD2, r25	; 0x802dd2 <xNextTaskUnblockTime+0x1>
    18b8:	a0 93 d3 2d 	sts	0x2DD3, r26	; 0x802dd3 <xNextTaskUnblockTime+0x2>
    18bc:	b0 93 d4 2d 	sts	0x2DD4, r27	; 0x802dd4 <xNextTaskUnblockTime+0x3>
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	80 93 d9 2d 	sts	0x2DD9, r24	; 0x802dd9 <xSchedulerRunning>
    18c6:	10 92 db 2d 	sts	0x2DDB, r1	; 0x802ddb <xTickCount>
    18ca:	10 92 dc 2d 	sts	0x2DDC, r1	; 0x802ddc <xTickCount+0x1>
    18ce:	10 92 dd 2d 	sts	0x2DDD, r1	; 0x802ddd <xTickCount+0x2>
    18d2:	10 92 de 2d 	sts	0x2DDE, r1	; 0x802dde <xTickCount+0x3>
    18d6:	0e 94 42 06 	call	0xc84	; 0xc84 <xPortStartScheduler>
    18da:	0f 91       	pop	r16
    18dc:	ff 90       	pop	r15
    18de:	ef 90       	pop	r14
    18e0:	08 95       	ret

000018e2 <vTaskSuspendAll>:
    18e2:	80 91 ce 2d 	lds	r24, 0x2DCE	; 0x802dce <uxSchedulerSuspended>
    18e6:	8f 5f       	subi	r24, 0xFF	; 255
    18e8:	80 93 ce 2d 	sts	0x2DCE, r24	; 0x802dce <uxSchedulerSuspended>
    18ec:	08 95       	ret

000018ee <xTaskGetTickCount>:
    18ee:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    18f2:	ff 93       	push	r31
    18f4:	f8 7f       	andi	r31, 0xF8	; 248
    18f6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    18fa:	60 91 db 2d 	lds	r22, 0x2DDB	; 0x802ddb <xTickCount>
    18fe:	70 91 dc 2d 	lds	r23, 0x2DDC	; 0x802ddc <xTickCount+0x1>
    1902:	80 91 dd 2d 	lds	r24, 0x2DDD	; 0x802ddd <xTickCount+0x2>
    1906:	90 91 de 2d 	lds	r25, 0x2DDE	; 0x802dde <xTickCount+0x3>
    190a:	ff 91       	pop	r31
    190c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1910:	08 95       	ret

00001912 <xTaskIncrementTick>:
    1912:	af 92       	push	r10
    1914:	bf 92       	push	r11
    1916:	cf 92       	push	r12
    1918:	df 92       	push	r13
    191a:	ef 92       	push	r14
    191c:	ff 92       	push	r15
    191e:	0f 93       	push	r16
    1920:	1f 93       	push	r17
    1922:	cf 93       	push	r28
    1924:	df 93       	push	r29
    1926:	80 91 ce 2d 	lds	r24, 0x2DCE	; 0x802dce <uxSchedulerSuspended>
    192a:	81 11       	cpse	r24, r1
    192c:	ad c0       	rjmp	.+346    	; 0x1a88 <xTaskIncrementTick+0x176>
    192e:	c0 90 db 2d 	lds	r12, 0x2DDB	; 0x802ddb <xTickCount>
    1932:	d0 90 dc 2d 	lds	r13, 0x2DDC	; 0x802ddc <xTickCount+0x1>
    1936:	e0 90 dd 2d 	lds	r14, 0x2DDD	; 0x802ddd <xTickCount+0x2>
    193a:	f0 90 de 2d 	lds	r15, 0x2DDE	; 0x802dde <xTickCount+0x3>
    193e:	8f ef       	ldi	r24, 0xFF	; 255
    1940:	c8 1a       	sub	r12, r24
    1942:	d8 0a       	sbc	r13, r24
    1944:	e8 0a       	sbc	r14, r24
    1946:	f8 0a       	sbc	r15, r24
    1948:	c0 92 db 2d 	sts	0x2DDB, r12	; 0x802ddb <xTickCount>
    194c:	d0 92 dc 2d 	sts	0x2DDC, r13	; 0x802ddc <xTickCount+0x1>
    1950:	e0 92 dd 2d 	sts	0x2DDD, r14	; 0x802ddd <xTickCount+0x2>
    1954:	f0 92 de 2d 	sts	0x2DDE, r15	; 0x802dde <xTickCount+0x3>
    1958:	c1 14       	cp	r12, r1
    195a:	d1 04       	cpc	r13, r1
    195c:	e1 04       	cpc	r14, r1
    195e:	f1 04       	cpc	r15, r1
    1960:	b9 f4       	brne	.+46     	; 0x1990 <xTaskIncrementTick+0x7e>
    1962:	80 91 f8 2d 	lds	r24, 0x2DF8	; 0x802df8 <pxDelayedTaskList>
    1966:	90 91 f9 2d 	lds	r25, 0x2DF9	; 0x802df9 <pxDelayedTaskList+0x1>
    196a:	20 91 f6 2d 	lds	r18, 0x2DF6	; 0x802df6 <pxOverflowDelayedTaskList>
    196e:	30 91 f7 2d 	lds	r19, 0x2DF7	; 0x802df7 <pxOverflowDelayedTaskList+0x1>
    1972:	20 93 f8 2d 	sts	0x2DF8, r18	; 0x802df8 <pxDelayedTaskList>
    1976:	30 93 f9 2d 	sts	0x2DF9, r19	; 0x802df9 <pxDelayedTaskList+0x1>
    197a:	80 93 f6 2d 	sts	0x2DF6, r24	; 0x802df6 <pxOverflowDelayedTaskList>
    197e:	90 93 f7 2d 	sts	0x2DF7, r25	; 0x802df7 <pxOverflowDelayedTaskList+0x1>
    1982:	80 91 d6 2d 	lds	r24, 0x2DD6	; 0x802dd6 <xNumOfOverflows>
    1986:	8f 5f       	subi	r24, 0xFF	; 255
    1988:	80 93 d6 2d 	sts	0x2DD6, r24	; 0x802dd6 <xNumOfOverflows>
    198c:	0e 94 76 0a 	call	0x14ec	; 0x14ec <prvResetNextTaskUnblockTime>
    1990:	80 91 d1 2d 	lds	r24, 0x2DD1	; 0x802dd1 <xNextTaskUnblockTime>
    1994:	90 91 d2 2d 	lds	r25, 0x2DD2	; 0x802dd2 <xNextTaskUnblockTime+0x1>
    1998:	a0 91 d3 2d 	lds	r26, 0x2DD3	; 0x802dd3 <xNextTaskUnblockTime+0x2>
    199c:	b0 91 d4 2d 	lds	r27, 0x2DD4	; 0x802dd4 <xNextTaskUnblockTime+0x3>
    19a0:	c8 16       	cp	r12, r24
    19a2:	d9 06       	cpc	r13, r25
    19a4:	ea 06       	cpc	r14, r26
    19a6:	fb 06       	cpc	r15, r27
    19a8:	10 f4       	brcc	.+4      	; 0x19ae <xTaskIncrementTick+0x9c>
    19aa:	b1 2c       	mov	r11, r1
    19ac:	5c c0       	rjmp	.+184    	; 0x1a66 <xTaskIncrementTick+0x154>
    19ae:	b1 2c       	mov	r11, r1
    19b0:	0f 2e       	mov	r0, r31
    19b2:	fb e0       	ldi	r31, 0x0B	; 11
    19b4:	af 2e       	mov	r10, r31
    19b6:	f0 2d       	mov	r31, r0
    19b8:	e0 91 f8 2d 	lds	r30, 0x2DF8	; 0x802df8 <pxDelayedTaskList>
    19bc:	f0 91 f9 2d 	lds	r31, 0x2DF9	; 0x802df9 <pxDelayedTaskList+0x1>
    19c0:	80 81       	ld	r24, Z
    19c2:	81 11       	cpse	r24, r1
    19c4:	0c c0       	rjmp	.+24     	; 0x19de <xTaskIncrementTick+0xcc>
    19c6:	8f ef       	ldi	r24, 0xFF	; 255
    19c8:	9f ef       	ldi	r25, 0xFF	; 255
    19ca:	dc 01       	movw	r26, r24
    19cc:	80 93 d1 2d 	sts	0x2DD1, r24	; 0x802dd1 <xNextTaskUnblockTime>
    19d0:	90 93 d2 2d 	sts	0x2DD2, r25	; 0x802dd2 <xNextTaskUnblockTime+0x1>
    19d4:	a0 93 d3 2d 	sts	0x2DD3, r26	; 0x802dd3 <xNextTaskUnblockTime+0x2>
    19d8:	b0 93 d4 2d 	sts	0x2DD4, r27	; 0x802dd4 <xNextTaskUnblockTime+0x3>
    19dc:	44 c0       	rjmp	.+136    	; 0x1a66 <xTaskIncrementTick+0x154>
    19de:	e0 91 f8 2d 	lds	r30, 0x2DF8	; 0x802df8 <pxDelayedTaskList>
    19e2:	f0 91 f9 2d 	lds	r31, 0x2DF9	; 0x802df9 <pxDelayedTaskList+0x1>
    19e6:	07 80       	ldd	r0, Z+7	; 0x07
    19e8:	f0 85       	ldd	r31, Z+8	; 0x08
    19ea:	e0 2d       	mov	r30, r0
    19ec:	c0 85       	ldd	r28, Z+8	; 0x08
    19ee:	d1 85       	ldd	r29, Z+9	; 0x09
    19f0:	8a 81       	ldd	r24, Y+2	; 0x02
    19f2:	9b 81       	ldd	r25, Y+3	; 0x03
    19f4:	ac 81       	ldd	r26, Y+4	; 0x04
    19f6:	bd 81       	ldd	r27, Y+5	; 0x05
    19f8:	c8 16       	cp	r12, r24
    19fa:	d9 06       	cpc	r13, r25
    19fc:	ea 06       	cpc	r14, r26
    19fe:	fb 06       	cpc	r15, r27
    1a00:	48 f4       	brcc	.+18     	; 0x1a14 <xTaskIncrementTick+0x102>
    1a02:	80 93 d1 2d 	sts	0x2DD1, r24	; 0x802dd1 <xNextTaskUnblockTime>
    1a06:	90 93 d2 2d 	sts	0x2DD2, r25	; 0x802dd2 <xNextTaskUnblockTime+0x1>
    1a0a:	a0 93 d3 2d 	sts	0x2DD3, r26	; 0x802dd3 <xNextTaskUnblockTime+0x2>
    1a0e:	b0 93 d4 2d 	sts	0x2DD4, r27	; 0x802dd4 <xNextTaskUnblockTime+0x3>
    1a12:	29 c0       	rjmp	.+82     	; 0x1a66 <xTaskIncrementTick+0x154>
    1a14:	8e 01       	movw	r16, r28
    1a16:	0e 5f       	subi	r16, 0xFE	; 254
    1a18:	1f 4f       	sbci	r17, 0xFF	; 255
    1a1a:	c8 01       	movw	r24, r16
    1a1c:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    1a20:	88 8d       	ldd	r24, Y+24	; 0x18
    1a22:	99 8d       	ldd	r25, Y+25	; 0x19
    1a24:	89 2b       	or	r24, r25
    1a26:	21 f0       	breq	.+8      	; 0x1a30 <xTaskIncrementTick+0x11e>
    1a28:	ce 01       	movw	r24, r28
    1a2a:	0e 96       	adiw	r24, 0x0e	; 14
    1a2c:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    1a30:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a32:	90 91 da 2d 	lds	r25, 0x2DDA	; 0x802dda <uxTopReadyPriority>
    1a36:	98 17       	cp	r25, r24
    1a38:	10 f4       	brcc	.+4      	; 0x1a3e <xTaskIncrementTick+0x12c>
    1a3a:	80 93 da 2d 	sts	0x2DDA, r24	; 0x802dda <uxTopReadyPriority>
    1a3e:	a8 9e       	mul	r10, r24
    1a40:	c0 01       	movw	r24, r0
    1a42:	11 24       	eor	r1, r1
    1a44:	b8 01       	movw	r22, r16
    1a46:	80 5f       	subi	r24, 0xF0	; 240
    1a48:	91 4d       	sbci	r25, 0xD1	; 209
    1a4a:	0e 94 39 05 	call	0xa72	; 0xa72 <vListInsertEnd>
    1a4e:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1a52:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1a56:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a58:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a5a:	98 17       	cp	r25, r24
    1a5c:	08 f4       	brcc	.+2      	; 0x1a60 <xTaskIncrementTick+0x14e>
    1a5e:	ac cf       	rjmp	.-168    	; 0x19b8 <xTaskIncrementTick+0xa6>
    1a60:	bb 24       	eor	r11, r11
    1a62:	b3 94       	inc	r11
    1a64:	a9 cf       	rjmp	.-174    	; 0x19b8 <xTaskIncrementTick+0xa6>
    1a66:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1a6a:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1a6e:	e2 8d       	ldd	r30, Z+26	; 0x1a
    1a70:	8b e0       	ldi	r24, 0x0B	; 11
    1a72:	e8 9f       	mul	r30, r24
    1a74:	f0 01       	movw	r30, r0
    1a76:	11 24       	eor	r1, r1
    1a78:	e0 5f       	subi	r30, 0xF0	; 240
    1a7a:	f1 4d       	sbci	r31, 0xD1	; 209
    1a7c:	80 81       	ld	r24, Z
    1a7e:	82 30       	cpi	r24, 0x02	; 2
    1a80:	48 f0       	brcs	.+18     	; 0x1a94 <xTaskIncrementTick+0x182>
    1a82:	bb 24       	eor	r11, r11
    1a84:	b3 94       	inc	r11
    1a86:	06 c0       	rjmp	.+12     	; 0x1a94 <xTaskIncrementTick+0x182>
    1a88:	80 91 d8 2d 	lds	r24, 0x2DD8	; 0x802dd8 <uxPendedTicks>
    1a8c:	8f 5f       	subi	r24, 0xFF	; 255
    1a8e:	80 93 d8 2d 	sts	0x2DD8, r24	; 0x802dd8 <uxPendedTicks>
    1a92:	b1 2c       	mov	r11, r1
    1a94:	80 91 d7 2d 	lds	r24, 0x2DD7	; 0x802dd7 <xYieldPending>
    1a98:	88 23       	and	r24, r24
    1a9a:	11 f0       	breq	.+4      	; 0x1aa0 <xTaskIncrementTick+0x18e>
    1a9c:	bb 24       	eor	r11, r11
    1a9e:	b3 94       	inc	r11
    1aa0:	8b 2d       	mov	r24, r11
    1aa2:	df 91       	pop	r29
    1aa4:	cf 91       	pop	r28
    1aa6:	1f 91       	pop	r17
    1aa8:	0f 91       	pop	r16
    1aaa:	ff 90       	pop	r15
    1aac:	ef 90       	pop	r14
    1aae:	df 90       	pop	r13
    1ab0:	cf 90       	pop	r12
    1ab2:	bf 90       	pop	r11
    1ab4:	af 90       	pop	r10
    1ab6:	08 95       	ret

00001ab8 <xTaskResumeAll>:
    1ab8:	cf 92       	push	r12
    1aba:	df 92       	push	r13
    1abc:	ef 92       	push	r14
    1abe:	ff 92       	push	r15
    1ac0:	0f 93       	push	r16
    1ac2:	1f 93       	push	r17
    1ac4:	cf 93       	push	r28
    1ac6:	df 93       	push	r29
    1ac8:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1acc:	ff 93       	push	r31
    1ace:	f8 7f       	andi	r31, 0xF8	; 248
    1ad0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1ad4:	80 91 ce 2d 	lds	r24, 0x2DCE	; 0x802dce <uxSchedulerSuspended>
    1ad8:	81 50       	subi	r24, 0x01	; 1
    1ada:	80 93 ce 2d 	sts	0x2DCE, r24	; 0x802dce <uxSchedulerSuspended>
    1ade:	80 91 ce 2d 	lds	r24, 0x2DCE	; 0x802dce <uxSchedulerSuspended>
    1ae2:	81 11       	cpse	r24, r1
    1ae4:	5c c0       	rjmp	.+184    	; 0x1b9e <xTaskResumeAll+0xe6>
    1ae6:	80 91 df 2d 	lds	r24, 0x2DDF	; 0x802ddf <uxCurrentNumberOfTasks>
    1aea:	81 11       	cpse	r24, r1
    1aec:	2c c0       	rjmp	.+88     	; 0x1b46 <xTaskResumeAll+0x8e>
    1aee:	5a c0       	rjmp	.+180    	; 0x1ba4 <xTaskResumeAll+0xec>
    1af0:	d7 01       	movw	r26, r14
    1af2:	17 96       	adiw	r26, 0x07	; 7
    1af4:	ed 91       	ld	r30, X+
    1af6:	fc 91       	ld	r31, X
    1af8:	18 97       	sbiw	r26, 0x08	; 8
    1afa:	c0 85       	ldd	r28, Z+8	; 0x08
    1afc:	d1 85       	ldd	r29, Z+9	; 0x09
    1afe:	ce 01       	movw	r24, r28
    1b00:	0e 96       	adiw	r24, 0x0e	; 14
    1b02:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    1b06:	8e 01       	movw	r16, r28
    1b08:	0e 5f       	subi	r16, 0xFE	; 254
    1b0a:	1f 4f       	sbci	r17, 0xFF	; 255
    1b0c:	c8 01       	movw	r24, r16
    1b0e:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    1b12:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b14:	90 91 da 2d 	lds	r25, 0x2DDA	; 0x802dda <uxTopReadyPriority>
    1b18:	98 17       	cp	r25, r24
    1b1a:	10 f4       	brcc	.+4      	; 0x1b20 <xTaskResumeAll+0x68>
    1b1c:	80 93 da 2d 	sts	0x2DDA, r24	; 0x802dda <uxTopReadyPriority>
    1b20:	d8 9e       	mul	r13, r24
    1b22:	c0 01       	movw	r24, r0
    1b24:	11 24       	eor	r1, r1
    1b26:	b8 01       	movw	r22, r16
    1b28:	80 5f       	subi	r24, 0xF0	; 240
    1b2a:	91 4d       	sbci	r25, 0xD1	; 209
    1b2c:	0e 94 39 05 	call	0xa72	; 0xa72 <vListInsertEnd>
    1b30:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1b34:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1b38:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b3a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b3c:	98 17       	cp	r25, r24
    1b3e:	88 f0       	brcs	.+34     	; 0x1b62 <xTaskResumeAll+0xaa>
    1b40:	c0 92 d7 2d 	sts	0x2DD7, r12	; 0x802dd7 <xYieldPending>
    1b44:	0e c0       	rjmp	.+28     	; 0x1b62 <xTaskResumeAll+0xaa>
    1b46:	c0 e0       	ldi	r28, 0x00	; 0
    1b48:	d0 e0       	ldi	r29, 0x00	; 0
    1b4a:	0f 2e       	mov	r0, r31
    1b4c:	fb ee       	ldi	r31, 0xEB	; 235
    1b4e:	ef 2e       	mov	r14, r31
    1b50:	fd e2       	ldi	r31, 0x2D	; 45
    1b52:	ff 2e       	mov	r15, r31
    1b54:	f0 2d       	mov	r31, r0
    1b56:	0f 2e       	mov	r0, r31
    1b58:	fb e0       	ldi	r31, 0x0B	; 11
    1b5a:	df 2e       	mov	r13, r31
    1b5c:	f0 2d       	mov	r31, r0
    1b5e:	cc 24       	eor	r12, r12
    1b60:	c3 94       	inc	r12
    1b62:	f7 01       	movw	r30, r14
    1b64:	80 81       	ld	r24, Z
    1b66:	81 11       	cpse	r24, r1
    1b68:	c3 cf       	rjmp	.-122    	; 0x1af0 <xTaskResumeAll+0x38>
    1b6a:	cd 2b       	or	r28, r29
    1b6c:	11 f0       	breq	.+4      	; 0x1b72 <xTaskResumeAll+0xba>
    1b6e:	0e 94 76 0a 	call	0x14ec	; 0x14ec <prvResetNextTaskUnblockTime>
    1b72:	c0 91 d8 2d 	lds	r28, 0x2DD8	; 0x802dd8 <uxPendedTicks>
    1b76:	cc 23       	and	r28, r28
    1b78:	51 f0       	breq	.+20     	; 0x1b8e <xTaskResumeAll+0xd6>
    1b7a:	d1 e0       	ldi	r29, 0x01	; 1
    1b7c:	0e 94 89 0c 	call	0x1912	; 0x1912 <xTaskIncrementTick>
    1b80:	81 11       	cpse	r24, r1
    1b82:	d0 93 d7 2d 	sts	0x2DD7, r29	; 0x802dd7 <xYieldPending>
    1b86:	c1 50       	subi	r28, 0x01	; 1
    1b88:	c9 f7       	brne	.-14     	; 0x1b7c <xTaskResumeAll+0xc4>
    1b8a:	10 92 d8 2d 	sts	0x2DD8, r1	; 0x802dd8 <uxPendedTicks>
    1b8e:	80 91 d7 2d 	lds	r24, 0x2DD7	; 0x802dd7 <xYieldPending>
    1b92:	88 23       	and	r24, r24
    1b94:	31 f0       	breq	.+12     	; 0x1ba2 <xTaskResumeAll+0xea>
    1b96:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    1b9a:	81 e0       	ldi	r24, 0x01	; 1
    1b9c:	03 c0       	rjmp	.+6      	; 0x1ba4 <xTaskResumeAll+0xec>
    1b9e:	80 e0       	ldi	r24, 0x00	; 0
    1ba0:	01 c0       	rjmp	.+2      	; 0x1ba4 <xTaskResumeAll+0xec>
    1ba2:	80 e0       	ldi	r24, 0x00	; 0
    1ba4:	ff 91       	pop	r31
    1ba6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1baa:	df 91       	pop	r29
    1bac:	cf 91       	pop	r28
    1bae:	1f 91       	pop	r17
    1bb0:	0f 91       	pop	r16
    1bb2:	ff 90       	pop	r15
    1bb4:	ef 90       	pop	r14
    1bb6:	df 90       	pop	r13
    1bb8:	cf 90       	pop	r12
    1bba:	08 95       	ret

00001bbc <vTaskDelay>:
    1bbc:	cf 92       	push	r12
    1bbe:	df 92       	push	r13
    1bc0:	ef 92       	push	r14
    1bc2:	ff 92       	push	r15
    1bc4:	6b 01       	movw	r12, r22
    1bc6:	7c 01       	movw	r14, r24
    1bc8:	67 2b       	or	r22, r23
    1bca:	68 2b       	or	r22, r24
    1bcc:	69 2b       	or	r22, r25
    1bce:	59 f0       	breq	.+22     	; 0x1be6 <vTaskDelay+0x2a>
    1bd0:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vTaskSuspendAll>
    1bd4:	40 e0       	ldi	r20, 0x00	; 0
    1bd6:	c7 01       	movw	r24, r14
    1bd8:	b6 01       	movw	r22, r12
    1bda:	0e 94 a0 0a 	call	0x1540	; 0x1540 <prvAddCurrentTaskToDelayedList>
    1bde:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
    1be2:	81 11       	cpse	r24, r1
    1be4:	02 c0       	rjmp	.+4      	; 0x1bea <vTaskDelay+0x2e>
    1be6:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    1bea:	ff 90       	pop	r15
    1bec:	ef 90       	pop	r14
    1bee:	df 90       	pop	r13
    1bf0:	cf 90       	pop	r12
    1bf2:	08 95       	ret

00001bf4 <vTaskSwitchContext>:
    1bf4:	80 91 ce 2d 	lds	r24, 0x2DCE	; 0x802dce <uxSchedulerSuspended>
    1bf8:	88 23       	and	r24, r24
    1bfa:	21 f0       	breq	.+8      	; 0x1c04 <vTaskSwitchContext+0x10>
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
    1bfe:	80 93 d7 2d 	sts	0x2DD7, r24	; 0x802dd7 <xYieldPending>
    1c02:	08 95       	ret
    1c04:	10 92 d7 2d 	sts	0x2DD7, r1	; 0x802dd7 <xYieldPending>
    1c08:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1c0c:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1c10:	03 8c       	ldd	r0, Z+27	; 0x1b
    1c12:	f4 8d       	ldd	r31, Z+28	; 0x1c
    1c14:	e0 2d       	mov	r30, r0
    1c16:	80 81       	ld	r24, Z
    1c18:	91 81       	ldd	r25, Z+1	; 0x01
    1c1a:	a2 81       	ldd	r26, Z+2	; 0x02
    1c1c:	b3 81       	ldd	r27, Z+3	; 0x03
    1c1e:	85 3a       	cpi	r24, 0xA5	; 165
    1c20:	95 4a       	sbci	r25, 0xA5	; 165
    1c22:	a5 4a       	sbci	r26, 0xA5	; 165
    1c24:	b5 4a       	sbci	r27, 0xA5	; 165
    1c26:	d9 f4       	brne	.+54     	; 0x1c5e <vTaskSwitchContext+0x6a>
    1c28:	84 81       	ldd	r24, Z+4	; 0x04
    1c2a:	95 81       	ldd	r25, Z+5	; 0x05
    1c2c:	a6 81       	ldd	r26, Z+6	; 0x06
    1c2e:	b7 81       	ldd	r27, Z+7	; 0x07
    1c30:	85 3a       	cpi	r24, 0xA5	; 165
    1c32:	95 4a       	sbci	r25, 0xA5	; 165
    1c34:	a5 4a       	sbci	r26, 0xA5	; 165
    1c36:	b5 4a       	sbci	r27, 0xA5	; 165
    1c38:	91 f4       	brne	.+36     	; 0x1c5e <vTaskSwitchContext+0x6a>
    1c3a:	80 85       	ldd	r24, Z+8	; 0x08
    1c3c:	91 85       	ldd	r25, Z+9	; 0x09
    1c3e:	a2 85       	ldd	r26, Z+10	; 0x0a
    1c40:	b3 85       	ldd	r27, Z+11	; 0x0b
    1c42:	85 3a       	cpi	r24, 0xA5	; 165
    1c44:	95 4a       	sbci	r25, 0xA5	; 165
    1c46:	a5 4a       	sbci	r26, 0xA5	; 165
    1c48:	b5 4a       	sbci	r27, 0xA5	; 165
    1c4a:	49 f4       	brne	.+18     	; 0x1c5e <vTaskSwitchContext+0x6a>
    1c4c:	84 85       	ldd	r24, Z+12	; 0x0c
    1c4e:	95 85       	ldd	r25, Z+13	; 0x0d
    1c50:	a6 85       	ldd	r26, Z+14	; 0x0e
    1c52:	b7 85       	ldd	r27, Z+15	; 0x0f
    1c54:	85 3a       	cpi	r24, 0xA5	; 165
    1c56:	95 4a       	sbci	r25, 0xA5	; 165
    1c58:	a5 4a       	sbci	r26, 0xA5	; 165
    1c5a:	b5 4a       	sbci	r27, 0xA5	; 165
    1c5c:	61 f0       	breq	.+24     	; 0x1c76 <vTaskSwitchContext+0x82>
    1c5e:	60 91 3c 2e 	lds	r22, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1c62:	70 91 3d 2e 	lds	r23, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1c66:	80 91 3c 2e 	lds	r24, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1c6a:	90 91 3d 2e 	lds	r25, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1c6e:	63 5e       	subi	r22, 0xE3	; 227
    1c70:	7f 4f       	sbci	r23, 0xFF	; 255
    1c72:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vApplicationStackOverflowHook>
    1c76:	80 91 da 2d 	lds	r24, 0x2DDA	; 0x802dda <uxTopReadyPriority>
    1c7a:	28 2f       	mov	r18, r24
    1c7c:	30 e0       	ldi	r19, 0x00	; 0
    1c7e:	9b e0       	ldi	r25, 0x0B	; 11
    1c80:	89 9f       	mul	r24, r25
    1c82:	f0 01       	movw	r30, r0
    1c84:	11 24       	eor	r1, r1
    1c86:	e0 5f       	subi	r30, 0xF0	; 240
    1c88:	f1 4d       	sbci	r31, 0xD1	; 209
    1c8a:	90 81       	ld	r25, Z
    1c8c:	91 11       	cpse	r25, r1
    1c8e:	0e c0       	rjmp	.+28     	; 0x1cac <vTaskSwitchContext+0xb8>
    1c90:	4b e0       	ldi	r20, 0x0B	; 11
    1c92:	81 50       	subi	r24, 0x01	; 1
    1c94:	28 2f       	mov	r18, r24
    1c96:	30 e0       	ldi	r19, 0x00	; 0
    1c98:	42 9f       	mul	r20, r18
    1c9a:	f0 01       	movw	r30, r0
    1c9c:	43 9f       	mul	r20, r19
    1c9e:	f0 0d       	add	r31, r0
    1ca0:	11 24       	eor	r1, r1
    1ca2:	e0 5f       	subi	r30, 0xF0	; 240
    1ca4:	f1 4d       	sbci	r31, 0xD1	; 209
    1ca6:	90 81       	ld	r25, Z
    1ca8:	99 23       	and	r25, r25
    1caa:	99 f3       	breq	.-26     	; 0x1c92 <vTaskSwitchContext+0x9e>
    1cac:	9b e0       	ldi	r25, 0x0B	; 11
    1cae:	92 9f       	mul	r25, r18
    1cb0:	a0 01       	movw	r20, r0
    1cb2:	93 9f       	mul	r25, r19
    1cb4:	50 0d       	add	r21, r0
    1cb6:	11 24       	eor	r1, r1
    1cb8:	da 01       	movw	r26, r20
    1cba:	a0 5f       	subi	r26, 0xF0	; 240
    1cbc:	b1 4d       	sbci	r27, 0xD1	; 209
    1cbe:	11 96       	adiw	r26, 0x01	; 1
    1cc0:	ed 91       	ld	r30, X+
    1cc2:	fc 91       	ld	r31, X
    1cc4:	12 97       	sbiw	r26, 0x02	; 2
    1cc6:	04 80       	ldd	r0, Z+4	; 0x04
    1cc8:	f5 81       	ldd	r31, Z+5	; 0x05
    1cca:	e0 2d       	mov	r30, r0
    1ccc:	11 96       	adiw	r26, 0x01	; 1
    1cce:	ed 93       	st	X+, r30
    1cd0:	fc 93       	st	X, r31
    1cd2:	12 97       	sbiw	r26, 0x02	; 2
    1cd4:	4d 5e       	subi	r20, 0xED	; 237
    1cd6:	51 4d       	sbci	r21, 0xD1	; 209
    1cd8:	e4 17       	cp	r30, r20
    1cda:	f5 07       	cpc	r31, r21
    1cdc:	29 f4       	brne	.+10     	; 0x1ce8 <vTaskSwitchContext+0xf4>
    1cde:	44 81       	ldd	r20, Z+4	; 0x04
    1ce0:	55 81       	ldd	r21, Z+5	; 0x05
    1ce2:	fd 01       	movw	r30, r26
    1ce4:	41 83       	std	Z+1, r20	; 0x01
    1ce6:	52 83       	std	Z+2, r21	; 0x02
    1ce8:	9b e0       	ldi	r25, 0x0B	; 11
    1cea:	92 9f       	mul	r25, r18
    1cec:	f0 01       	movw	r30, r0
    1cee:	93 9f       	mul	r25, r19
    1cf0:	f0 0d       	add	r31, r0
    1cf2:	11 24       	eor	r1, r1
    1cf4:	e0 5f       	subi	r30, 0xF0	; 240
    1cf6:	f1 4d       	sbci	r31, 0xD1	; 209
    1cf8:	01 80       	ldd	r0, Z+1	; 0x01
    1cfa:	f2 81       	ldd	r31, Z+2	; 0x02
    1cfc:	e0 2d       	mov	r30, r0
    1cfe:	20 85       	ldd	r18, Z+8	; 0x08
    1d00:	31 85       	ldd	r19, Z+9	; 0x09
    1d02:	20 93 3c 2e 	sts	0x2E3C, r18	; 0x802e3c <pxCurrentTCB>
    1d06:	30 93 3d 2e 	sts	0x2E3D, r19	; 0x802e3d <pxCurrentTCB+0x1>
    1d0a:	80 93 da 2d 	sts	0x2DDA, r24	; 0x802dda <uxTopReadyPriority>
    1d0e:	08 95       	ret

00001d10 <vTaskPlaceOnEventList>:
    1d10:	cf 92       	push	r12
    1d12:	df 92       	push	r13
    1d14:	ef 92       	push	r14
    1d16:	ff 92       	push	r15
    1d18:	6a 01       	movw	r12, r20
    1d1a:	7b 01       	movw	r14, r22
    1d1c:	60 91 3c 2e 	lds	r22, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1d20:	70 91 3d 2e 	lds	r23, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1d24:	62 5f       	subi	r22, 0xF2	; 242
    1d26:	7f 4f       	sbci	r23, 0xFF	; 255
    1d28:	0e 94 5a 05 	call	0xab4	; 0xab4 <vListInsert>
    1d2c:	41 e0       	ldi	r20, 0x01	; 1
    1d2e:	c7 01       	movw	r24, r14
    1d30:	b6 01       	movw	r22, r12
    1d32:	0e 94 a0 0a 	call	0x1540	; 0x1540 <prvAddCurrentTaskToDelayedList>
    1d36:	ff 90       	pop	r15
    1d38:	ef 90       	pop	r14
    1d3a:	df 90       	pop	r13
    1d3c:	cf 90       	pop	r12
    1d3e:	08 95       	ret

00001d40 <vTaskPlaceOnUnorderedEventList>:
    1d40:	cf 92       	push	r12
    1d42:	df 92       	push	r13
    1d44:	ef 92       	push	r14
    1d46:	ff 92       	push	r15
    1d48:	0f 93       	push	r16
    1d4a:	1f 93       	push	r17
    1d4c:	68 01       	movw	r12, r16
    1d4e:	79 01       	movw	r14, r18
    1d50:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1d54:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1d58:	70 68       	ori	r23, 0x80	; 128
    1d5a:	46 87       	std	Z+14, r20	; 0x0e
    1d5c:	57 87       	std	Z+15, r21	; 0x0f
    1d5e:	60 8b       	std	Z+16, r22	; 0x10
    1d60:	71 8b       	std	Z+17, r23	; 0x11
    1d62:	60 91 3c 2e 	lds	r22, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1d66:	70 91 3d 2e 	lds	r23, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1d6a:	62 5f       	subi	r22, 0xF2	; 242
    1d6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d6e:	0e 94 39 05 	call	0xa72	; 0xa72 <vListInsertEnd>
    1d72:	41 e0       	ldi	r20, 0x01	; 1
    1d74:	c7 01       	movw	r24, r14
    1d76:	b6 01       	movw	r22, r12
    1d78:	0e 94 a0 0a 	call	0x1540	; 0x1540 <prvAddCurrentTaskToDelayedList>
    1d7c:	1f 91       	pop	r17
    1d7e:	0f 91       	pop	r16
    1d80:	ff 90       	pop	r15
    1d82:	ef 90       	pop	r14
    1d84:	df 90       	pop	r13
    1d86:	cf 90       	pop	r12
    1d88:	08 95       	ret

00001d8a <vTaskPlaceOnEventListRestricted>:
    1d8a:	cf 92       	push	r12
    1d8c:	df 92       	push	r13
    1d8e:	ef 92       	push	r14
    1d90:	ff 92       	push	r15
    1d92:	cf 93       	push	r28
    1d94:	6a 01       	movw	r12, r20
    1d96:	7b 01       	movw	r14, r22
    1d98:	c2 2f       	mov	r28, r18
    1d9a:	60 91 3c 2e 	lds	r22, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1d9e:	70 91 3d 2e 	lds	r23, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1da2:	62 5f       	subi	r22, 0xF2	; 242
    1da4:	7f 4f       	sbci	r23, 0xFF	; 255
    1da6:	0e 94 39 05 	call	0xa72	; 0xa72 <vListInsertEnd>
    1daa:	cc 23       	and	r28, r28
    1dac:	21 f0       	breq	.+8      	; 0x1db6 <vTaskPlaceOnEventListRestricted+0x2c>
    1dae:	cc 24       	eor	r12, r12
    1db0:	ca 94       	dec	r12
    1db2:	dc 2c       	mov	r13, r12
    1db4:	76 01       	movw	r14, r12
    1db6:	4c 2f       	mov	r20, r28
    1db8:	c7 01       	movw	r24, r14
    1dba:	b6 01       	movw	r22, r12
    1dbc:	0e 94 a0 0a 	call	0x1540	; 0x1540 <prvAddCurrentTaskToDelayedList>
    1dc0:	cf 91       	pop	r28
    1dc2:	ff 90       	pop	r15
    1dc4:	ef 90       	pop	r14
    1dc6:	df 90       	pop	r13
    1dc8:	cf 90       	pop	r12
    1dca:	08 95       	ret

00001dcc <xTaskRemoveFromEventList>:
    1dcc:	0f 93       	push	r16
    1dce:	1f 93       	push	r17
    1dd0:	cf 93       	push	r28
    1dd2:	df 93       	push	r29
    1dd4:	dc 01       	movw	r26, r24
    1dd6:	17 96       	adiw	r26, 0x07	; 7
    1dd8:	ed 91       	ld	r30, X+
    1dda:	fc 91       	ld	r31, X
    1ddc:	18 97       	sbiw	r26, 0x08	; 8
    1dde:	c0 85       	ldd	r28, Z+8	; 0x08
    1de0:	d1 85       	ldd	r29, Z+9	; 0x09
    1de2:	8e 01       	movw	r16, r28
    1de4:	02 5f       	subi	r16, 0xF2	; 242
    1de6:	1f 4f       	sbci	r17, 0xFF	; 255
    1de8:	c8 01       	movw	r24, r16
    1dea:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    1dee:	80 91 ce 2d 	lds	r24, 0x2DCE	; 0x802dce <uxSchedulerSuspended>
    1df2:	81 11       	cpse	r24, r1
    1df4:	16 c0       	rjmp	.+44     	; 0x1e22 <xTaskRemoveFromEventList+0x56>
    1df6:	0c 50       	subi	r16, 0x0C	; 12
    1df8:	11 09       	sbc	r17, r1
    1dfa:	c8 01       	movw	r24, r16
    1dfc:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    1e00:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e02:	90 91 da 2d 	lds	r25, 0x2DDA	; 0x802dda <uxTopReadyPriority>
    1e06:	98 17       	cp	r25, r24
    1e08:	10 f4       	brcc	.+4      	; 0x1e0e <xTaskRemoveFromEventList+0x42>
    1e0a:	80 93 da 2d 	sts	0x2DDA, r24	; 0x802dda <uxTopReadyPriority>
    1e0e:	bb e0       	ldi	r27, 0x0B	; 11
    1e10:	8b 9f       	mul	r24, r27
    1e12:	c0 01       	movw	r24, r0
    1e14:	11 24       	eor	r1, r1
    1e16:	b8 01       	movw	r22, r16
    1e18:	80 5f       	subi	r24, 0xF0	; 240
    1e1a:	91 4d       	sbci	r25, 0xD1	; 209
    1e1c:	0e 94 39 05 	call	0xa72	; 0xa72 <vListInsertEnd>
    1e20:	05 c0       	rjmp	.+10     	; 0x1e2c <xTaskRemoveFromEventList+0x60>
    1e22:	b8 01       	movw	r22, r16
    1e24:	8b ee       	ldi	r24, 0xEB	; 235
    1e26:	9d e2       	ldi	r25, 0x2D	; 45
    1e28:	0e 94 39 05 	call	0xa72	; 0xa72 <vListInsertEnd>
    1e2c:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1e30:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1e34:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e36:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e38:	89 17       	cp	r24, r25
    1e3a:	20 f4       	brcc	.+8      	; 0x1e44 <xTaskRemoveFromEventList+0x78>
    1e3c:	81 e0       	ldi	r24, 0x01	; 1
    1e3e:	80 93 d7 2d 	sts	0x2DD7, r24	; 0x802dd7 <xYieldPending>
    1e42:	01 c0       	rjmp	.+2      	; 0x1e46 <xTaskRemoveFromEventList+0x7a>
    1e44:	80 e0       	ldi	r24, 0x00	; 0
    1e46:	df 91       	pop	r29
    1e48:	cf 91       	pop	r28
    1e4a:	1f 91       	pop	r17
    1e4c:	0f 91       	pop	r16
    1e4e:	08 95       	ret

00001e50 <vTaskRemoveFromUnorderedEventList>:
    1e50:	0f 93       	push	r16
    1e52:	1f 93       	push	r17
    1e54:	cf 93       	push	r28
    1e56:	df 93       	push	r29
    1e58:	70 68       	ori	r23, 0x80	; 128
    1e5a:	fc 01       	movw	r30, r24
    1e5c:	40 83       	st	Z, r20
    1e5e:	51 83       	std	Z+1, r21	; 0x01
    1e60:	62 83       	std	Z+2, r22	; 0x02
    1e62:	73 83       	std	Z+3, r23	; 0x03
    1e64:	c0 85       	ldd	r28, Z+8	; 0x08
    1e66:	d1 85       	ldd	r29, Z+9	; 0x09
    1e68:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    1e6c:	8e 01       	movw	r16, r28
    1e6e:	0e 5f       	subi	r16, 0xFE	; 254
    1e70:	1f 4f       	sbci	r17, 0xFF	; 255
    1e72:	c8 01       	movw	r24, r16
    1e74:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    1e78:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e7a:	90 91 da 2d 	lds	r25, 0x2DDA	; 0x802dda <uxTopReadyPriority>
    1e7e:	98 17       	cp	r25, r24
    1e80:	10 f4       	brcc	.+4      	; 0x1e86 <vTaskRemoveFromUnorderedEventList+0x36>
    1e82:	80 93 da 2d 	sts	0x2DDA, r24	; 0x802dda <uxTopReadyPriority>
    1e86:	fb e0       	ldi	r31, 0x0B	; 11
    1e88:	8f 9f       	mul	r24, r31
    1e8a:	c0 01       	movw	r24, r0
    1e8c:	11 24       	eor	r1, r1
    1e8e:	b8 01       	movw	r22, r16
    1e90:	80 5f       	subi	r24, 0xF0	; 240
    1e92:	91 4d       	sbci	r25, 0xD1	; 209
    1e94:	0e 94 39 05 	call	0xa72	; 0xa72 <vListInsertEnd>
    1e98:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1e9c:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1ea0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1ea2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ea4:	89 17       	cp	r24, r25
    1ea6:	18 f4       	brcc	.+6      	; 0x1eae <vTaskRemoveFromUnorderedEventList+0x5e>
    1ea8:	81 e0       	ldi	r24, 0x01	; 1
    1eaa:	80 93 d7 2d 	sts	0x2DD7, r24	; 0x802dd7 <xYieldPending>
    1eae:	df 91       	pop	r29
    1eb0:	cf 91       	pop	r28
    1eb2:	1f 91       	pop	r17
    1eb4:	0f 91       	pop	r16
    1eb6:	08 95       	ret

00001eb8 <vTaskInternalSetTimeOutState>:
    1eb8:	20 91 d6 2d 	lds	r18, 0x2DD6	; 0x802dd6 <xNumOfOverflows>
    1ebc:	fc 01       	movw	r30, r24
    1ebe:	20 83       	st	Z, r18
    1ec0:	40 91 db 2d 	lds	r20, 0x2DDB	; 0x802ddb <xTickCount>
    1ec4:	50 91 dc 2d 	lds	r21, 0x2DDC	; 0x802ddc <xTickCount+0x1>
    1ec8:	60 91 dd 2d 	lds	r22, 0x2DDD	; 0x802ddd <xTickCount+0x2>
    1ecc:	70 91 de 2d 	lds	r23, 0x2DDE	; 0x802dde <xTickCount+0x3>
    1ed0:	41 83       	std	Z+1, r20	; 0x01
    1ed2:	52 83       	std	Z+2, r21	; 0x02
    1ed4:	63 83       	std	Z+3, r22	; 0x03
    1ed6:	74 83       	std	Z+4, r23	; 0x04
    1ed8:	08 95       	ret

00001eda <xTaskCheckForTimeOut>:
    1eda:	cf 92       	push	r12
    1edc:	df 92       	push	r13
    1ede:	ef 92       	push	r14
    1ee0:	ff 92       	push	r15
    1ee2:	0f 93       	push	r16
    1ee4:	1f 93       	push	r17
    1ee6:	cf 93       	push	r28
    1ee8:	df 93       	push	r29
    1eea:	db 01       	movw	r26, r22
    1eec:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1ef0:	ff 93       	push	r31
    1ef2:	f8 7f       	andi	r31, 0xF8	; 248
    1ef4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1ef8:	40 91 db 2d 	lds	r20, 0x2DDB	; 0x802ddb <xTickCount>
    1efc:	50 91 dc 2d 	lds	r21, 0x2DDC	; 0x802ddc <xTickCount+0x1>
    1f00:	60 91 dd 2d 	lds	r22, 0x2DDD	; 0x802ddd <xTickCount+0x2>
    1f04:	70 91 de 2d 	lds	r23, 0x2DDE	; 0x802dde <xTickCount+0x3>
    1f08:	0d 91       	ld	r16, X+
    1f0a:	1d 91       	ld	r17, X+
    1f0c:	2d 91       	ld	r18, X+
    1f0e:	3c 91       	ld	r19, X
    1f10:	13 97       	sbiw	r26, 0x03	; 3
    1f12:	0f 3f       	cpi	r16, 0xFF	; 255
    1f14:	cf ef       	ldi	r28, 0xFF	; 255
    1f16:	1c 07       	cpc	r17, r28
    1f18:	2c 07       	cpc	r18, r28
    1f1a:	3c 07       	cpc	r19, r28
    1f1c:	69 f1       	breq	.+90     	; 0x1f78 <xTaskCheckForTimeOut+0x9e>
    1f1e:	fc 01       	movw	r30, r24
    1f20:	c1 80       	ldd	r12, Z+1	; 0x01
    1f22:	d2 80       	ldd	r13, Z+2	; 0x02
    1f24:	e3 80       	ldd	r14, Z+3	; 0x03
    1f26:	f4 80       	ldd	r15, Z+4	; 0x04
    1f28:	e0 91 d6 2d 	lds	r30, 0x2DD6	; 0x802dd6 <xNumOfOverflows>
    1f2c:	ec 01       	movw	r28, r24
    1f2e:	f8 81       	ld	r31, Y
    1f30:	fe 17       	cp	r31, r30
    1f32:	29 f0       	breq	.+10     	; 0x1f3e <xTaskCheckForTimeOut+0x64>
    1f34:	4c 15       	cp	r20, r12
    1f36:	5d 05       	cpc	r21, r13
    1f38:	6e 05       	cpc	r22, r14
    1f3a:	7f 05       	cpc	r23, r15
    1f3c:	f8 f4       	brcc	.+62     	; 0x1f7c <xTaskCheckForTimeOut+0xa2>
    1f3e:	4c 19       	sub	r20, r12
    1f40:	5d 09       	sbc	r21, r13
    1f42:	6e 09       	sbc	r22, r14
    1f44:	7f 09       	sbc	r23, r15
    1f46:	40 17       	cp	r20, r16
    1f48:	51 07       	cpc	r21, r17
    1f4a:	62 07       	cpc	r22, r18
    1f4c:	73 07       	cpc	r23, r19
    1f4e:	68 f4       	brcc	.+26     	; 0x1f6a <xTaskCheckForTimeOut+0x90>
    1f50:	fd 01       	movw	r30, r26
    1f52:	04 1b       	sub	r16, r20
    1f54:	15 0b       	sbc	r17, r21
    1f56:	26 0b       	sbc	r18, r22
    1f58:	37 0b       	sbc	r19, r23
    1f5a:	00 83       	st	Z, r16
    1f5c:	11 83       	std	Z+1, r17	; 0x01
    1f5e:	22 83       	std	Z+2, r18	; 0x02
    1f60:	33 83       	std	Z+3, r19	; 0x03
    1f62:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vTaskInternalSetTimeOutState>
    1f66:	80 e0       	ldi	r24, 0x00	; 0
    1f68:	0a c0       	rjmp	.+20     	; 0x1f7e <xTaskCheckForTimeOut+0xa4>
    1f6a:	1d 92       	st	X+, r1
    1f6c:	1d 92       	st	X+, r1
    1f6e:	1d 92       	st	X+, r1
    1f70:	1c 92       	st	X, r1
    1f72:	13 97       	sbiw	r26, 0x03	; 3
    1f74:	81 e0       	ldi	r24, 0x01	; 1
    1f76:	03 c0       	rjmp	.+6      	; 0x1f7e <xTaskCheckForTimeOut+0xa4>
    1f78:	80 e0       	ldi	r24, 0x00	; 0
    1f7a:	01 c0       	rjmp	.+2      	; 0x1f7e <xTaskCheckForTimeOut+0xa4>
    1f7c:	81 e0       	ldi	r24, 0x01	; 1
    1f7e:	ff 91       	pop	r31
    1f80:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f84:	df 91       	pop	r29
    1f86:	cf 91       	pop	r28
    1f88:	1f 91       	pop	r17
    1f8a:	0f 91       	pop	r16
    1f8c:	ff 90       	pop	r15
    1f8e:	ef 90       	pop	r14
    1f90:	df 90       	pop	r13
    1f92:	cf 90       	pop	r12
    1f94:	08 95       	ret

00001f96 <vTaskMissedYield>:
    1f96:	81 e0       	ldi	r24, 0x01	; 1
    1f98:	80 93 d7 2d 	sts	0x2DD7, r24	; 0x802dd7 <xYieldPending>
    1f9c:	08 95       	ret

00001f9e <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    1f9e:	80 91 d9 2d 	lds	r24, 0x2DD9	; 0x802dd9 <xSchedulerRunning>
    1fa2:	88 23       	and	r24, r24
    1fa4:	31 f0       	breq	.+12     	; 0x1fb2 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1fa6:	80 91 ce 2d 	lds	r24, 0x2DCE	; 0x802dce <uxSchedulerSuspended>
    1faa:	88 23       	and	r24, r24
    1fac:	21 f0       	breq	.+8      	; 0x1fb6 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1fae:	80 e0       	ldi	r24, 0x00	; 0
    1fb0:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1fb2:	81 e0       	ldi	r24, 0x01	; 1
    1fb4:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    1fb6:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    1fb8:	08 95       	ret

00001fba <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    1fba:	cf 92       	push	r12
    1fbc:	df 92       	push	r13
    1fbe:	ef 92       	push	r14
    1fc0:	ff 92       	push	r15
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1fc2:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1fc6:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1fca:	66 85       	ldd	r22, Z+14	; 0x0e
    1fcc:	77 85       	ldd	r23, Z+15	; 0x0f
    1fce:	80 89       	ldd	r24, Z+16	; 0x10
    1fd0:	91 89       	ldd	r25, Z+17	; 0x11

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1fd2:	e0 91 3c 2e 	lds	r30, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1fd6:	f0 91 3d 2e 	lds	r31, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1fda:	a0 91 3c 2e 	lds	r26, 0x2E3C	; 0x802e3c <pxCurrentTCB>
    1fde:	b0 91 3d 2e 	lds	r27, 0x2E3D	; 0x802e3d <pxCurrentTCB+0x1>
    1fe2:	5a 96       	adiw	r26, 0x1a	; 26
    1fe4:	2c 91       	ld	r18, X
    1fe6:	c1 2c       	mov	r12, r1
    1fe8:	d1 2c       	mov	r13, r1
    1fea:	76 01       	movw	r14, r12
    1fec:	68 94       	set
    1fee:	c2 f8       	bld	r12, 2
    1ff0:	c2 1a       	sub	r12, r18
    1ff2:	d1 08       	sbc	r13, r1
    1ff4:	e1 08       	sbc	r14, r1
    1ff6:	f1 08       	sbc	r15, r1
    1ff8:	c6 86       	std	Z+14, r12	; 0x0e
    1ffa:	d7 86       	std	Z+15, r13	; 0x0f
    1ffc:	e0 8a       	std	Z+16, r14	; 0x10
    1ffe:	f1 8a       	std	Z+17, r15	; 0x11

	return uxReturn;
}
    2000:	ff 90       	pop	r15
    2002:	ef 90       	pop	r14
    2004:	df 90       	pop	r13
    2006:	cf 90       	pop	r12
    2008:	08 95       	ret

0000200a <prvInsertTimerInActiveList>:

	taskENTER_CRITICAL();
	{
		pxTimer->pvTimerID = pvNewID;
	}
	taskEXIT_CRITICAL();
    200a:	cf 92       	push	r12
    200c:	df 92       	push	r13
    200e:	ef 92       	push	r14
    2010:	ff 92       	push	r15
    2012:	0f 93       	push	r16
    2014:	1f 93       	push	r17
    2016:	fc 01       	movw	r30, r24
    2018:	42 83       	std	Z+2, r20	; 0x02
    201a:	53 83       	std	Z+3, r21	; 0x03
    201c:	64 83       	std	Z+4, r22	; 0x04
    201e:	75 83       	std	Z+5, r23	; 0x05
    2020:	82 87       	std	Z+10, r24	; 0x0a
    2022:	93 87       	std	Z+11, r25	; 0x0b
    2024:	04 17       	cp	r16, r20
    2026:	15 07       	cpc	r17, r21
    2028:	26 07       	cpc	r18, r22
    202a:	37 07       	cpc	r19, r23
    202c:	c0 f0       	brcs	.+48     	; 0x205e <prvInsertTimerInActiveList+0x54>
    202e:	0c 19       	sub	r16, r12
    2030:	1d 09       	sbc	r17, r13
    2032:	2e 09       	sbc	r18, r14
    2034:	3f 09       	sbc	r19, r15
    2036:	86 85       	ldd	r24, Z+14	; 0x0e
    2038:	97 85       	ldd	r25, Z+15	; 0x0f
    203a:	a0 89       	ldd	r26, Z+16	; 0x10
    203c:	b1 89       	ldd	r27, Z+17	; 0x11
    203e:	08 17       	cp	r16, r24
    2040:	19 07       	cpc	r17, r25
    2042:	2a 07       	cpc	r18, r26
    2044:	3b 07       	cpc	r19, r27
    2046:	00 f5       	brcc	.+64     	; 0x2088 <prvInsertTimerInActiveList+0x7e>
    2048:	bf 01       	movw	r22, r30
    204a:	6e 5f       	subi	r22, 0xFE	; 254
    204c:	7f 4f       	sbci	r23, 0xFF	; 255
    204e:	80 91 46 2e 	lds	r24, 0x2E46	; 0x802e46 <pxOverflowTimerList>
    2052:	90 91 47 2e 	lds	r25, 0x2E47	; 0x802e47 <pxOverflowTimerList+0x1>
    2056:	0e 94 5a 05 	call	0xab4	; 0xab4 <vListInsert>
    205a:	80 e0       	ldi	r24, 0x00	; 0
    205c:	18 c0       	rjmp	.+48     	; 0x208e <prvInsertTimerInActiveList+0x84>
    205e:	0c 15       	cp	r16, r12
    2060:	1d 05       	cpc	r17, r13
    2062:	2e 05       	cpc	r18, r14
    2064:	3f 05       	cpc	r19, r15
    2066:	28 f4       	brcc	.+10     	; 0x2072 <prvInsertTimerInActiveList+0x68>
    2068:	4c 15       	cp	r20, r12
    206a:	5d 05       	cpc	r21, r13
    206c:	6e 05       	cpc	r22, r14
    206e:	7f 05       	cpc	r23, r15
    2070:	68 f4       	brcc	.+26     	; 0x208c <prvInsertTimerInActiveList+0x82>
    2072:	bf 01       	movw	r22, r30
    2074:	6e 5f       	subi	r22, 0xFE	; 254
    2076:	7f 4f       	sbci	r23, 0xFF	; 255
    2078:	80 91 48 2e 	lds	r24, 0x2E48	; 0x802e48 <pxCurrentTimerList>
    207c:	90 91 49 2e 	lds	r25, 0x2E49	; 0x802e49 <pxCurrentTimerList+0x1>
    2080:	0e 94 5a 05 	call	0xab4	; 0xab4 <vListInsert>
    2084:	80 e0       	ldi	r24, 0x00	; 0
    2086:	03 c0       	rjmp	.+6      	; 0x208e <prvInsertTimerInActiveList+0x84>
    2088:	81 e0       	ldi	r24, 0x01	; 1
    208a:	01 c0       	rjmp	.+2      	; 0x208e <prvInsertTimerInActiveList+0x84>
    208c:	81 e0       	ldi	r24, 0x01	; 1
    208e:	1f 91       	pop	r17
    2090:	0f 91       	pop	r16
    2092:	ff 90       	pop	r15
    2094:	ef 90       	pop	r14
    2096:	df 90       	pop	r13
    2098:	cf 90       	pop	r12
    209a:	08 95       	ret

0000209c <prvCheckForValidListAndQueue>:
    209c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    20a0:	ff 93       	push	r31
    20a2:	f8 7f       	andi	r31, 0xF8	; 248
    20a4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    20a8:	80 91 44 2e 	lds	r24, 0x2E44	; 0x802e44 <xTimerQueue>
    20ac:	90 91 45 2e 	lds	r25, 0x2E45	; 0x802e45 <xTimerQueue+0x1>
    20b0:	89 2b       	or	r24, r25
    20b2:	e9 f4       	brne	.+58     	; 0x20ee <prvCheckForValidListAndQueue+0x52>
    20b4:	85 e5       	ldi	r24, 0x55	; 85
    20b6:	9e e2       	ldi	r25, 0x2E	; 46
    20b8:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    20bc:	8a e4       	ldi	r24, 0x4A	; 74
    20be:	9e e2       	ldi	r25, 0x2E	; 46
    20c0:	0e 94 24 05 	call	0xa48	; 0xa48 <vListInitialise>
    20c4:	85 e5       	ldi	r24, 0x55	; 85
    20c6:	9e e2       	ldi	r25, 0x2E	; 46
    20c8:	80 93 48 2e 	sts	0x2E48, r24	; 0x802e48 <pxCurrentTimerList>
    20cc:	90 93 49 2e 	sts	0x2E49, r25	; 0x802e49 <pxCurrentTimerList+0x1>
    20d0:	8a e4       	ldi	r24, 0x4A	; 74
    20d2:	9e e2       	ldi	r25, 0x2E	; 46
    20d4:	80 93 46 2e 	sts	0x2E46, r24	; 0x802e46 <pxOverflowTimerList>
    20d8:	90 93 47 2e 	sts	0x2E47, r25	; 0x802e47 <pxOverflowTimerList+0x1>
    20dc:	40 e0       	ldi	r20, 0x00	; 0
    20de:	69 e0       	ldi	r22, 0x09	; 9
    20e0:	85 e0       	ldi	r24, 0x05	; 5
    20e2:	0e 94 87 08 	call	0x110e	; 0x110e <xQueueGenericCreate>
    20e6:	80 93 44 2e 	sts	0x2E44, r24	; 0x802e44 <xTimerQueue>
    20ea:	90 93 45 2e 	sts	0x2E45, r25	; 0x802e45 <xTimerQueue+0x1>
    20ee:	ff 91       	pop	r31
    20f0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    20f4:	08 95       	ret

000020f6 <xTimerCreateTimerTask>:
    20f6:	ef 92       	push	r14
    20f8:	ff 92       	push	r15
    20fa:	0f 93       	push	r16
    20fc:	0e 94 4e 10 	call	0x209c	; 0x209c <prvCheckForValidListAndQueue>
    2100:	80 91 44 2e 	lds	r24, 0x2E44	; 0x802e44 <xTimerQueue>
    2104:	90 91 45 2e 	lds	r25, 0x2E45	; 0x802e45 <xTimerQueue+0x1>
    2108:	89 2b       	or	r24, r25
    210a:	91 f0       	breq	.+36     	; 0x2130 <xTimerCreateTimerTask+0x3a>
    210c:	0f 2e       	mov	r0, r31
    210e:	f2 e4       	ldi	r31, 0x42	; 66
    2110:	ef 2e       	mov	r14, r31
    2112:	fe e2       	ldi	r31, 0x2E	; 46
    2114:	ff 2e       	mov	r15, r31
    2116:	f0 2d       	mov	r31, r0
    2118:	03 e0       	ldi	r16, 0x03	; 3
    211a:	20 e0       	ldi	r18, 0x00	; 0
    211c:	30 e0       	ldi	r19, 0x00	; 0
    211e:	48 ec       	ldi	r20, 0xC8	; 200
    2120:	50 e0       	ldi	r21, 0x00	; 0
    2122:	68 e8       	ldi	r22, 0x88	; 136
    2124:	71 e2       	ldi	r23, 0x21	; 33
    2126:	8e e8       	ldi	r24, 0x8E	; 142
    2128:	91 e1       	ldi	r25, 0x11	; 17
    212a:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTaskCreate>
    212e:	01 c0       	rjmp	.+2      	; 0x2132 <xTimerCreateTimerTask+0x3c>
    2130:	80 e0       	ldi	r24, 0x00	; 0
    2132:	0f 91       	pop	r16
    2134:	ff 90       	pop	r15
    2136:	ef 90       	pop	r14
    2138:	08 95       	ret

0000213a <xTimerGenericCommand>:
    213a:	8f 92       	push	r8
    213c:	9f 92       	push	r9
    213e:	af 92       	push	r10
    2140:	bf 92       	push	r11
    2142:	cf 92       	push	r12
    2144:	df 92       	push	r13
    2146:	ef 92       	push	r14
    2148:	ff 92       	push	r15
    214a:	0f 93       	push	r16
    214c:	1f 93       	push	r17
    214e:	cf 93       	push	r28
    2150:	df 93       	push	r29
    2152:	cd b7       	in	r28, 0x3d	; 61
    2154:	de b7       	in	r29, 0x3e	; 62
    2156:	29 97       	sbiw	r28, 0x09	; 9
    2158:	cd bf       	out	0x3d, r28	; 61
    215a:	de bf       	out	0x3e, r29	; 62
    215c:	e0 91 44 2e 	lds	r30, 0x2E44	; 0x802e44 <xTimerQueue>
    2160:	f0 91 45 2e 	lds	r31, 0x2E45	; 0x802e45 <xTimerQueue+0x1>
    2164:	30 97       	sbiw	r30, 0x00	; 0
    2166:	89 f1       	breq	.+98     	; 0x21ca <xTimerGenericCommand+0x90>
    2168:	69 83       	std	Y+1, r22	; 0x01
    216a:	2a 83       	std	Y+2, r18	; 0x02
    216c:	3b 83       	std	Y+3, r19	; 0x03
    216e:	4c 83       	std	Y+4, r20	; 0x04
    2170:	5d 83       	std	Y+5, r21	; 0x05
    2172:	8e 83       	std	Y+6, r24	; 0x06
    2174:	9f 83       	std	Y+7, r25	; 0x07
    2176:	66 30       	cpi	r22, 0x06	; 6
    2178:	fc f4       	brge	.+62     	; 0x21b8 <xTimerGenericCommand+0x7e>
    217a:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <xTaskGetSchedulerState>
    217e:	82 30       	cpi	r24, 0x02	; 2
    2180:	69 f4       	brne	.+26     	; 0x219c <xTimerGenericCommand+0x62>
    2182:	00 e0       	ldi	r16, 0x00	; 0
    2184:	a7 01       	movw	r20, r14
    2186:	96 01       	movw	r18, r12
    2188:	be 01       	movw	r22, r28
    218a:	6f 5f       	subi	r22, 0xFF	; 255
    218c:	7f 4f       	sbci	r23, 0xFF	; 255
    218e:	80 91 44 2e 	lds	r24, 0x2E44	; 0x802e44 <xTimerQueue>
    2192:	90 91 45 2e 	lds	r25, 0x2E45	; 0x802e45 <xTimerQueue+0x1>
    2196:	0e 94 b8 08 	call	0x1170	; 0x1170 <xQueueGenericSend>
    219a:	18 c0       	rjmp	.+48     	; 0x21cc <xTimerGenericCommand+0x92>
    219c:	00 e0       	ldi	r16, 0x00	; 0
    219e:	20 e0       	ldi	r18, 0x00	; 0
    21a0:	30 e0       	ldi	r19, 0x00	; 0
    21a2:	a9 01       	movw	r20, r18
    21a4:	be 01       	movw	r22, r28
    21a6:	6f 5f       	subi	r22, 0xFF	; 255
    21a8:	7f 4f       	sbci	r23, 0xFF	; 255
    21aa:	80 91 44 2e 	lds	r24, 0x2E44	; 0x802e44 <xTimerQueue>
    21ae:	90 91 45 2e 	lds	r25, 0x2E45	; 0x802e45 <xTimerQueue+0x1>
    21b2:	0e 94 b8 08 	call	0x1170	; 0x1170 <xQueueGenericSend>
    21b6:	0a c0       	rjmp	.+20     	; 0x21cc <xTimerGenericCommand+0x92>
    21b8:	20 e0       	ldi	r18, 0x00	; 0
    21ba:	a8 01       	movw	r20, r16
    21bc:	be 01       	movw	r22, r28
    21be:	6f 5f       	subi	r22, 0xFF	; 255
    21c0:	7f 4f       	sbci	r23, 0xFF	; 255
    21c2:	cf 01       	movw	r24, r30
    21c4:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xQueueGenericSendFromISR>
    21c8:	01 c0       	rjmp	.+2      	; 0x21cc <xTimerGenericCommand+0x92>
    21ca:	80 e0       	ldi	r24, 0x00	; 0
    21cc:	29 96       	adiw	r28, 0x09	; 9
    21ce:	cd bf       	out	0x3d, r28	; 61
    21d0:	de bf       	out	0x3e, r29	; 62
    21d2:	df 91       	pop	r29
    21d4:	cf 91       	pop	r28
    21d6:	1f 91       	pop	r17
    21d8:	0f 91       	pop	r16
    21da:	ff 90       	pop	r15
    21dc:	ef 90       	pop	r14
    21de:	df 90       	pop	r13
    21e0:	cf 90       	pop	r12
    21e2:	bf 90       	pop	r11
    21e4:	af 90       	pop	r10
    21e6:	9f 90       	pop	r9
    21e8:	8f 90       	pop	r8
    21ea:	08 95       	ret

000021ec <prvSampleTimeNow>:
    21ec:	2f 92       	push	r2
    21ee:	3f 92       	push	r3
    21f0:	4f 92       	push	r4
    21f2:	5f 92       	push	r5
    21f4:	6f 92       	push	r6
    21f6:	7f 92       	push	r7
    21f8:	8f 92       	push	r8
    21fa:	9f 92       	push	r9
    21fc:	af 92       	push	r10
    21fe:	bf 92       	push	r11
    2200:	cf 92       	push	r12
    2202:	df 92       	push	r13
    2204:	ef 92       	push	r14
    2206:	ff 92       	push	r15
    2208:	0f 93       	push	r16
    220a:	1f 93       	push	r17
    220c:	cf 93       	push	r28
    220e:	df 93       	push	r29
    2210:	1c 01       	movw	r2, r24
    2212:	0e 94 77 0c 	call	0x18ee	; 0x18ee <xTaskGetTickCount>
    2216:	2b 01       	movw	r4, r22
    2218:	3c 01       	movw	r6, r24
    221a:	80 91 3e 2e 	lds	r24, 0x2E3E	; 0x802e3e <xLastTime.4745>
    221e:	90 91 3f 2e 	lds	r25, 0x2E3F	; 0x802e3f <xLastTime.4745+0x1>
    2222:	a0 91 40 2e 	lds	r26, 0x2E40	; 0x802e40 <xLastTime.4745+0x2>
    2226:	b0 91 41 2e 	lds	r27, 0x2E41	; 0x802e41 <xLastTime.4745+0x3>
    222a:	48 16       	cp	r4, r24
    222c:	59 06       	cpc	r5, r25
    222e:	6a 06       	cpc	r6, r26
    2230:	7b 06       	cpc	r7, r27
    2232:	08 f0       	brcs	.+2      	; 0x2236 <prvSampleTimeNow+0x4a>
    2234:	54 c0       	rjmp	.+168    	; 0x22de <prvSampleTimeNow+0xf2>
    2236:	3c c0       	rjmp	.+120    	; 0x22b0 <prvSampleTimeNow+0xc4>
    2238:	07 80       	ldd	r0, Z+7	; 0x07
    223a:	f0 85       	ldd	r31, Z+8	; 0x08
    223c:	e0 2d       	mov	r30, r0
    223e:	80 80       	ld	r8, Z
    2240:	91 80       	ldd	r9, Z+1	; 0x01
    2242:	a2 80       	ldd	r10, Z+2	; 0x02
    2244:	b3 80       	ldd	r11, Z+3	; 0x03
    2246:	c0 85       	ldd	r28, Z+8	; 0x08
    2248:	d1 85       	ldd	r29, Z+9	; 0x09
    224a:	8e 01       	movw	r16, r28
    224c:	0e 5f       	subi	r16, 0xFE	; 254
    224e:	1f 4f       	sbci	r17, 0xFF	; 255
    2250:	c8 01       	movw	r24, r16
    2252:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    2256:	ed 89       	ldd	r30, Y+21	; 0x15
    2258:	fe 89       	ldd	r31, Y+22	; 0x16
    225a:	ce 01       	movw	r24, r28
    225c:	19 95       	eicall
    225e:	8a 89       	ldd	r24, Y+18	; 0x12
    2260:	81 30       	cpi	r24, 0x01	; 1
    2262:	31 f5       	brne	.+76     	; 0x22b0 <prvSampleTimeNow+0xc4>
    2264:	8e 85       	ldd	r24, Y+14	; 0x0e
    2266:	9f 85       	ldd	r25, Y+15	; 0x0f
    2268:	a8 89       	ldd	r26, Y+16	; 0x10
    226a:	b9 89       	ldd	r27, Y+17	; 0x11
    226c:	88 0d       	add	r24, r8
    226e:	99 1d       	adc	r25, r9
    2270:	aa 1d       	adc	r26, r10
    2272:	bb 1d       	adc	r27, r11
    2274:	88 16       	cp	r8, r24
    2276:	99 06       	cpc	r9, r25
    2278:	aa 06       	cpc	r10, r26
    227a:	bb 06       	cpc	r11, r27
    227c:	70 f4       	brcc	.+28     	; 0x229a <prvSampleTimeNow+0xae>
    227e:	8a 83       	std	Y+2, r24	; 0x02
    2280:	9b 83       	std	Y+3, r25	; 0x03
    2282:	ac 83       	std	Y+4, r26	; 0x04
    2284:	bd 83       	std	Y+5, r27	; 0x05
    2286:	ca 87       	std	Y+10, r28	; 0x0a
    2288:	db 87       	std	Y+11, r29	; 0x0b
    228a:	b8 01       	movw	r22, r16
    228c:	80 91 48 2e 	lds	r24, 0x2E48	; 0x802e48 <pxCurrentTimerList>
    2290:	90 91 49 2e 	lds	r25, 0x2E49	; 0x802e49 <pxCurrentTimerList+0x1>
    2294:	0e 94 5a 05 	call	0xab4	; 0xab4 <vListInsert>
    2298:	0b c0       	rjmp	.+22     	; 0x22b0 <prvSampleTimeNow+0xc4>
    229a:	c1 2c       	mov	r12, r1
    229c:	d1 2c       	mov	r13, r1
    229e:	76 01       	movw	r14, r12
    22a0:	00 e0       	ldi	r16, 0x00	; 0
    22a2:	10 e0       	ldi	r17, 0x00	; 0
    22a4:	a5 01       	movw	r20, r10
    22a6:	94 01       	movw	r18, r8
    22a8:	60 e0       	ldi	r22, 0x00	; 0
    22aa:	ce 01       	movw	r24, r28
    22ac:	0e 94 9d 10 	call	0x213a	; 0x213a <xTimerGenericCommand>
    22b0:	e0 91 48 2e 	lds	r30, 0x2E48	; 0x802e48 <pxCurrentTimerList>
    22b4:	f0 91 49 2e 	lds	r31, 0x2E49	; 0x802e49 <pxCurrentTimerList+0x1>
    22b8:	80 81       	ld	r24, Z
    22ba:	81 11       	cpse	r24, r1
    22bc:	bd cf       	rjmp	.-134    	; 0x2238 <prvSampleTimeNow+0x4c>
    22be:	80 91 46 2e 	lds	r24, 0x2E46	; 0x802e46 <pxOverflowTimerList>
    22c2:	90 91 47 2e 	lds	r25, 0x2E47	; 0x802e47 <pxOverflowTimerList+0x1>
    22c6:	80 93 48 2e 	sts	0x2E48, r24	; 0x802e48 <pxCurrentTimerList>
    22ca:	90 93 49 2e 	sts	0x2E49, r25	; 0x802e49 <pxCurrentTimerList+0x1>
    22ce:	e0 93 46 2e 	sts	0x2E46, r30	; 0x802e46 <pxOverflowTimerList>
    22d2:	f0 93 47 2e 	sts	0x2E47, r31	; 0x802e47 <pxOverflowTimerList+0x1>
    22d6:	81 e0       	ldi	r24, 0x01	; 1
    22d8:	f1 01       	movw	r30, r2
    22da:	80 83       	st	Z, r24
    22dc:	02 c0       	rjmp	.+4      	; 0x22e2 <prvSampleTimeNow+0xf6>
    22de:	f1 01       	movw	r30, r2
    22e0:	10 82       	st	Z, r1
    22e2:	40 92 3e 2e 	sts	0x2E3E, r4	; 0x802e3e <xLastTime.4745>
    22e6:	50 92 3f 2e 	sts	0x2E3F, r5	; 0x802e3f <xLastTime.4745+0x1>
    22ea:	60 92 40 2e 	sts	0x2E40, r6	; 0x802e40 <xLastTime.4745+0x2>
    22ee:	70 92 41 2e 	sts	0x2E41, r7	; 0x802e41 <xLastTime.4745+0x3>
    22f2:	c3 01       	movw	r24, r6
    22f4:	b2 01       	movw	r22, r4
    22f6:	df 91       	pop	r29
    22f8:	cf 91       	pop	r28
    22fa:	1f 91       	pop	r17
    22fc:	0f 91       	pop	r16
    22fe:	ff 90       	pop	r15
    2300:	ef 90       	pop	r14
    2302:	df 90       	pop	r13
    2304:	cf 90       	pop	r12
    2306:	bf 90       	pop	r11
    2308:	af 90       	pop	r10
    230a:	9f 90       	pop	r9
    230c:	8f 90       	pop	r8
    230e:	7f 90       	pop	r7
    2310:	6f 90       	pop	r6
    2312:	5f 90       	pop	r5
    2314:	4f 90       	pop	r4
    2316:	3f 90       	pop	r3
    2318:	2f 90       	pop	r2
    231a:	08 95       	ret

0000231c <prvTimerTask>:
    231c:	cf 93       	push	r28
    231e:	df 93       	push	r29
    2320:	cd b7       	in	r28, 0x3d	; 61
    2322:	de b7       	in	r29, 0x3e	; 62
    2324:	2e 97       	sbiw	r28, 0x0e	; 14
    2326:	cd bf       	out	0x3d, r28	; 61
    2328:	de bf       	out	0x3e, r29	; 62
    232a:	ce 01       	movw	r24, r28
    232c:	01 96       	adiw	r24, 0x01	; 1
    232e:	1c 01       	movw	r2, r24
    2330:	a8 2e       	mov	r10, r24
    2332:	b3 2c       	mov	r11, r3
    2334:	e0 91 48 2e 	lds	r30, 0x2E48	; 0x802e48 <pxCurrentTimerList>
    2338:	f0 91 49 2e 	lds	r31, 0x2E49	; 0x802e49 <pxCurrentTimerList+0x1>
    233c:	80 81       	ld	r24, Z
    233e:	88 23       	and	r24, r24
    2340:	09 f4       	brne	.+2      	; 0x2344 <prvTimerTask+0x28>
    2342:	03 c1       	rjmp	.+518    	; 0x254a <prvTimerTask+0x22e>
    2344:	07 80       	ldd	r0, Z+7	; 0x07
    2346:	f0 85       	ldd	r31, Z+8	; 0x08
    2348:	e0 2d       	mov	r30, r0
    234a:	40 80       	ld	r4, Z
    234c:	51 80       	ldd	r5, Z+1	; 0x01
    234e:	62 80       	ldd	r6, Z+2	; 0x02
    2350:	73 80       	ldd	r7, Z+3	; 0x03
    2352:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vTaskSuspendAll>
    2356:	c1 01       	movw	r24, r2
    2358:	0e 94 f6 10 	call	0x21ec	; 0x21ec <prvSampleTimeNow>
    235c:	6b 87       	std	Y+11, r22	; 0x0b
    235e:	7c 87       	std	Y+12, r23	; 0x0c
    2360:	8d 87       	std	Y+13, r24	; 0x0d
    2362:	9e 87       	std	Y+14, r25	; 0x0e
    2364:	89 81       	ldd	r24, Y+1	; 0x01
    2366:	81 11       	cpse	r24, r1
    2368:	5e c0       	rjmp	.+188    	; 0x2426 <prvTimerTask+0x10a>
    236a:	8b 85       	ldd	r24, Y+11	; 0x0b
    236c:	9c 85       	ldd	r25, Y+12	; 0x0c
    236e:	ad 85       	ldd	r26, Y+13	; 0x0d
    2370:	be 85       	ldd	r27, Y+14	; 0x0e
    2372:	84 15       	cp	r24, r4
    2374:	95 05       	cpc	r25, r5
    2376:	a6 05       	cpc	r26, r6
    2378:	b7 05       	cpc	r27, r7
    237a:	e8 f1       	brcs	.+122    	; 0x23f6 <prvTimerTask+0xda>
    237c:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
    2380:	e0 91 48 2e 	lds	r30, 0x2E48	; 0x802e48 <pxCurrentTimerList>
    2384:	f0 91 49 2e 	lds	r31, 0x2E49	; 0x802e49 <pxCurrentTimerList+0x1>
    2388:	07 80       	ldd	r0, Z+7	; 0x07
    238a:	f0 85       	ldd	r31, Z+8	; 0x08
    238c:	e0 2d       	mov	r30, r0
    238e:	80 84       	ldd	r8, Z+8	; 0x08
    2390:	91 84       	ldd	r9, Z+9	; 0x09
    2392:	c4 01       	movw	r24, r8
    2394:	02 96       	adiw	r24, 0x02	; 2
    2396:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    239a:	d4 01       	movw	r26, r8
    239c:	52 96       	adiw	r26, 0x12	; 18
    239e:	8c 91       	ld	r24, X
    23a0:	52 97       	sbiw	r26, 0x12	; 18
    23a2:	81 30       	cpi	r24, 0x01	; 1
    23a4:	01 f5       	brne	.+64     	; 0x23e6 <prvTimerTask+0xca>
    23a6:	1e 96       	adiw	r26, 0x0e	; 14
    23a8:	4d 91       	ld	r20, X+
    23aa:	5d 91       	ld	r21, X+
    23ac:	6d 91       	ld	r22, X+
    23ae:	7c 91       	ld	r23, X
    23b0:	51 97       	sbiw	r26, 0x11	; 17
    23b2:	44 0d       	add	r20, r4
    23b4:	55 1d       	adc	r21, r5
    23b6:	66 1d       	adc	r22, r6
    23b8:	77 1d       	adc	r23, r7
    23ba:	73 01       	movw	r14, r6
    23bc:	62 01       	movw	r12, r4
    23be:	0b 85       	ldd	r16, Y+11	; 0x0b
    23c0:	1c 85       	ldd	r17, Y+12	; 0x0c
    23c2:	2d 85       	ldd	r18, Y+13	; 0x0d
    23c4:	3e 85       	ldd	r19, Y+14	; 0x0e
    23c6:	c4 01       	movw	r24, r8
    23c8:	0e 94 05 10 	call	0x200a	; 0x200a <prvInsertTimerInActiveList>
    23cc:	88 23       	and	r24, r24
    23ce:	59 f0       	breq	.+22     	; 0x23e6 <prvTimerTask+0xca>
    23d0:	c1 2c       	mov	r12, r1
    23d2:	d1 2c       	mov	r13, r1
    23d4:	76 01       	movw	r14, r12
    23d6:	00 e0       	ldi	r16, 0x00	; 0
    23d8:	10 e0       	ldi	r17, 0x00	; 0
    23da:	a3 01       	movw	r20, r6
    23dc:	92 01       	movw	r18, r4
    23de:	60 e0       	ldi	r22, 0x00	; 0
    23e0:	c4 01       	movw	r24, r8
    23e2:	0e 94 9d 10 	call	0x213a	; 0x213a <xTimerGenericCommand>
    23e6:	d4 01       	movw	r26, r8
    23e8:	55 96       	adiw	r26, 0x15	; 21
    23ea:	ed 91       	ld	r30, X+
    23ec:	fc 91       	ld	r31, X
    23ee:	56 97       	sbiw	r26, 0x16	; 22
    23f0:	c4 01       	movw	r24, r8
    23f2:	19 95       	eicall
    23f4:	9c c0       	rjmp	.+312    	; 0x252e <prvTimerTask+0x212>
    23f6:	20 e0       	ldi	r18, 0x00	; 0
    23f8:	b3 01       	movw	r22, r6
    23fa:	a2 01       	movw	r20, r4
    23fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    23fe:	9c 85       	ldd	r25, Y+12	; 0x0c
    2400:	ad 85       	ldd	r26, Y+13	; 0x0d
    2402:	be 85       	ldd	r27, Y+14	; 0x0e
    2404:	48 1b       	sub	r20, r24
    2406:	59 0b       	sbc	r21, r25
    2408:	6a 0b       	sbc	r22, r26
    240a:	7b 0b       	sbc	r23, r27
    240c:	80 91 44 2e 	lds	r24, 0x2E44	; 0x802e44 <xTimerQueue>
    2410:	90 91 45 2e 	lds	r25, 0x2E45	; 0x802e45 <xTimerQueue+0x1>
    2414:	0e 94 55 0a 	call	0x14aa	; 0x14aa <vQueueWaitForMessageRestricted>
    2418:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
    241c:	81 11       	cpse	r24, r1
    241e:	87 c0       	rjmp	.+270    	; 0x252e <prvTimerTask+0x212>
    2420:	0e 94 82 06 	call	0xd04	; 0xd04 <vPortYield>
    2424:	84 c0       	rjmp	.+264    	; 0x252e <prvTimerTask+0x212>
    2426:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <xTaskResumeAll>
    242a:	81 c0       	rjmp	.+258    	; 0x252e <prvTimerTask+0x212>
    242c:	89 81       	ldd	r24, Y+1	; 0x01
    242e:	88 23       	and	r24, r24
    2430:	6c f4       	brge	.+26     	; 0x244c <prvTimerTask+0x130>
    2432:	4e 81       	ldd	r20, Y+6	; 0x06
    2434:	5f 81       	ldd	r21, Y+7	; 0x07
    2436:	68 85       	ldd	r22, Y+8	; 0x08
    2438:	79 85       	ldd	r23, Y+9	; 0x09
    243a:	ea 81       	ldd	r30, Y+2	; 0x02
    243c:	fb 81       	ldd	r31, Y+3	; 0x03
    243e:	8c 81       	ldd	r24, Y+4	; 0x04
    2440:	9d 81       	ldd	r25, Y+5	; 0x05
    2442:	19 95       	eicall
    2444:	89 81       	ldd	r24, Y+1	; 0x01
    2446:	88 23       	and	r24, r24
    2448:	0c f4       	brge	.+2      	; 0x244c <prvTimerTask+0x130>
    244a:	71 c0       	rjmp	.+226    	; 0x252e <prvTimerTask+0x212>
    244c:	8e 80       	ldd	r8, Y+6	; 0x06
    244e:	9f 80       	ldd	r9, Y+7	; 0x07
    2450:	d4 01       	movw	r26, r8
    2452:	1c 96       	adiw	r26, 0x0c	; 12
    2454:	8d 91       	ld	r24, X+
    2456:	9c 91       	ld	r25, X
    2458:	1d 97       	sbiw	r26, 0x0d	; 13
    245a:	89 2b       	or	r24, r25
    245c:	21 f0       	breq	.+8      	; 0x2466 <prvTimerTask+0x14a>
    245e:	c4 01       	movw	r24, r8
    2460:	02 96       	adiw	r24, 0x02	; 2
    2462:	0e 94 97 05 	call	0xb2e	; 0xb2e <uxListRemove>
    2466:	ce 01       	movw	r24, r28
    2468:	0a 96       	adiw	r24, 0x0a	; 10
    246a:	0e 94 f6 10 	call	0x21ec	; 0x21ec <prvSampleTimeNow>
    246e:	8b 01       	movw	r16, r22
    2470:	9c 01       	movw	r18, r24
    2472:	89 81       	ldd	r24, Y+1	; 0x01
    2474:	08 2e       	mov	r0, r24
    2476:	00 0c       	add	r0, r0
    2478:	99 0b       	sbc	r25, r25
    247a:	aa 0b       	sbc	r26, r26
    247c:	bb 0b       	sbc	r27, r27
    247e:	8a 30       	cpi	r24, 0x0A	; 10
    2480:	91 05       	cpc	r25, r1
    2482:	08 f0       	brcs	.+2      	; 0x2486 <prvTimerTask+0x16a>
    2484:	54 c0       	rjmp	.+168    	; 0x252e <prvTimerTask+0x212>
    2486:	fc 01       	movw	r30, r24
    2488:	88 27       	eor	r24, r24
    248a:	e2 50       	subi	r30, 0x02	; 2
    248c:	ff 4f       	sbci	r31, 0xFF	; 255
    248e:	8f 4f       	sbci	r24, 0xFF	; 255
    2490:	0c 94 af 1f 	jmp	0x3f5e	; 0x3f5e <__tablejump2__>
    2494:	ca 80       	ldd	r12, Y+2	; 0x02
    2496:	db 80       	ldd	r13, Y+3	; 0x03
    2498:	ec 80       	ldd	r14, Y+4	; 0x04
    249a:	fd 80       	ldd	r15, Y+5	; 0x05
    249c:	f4 01       	movw	r30, r8
    249e:	46 85       	ldd	r20, Z+14	; 0x0e
    24a0:	57 85       	ldd	r21, Z+15	; 0x0f
    24a2:	60 89       	ldd	r22, Z+16	; 0x10
    24a4:	71 89       	ldd	r23, Z+17	; 0x11
    24a6:	4c 0d       	add	r20, r12
    24a8:	5d 1d       	adc	r21, r13
    24aa:	6e 1d       	adc	r22, r14
    24ac:	7f 1d       	adc	r23, r15
    24ae:	c4 01       	movw	r24, r8
    24b0:	0e 94 05 10 	call	0x200a	; 0x200a <prvInsertTimerInActiveList>
    24b4:	88 23       	and	r24, r24
    24b6:	d9 f1       	breq	.+118    	; 0x252e <prvTimerTask+0x212>
    24b8:	d4 01       	movw	r26, r8
    24ba:	55 96       	adiw	r26, 0x15	; 21
    24bc:	ed 91       	ld	r30, X+
    24be:	fc 91       	ld	r31, X
    24c0:	56 97       	sbiw	r26, 0x16	; 22
    24c2:	c4 01       	movw	r24, r8
    24c4:	19 95       	eicall
    24c6:	f4 01       	movw	r30, r8
    24c8:	82 89       	ldd	r24, Z+18	; 0x12
    24ca:	81 30       	cpi	r24, 0x01	; 1
    24cc:	81 f5       	brne	.+96     	; 0x252e <prvTimerTask+0x212>
    24ce:	4a 81       	ldd	r20, Y+2	; 0x02
    24d0:	5b 81       	ldd	r21, Y+3	; 0x03
    24d2:	6c 81       	ldd	r22, Y+4	; 0x04
    24d4:	7d 81       	ldd	r23, Y+5	; 0x05
    24d6:	86 85       	ldd	r24, Z+14	; 0x0e
    24d8:	97 85       	ldd	r25, Z+15	; 0x0f
    24da:	a0 89       	ldd	r26, Z+16	; 0x10
    24dc:	b1 89       	ldd	r27, Z+17	; 0x11
    24de:	9a 01       	movw	r18, r20
    24e0:	ab 01       	movw	r20, r22
    24e2:	28 0f       	add	r18, r24
    24e4:	39 1f       	adc	r19, r25
    24e6:	4a 1f       	adc	r20, r26
    24e8:	5b 1f       	adc	r21, r27
    24ea:	c1 2c       	mov	r12, r1
    24ec:	d1 2c       	mov	r13, r1
    24ee:	76 01       	movw	r14, r12
    24f0:	00 e0       	ldi	r16, 0x00	; 0
    24f2:	10 e0       	ldi	r17, 0x00	; 0
    24f4:	60 e0       	ldi	r22, 0x00	; 0
    24f6:	c4 01       	movw	r24, r8
    24f8:	0e 94 9d 10 	call	0x213a	; 0x213a <xTimerGenericCommand>
    24fc:	18 c0       	rjmp	.+48     	; 0x252e <prvTimerTask+0x212>
    24fe:	4a 81       	ldd	r20, Y+2	; 0x02
    2500:	5b 81       	ldd	r21, Y+3	; 0x03
    2502:	6c 81       	ldd	r22, Y+4	; 0x04
    2504:	7d 81       	ldd	r23, Y+5	; 0x05
    2506:	d4 01       	movw	r26, r8
    2508:	1e 96       	adiw	r26, 0x0e	; 14
    250a:	4d 93       	st	X+, r20
    250c:	5d 93       	st	X+, r21
    250e:	6d 93       	st	X+, r22
    2510:	7c 93       	st	X, r23
    2512:	51 97       	sbiw	r26, 0x11	; 17
    2514:	40 0f       	add	r20, r16
    2516:	51 1f       	adc	r21, r17
    2518:	62 1f       	adc	r22, r18
    251a:	73 1f       	adc	r23, r19
    251c:	68 01       	movw	r12, r16
    251e:	79 01       	movw	r14, r18
    2520:	c4 01       	movw	r24, r8
    2522:	0e 94 05 10 	call	0x200a	; 0x200a <prvInsertTimerInActiveList>
    2526:	03 c0       	rjmp	.+6      	; 0x252e <prvTimerTask+0x212>
    2528:	c4 01       	movw	r24, r8
    252a:	0e 94 23 05 	call	0xa46	; 0xa46 <vPortFree>
    252e:	20 e0       	ldi	r18, 0x00	; 0
    2530:	30 e0       	ldi	r19, 0x00	; 0
    2532:	a9 01       	movw	r20, r18
    2534:	6a 2d       	mov	r22, r10
    2536:	7b 2d       	mov	r23, r11
    2538:	80 91 44 2e 	lds	r24, 0x2E44	; 0x802e44 <xTimerQueue>
    253c:	90 91 45 2e 	lds	r25, 0x2E45	; 0x802e45 <xTimerQueue+0x1>
    2540:	0e 94 a3 09 	call	0x1346	; 0x1346 <xQueueReceive>
    2544:	81 11       	cpse	r24, r1
    2546:	72 cf       	rjmp	.-284    	; 0x242c <prvTimerTask+0x110>
    2548:	f5 ce       	rjmp	.-534    	; 0x2334 <prvTimerTask+0x18>
    254a:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vTaskSuspendAll>
    254e:	c1 01       	movw	r24, r2
    2550:	0e 94 f6 10 	call	0x21ec	; 0x21ec <prvSampleTimeNow>
    2554:	6b 87       	std	Y+11, r22	; 0x0b
    2556:	7c 87       	std	Y+12, r23	; 0x0c
    2558:	8d 87       	std	Y+13, r24	; 0x0d
    255a:	9e 87       	std	Y+14, r25	; 0x0e
    255c:	89 81       	ldd	r24, Y+1	; 0x01
    255e:	81 11       	cpse	r24, r1
    2560:	62 cf       	rjmp	.-316    	; 0x2426 <prvTimerTask+0x10a>
    2562:	e0 91 46 2e 	lds	r30, 0x2E46	; 0x802e46 <pxOverflowTimerList>
    2566:	f0 91 47 2e 	lds	r31, 0x2E47	; 0x802e47 <pxOverflowTimerList+0x1>
    256a:	80 81       	ld	r24, Z
    256c:	21 e0       	ldi	r18, 0x01	; 1
    256e:	81 11       	cpse	r24, r1
    2570:	20 e0       	ldi	r18, 0x00	; 0
    2572:	41 2c       	mov	r4, r1
    2574:	51 2c       	mov	r5, r1
    2576:	32 01       	movw	r6, r4
    2578:	3f cf       	rjmp	.-386    	; 0x23f8 <prvTimerTask+0xdc>

0000257a <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
    257a:	0f 93       	push	r16
    257c:	1f 93       	push	r17
    257e:	cf 93       	push	r28
    2580:	df 93       	push	r29
    2582:	cd b7       	in	r28, 0x3d	; 61
    2584:	de b7       	in	r29, 0x3e	; 62
    2586:	29 97       	sbiw	r28, 0x09	; 9
    2588:	cd bf       	out	0x3d, r28	; 61
    258a:	de bf       	out	0x3e, r29	; 62
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    258c:	ee ef       	ldi	r30, 0xFE	; 254
    258e:	e9 83       	std	Y+1, r30	; 0x01
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    2590:	8a 83       	std	Y+2, r24	; 0x02
    2592:	9b 83       	std	Y+3, r25	; 0x03
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    2594:	6c 83       	std	Y+4, r22	; 0x04
    2596:	7d 83       	std	Y+5, r23	; 0x05
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    2598:	2e 83       	std	Y+6, r18	; 0x06
    259a:	3f 83       	std	Y+7, r19	; 0x07
    259c:	48 87       	std	Y+8, r20	; 0x08
    259e:	59 87       	std	Y+9, r21	; 0x09

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    25a0:	20 e0       	ldi	r18, 0x00	; 0
    25a2:	a8 01       	movw	r20, r16
    25a4:	be 01       	movw	r22, r28
    25a6:	6f 5f       	subi	r22, 0xFF	; 255
    25a8:	7f 4f       	sbci	r23, 0xFF	; 255
    25aa:	80 91 44 2e 	lds	r24, 0x2E44	; 0x802e44 <xTimerQueue>
    25ae:	90 91 45 2e 	lds	r25, 0x2E45	; 0x802e45 <xTimerQueue+0x1>
    25b2:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
    25b6:	29 96       	adiw	r28, 0x09	; 9
    25b8:	cd bf       	out	0x3d, r28	; 61
    25ba:	de bf       	out	0x3e, r29	; 62
    25bc:	df 91       	pop	r29
    25be:	cf 91       	pop	r28
    25c0:	1f 91       	pop	r17
    25c2:	0f 91       	pop	r16
    25c4:	08 95       	ret

000025c6 <vInitClock>:
#include "clksys_driver.h"


void vInitClock(void)
{
	CLKSYS_Enable( OSC_RC2MEN_bm );
    25c6:	e0 e5       	ldi	r30, 0x50	; 80
    25c8:	f0 e0       	ldi	r31, 0x00	; 0
    25ca:	80 81       	ld	r24, Z
    25cc:	81 60       	ori	r24, 0x01	; 1
    25ce:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC2MRDY_bm ) == 0 );
    25d0:	81 81       	ldd	r24, Z+1	; 0x01
    25d2:	80 ff       	sbrs	r24, 0
    25d4:	fd cf       	rjmp	.-6      	; 0x25d0 <vInitClock+0xa>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC2M_gc );
    25d6:	80 e0       	ldi	r24, 0x00	; 0
    25d8:	0e 94 2f 03 	call	0x65e	; 0x65e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
    25dc:	8e e1       	ldi	r24, 0x1E	; 30
    25de:	0e 94 1f 03 	call	0x63e	; 0x63e <CLKSYS_Disable>
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    25e2:	60 e0       	ldi	r22, 0x00	; 0
    25e4:	80 e0       	ldi	r24, 0x00	; 0
    25e6:	0e 94 29 03 	call	0x652	; 0x652 <CLKSYS_Prescalers_Config>
	CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,false,OSC_XOSCSEL_XTAL_256CLK_gc );
    25ea:	43 e0       	ldi	r20, 0x03	; 3
    25ec:	60 e0       	ldi	r22, 0x00	; 0
    25ee:	80 e4       	ldi	r24, 0x40	; 64
    25f0:	0e 94 10 03 	call	0x620	; 0x620 <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
    25f4:	e0 e5       	ldi	r30, 0x50	; 80
    25f6:	f0 e0       	ldi	r31, 0x00	; 0
    25f8:	80 81       	ld	r24, Z
    25fa:	88 60       	ori	r24, 0x08	; 8
    25fc:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    25fe:	81 81       	ldd	r24, Z+1	; 0x01
    2600:	83 ff       	sbrs	r24, 3
    2602:	fd cf       	rjmp	.-6      	; 0x25fe <vInitClock+0x38>
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 4 );
    2604:	64 e0       	ldi	r22, 0x04	; 4
    2606:	80 ec       	ldi	r24, 0xC0	; 192
    2608:	0e 94 1a 03 	call	0x634	; 0x634 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    260c:	e0 e5       	ldi	r30, 0x50	; 80
    260e:	f0 e0       	ldi	r31, 0x00	; 0
    2610:	80 81       	ld	r24, Z
    2612:	80 61       	ori	r24, 0x10	; 16
    2614:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    2616:	60 e0       	ldi	r22, 0x00	; 0
    2618:	80 e0       	ldi	r24, 0x00	; 0
    261a:	0e 94 29 03 	call	0x652	; 0x652 <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    261e:	e0 e5       	ldi	r30, 0x50	; 80
    2620:	f0 e0       	ldi	r31, 0x00	; 0
    2622:	81 81       	ldd	r24, Z+1	; 0x01
    2624:	84 ff       	sbrs	r24, 4
    2626:	fd cf       	rjmp	.-6      	; 0x2622 <vInitClock+0x5c>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    2628:	84 e0       	ldi	r24, 0x04	; 4
    262a:	0e 94 2f 03 	call	0x65e	; 0x65e <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm);
    262e:	87 e0       	ldi	r24, 0x07	; 7
    2630:	0e 94 1f 03 	call	0x63e	; 0x63e <CLKSYS_Disable>
    2634:	08 95       	ret

00002636 <vLedBlink>:
	return 0;
}

void vLedBlink(void *pvParameters) {
	(void) pvParameters;
	PORTE.DIRSET = PIN3_bm; /*LED1*/
    2636:	e0 e8       	ldi	r30, 0x80	; 128
    2638:	f6 e0       	ldi	r31, 0x06	; 6
    263a:	88 e0       	ldi	r24, 0x08	; 8
    263c:	81 83       	std	Z+1, r24	; 0x01
	PORTE.OUT = 0x08;
    263e:	84 83       	std	Z+4, r24	; 0x04
	for(;;) {
		PORTE.OUTTGL = 0x08;				
    2640:	00 e8       	ldi	r16, 0x80	; 128
    2642:	16 e0       	ldi	r17, 0x06	; 6
    2644:	c8 e0       	ldi	r28, 0x08	; 8
    2646:	f8 01       	movw	r30, r16
    2648:	c7 83       	std	Z+7, r28	; 0x07
		vTaskDelay(100 / portTICK_RATE_MS);
    264a:	64 e6       	ldi	r22, 0x64	; 100
    264c:	70 e0       	ldi	r23, 0x00	; 0
    264e:	80 e0       	ldi	r24, 0x00	; 0
    2650:	90 e0       	ldi	r25, 0x00	; 0
    2652:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vTaskDelay>
    2656:	f7 cf       	rjmp	.-18     	; 0x2646 <vLedBlink+0x10>

00002658 <vWrite_Display>:

	for (;;)
	{
		
			vDisplayClear();
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    2658:	00 e9       	ldi	r16, 0x90	; 144
    265a:	11 e2       	ldi	r17, 0x21	; 33
			vDisplayWriteStringAtPos(1,0,"a: %d b: %d",buffer_a[1],buffer_b[1]);
    265c:	0f 2e       	mov	r0, r31
    265e:	f0 ea       	ldi	r31, 0xA0	; 160
    2660:	cf 2e       	mov	r12, r31
    2662:	f0 e3       	ldi	r31, 0x30	; 48
    2664:	df 2e       	mov	r13, r31
    2666:	f0 2d       	mov	r31, r0
    2668:	0f 2e       	mov	r0, r31
    266a:	f0 ee       	ldi	r31, 0xE0	; 224
    266c:	ef 2e       	mov	r14, r31
    266e:	f0 e3       	ldi	r31, 0x30	; 48
    2670:	ff 2e       	mov	r15, r31
    2672:	f0 2d       	mov	r31, r0
    2674:	c0 ea       	ldi	r28, 0xA0	; 160
    2676:	d1 e2       	ldi	r29, 0x21	; 33
    2678:	bb 24       	eor	r11, r11
    267a:	b3 94       	inc	r11
void vWrite_Display(void *pvParameters){

	for (;;)
	{
		
			vDisplayClear();
    267c:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <vDisplayClear>
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    2680:	1f 93       	push	r17
    2682:	0f 93       	push	r16
    2684:	1f 92       	push	r1
    2686:	1f 92       	push	r1
    2688:	1f 92       	push	r1
    268a:	1f 92       	push	r1
    268c:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(1,0,"a: %d b: %d",buffer_a[1],buffer_b[1]);
    2690:	f6 01       	movw	r30, r12
    2692:	91 81       	ldd	r25, Z+1	; 0x01
    2694:	f7 01       	movw	r30, r14
    2696:	81 81       	ldd	r24, Z+1	; 0x01
    2698:	1f 92       	push	r1
    269a:	9f 93       	push	r25
    269c:	1f 92       	push	r1
    269e:	8f 93       	push	r24
    26a0:	df 93       	push	r29
    26a2:	cf 93       	push	r28
    26a4:	1f 92       	push	r1
    26a6:	1f 92       	push	r1
    26a8:	1f 92       	push	r1
    26aa:	bf 92       	push	r11
    26ac:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <vDisplayWriteStringAtPos>
			//vDisplayWriteStringAtPos(2,0,"H: %d L: %d ",high_peak, low_peak);
			//vDisplayWriteStringAtPos(3,0,"Control: %lu ",control_result );
			//vDisplayWriteStringAtPos(3,0,"Hoi");
			vTaskStartScheduler();
    26b0:	0e 94 36 0c 	call	0x186c	; 0x186c <vTaskStartScheduler>
			vTaskDelay(100 / portTICK_RATE_MS);
    26b4:	64 e6       	ldi	r22, 0x64	; 100
    26b6:	70 e0       	ldi	r23, 0x00	; 0
    26b8:	80 e0       	ldi	r24, 0x00	; 0
    26ba:	90 e0       	ldi	r25, 0x00	; 0
    26bc:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vTaskDelay>
    26c0:	ed b7       	in	r30, 0x3d	; 61
    26c2:	fe b7       	in	r31, 0x3e	; 62
    26c4:	70 96       	adiw	r30, 0x10	; 16
    26c6:	ed bf       	out	0x3d, r30	; 61
    26c8:	fe bf       	out	0x3e, r31	; 62
    26ca:	d8 cf       	rjmp	.-80     	; 0x267c <vWrite_Display+0x24>

000026cc <vApplicationIdleHook>:
TaskHandle_t my_Display;
TaskHandle_t TaskDMAHandler;


void vApplicationIdleHook( void )
{	
    26cc:	08 95       	ret

000026ce <main>:
	
}

int main(void)
{
    26ce:	ef 92       	push	r14
    26d0:	ff 92       	push	r15
    26d2:	0f 93       	push	r16
    26d4:	cf 93       	push	r28
    resetReason_t reason = getResetReason();
    26d6:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <getResetReason>
    26da:	c8 2f       	mov	r28, r24

	vInitClock();
    26dc:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <vInitClock>
	vInitDisplay();
    26e0:	0e 94 0f 15 	call	0x2a1e	; 0x2a1e <vInitDisplay>
	
	xTaskCreate( vLedBlink, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+10, NULL, 1, &ledTask);
    26e4:	0f 2e       	mov	r0, r31
    26e6:	f1 ea       	ldi	r31, 0xA1	; 161
    26e8:	ef 2e       	mov	r14, r31
    26ea:	f1 e3       	ldi	r31, 0x31	; 49
    26ec:	ff 2e       	mov	r15, r31
    26ee:	f0 2d       	mov	r31, r0
    26f0:	01 e0       	ldi	r16, 0x01	; 1
    26f2:	20 e0       	ldi	r18, 0x00	; 0
    26f4:	30 e0       	ldi	r19, 0x00	; 0
    26f6:	42 ed       	ldi	r20, 0xD2	; 210
    26f8:	50 e0       	ldi	r21, 0x00	; 0
    26fa:	6c ea       	ldi	r22, 0xAC	; 172
    26fc:	71 e2       	ldi	r23, 0x21	; 33
    26fe:	8b e1       	ldi	r24, 0x1B	; 27
    2700:	93 e1       	ldi	r25, 0x13	; 19
    2702:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTaskCreate>
	xTaskCreate( vRead_Peaks, (const char *) "read_Peaks", configMINIMAL_STACK_SIZE+100, NULL, 1, &my_read_Peaks);
    2706:	0f 2e       	mov	r0, r31
    2708:	f5 ea       	ldi	r31, 0xA5	; 165
    270a:	ef 2e       	mov	r14, r31
    270c:	f1 e3       	ldi	r31, 0x31	; 49
    270e:	ff 2e       	mov	r15, r31
    2710:	f0 2d       	mov	r31, r0
    2712:	20 e0       	ldi	r18, 0x00	; 0
    2714:	30 e0       	ldi	r19, 0x00	; 0
    2716:	4c e2       	ldi	r20, 0x2C	; 44
    2718:	51 e0       	ldi	r21, 0x01	; 1
    271a:	65 eb       	ldi	r22, 0xB5	; 181
    271c:	71 e2       	ldi	r23, 0x21	; 33
    271e:	86 ef       	ldi	r24, 0xF6	; 246
    2720:	9a e1       	ldi	r25, 0x1A	; 26
    2722:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTaskCreate>
	xTaskCreate( vPhase_Detection, (const char *) "phase_detect", configMINIMAL_STACK_SIZE+10, NULL, 1, &my_phase_detection);
    2726:	0f 2e       	mov	r0, r31
    2728:	f3 ea       	ldi	r31, 0xA3	; 163
    272a:	ef 2e       	mov	r14, r31
    272c:	f1 e3       	ldi	r31, 0x31	; 49
    272e:	ff 2e       	mov	r15, r31
    2730:	f0 2d       	mov	r31, r0
    2732:	20 e0       	ldi	r18, 0x00	; 0
    2734:	30 e0       	ldi	r19, 0x00	; 0
    2736:	42 ed       	ldi	r20, 0xD2	; 210
    2738:	50 e0       	ldi	r21, 0x00	; 0
    273a:	60 ec       	ldi	r22, 0xC0	; 192
    273c:	71 e2       	ldi	r23, 0x21	; 33
    273e:	89 e3       	ldi	r24, 0x39	; 57
    2740:	9a e1       	ldi	r25, 0x1A	; 26
    2742:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTaskCreate>
	xTaskCreate( vWrite_Display, (const char *) "display", configMINIMAL_STACK_SIZE+10, NULL, 1, &my_Display);
    2746:	0f 2e       	mov	r0, r31
    2748:	f9 e2       	ldi	r31, 0x29	; 41
    274a:	ef 2e       	mov	r14, r31
    274c:	f2 e3       	ldi	r31, 0x32	; 50
    274e:	ff 2e       	mov	r15, r31
    2750:	f0 2d       	mov	r31, r0
    2752:	20 e0       	ldi	r18, 0x00	; 0
    2754:	30 e0       	ldi	r19, 0x00	; 0
    2756:	42 ed       	ldi	r20, 0xD2	; 210
    2758:	50 e0       	ldi	r21, 0x00	; 0
    275a:	6d ec       	ldi	r22, 0xCD	; 205
    275c:	71 e2       	ldi	r23, 0x21	; 33
    275e:	8c e2       	ldi	r24, 0x2C	; 44
    2760:	93 e1       	ldi	r25, 0x13	; 19
    2762:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTaskCreate>
	xTaskCreate( vTask_DMAHandler, (const char *) "dmaHandler", configMINIMAL_STACK_SIZE + 100, NULL, 1, &TaskDMAHandler);		
    2766:	0f 2e       	mov	r0, r31
    2768:	fb e2       	ldi	r31, 0x2B	; 43
    276a:	ef 2e       	mov	r14, r31
    276c:	f2 e3       	ldi	r31, 0x32	; 50
    276e:	ff 2e       	mov	r15, r31
    2770:	f0 2d       	mov	r31, r0
    2772:	20 e0       	ldi	r18, 0x00	; 0
    2774:	30 e0       	ldi	r19, 0x00	; 0
    2776:	4c e2       	ldi	r20, 0x2C	; 44
    2778:	51 e0       	ldi	r21, 0x01	; 1
    277a:	65 ed       	ldi	r22, 0xD5	; 213
    277c:	71 e2       	ldi	r23, 0x21	; 33
    277e:	85 e4       	ldi	r24, 0x45	; 69
    2780:	92 e0       	ldi	r25, 0x02	; 2
    2782:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTaskCreate>
	xSignalProcessEventGroup = xEventGroupCreate();
    2786:	0e 94 60 03 	call	0x6c0	; 0x6c0 <xEventGroupCreate>
    278a:	80 93 a4 2f 	sts	0x2FA4, r24	; 0x802fa4 <xSignalProcessEventGroup>
    278e:	90 93 a5 2f 	sts	0x2FA5, r25	; 0x802fa5 <xSignalProcessEventGroup+0x1>
	xPhaseDetectionEventGroup = xEventGroupCreate();
    2792:	0e 94 60 03 	call	0x6c0	; 0x6c0 <xEventGroupCreate>
    2796:	80 93 a7 31 	sts	0x31A7, r24	; 0x8031a7 <xPhaseDetectionEventGroup>
    279a:	90 93 a8 31 	sts	0x31A8, r25	; 0x8031a8 <xPhaseDetectionEventGroup+0x1>
	vInitDMA();			
    279e:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <vInitDMA>

	vDisplayClear();
    27a2:	0e 94 8b 16 	call	0x2d16	; 0x2d16 <vDisplayClear>
	vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    27a6:	80 e9       	ldi	r24, 0x90	; 144
    27a8:	91 e2       	ldi	r25, 0x21	; 33
    27aa:	9f 93       	push	r25
    27ac:	8f 93       	push	r24
    27ae:	1f 92       	push	r1
    27b0:	1f 92       	push	r1
    27b2:	1f 92       	push	r1
    27b4:	1f 92       	push	r1
    27b6:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(1,0,"EDUBoard 1.0");
    27ba:	80 ee       	ldi	r24, 0xE0	; 224
    27bc:	91 e2       	ldi	r25, 0x21	; 33
    27be:	9f 93       	push	r25
    27c0:	8f 93       	push	r24
    27c2:	1f 92       	push	r1
    27c4:	1f 92       	push	r1
    27c6:	1f 92       	push	r1
    27c8:	81 e0       	ldi	r24, 0x01	; 1
    27ca:	8f 93       	push	r24
    27cc:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(2,0,"Template");
    27d0:	8d ee       	ldi	r24, 0xED	; 237
    27d2:	91 e2       	ldi	r25, 0x21	; 33
    27d4:	9f 93       	push	r25
    27d6:	8f 93       	push	r24
    27d8:	1f 92       	push	r1
    27da:	1f 92       	push	r1
    27dc:	1f 92       	push	r1
    27de:	82 e0       	ldi	r24, 0x02	; 2
    27e0:	8f 93       	push	r24
    27e2:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(3,0,"ResetReason: %d", reason);
    27e6:	1f 92       	push	r1
    27e8:	cf 93       	push	r28
    27ea:	86 ef       	ldi	r24, 0xF6	; 246
    27ec:	91 e2       	ldi	r25, 0x21	; 33
    27ee:	9f 93       	push	r25
    27f0:	8f 93       	push	r24
    27f2:	1f 92       	push	r1
    27f4:	1f 92       	push	r1
    27f6:	1f 92       	push	r1
    27f8:	83 e0       	ldi	r24, 0x03	; 3
    27fa:	8f 93       	push	r24
    27fc:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <vDisplayWriteStringAtPos>
	vTaskStartScheduler();
    2800:	0e 94 36 0c 	call	0x186c	; 0x186c <vTaskStartScheduler>
    2804:	8d b7       	in	r24, 0x3d	; 61
    2806:	9e b7       	in	r25, 0x3e	; 62
    2808:	4a 96       	adiw	r24, 0x1a	; 26
    280a:	8d bf       	out	0x3d, r24	; 61
    280c:	9e bf       	out	0x3e, r25	; 62
	return 0;
}
    280e:	80 e0       	ldi	r24, 0x00	; 0
    2810:	90 e0       	ldi	r25, 0x00	; 0
    2812:	cf 91       	pop	r28
    2814:	0f 91       	pop	r16
    2816:	ff 90       	pop	r15
    2818:	ef 90       	pop	r14
    281a:	08 95       	ret

0000281c <__vector_108>:
 void displayHome() {
	 command(0x02);
 }
 void _displayClear() {
	 command(0x01);
	 delayUS(2000);
    281c:	1f 92       	push	r1
    281e:	0f 92       	push	r0
    2820:	0f b6       	in	r0, 0x3f	; 63
    2822:	0f 92       	push	r0
    2824:	11 24       	eor	r1, r1
    2826:	0b b6       	in	r0, 0x3b	; 59
    2828:	0f 92       	push	r0
    282a:	2f 93       	push	r18
    282c:	3f 93       	push	r19
    282e:	4f 93       	push	r20
    2830:	5f 93       	push	r21
    2832:	6f 93       	push	r22
    2834:	7f 93       	push	r23
    2836:	8f 93       	push	r24
    2838:	9f 93       	push	r25
    283a:	af 93       	push	r26
    283c:	bf 93       	push	r27
    283e:	ef 93       	push	r30
    2840:	ff 93       	push	r31
    2842:	cf 93       	push	r28
    2844:	df 93       	push	r29
    2846:	1f 92       	push	r1
    2848:	cd b7       	in	r28, 0x3d	; 61
    284a:	de b7       	in	r29, 0x3e	; 62
    284c:	19 82       	std	Y+1, r1	; 0x01
    284e:	9e 01       	movw	r18, r28
    2850:	2f 5f       	subi	r18, 0xFF	; 255
    2852:	3f 4f       	sbci	r19, 0xFF	; 255
    2854:	41 e0       	ldi	r20, 0x01	; 1
    2856:	50 e0       	ldi	r21, 0x00	; 0
    2858:	60 e0       	ldi	r22, 0x00	; 0
    285a:	70 e0       	ldi	r23, 0x00	; 0
    285c:	80 91 2f 32 	lds	r24, 0x322F	; 0x80322f <egDisplayTiming>
    2860:	90 91 30 32 	lds	r25, 0x3230	; 0x803230 <egDisplayTiming+0x1>
    2864:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <xEventGroupSetBitsFromISR>
    2868:	60 e0       	ldi	r22, 0x00	; 0
    286a:	80 e0       	ldi	r24, 0x00	; 0
    286c:	9b e0       	ldi	r25, 0x0B	; 11
    286e:	0e 94 44 03 	call	0x688	; 0x688 <TC0_ConfigClockSource>
    2872:	10 92 06 0b 	sts	0x0B06, r1	; 0x800b06 <__TEXT_REGION_LENGTH__+0x700b06>
    2876:	0f 90       	pop	r0
    2878:	df 91       	pop	r29
    287a:	cf 91       	pop	r28
    287c:	ff 91       	pop	r31
    287e:	ef 91       	pop	r30
    2880:	bf 91       	pop	r27
    2882:	af 91       	pop	r26
    2884:	9f 91       	pop	r25
    2886:	8f 91       	pop	r24
    2888:	7f 91       	pop	r23
    288a:	6f 91       	pop	r22
    288c:	5f 91       	pop	r21
    288e:	4f 91       	pop	r20
    2890:	3f 91       	pop	r19
    2892:	2f 91       	pop	r18
    2894:	0f 90       	pop	r0
    2896:	0b be       	out	0x3b, r0	; 59
    2898:	0f 90       	pop	r0
    289a:	0f be       	out	0x3f, r0	; 63
    289c:	0f 90       	pop	r0
    289e:	1f 90       	pop	r1
    28a0:	18 95       	reti

000028a2 <delayUS>:
    28a2:	cf 92       	push	r12
    28a4:	df 92       	push	r13
    28a6:	ef 92       	push	r14
    28a8:	ff 92       	push	r15
    28aa:	0f 93       	push	r16
    28ac:	6b 01       	movw	r12, r22
    28ae:	7c 01       	movw	r14, r24
    28b0:	82 e0       	ldi	r24, 0x02	; 2
    28b2:	c8 16       	cp	r12, r24
    28b4:	d1 04       	cpc	r13, r1
    28b6:	e1 04       	cpc	r14, r1
    28b8:	f1 04       	cpc	r15, r1
    28ba:	08 f4       	brcc	.+2      	; 0x28be <delayUS+0x1c>
    28bc:	4e c0       	rjmp	.+156    	; 0x295a <delayUS+0xb8>
    28be:	e0 e0       	ldi	r30, 0x00	; 0
    28c0:	fb e0       	ldi	r31, 0x0B	; 11
    28c2:	81 e0       	ldi	r24, 0x01	; 1
    28c4:	86 83       	std	Z+6, r24	; 0x06
    28c6:	10 a2       	std	Z+32, r1	; 0x20
    28c8:	11 a2       	std	Z+33, r1	; 0x21
    28ca:	60 e0       	ldi	r22, 0x00	; 0
    28cc:	80 e0       	ldi	r24, 0x00	; 0
    28ce:	9b e0       	ldi	r25, 0x0B	; 11
    28d0:	0e 94 4a 03 	call	0x694	; 0x694 <TC0_ConfigWGM>
    28d4:	8e ef       	ldi	r24, 0xFE	; 254
    28d6:	c8 16       	cp	r12, r24
    28d8:	8f ef       	ldi	r24, 0xFF	; 255
    28da:	d8 06       	cpc	r13, r24
    28dc:	e1 04       	cpc	r14, r1
    28de:	f1 04       	cpc	r15, r1
    28e0:	70 f4       	brcc	.+28     	; 0x28fe <delayUS+0x5c>
    28e2:	f6 94       	lsr	r15
    28e4:	e7 94       	ror	r14
    28e6:	d7 94       	ror	r13
    28e8:	c7 94       	ror	r12
    28ea:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    28ee:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    28f2:	65 e0       	ldi	r22, 0x05	; 5
    28f4:	80 e0       	ldi	r24, 0x00	; 0
    28f6:	9b e0       	ldi	r25, 0x0B	; 11
    28f8:	0e 94 44 03 	call	0x688	; 0x688 <TC0_ConfigClockSource>
    28fc:	19 c0       	rjmp	.+50     	; 0x2930 <delayUS+0x8e>
    28fe:	80 e4       	ldi	r24, 0x40	; 64
    2900:	c8 16       	cp	r12, r24
    2902:	82 e4       	ldi	r24, 0x42	; 66
    2904:	d8 06       	cpc	r13, r24
    2906:	8f e0       	ldi	r24, 0x0F	; 15
    2908:	e8 06       	cpc	r14, r24
    290a:	f1 04       	cpc	r15, r1
    290c:	88 f4       	brcc	.+34     	; 0x2930 <delayUS+0x8e>
    290e:	68 94       	set
    2910:	14 f8       	bld	r1, 4
    2912:	f6 94       	lsr	r15
    2914:	e7 94       	ror	r14
    2916:	d7 94       	ror	r13
    2918:	c7 94       	ror	r12
    291a:	16 94       	lsr	r1
    291c:	d1 f7       	brne	.-12     	; 0x2912 <delayUS+0x70>
    291e:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2922:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2926:	67 e0       	ldi	r22, 0x07	; 7
    2928:	80 e0       	ldi	r24, 0x00	; 0
    292a:	9b e0       	ldi	r25, 0x0B	; 11
    292c:	0e 94 44 03 	call	0x688	; 0x688 <TC0_ConfigClockSource>
    2930:	0f 2e       	mov	r0, r31
    2932:	f4 ef       	ldi	r31, 0xF4	; 244
    2934:	cf 2e       	mov	r12, r31
    2936:	dd 24       	eor	r13, r13
    2938:	d3 94       	inc	r13
    293a:	e1 2c       	mov	r14, r1
    293c:	f1 2c       	mov	r15, r1
    293e:	f0 2d       	mov	r31, r0
    2940:	00 e0       	ldi	r16, 0x00	; 0
    2942:	21 e0       	ldi	r18, 0x01	; 1
    2944:	41 e0       	ldi	r20, 0x01	; 1
    2946:	50 e0       	ldi	r21, 0x00	; 0
    2948:	60 e0       	ldi	r22, 0x00	; 0
    294a:	70 e0       	ldi	r23, 0x00	; 0
    294c:	80 91 2f 32 	lds	r24, 0x322F	; 0x80322f <egDisplayTiming>
    2950:	90 91 30 32 	lds	r25, 0x3230	; 0x803230 <egDisplayTiming+0x1>
    2954:	0e 94 75 03 	call	0x6ea	; 0x6ea <xEventGroupWaitBits>
    2958:	11 c0       	rjmp	.+34     	; 0x297c <delayUS+0xda>
    295a:	e0 e0       	ldi	r30, 0x00	; 0
    295c:	fb e0       	ldi	r31, 0x0B	; 11
    295e:	81 e0       	ldi	r24, 0x01	; 1
    2960:	86 83       	std	Z+6, r24	; 0x06
    2962:	10 a2       	std	Z+32, r1	; 0x20
    2964:	11 a2       	std	Z+33, r1	; 0x21
    2966:	60 e0       	ldi	r22, 0x00	; 0
    2968:	80 e0       	ldi	r24, 0x00	; 0
    296a:	9b e0       	ldi	r25, 0x0B	; 11
    296c:	0e 94 4a 03 	call	0x694	; 0x694 <TC0_ConfigWGM>
    2970:	c1 2c       	mov	r12, r1
    2972:	d1 2c       	mov	r13, r1
    2974:	76 01       	movw	r14, r12
    2976:	68 94       	set
    2978:	c1 f8       	bld	r12, 1
    297a:	b3 cf       	rjmp	.-154    	; 0x28e2 <delayUS+0x40>
    297c:	0f 91       	pop	r16
    297e:	ff 90       	pop	r15
    2980:	ef 90       	pop	r14
    2982:	df 90       	pop	r13
    2984:	cf 90       	pop	r12
    2986:	08 95       	ret

00002988 <setPort>:
    2988:	82 95       	swap	r24
    298a:	80 7f       	andi	r24, 0xF0	; 240
    298c:	e0 e0       	ldi	r30, 0x00	; 0
    298e:	f6 e0       	ldi	r31, 0x06	; 6
    2990:	94 81       	ldd	r25, Z+4	; 0x04
    2992:	28 2f       	mov	r18, r24
    2994:	2f 60       	ori	r18, 0x0F	; 15
    2996:	92 23       	and	r25, r18
    2998:	94 83       	std	Z+4, r25	; 0x04
    299a:	94 81       	ldd	r25, Z+4	; 0x04
    299c:	89 2b       	or	r24, r25
    299e:	84 83       	std	Z+4, r24	; 0x04
    29a0:	08 95       	ret

000029a2 <Nybble>:
    29a2:	1f 93       	push	r17
    29a4:	cf 93       	push	r28
    29a6:	df 93       	push	r29
    29a8:	c0 e6       	ldi	r28, 0x60	; 96
    29aa:	d6 e0       	ldi	r29, 0x06	; 6
    29ac:	14 e0       	ldi	r17, 0x04	; 4
    29ae:	1d 83       	std	Y+5, r17	; 0x05
    29b0:	61 e0       	ldi	r22, 0x01	; 1
    29b2:	70 e0       	ldi	r23, 0x00	; 0
    29b4:	80 e0       	ldi	r24, 0x00	; 0
    29b6:	90 e0       	ldi	r25, 0x00	; 0
    29b8:	0e 94 51 14 	call	0x28a2	; 0x28a2 <delayUS>
    29bc:	1e 83       	std	Y+6, r17	; 0x06
    29be:	df 91       	pop	r29
    29c0:	cf 91       	pop	r28
    29c2:	1f 91       	pop	r17
    29c4:	08 95       	ret

000029c6 <command>:
    29c6:	cf 93       	push	r28
    29c8:	c8 2f       	mov	r28, r24
    29ca:	82 95       	swap	r24
    29cc:	8f 70       	andi	r24, 0x0F	; 15
    29ce:	0e 94 c4 14 	call	0x2988	; 0x2988 <setPort>
    29d2:	e0 e6       	ldi	r30, 0x60	; 96
    29d4:	f6 e0       	ldi	r31, 0x06	; 6
    29d6:	81 e0       	ldi	r24, 0x01	; 1
    29d8:	86 83       	std	Z+6, r24	; 0x06
    29da:	82 e0       	ldi	r24, 0x02	; 2
    29dc:	86 83       	std	Z+6, r24	; 0x06
    29de:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <Nybble>
    29e2:	8c 2f       	mov	r24, r28
    29e4:	8f 70       	andi	r24, 0x0F	; 15
    29e6:	0e 94 c4 14 	call	0x2988	; 0x2988 <setPort>
    29ea:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <Nybble>
    29ee:	cf 91       	pop	r28
    29f0:	08 95       	ret

000029f2 <write>:
    29f2:	cf 93       	push	r28
    29f4:	c8 2f       	mov	r28, r24
    29f6:	82 95       	swap	r24
    29f8:	8f 70       	andi	r24, 0x0F	; 15
    29fa:	0e 94 c4 14 	call	0x2988	; 0x2988 <setPort>
    29fe:	e0 e6       	ldi	r30, 0x60	; 96
    2a00:	f6 e0       	ldi	r31, 0x06	; 6
    2a02:	81 e0       	ldi	r24, 0x01	; 1
    2a04:	85 83       	std	Z+5, r24	; 0x05
    2a06:	82 e0       	ldi	r24, 0x02	; 2
    2a08:	86 83       	std	Z+6, r24	; 0x06
    2a0a:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <Nybble>
    2a0e:	8c 2f       	mov	r24, r28
    2a10:	8f 70       	andi	r24, 0x0F	; 15
    2a12:	0e 94 c4 14 	call	0x2988	; 0x2988 <setPort>
    2a16:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <Nybble>
    2a1a:	cf 91       	pop	r28
    2a1c:	08 95       	ret

00002a1e <vInitDisplay>:
 }
 
 void vInitDisplay() {
    2a1e:	ef 92       	push	r14
    2a20:	ff 92       	push	r15
    2a22:	0f 93       	push	r16
	PORTA.DIRSET = PIN4_bm;
    2a24:	e0 e0       	ldi	r30, 0x00	; 0
    2a26:	f6 e0       	ldi	r31, 0x06	; 6
    2a28:	80 e1       	ldi	r24, 0x10	; 16
    2a2a:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN5_bm;
    2a2c:	80 e2       	ldi	r24, 0x20	; 32
    2a2e:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN6_bm;
    2a30:	80 e4       	ldi	r24, 0x40	; 64
    2a32:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN7_bm;
    2a34:	80 e8       	ldi	r24, 0x80	; 128
    2a36:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN0_bm;
    2a38:	a0 e6       	ldi	r26, 0x60	; 96
    2a3a:	b6 e0       	ldi	r27, 0x06	; 6
    2a3c:	81 e0       	ldi	r24, 0x01	; 1
    2a3e:	11 96       	adiw	r26, 0x01	; 1
    2a40:	8c 93       	st	X, r24
    2a42:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN1_bm;
    2a44:	82 e0       	ldi	r24, 0x02	; 2
    2a46:	11 96       	adiw	r26, 0x01	; 1
    2a48:	8c 93       	st	X, r24
    2a4a:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN2_bm;
    2a4c:	84 e0       	ldi	r24, 0x04	; 4
    2a4e:	11 96       	adiw	r26, 0x01	; 1
    2a50:	8c 93       	st	X, r24
    2a52:	11 97       	sbiw	r26, 0x01	; 1
	PORTA.OUT &= 0x0F;
    2a54:	84 81       	ldd	r24, Z+4	; 0x04
    2a56:	8f 70       	andi	r24, 0x0F	; 15
    2a58:	84 83       	std	Z+4, r24	; 0x04
	PORTD.OUT &= 0xF8;
    2a5a:	14 96       	adiw	r26, 0x04	; 4
    2a5c:	8c 91       	ld	r24, X
    2a5e:	14 97       	sbiw	r26, 0x04	; 4
    2a60:	88 7f       	andi	r24, 0xF8	; 248
    2a62:	14 96       	adiw	r26, 0x04	; 4
    2a64:	8c 93       	st	X, r24

	if((displayLineQueue = xQueueCreate(DISPLAY_QUEUE_DEPTH, sizeof(displayLine_t))) == NULL)
    2a66:	40 e0       	ldi	r20, 0x00	; 0
    2a68:	66 e1       	ldi	r22, 0x16	; 22
    2a6a:	88 e0       	ldi	r24, 0x08	; 8
    2a6c:	0e 94 87 08 	call	0x110e	; 0x110e <xQueueGenericCreate>
    2a70:	80 93 2d 32 	sts	0x322D, r24	; 0x80322d <displayLineQueue>
    2a74:	90 93 2e 32 	sts	0x322E, r25	; 0x80322e <displayLineQueue+0x1>
	{
		//error(ERR_QUEUE_CREATE_HANDLE_NULL);
	}
	
	egDisplayTiming = xEventGroupCreate();
    2a78:	0e 94 60 03 	call	0x6c0	; 0x6c0 <xEventGroupCreate>
    2a7c:	80 93 2f 32 	sts	0x322F, r24	; 0x80322f <egDisplayTiming>
    2a80:	90 93 30 32 	sts	0x3230, r25	; 0x803230 <egDisplayTiming+0x1>
	

	xTaskCreate(vDisplayUpdateTask, (const char*) "dispUpdate", configMINIMAL_STACK_SIZE+150, NULL, 1, NULL);	
    2a84:	e1 2c       	mov	r14, r1
    2a86:	f1 2c       	mov	r15, r1
    2a88:	01 e0       	ldi	r16, 0x01	; 1
    2a8a:	20 e0       	ldi	r18, 0x00	; 0
    2a8c:	30 e0       	ldi	r19, 0x00	; 0
    2a8e:	4e e5       	ldi	r20, 0x5E	; 94
    2a90:	51 e0       	ldi	r21, 0x01	; 1
    2a92:	66 e0       	ldi	r22, 0x06	; 6
    2a94:	72 e2       	ldi	r23, 0x22	; 34
    2a96:	8d ea       	ldi	r24, 0xAD	; 173
    2a98:	95 e1       	ldi	r25, 0x15	; 21
    2a9a:	0e 94 21 0b 	call	0x1642	; 0x1642 <xTaskCreate>
 }
    2a9e:	0f 91       	pop	r16
    2aa0:	ff 90       	pop	r15
    2aa2:	ef 90       	pop	r14
    2aa4:	08 95       	ret

00002aa6 <_displaySetPos>:
 
 void _displaySetPos(int line, int pos) {
	 switch(line) {
    2aa6:	81 30       	cpi	r24, 0x01	; 1
    2aa8:	91 05       	cpc	r25, r1
    2aaa:	79 f0       	breq	.+30     	; 0x2aca <_displaySetPos+0x24>
    2aac:	1c f4       	brge	.+6      	; 0x2ab4 <_displaySetPos+0xe>
    2aae:	89 2b       	or	r24, r25
    2ab0:	39 f0       	breq	.+14     	; 0x2ac0 <_displaySetPos+0x1a>
    2ab2:	19 c0       	rjmp	.+50     	; 0x2ae6 <_displaySetPos+0x40>
    2ab4:	82 30       	cpi	r24, 0x02	; 2
    2ab6:	91 05       	cpc	r25, r1
    2ab8:	69 f0       	breq	.+26     	; 0x2ad4 <_displaySetPos+0x2e>
    2aba:	03 97       	sbiw	r24, 0x03	; 3
    2abc:	81 f0       	breq	.+32     	; 0x2ade <_displaySetPos+0x38>
    2abe:	13 c0       	rjmp	.+38     	; 0x2ae6 <_displaySetPos+0x40>
		 case 0:
		 command(0x80 + 0x00 + pos);
    2ac0:	80 e8       	ldi	r24, 0x80	; 128
    2ac2:	86 0f       	add	r24, r22
    2ac4:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <command>
		 break;
    2ac8:	0e c0       	rjmp	.+28     	; 0x2ae6 <_displaySetPos+0x40>
		 case 1:
		 command(0x80 + 0x40 + pos);
    2aca:	80 ec       	ldi	r24, 0xC0	; 192
    2acc:	86 0f       	add	r24, r22
    2ace:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <command>
		 break;
    2ad2:	09 c0       	rjmp	.+18     	; 0x2ae6 <_displaySetPos+0x40>
		 case 2:
		 command(0x80 + 0x14 + pos);
    2ad4:	84 e9       	ldi	r24, 0x94	; 148
    2ad6:	86 0f       	add	r24, r22
    2ad8:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <command>
		 break;
    2adc:	04 c0       	rjmp	.+8      	; 0x2ae6 <_displaySetPos+0x40>
		 case 3:
		 command(0x80 + 0x54 + pos);
    2ade:	84 ed       	ldi	r24, 0xD4	; 212
    2ae0:	86 0f       	add	r24, r22
    2ae2:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <command>
		 break;
	 }
	 delayUS(39);
    2ae6:	67 e2       	ldi	r22, 0x27	; 39
    2ae8:	70 e0       	ldi	r23, 0x00	; 0
    2aea:	80 e0       	ldi	r24, 0x00	; 0
    2aec:	90 e0       	ldi	r25, 0x00	; 0
    2aee:	0e 94 51 14 	call	0x28a2	; 0x28a2 <delayUS>
    2af2:	08 95       	ret

00002af4 <_displayWriteChar>:
 }

 void _displayWriteChar(char c) {
	 write(c);
    2af4:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <write>
	 delayUS(43);
    2af8:	6b e2       	ldi	r22, 0x2B	; 43
    2afa:	70 e0       	ldi	r23, 0x00	; 0
    2afc:	80 e0       	ldi	r24, 0x00	; 0
    2afe:	90 e0       	ldi	r25, 0x00	; 0
    2b00:	0e 94 51 14 	call	0x28a2	; 0x28a2 <delayUS>
    2b04:	08 95       	ret

00002b06 <_displayWriteString>:
 }
 
 void _displayWriteString(char* s) {
    2b06:	0f 93       	push	r16
    2b08:	1f 93       	push	r17
    2b0a:	cf 93       	push	r28
    2b0c:	df 93       	push	r29
    2b0e:	fc 01       	movw	r30, r24
	 for(int i = 0; i < 20; i++) {
		 if(s[i] == '\0') {
    2b10:	80 81       	ld	r24, Z
    2b12:	81 11       	cpse	r24, r1
    2b14:	0a c0       	rjmp	.+20     	; 0x2b2a <_displayWriteString+0x24>
    2b16:	11 c0       	rjmp	.+34     	; 0x2b3a <_displayWriteString+0x34>
    2b18:	89 91       	ld	r24, Y+
    2b1a:	88 23       	and	r24, r24
    2b1c:	71 f0       	breq	.+28     	; 0x2b3a <_displayWriteString+0x34>
			 break;
		 }
		 _displayWriteChar(s[i]);
    2b1e:	0e 94 7a 15 	call	0x2af4	; 0x2af4 <_displayWriteChar>
	 write(c);
	 delayUS(43);
 }
 
 void _displayWriteString(char* s) {
	 for(int i = 0; i < 20; i++) {
    2b22:	0c 17       	cp	r16, r28
    2b24:	1d 07       	cpc	r17, r29
    2b26:	c1 f7       	brne	.-16     	; 0x2b18 <_displayWriteString+0x12>
    2b28:	08 c0       	rjmp	.+16     	; 0x2b3a <_displayWriteString+0x34>
    2b2a:	8f 01       	movw	r16, r30
		 if(s[i] == '\0') {
			 break;
		 }
		 _displayWriteChar(s[i]);
    2b2c:	0e 94 7a 15 	call	0x2af4	; 0x2af4 <_displayWriteChar>
    2b30:	e8 01       	movw	r28, r16
    2b32:	21 96       	adiw	r28, 0x01	; 1
    2b34:	0c 5e       	subi	r16, 0xEC	; 236
    2b36:	1f 4f       	sbci	r17, 0xFF	; 255
    2b38:	ef cf       	rjmp	.-34     	; 0x2b18 <_displayWriteString+0x12>
	 }
 }
    2b3a:	df 91       	pop	r29
    2b3c:	cf 91       	pop	r28
    2b3e:	1f 91       	pop	r17
    2b40:	0f 91       	pop	r16
    2b42:	08 95       	ret

00002b44 <_displayWriteStringAtPos>:

 void _displayWriteStringAtPos(int line, int pos, char* s) {
    2b44:	cf 93       	push	r28
    2b46:	df 93       	push	r29
    2b48:	ea 01       	movw	r28, r20
	 _displaySetPos(line, pos);
    2b4a:	0e 94 53 15 	call	0x2aa6	; 0x2aa6 <_displaySetPos>
	 _displayWriteString(s);
    2b4e:	ce 01       	movw	r24, r28
    2b50:	0e 94 83 15 	call	0x2b06	; 0x2b06 <_displayWriteString>
 }
    2b54:	df 91       	pop	r29
    2b56:	cf 91       	pop	r28
    2b58:	08 95       	ret

00002b5a <vDisplayUpdateTask>:

 void vDisplayUpdateTask(void *pvParameters) {
    2b5a:	cf 93       	push	r28
    2b5c:	df 93       	push	r29
    2b5e:	cd b7       	in	r28, 0x3d	; 61
    2b60:	de b7       	in	r29, 0x3e	; 62
    2b62:	c6 56       	subi	r28, 0x66	; 102
    2b64:	d1 09       	sbc	r29, r1
    2b66:	cd bf       	out	0x3d, r28	; 61
    2b68:	de bf       	out	0x3e, r29	; 62
    2b6a:	5e 01       	movw	r10, r28
    2b6c:	41 e5       	ldi	r20, 0x51	; 81
    2b6e:	a4 0e       	add	r10, r20
    2b70:	b1 1c       	adc	r11, r1
    2b72:	fe 01       	movw	r30, r28
    2b74:	31 96       	adiw	r30, 0x01	; 1
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
			displayLines[i][j] = 0x20;
    2b76:	20 e2       	ldi	r18, 0x20	; 32
    2b78:	08 c0       	rjmp	.+16     	; 0x2b8a <vDisplayUpdateTask+0x30>
    2b7a:	21 93       	st	Z+, r18
 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
    2b7c:	e8 17       	cp	r30, r24
    2b7e:	f9 07       	cpc	r31, r25
    2b80:	e1 f7       	brne	.-8      	; 0x2b7a <vDisplayUpdateTask+0x20>
    2b82:	fc 01       	movw	r30, r24

 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
    2b84:	a8 16       	cp	r10, r24
    2b86:	b9 06       	cpc	r11, r25
    2b88:	19 f0       	breq	.+6      	; 0x2b90 <vDisplayUpdateTask+0x36>
    2b8a:	cf 01       	movw	r24, r30
    2b8c:	44 96       	adiw	r24, 0x14	; 20
    2b8e:	f5 cf       	rjmp	.-22     	; 0x2b7a <vDisplayUpdateTask+0x20>
			displayLines[i][j] = 0x20;
		}
	 }
	 displayLine_t newLine;

	 delayUS(40000);
    2b90:	60 e4       	ldi	r22, 0x40	; 64
    2b92:	7c e9       	ldi	r23, 0x9C	; 156
    2b94:	80 e0       	ldi	r24, 0x00	; 0
    2b96:	90 e0       	ldi	r25, 0x00	; 0
    2b98:	0e 94 51 14 	call	0x28a2	; 0x28a2 <delayUS>
	 setPort(0x03);
    2b9c:	83 e0       	ldi	r24, 0x03	; 3
    2b9e:	0e 94 c4 14 	call	0x2988	; 0x2988 <setPort>
	 delayUS(5000);
    2ba2:	68 e8       	ldi	r22, 0x88	; 136
    2ba4:	73 e1       	ldi	r23, 0x13	; 19
    2ba6:	80 e0       	ldi	r24, 0x00	; 0
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	0e 94 51 14 	call	0x28a2	; 0x28a2 <delayUS>
	 Nybble();
    2bae:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <Nybble>
	 delayUS(160);
    2bb2:	60 ea       	ldi	r22, 0xA0	; 160
    2bb4:	70 e0       	ldi	r23, 0x00	; 0
    2bb6:	80 e0       	ldi	r24, 0x00	; 0
    2bb8:	90 e0       	ldi	r25, 0x00	; 0
    2bba:	0e 94 51 14 	call	0x28a2	; 0x28a2 <delayUS>
	 Nybble();
    2bbe:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <Nybble>
	 delayUS(160);
    2bc2:	60 ea       	ldi	r22, 0xA0	; 160
    2bc4:	70 e0       	ldi	r23, 0x00	; 0
    2bc6:	80 e0       	ldi	r24, 0x00	; 0
    2bc8:	90 e0       	ldi	r25, 0x00	; 0
    2bca:	0e 94 51 14 	call	0x28a2	; 0x28a2 <delayUS>
	 Nybble();
    2bce:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <Nybble>
	 delayUS(160);
    2bd2:	60 ea       	ldi	r22, 0xA0	; 160
    2bd4:	70 e0       	ldi	r23, 0x00	; 0
    2bd6:	80 e0       	ldi	r24, 0x00	; 0
    2bd8:	90 e0       	ldi	r25, 0x00	; 0
    2bda:	0e 94 51 14 	call	0x28a2	; 0x28a2 <delayUS>
	 setPort(0x02);
    2bde:	82 e0       	ldi	r24, 0x02	; 2
    2be0:	0e 94 c4 14 	call	0x2988	; 0x2988 <setPort>
	 Nybble();
    2be4:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <Nybble>
	 command(0x28);
    2be8:	88 e2       	ldi	r24, 0x28	; 40
    2bea:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <command>
	 command(0x10);
    2bee:	80 e1       	ldi	r24, 0x10	; 16
    2bf0:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <command>
	 command(0x0C); //Cursor and Blinking off
    2bf4:	8c e0       	ldi	r24, 0x0C	; 12
    2bf6:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <command>
	 command(0x06);
    2bfa:	86 e0       	ldi	r24, 0x06	; 6
    2bfc:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <command>
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2c00:	10 e2       	ldi	r17, 0x20	; 32
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2c02:	6e 01       	movw	r12, r28
    2c04:	51 e5       	ldi	r21, 0x51	; 81
    2c06:	c5 0e       	add	r12, r21
    2c08:	d1 1c       	adc	r13, r1
    2c0a:	0f 2e       	mov	r0, r31
    2c0c:	f4 e1       	ldi	r31, 0x14	; 20
    2c0e:	4f 2e       	mov	r4, r31
    2c10:	f0 2d       	mov	r31, r0
    2c12:	0f 2e       	mov	r0, r31
    2c14:	f6 e1       	ldi	r31, 0x16	; 22
    2c16:	8f 2e       	mov	r8, r31
    2c18:	91 2c       	mov	r9, r1
    2c1a:	f0 2d       	mov	r31, r0
    2c1c:	5c 2c       	mov	r5, r12
    2c1e:	0d 2d       	mov	r16, r13
	 command(0x10);
	 command(0x0C); //Cursor and Blinking off
	 command(0x06);
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
    2c20:	68 ec       	ldi	r22, 0xC8	; 200
    2c22:	70 e0       	ldi	r23, 0x00	; 0
    2c24:	80 e0       	ldi	r24, 0x00	; 0
    2c26:	90 e0       	ldi	r25, 0x00	; 0
    2c28:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vTaskDelay>
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
    2c2c:	40 e0       	ldi	r20, 0x00	; 0
    2c2e:	50 e0       	ldi	r21, 0x00	; 0
    2c30:	ba 01       	movw	r22, r20
    2c32:	80 91 2f 32 	lds	r24, 0x322F	; 0x80322f <egDisplayTiming>
    2c36:	90 91 30 32 	lds	r25, 0x3230	; 0x803230 <egDisplayTiming+0x1>
    2c3a:	0e 94 3a 04 	call	0x874	; 0x874 <xEventGroupClearBits>
    2c3e:	67 2b       	or	r22, r23
    2c40:	68 2b       	or	r22, r24
    2c42:	69 2b       	or	r22, r25
    2c44:	09 f4       	brne	.+2      	; 0x2c48 <vDisplayUpdateTask+0xee>
    2c46:	49 c0       	rjmp	.+146    	; 0x2cda <vDisplayUpdateTask+0x180>
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2c48:	42 e0       	ldi	r20, 0x02	; 2
    2c4a:	50 e0       	ldi	r21, 0x00	; 0
    2c4c:	60 e0       	ldi	r22, 0x00	; 0
    2c4e:	70 e0       	ldi	r23, 0x00	; 0
    2c50:	80 91 2f 32 	lds	r24, 0x322F	; 0x80322f <egDisplayTiming>
    2c54:	90 91 30 32 	lds	r25, 0x3230	; 0x803230 <egDisplayTiming+0x1>
    2c58:	0e 94 3a 04 	call	0x874	; 0x874 <xEventGroupClearBits>
    2c5c:	fe 01       	movw	r30, r28
    2c5e:	31 96       	adiw	r30, 0x01	; 1
    2c60:	08 c0       	rjmp	.+16     	; 0x2c72 <vDisplayUpdateTask+0x118>
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2c62:	11 93       	st	Z+, r17
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
    2c64:	e8 17       	cp	r30, r24
    2c66:	f9 07       	cpc	r31, r25
    2c68:	e1 f7       	brne	.-8      	; 0x2c62 <vDisplayUpdateTask+0x108>
    2c6a:	fc 01       	movw	r30, r24
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
    2c6c:	8a 15       	cp	r24, r10
    2c6e:	9b 05       	cpc	r25, r11
    2c70:	a1 f1       	breq	.+104    	; 0x2cda <vDisplayUpdateTask+0x180>
    2c72:	cf 01       	movw	r24, r30
    2c74:	44 96       	adiw	r24, 0x14	; 20
    2c76:	f5 cf       	rjmp	.-22     	; 0x2c62 <vDisplayUpdateTask+0x108>
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2c78:	2f ef       	ldi	r18, 0xFF	; 255
    2c7a:	3f ef       	ldi	r19, 0xFF	; 255
    2c7c:	a9 01       	movw	r20, r18
    2c7e:	65 2d       	mov	r22, r5
    2c80:	70 2f       	mov	r23, r16
    2c82:	80 91 2d 32 	lds	r24, 0x322D	; 0x80322d <displayLineQueue>
    2c86:	90 91 2e 32 	lds	r25, 0x322E	; 0x80322e <displayLineQueue+0x1>
    2c8a:	0e 94 a3 09 	call	0x1346	; 0x1346 <xQueueReceive>
    2c8e:	88 23       	and	r24, r24
    2c90:	21 f1       	breq	.+72     	; 0x2cda <vDisplayUpdateTask+0x180>
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2c92:	f6 01       	movw	r30, r12
    2c94:	21 81       	ldd	r18, Z+1	; 0x01
    2c96:	82 2f       	mov	r24, r18
    2c98:	90 e0       	ldi	r25, 0x00	; 0
    2c9a:	44 97       	sbiw	r24, 0x14	; 20
    2c9c:	f4 f4       	brge	.+60     	; 0x2cda <vDisplayUpdateTask+0x180>
    2c9e:	82 81       	ldd	r24, Z+2	; 0x02
    2ca0:	88 23       	and	r24, r24
    2ca2:	d9 f0       	breq	.+54     	; 0x2cda <vDisplayUpdateTask+0x180>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
    2ca4:	90 81       	ld	r25, Z
    2ca6:	30 e0       	ldi	r19, 0x00	; 0
    2ca8:	d9 01       	movw	r26, r18
    2caa:	49 9e       	mul	r4, r25
    2cac:	a0 0d       	add	r26, r0
    2cae:	b1 1d       	adc	r27, r1
    2cb0:	11 24       	eor	r1, r1
    2cb2:	41 e0       	ldi	r20, 0x01	; 1
    2cb4:	50 e0       	ldi	r21, 0x00	; 0
    2cb6:	4c 0f       	add	r20, r28
    2cb8:	5d 1f       	adc	r21, r29
    2cba:	a4 0f       	add	r26, r20
    2cbc:	b5 1f       	adc	r27, r21
    2cbe:	33 96       	adiw	r30, 0x03	; 3
    2cc0:	a4 01       	movw	r20, r8
    2cc2:	42 1b       	sub	r20, r18
    2cc4:	53 0b       	sbc	r21, r19
    2cc6:	9a 01       	movw	r18, r20
    2cc8:	2c 0d       	add	r18, r12
    2cca:	3d 1d       	adc	r19, r13
    2ccc:	8d 93       	st	X+, r24
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2cce:	e2 17       	cp	r30, r18
    2cd0:	f3 07       	cpc	r31, r19
    2cd2:	19 f0       	breq	.+6      	; 0x2cda <vDisplayUpdateTask+0x180>
    2cd4:	81 91       	ld	r24, Z+
    2cd6:	81 11       	cpse	r24, r1
    2cd8:	f9 cf       	rjmp	.-14     	; 0x2ccc <vDisplayUpdateTask+0x172>
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
    2cda:	80 91 2d 32 	lds	r24, 0x322D	; 0x80322d <displayLineQueue>
    2cde:	90 91 2e 32 	lds	r25, 0x322E	; 0x80322e <displayLineQueue+0x1>
    2ce2:	0e 94 49 0a 	call	0x1492	; 0x1492 <uxQueueMessagesWaiting>
    2ce6:	81 11       	cpse	r24, r1
    2ce8:	c7 cf       	rjmp	.-114    	; 0x2c78 <vDisplayUpdateTask+0x11e>
    2cea:	ce 01       	movw	r24, r28
    2cec:	01 96       	adiw	r24, 0x01	; 1
    2cee:	7c 01       	movw	r14, r24
    2cf0:	61 2c       	mov	r6, r1
    2cf2:	71 2c       	mov	r7, r1
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
			 _displayWriteStringAtPos(i,0,&displayLines[i][0]);
    2cf4:	a7 01       	movw	r20, r14
    2cf6:	60 e0       	ldi	r22, 0x00	; 0
    2cf8:	70 e0       	ldi	r23, 0x00	; 0
    2cfa:	c3 01       	movw	r24, r6
    2cfc:	0e 94 a2 15 	call	0x2b44	; 0x2b44 <_displayWriteStringAtPos>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
    2d00:	9f ef       	ldi	r25, 0xFF	; 255
    2d02:	69 1a       	sub	r6, r25
    2d04:	79 0a       	sbc	r7, r25
    2d06:	e4 e1       	ldi	r30, 0x14	; 20
    2d08:	ee 0e       	add	r14, r30
    2d0a:	f1 1c       	adc	r15, r1
    2d0c:	f4 e0       	ldi	r31, 0x04	; 4
    2d0e:	6f 16       	cp	r6, r31
    2d10:	71 04       	cpc	r7, r1
    2d12:	81 f7       	brne	.-32     	; 0x2cf4 <vDisplayUpdateTask+0x19a>
    2d14:	85 cf       	rjmp	.-246    	; 0x2c20 <vDisplayUpdateTask+0xc6>

00002d16 <vDisplayClear>:
	 }
 }
 

void vDisplayClear() {
	xEventGroupSetBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2d16:	42 e0       	ldi	r20, 0x02	; 2
    2d18:	50 e0       	ldi	r21, 0x00	; 0
    2d1a:	60 e0       	ldi	r22, 0x00	; 0
    2d1c:	70 e0       	ldi	r23, 0x00	; 0
    2d1e:	80 91 2f 32 	lds	r24, 0x322F	; 0x80322f <egDisplayTiming>
    2d22:	90 91 30 32 	lds	r25, 0x3230	; 0x803230 <egDisplayTiming+0x1>
    2d26:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <xEventGroupSetBits>
    2d2a:	08 95       	ret

00002d2c <vDisplayWriteStringAtPos>:
}

void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
    2d2c:	2f 92       	push	r2
    2d2e:	3f 92       	push	r3
    2d30:	4f 92       	push	r4
    2d32:	5f 92       	push	r5
    2d34:	6f 92       	push	r6
    2d36:	7f 92       	push	r7
    2d38:	8f 92       	push	r8
    2d3a:	9f 92       	push	r9
    2d3c:	af 92       	push	r10
    2d3e:	bf 92       	push	r11
    2d40:	cf 92       	push	r12
    2d42:	df 92       	push	r13
    2d44:	ef 92       	push	r14
    2d46:	ff 92       	push	r15
    2d48:	0f 93       	push	r16
    2d4a:	1f 93       	push	r17
    2d4c:	cf 93       	push	r28
    2d4e:	df 93       	push	r29
    2d50:	cd b7       	in	r28, 0x3d	; 61
    2d52:	de b7       	in	r29, 0x3e	; 62
    2d54:	6d 97       	sbiw	r28, 0x1d	; 29
    2d56:	cd bf       	out	0x3d, r28	; 61
    2d58:	de bf       	out	0x3e, r29	; 62
    2d5a:	2b a9       	ldd	r18, Y+51	; 0x33
    2d5c:	2b 8f       	std	Y+27, r18	; 0x1b
    2d5e:	af a9       	ldd	r26, Y+55	; 0x37
    2d60:	b8 ad       	ldd	r27, Y+56	; 0x38
	va_list arg;	
	va_start(arg, fmt);
    2d62:	7e 01       	movw	r14, r28
    2d64:	39 e3       	ldi	r19, 0x39	; 57
    2d66:	e3 0e       	add	r14, r19
    2d68:	f1 1c       	adc	r15, r1
    2d6a:	28 e8       	ldi	r18, 0x88	; 136
    2d6c:	3e e2       	ldi	r19, 0x2E	; 46
	display_vprintf(line, pos, fmt, arg);
    2d6e:	e4 e7       	ldi	r30, 0x74	; 116
    2d70:	fe e2       	ldi	r31, 0x2E	; 46
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
    2d72:	11 92       	st	Z+, r1
	char ch;
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
    2d74:	e2 17       	cp	r30, r18
    2d76:	f3 07       	cpc	r31, r19
    2d78:	e1 f7       	brne	.-8      	; 0x2d72 <vDisplayWriteStringAtPos+0x46>
    2d7a:	0f 2e       	mov	r0, r31
    2d7c:	f0 e6       	ldi	r31, 0x60	; 96
    2d7e:	af 2e       	mov	r10, r31
    2d80:	fe e2       	ldi	r31, 0x2E	; 46
    2d82:	bf 2e       	mov	r11, r31
    2d84:	f0 2d       	mov	r31, r0
    2d86:	24 e7       	ldi	r18, 0x74	; 116
    2d88:	3e e2       	ldi	r19, 0x2E	; 46
    2d8a:	f5 01       	movw	r30, r10
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
    2d8c:	11 92       	st	Z+, r1
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    2d8e:	e2 17       	cp	r30, r18
    2d90:	f3 07       	cpc	r31, r19
    2d92:	e1 f7       	brne	.-8      	; 0x2d8c <vDisplayWriteStringAtPos+0x60>
    2d94:	81 2c       	mov	r8, r1
    2d96:	91 2c       	mov	r9, r1
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    2d98:	0f 2e       	mov	r0, r31
    2d9a:	f4 e7       	ldi	r31, 0x74	; 116
    2d9c:	cf 2e       	mov	r12, r31
    2d9e:	fe e2       	ldi	r31, 0x2E	; 46
    2da0:	df 2e       	mov	r13, r31
    2da2:	f0 2d       	mov	r31, r0
    2da4:	fc c2       	rjmp	.+1528   	; 0x339e <vDisplayWriteStringAtPos+0x672>
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
    2da6:	85 32       	cpi	r24, 0x25	; 37
    2da8:	09 f0       	breq	.+2      	; 0x2dac <vDisplayWriteStringAtPos+0x80>
    2daa:	e8 c2       	rjmp	.+1488   	; 0x337c <vDisplayWriteStringAtPos+0x650>
			switch (ch = *fmt++) {
    2dac:	2d 01       	movw	r4, r26
    2dae:	82 e0       	ldi	r24, 0x02	; 2
    2db0:	48 0e       	add	r4, r24
    2db2:	51 1c       	adc	r5, r1
    2db4:	11 96       	adiw	r26, 0x01	; 1
    2db6:	8c 91       	ld	r24, X
    2db8:	85 36       	cpi	r24, 0x65	; 101
    2dba:	09 f4       	brne	.+2      	; 0x2dbe <vDisplayWriteStringAtPos+0x92>
    2dbc:	db c1       	rjmp	.+950    	; 0x3174 <vDisplayWriteStringAtPos+0x448>
    2dbe:	38 f4       	brcc	.+14     	; 0x2dce <vDisplayWriteStringAtPos+0xa2>
    2dc0:	83 36       	cpi	r24, 0x63	; 99
    2dc2:	c1 f0       	breq	.+48     	; 0x2df4 <vDisplayWriteStringAtPos+0xc8>
    2dc4:	08 f0       	brcs	.+2      	; 0x2dc8 <vDisplayWriteStringAtPos+0x9c>
    2dc6:	48 c0       	rjmp	.+144    	; 0x2e58 <vDisplayWriteStringAtPos+0x12c>
    2dc8:	85 32       	cpi	r24, 0x25	; 37
    2dca:	51 f0       	breq	.+20     	; 0x2de0 <vDisplayWriteStringAtPos+0xb4>
    2dcc:	e7 c2       	rjmp	.+1486   	; 0x339c <vDisplayWriteStringAtPos+0x670>
    2dce:	83 37       	cpi	r24, 0x73	; 115
    2dd0:	f9 f0       	breq	.+62     	; 0x2e10 <vDisplayWriteStringAtPos+0xe4>
    2dd2:	88 37       	cpi	r24, 0x78	; 120
    2dd4:	09 f4       	brne	.+2      	; 0x2dd8 <vDisplayWriteStringAtPos+0xac>
    2dd6:	68 c0       	rjmp	.+208    	; 0x2ea8 <vDisplayWriteStringAtPos+0x17c>
    2dd8:	86 36       	cpi	r24, 0x66	; 102
    2dda:	09 f0       	breq	.+2      	; 0x2dde <vDisplayWriteStringAtPos+0xb2>
    2ddc:	df c2       	rjmp	.+1470   	; 0x339c <vDisplayWriteStringAtPos+0x670>
    2dde:	8c c0       	rjmp	.+280    	; 0x2ef8 <vDisplayWriteStringAtPos+0x1cc>
				/* %% - print out a single %    */
				case '%':
				str[length] = '%';
    2de0:	f4 01       	movw	r30, r8
    2de2:	e0 5a       	subi	r30, 0xA0	; 160
    2de4:	f1 4d       	sbci	r31, 0xD1	; 209
    2de6:	95 e2       	ldi	r25, 0x25	; 37
    2de8:	90 83       	st	Z, r25
				length++;
    2dea:	af ef       	ldi	r26, 0xFF	; 255
    2dec:	8a 1a       	sub	r8, r26
    2dee:	9a 0a       	sbc	r9, r26
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2df0:	d2 01       	movw	r26, r4
    2df2:	d5 c2       	rjmp	.+1450   	; 0x339e <vDisplayWriteStringAtPos+0x672>
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
				str[length] = char_temp;
    2df4:	f4 01       	movw	r30, r8
    2df6:	e0 5a       	subi	r30, 0xA0	; 160
    2df8:	f1 4d       	sbci	r31, 0xD1	; 209
    2dfa:	d7 01       	movw	r26, r14
    2dfc:	8c 91       	ld	r24, X
    2dfe:	80 83       	st	Z, r24
				length++;
    2e00:	bf ef       	ldi	r27, 0xFF	; 255
    2e02:	8b 1a       	sub	r8, r27
    2e04:	9b 0a       	sbc	r9, r27
				length++;
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
    2e06:	f7 01       	movw	r30, r14
    2e08:	32 96       	adiw	r30, 0x02	; 2
    2e0a:	7f 01       	movw	r14, r30
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2e0c:	d2 01       	movw	r26, r4
    2e0e:	c7 c2       	rjmp	.+1422   	; 0x339e <vDisplayWriteStringAtPos+0x672>
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2e10:	a7 01       	movw	r20, r14
    2e12:	4e 5f       	subi	r20, 0xFE	; 254
    2e14:	5f 4f       	sbci	r21, 0xFF	; 255
    2e16:	d7 01       	movw	r26, r14
    2e18:	8d 91       	ld	r24, X+
    2e1a:	9c 91       	ld	r25, X
    2e1c:	9c 01       	movw	r18, r24
    2e1e:	b4 01       	movw	r22, r8
    2e20:	f4 01       	movw	r30, r8
    2e22:	e0 5a       	subi	r30, 0xA0	; 160
    2e24:	f1 4d       	sbci	r31, 0xD1	; 209
				for(int i = 0; i < strlen(string_temp);i++) {
    2e26:	00 e0       	ldi	r16, 0x00	; 0
    2e28:	10 e0       	ldi	r17, 0x00	; 0
    2e2a:	06 c0       	rjmp	.+12     	; 0x2e38 <vDisplayWriteStringAtPos+0x10c>
					str[length+i] = string_temp[i];
    2e2c:	d9 01       	movw	r26, r18
    2e2e:	fd 90       	ld	r15, X+
    2e30:	9d 01       	movw	r18, r26
    2e32:	f1 92       	st	Z+, r15
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
				for(int i = 0; i < strlen(string_temp);i++) {
    2e34:	0f 5f       	subi	r16, 0xFF	; 255
    2e36:	1f 4f       	sbci	r17, 0xFF	; 255
    2e38:	dc 01       	movw	r26, r24
    2e3a:	0d 90       	ld	r0, X+
    2e3c:	00 20       	and	r0, r0
    2e3e:	e9 f7       	brne	.-6      	; 0x2e3a <vDisplayWriteStringAtPos+0x10e>
    2e40:	11 97       	sbiw	r26, 0x01	; 1
    2e42:	a8 1b       	sub	r26, r24
    2e44:	b9 0b       	sbc	r27, r25
    2e46:	0a 17       	cp	r16, r26
    2e48:	1b 07       	cpc	r17, r27
    2e4a:	80 f3       	brcs	.-32     	; 0x2e2c <vDisplayWriteStringAtPos+0x100>
					str[length+i] = string_temp[i];
				}
				length += strlen(string_temp);
    2e4c:	4d 01       	movw	r8, r26
    2e4e:	86 0e       	add	r8, r22
    2e50:	97 1e       	adc	r9, r23
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2e52:	7a 01       	movw	r14, r20
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2e54:	d2 01       	movw	r26, r4
    2e56:	a3 c2       	rjmp	.+1350   	; 0x339e <vDisplayWriteStringAtPos+0x672>
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    2e58:	87 01       	movw	r16, r14
    2e5a:	0e 5f       	subi	r16, 0xFE	; 254
    2e5c:	1f 4f       	sbci	r17, 0xFF	; 255
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    2e5e:	4a e0       	ldi	r20, 0x0A	; 10
    2e60:	b6 01       	movw	r22, r12
    2e62:	f7 01       	movw	r30, r14
    2e64:	80 81       	ld	r24, Z
    2e66:	91 81       	ldd	r25, Z+1	; 0x01
    2e68:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <__itoa_ncheck>
    2e6c:	94 01       	movw	r18, r8
    2e6e:	d4 01       	movw	r26, r8
    2e70:	a0 5a       	subi	r26, 0xA0	; 160
    2e72:	b1 4d       	sbci	r27, 0xD1	; 209
    2e74:	44 e7       	ldi	r20, 0x74	; 116
    2e76:	5e e2       	ldi	r21, 0x2E	; 46
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    2e78:	80 e0       	ldi	r24, 0x00	; 0
    2e7a:	90 e0       	ldi	r25, 0x00	; 0
    2e7c:	05 c0       	rjmp	.+10     	; 0x2e88 <vDisplayWriteStringAtPos+0x15c>
					str[length+i] = buffer[i];
    2e7e:	fa 01       	movw	r30, r20
    2e80:	61 91       	ld	r22, Z+
    2e82:	af 01       	movw	r20, r30
    2e84:	6d 93       	st	X+, r22

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    2e86:	01 96       	adiw	r24, 0x01	; 1
    2e88:	f6 01       	movw	r30, r12
    2e8a:	01 90       	ld	r0, Z+
    2e8c:	00 20       	and	r0, r0
    2e8e:	e9 f7       	brne	.-6      	; 0x2e8a <vDisplayWriteStringAtPos+0x15e>
    2e90:	31 97       	sbiw	r30, 0x01	; 1
    2e92:	e4 57       	subi	r30, 0x74	; 116
    2e94:	fe 42       	sbci	r31, 0x2E	; 46
    2e96:	8e 17       	cp	r24, r30
    2e98:	9f 07       	cpc	r25, r31
    2e9a:	88 f3       	brcs	.-30     	; 0x2e7e <vDisplayWriteStringAtPos+0x152>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    2e9c:	4f 01       	movw	r8, r30
    2e9e:	82 0e       	add	r8, r18
    2ea0:	93 1e       	adc	r9, r19
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    2ea2:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2ea4:	d2 01       	movw	r26, r4
    2ea6:	7b c2       	rjmp	.+1270   	; 0x339e <vDisplayWriteStringAtPos+0x672>
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    2ea8:	87 01       	movw	r16, r14
    2eaa:	0e 5f       	subi	r16, 0xFE	; 254
    2eac:	1f 4f       	sbci	r17, 0xFF	; 255
    2eae:	40 e1       	ldi	r20, 0x10	; 16
    2eb0:	b6 01       	movw	r22, r12
    2eb2:	d7 01       	movw	r26, r14
    2eb4:	8d 91       	ld	r24, X+
    2eb6:	9c 91       	ld	r25, X
    2eb8:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <__itoa_ncheck>
    2ebc:	94 01       	movw	r18, r8
    2ebe:	f4 01       	movw	r30, r8
    2ec0:	e0 5a       	subi	r30, 0xA0	; 160
    2ec2:	f1 4d       	sbci	r31, 0xD1	; 209
    2ec4:	44 e7       	ldi	r20, 0x74	; 116
    2ec6:	5e e2       	ldi	r21, 0x2E	; 46
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    2ec8:	80 e0       	ldi	r24, 0x00	; 0
    2eca:	90 e0       	ldi	r25, 0x00	; 0
    2ecc:	05 c0       	rjmp	.+10     	; 0x2ed8 <vDisplayWriteStringAtPos+0x1ac>
					str[length+i] = buffer[i];
    2ece:	da 01       	movw	r26, r20
    2ed0:	6d 91       	ld	r22, X+
    2ed2:	ad 01       	movw	r20, r26
    2ed4:	61 93       	st	Z+, r22

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    2ed6:	01 96       	adiw	r24, 0x01	; 1
    2ed8:	d6 01       	movw	r26, r12
    2eda:	0d 90       	ld	r0, X+
    2edc:	00 20       	and	r0, r0
    2ede:	e9 f7       	brne	.-6      	; 0x2eda <vDisplayWriteStringAtPos+0x1ae>
    2ee0:	11 97       	sbiw	r26, 0x01	; 1
    2ee2:	a4 57       	subi	r26, 0x74	; 116
    2ee4:	be 42       	sbci	r27, 0x2E	; 46
    2ee6:	8a 17       	cp	r24, r26
    2ee8:	9b 07       	cpc	r25, r27
    2eea:	88 f3       	brcs	.-30     	; 0x2ece <vDisplayWriteStringAtPos+0x1a2>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    2eec:	4d 01       	movw	r8, r26
    2eee:	82 0e       	add	r8, r18
    2ef0:	93 1e       	adc	r9, r19
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    2ef2:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2ef4:	d2 01       	movw	r26, r4
    2ef6:	53 c2       	rjmp	.+1190   	; 0x339e <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    2ef8:	17 01       	movw	r2, r14
    2efa:	b4 e0       	ldi	r27, 0x04	; 4
    2efc:	2b 0e       	add	r2, r27
    2efe:	31 1c       	adc	r3, r1
    2f00:	d7 01       	movw	r26, r14
    2f02:	8d 91       	ld	r24, X+
    2f04:	9d 91       	ld	r25, X+
    2f06:	0d 90       	ld	r0, X+
    2f08:	bc 91       	ld	r27, X
    2f0a:	a0 2d       	mov	r26, r0
    2f0c:	8f 8b       	std	Y+23, r24	; 0x17
    2f0e:	98 8f       	std	Y+24, r25	; 0x18
    2f10:	a9 8f       	std	Y+25, r26	; 0x19
    2f12:	ba 8f       	std	Y+26, r27	; 0x1a

    int exponent = 0;
    int places = 0;
    static const int width = 4;

    if (value == 0.0) {
    2f14:	20 e0       	ldi	r18, 0x00	; 0
    2f16:	30 e0       	ldi	r19, 0x00	; 0
    2f18:	a9 01       	movw	r20, r18
    2f1a:	bc 01       	movw	r22, r24
    2f1c:	cd 01       	movw	r24, r26
    2f1e:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    2f22:	81 11       	cpse	r24, r1
    2f24:	05 c0       	rjmp	.+10     	; 0x2f30 <vDisplayWriteStringAtPos+0x204>
        buffer[0] = '0';
    2f26:	20 e3       	ldi	r18, 0x30	; 48
    2f28:	f6 01       	movw	r30, r12
    2f2a:	20 83       	st	Z, r18
        buffer[1] = '\0';
    2f2c:	11 82       	std	Z+1, r1	; 0x01
    2f2e:	04 c1       	rjmp	.+520    	; 0x3138 <vDisplayWriteStringAtPos+0x40c>
        return;
    }         

    if (value < 0.0) {
    2f30:	20 e0       	ldi	r18, 0x00	; 0
    2f32:	30 e0       	ldi	r19, 0x00	; 0
    2f34:	a9 01       	movw	r20, r18
    2f36:	6f 89       	ldd	r22, Y+23	; 0x17
    2f38:	78 8d       	ldd	r23, Y+24	; 0x18
    2f3a:	89 8d       	ldd	r24, Y+25	; 0x19
    2f3c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f3e:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    2f42:	88 23       	and	r24, r24
    2f44:	9c f4       	brge	.+38     	; 0x2f6c <vDisplayWriteStringAtPos+0x240>
        *buffer++ = '-';
    2f46:	ed e2       	ldi	r30, 0x2D	; 45
    2f48:	d6 01       	movw	r26, r12
    2f4a:	ec 93       	st	X, r30
        value = -value;
    2f4c:	8f 89       	ldd	r24, Y+23	; 0x17
    2f4e:	98 8d       	ldd	r25, Y+24	; 0x18
    2f50:	a9 8d       	ldd	r26, Y+25	; 0x19
    2f52:	ba 8d       	ldd	r27, Y+26	; 0x1a
    2f54:	b0 58       	subi	r27, 0x80	; 128
    2f56:	8f 8b       	std	Y+23, r24	; 0x17
    2f58:	98 8f       	std	Y+24, r25	; 0x18
    2f5a:	a9 8f       	std	Y+25, r26	; 0x19
    2f5c:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
        *buffer++ = '-';
    2f5e:	0f 2e       	mov	r0, r31
    2f60:	f5 e7       	ldi	r31, 0x75	; 117
    2f62:	6f 2e       	mov	r6, r31
    2f64:	fe e2       	ldi	r31, 0x2E	; 46
    2f66:	7f 2e       	mov	r7, r31
    2f68:	f0 2d       	mov	r31, r0
    2f6a:	01 c0       	rjmp	.+2      	; 0x2f6e <vDisplayWriteStringAtPos+0x242>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
    2f6c:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    2f6e:	20 e0       	ldi	r18, 0x00	; 0
    2f70:	30 e0       	ldi	r19, 0x00	; 0
    2f72:	40 e8       	ldi	r20, 0x80	; 128
    2f74:	5f e3       	ldi	r21, 0x3F	; 63
    2f76:	6f 89       	ldd	r22, Y+23	; 0x17
    2f78:	78 8d       	ldd	r23, Y+24	; 0x18
    2f7a:	89 8d       	ldd	r24, Y+25	; 0x19
    2f7c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f7e:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    2f82:	88 23       	and	r24, r24
    2f84:	0c f4       	brge	.+2      	; 0x2f88 <vDisplayWriteStringAtPos+0x25c>
    2f86:	44 c2       	rjmp	.+1160   	; 0x3410 <vDisplayWriteStringAtPos+0x6e4>
    2f88:	00 e0       	ldi	r16, 0x00	; 0
    2f8a:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    2f8c:	20 e0       	ldi	r18, 0x00	; 0
    2f8e:	30 e0       	ldi	r19, 0x00	; 0
    2f90:	40 e2       	ldi	r20, 0x20	; 32
    2f92:	51 e4       	ldi	r21, 0x41	; 65
    2f94:	6f 89       	ldd	r22, Y+23	; 0x17
    2f96:	78 8d       	ldd	r23, Y+24	; 0x18
    2f98:	89 8d       	ldd	r24, Y+25	; 0x19
    2f9a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f9c:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <__divsf3>
    2fa0:	6f 8b       	std	Y+23, r22	; 0x17
    2fa2:	78 8f       	std	Y+24, r23	; 0x18
    2fa4:	89 8f       	std	Y+25, r24	; 0x19
    2fa6:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    2fa8:	0f 5f       	subi	r16, 0xFF	; 255
    2faa:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    2fac:	20 e0       	ldi	r18, 0x00	; 0
    2fae:	30 e0       	ldi	r19, 0x00	; 0
    2fb0:	40 e8       	ldi	r20, 0x80	; 128
    2fb2:	5f e3       	ldi	r21, 0x3F	; 63
    2fb4:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    2fb8:	88 23       	and	r24, r24
    2fba:	44 f7       	brge	.-48     	; 0x2f8c <vDisplayWriteStringAtPos+0x260>
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    2fbc:	2d ec       	ldi	r18, 0xCD	; 205
    2fbe:	3c ec       	ldi	r19, 0xCC	; 204
    2fc0:	4c ec       	ldi	r20, 0xCC	; 204
    2fc2:	5d e3       	ldi	r21, 0x3D	; 61
    2fc4:	6f 89       	ldd	r22, Y+23	; 0x17
    2fc6:	78 8d       	ldd	r23, Y+24	; 0x18
    2fc8:	89 8d       	ldd	r24, Y+25	; 0x19
    2fca:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2fcc:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    2fd0:	88 23       	and	r24, r24
    2fd2:	1c f0       	brlt	.+6      	; 0x2fda <vDisplayWriteStringAtPos+0x2ae>
    2fd4:	1a c0       	rjmp	.+52     	; 0x300a <vDisplayWriteStringAtPos+0x2de>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    2fd6:	00 e0       	ldi	r16, 0x00	; 0
    2fd8:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
        value *= 10.0;
    2fda:	20 e0       	ldi	r18, 0x00	; 0
    2fdc:	30 e0       	ldi	r19, 0x00	; 0
    2fde:	40 e2       	ldi	r20, 0x20	; 32
    2fe0:	51 e4       	ldi	r21, 0x41	; 65
    2fe2:	6f 89       	ldd	r22, Y+23	; 0x17
    2fe4:	78 8d       	ldd	r23, Y+24	; 0x18
    2fe6:	89 8d       	ldd	r24, Y+25	; 0x19
    2fe8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2fea:	0e 94 2e 1f 	call	0x3e5c	; 0x3e5c <__mulsf3>
    2fee:	6f 8b       	std	Y+23, r22	; 0x17
    2ff0:	78 8f       	std	Y+24, r23	; 0x18
    2ff2:	89 8f       	std	Y+25, r24	; 0x19
    2ff4:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    2ff6:	01 50       	subi	r16, 0x01	; 1
    2ff8:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    2ffa:	2d ec       	ldi	r18, 0xCD	; 205
    2ffc:	3c ec       	ldi	r19, 0xCC	; 204
    2ffe:	4c ec       	ldi	r20, 0xCC	; 204
    3000:	5d e3       	ldi	r21, 0x3D	; 61
    3002:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    3006:	88 23       	and	r24, r24
    3008:	44 f3       	brlt	.-48     	; 0x2fda <vDisplayWriteStringAtPos+0x2ae>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    300a:	10 16       	cp	r1, r16
    300c:	11 06       	cpc	r1, r17
    300e:	ac f5       	brge	.+106    	; 0x307a <vDisplayWriteStringAtPos+0x34e>
    3010:	73 01       	movw	r14, r6
    3012:	d3 01       	movw	r26, r6
    3014:	a0 0f       	add	r26, r16
    3016:	b1 1f       	adc	r27, r17
    3018:	ac 8f       	std	Y+28, r26	; 0x1c
    301a:	bd 8f       	std	Y+29, r27	; 0x1d
    301c:	3d 01       	movw	r6, r26
    301e:	6f 89       	ldd	r22, Y+23	; 0x17
    3020:	78 8d       	ldd	r23, Y+24	; 0x18
    3022:	89 8d       	ldd	r24, Y+25	; 0x19
    3024:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10;
    3026:	20 e0       	ldi	r18, 0x00	; 0
    3028:	30 e0       	ldi	r19, 0x00	; 0
    302a:	40 e2       	ldi	r20, 0x20	; 32
    302c:	51 e4       	ldi	r21, 0x41	; 65
    302e:	0e 94 2e 1f 	call	0x3e5c	; 0x3e5c <__mulsf3>
    3032:	6f 8b       	std	Y+23, r22	; 0x17
    3034:	78 8f       	std	Y+24, r23	; 0x18
    3036:	89 8f       	std	Y+25, r24	; 0x19
    3038:	9a 8f       	std	Y+26, r25	; 0x1a
    303a:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <__fixsfsi>
        *buffer++ = digit + '0';
    303e:	20 e3       	ldi	r18, 0x30	; 48
    3040:	26 0f       	add	r18, r22
    3042:	f7 01       	movw	r30, r14
    3044:	21 93       	st	Z+, r18
    3046:	7f 01       	movw	r14, r30
        value = value * 10 - digit;
    3048:	07 2e       	mov	r0, r23
    304a:	00 0c       	add	r0, r0
    304c:	88 0b       	sbc	r24, r24
    304e:	99 0b       	sbc	r25, r25
    3050:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <__floatsisf>
    3054:	9b 01       	movw	r18, r22
    3056:	ac 01       	movw	r20, r24
    3058:	6f 89       	ldd	r22, Y+23	; 0x17
    305a:	78 8d       	ldd	r23, Y+24	; 0x18
    305c:	89 8d       	ldd	r24, Y+25	; 0x19
    305e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3060:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <__subsf3>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    3064:	e6 14       	cp	r14, r6
    3066:	f7 04       	cpc	r15, r7
    3068:	f1 f6       	brne	.-68     	; 0x3026 <vDisplayWriteStringAtPos+0x2fa>
    306a:	6f 8b       	std	Y+23, r22	; 0x17
    306c:	78 8f       	std	Y+24, r23	; 0x18
    306e:	89 8f       	std	Y+25, r24	; 0x19
    3070:	9a 8f       	std	Y+26, r25	; 0x1a
        value = value * 10 - digit;
        ++places;
        --exponent;
    }

    if (places == 0)
    3072:	01 15       	cp	r16, r1
    3074:	11 05       	cpc	r17, r1
    3076:	89 f4       	brne	.+34     	; 0x309a <vDisplayWriteStringAtPos+0x36e>
    3078:	db c1       	rjmp	.+950    	; 0x3430 <vDisplayWriteStringAtPos+0x704>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    307a:	c8 01       	movw	r24, r16
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    307c:	e0 e3       	ldi	r30, 0x30	; 48
    307e:	d3 01       	movw	r26, r6
    3080:	ec 93       	st	X, r30

    *buffer++ = '.';
    3082:	73 01       	movw	r14, r6
    3084:	f2 e0       	ldi	r31, 0x02	; 2
    3086:	ef 0e       	add	r14, r31
    3088:	f1 1c       	adc	r15, r1
    308a:	2e e2       	ldi	r18, 0x2E	; 46
    308c:	11 96       	adiw	r26, 0x01	; 1
    308e:	2c 93       	st	X, r18

    while (exponent < 0 && places < width) {
    3090:	99 23       	and	r25, r25
    3092:	6c f0       	brlt	.+26     	; 0x30ae <vDisplayWriteStringAtPos+0x382>
    3094:	00 e0       	ldi	r16, 0x00	; 0
    3096:	10 e0       	ldi	r17, 0x00	; 0
    3098:	1f c0       	rjmp	.+62     	; 0x30d8 <vDisplayWriteStringAtPos+0x3ac>
    }

    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';
    309a:	ec 8c       	ldd	r14, Y+28	; 0x1c
    309c:	fd 8c       	ldd	r15, Y+29	; 0x1d
    309e:	3f ef       	ldi	r19, 0xFF	; 255
    30a0:	e3 1a       	sub	r14, r19
    30a2:	f3 0a       	sbc	r15, r19
    30a4:	ee e2       	ldi	r30, 0x2E	; 46
    30a6:	ac 8d       	ldd	r26, Y+28	; 0x1c
    30a8:	bd 8d       	ldd	r27, Y+29	; 0x1d
    30aa:	ec 93       	st	X, r30
    30ac:	12 c0       	rjmp	.+36     	; 0x30d2 <vDisplayWriteStringAtPos+0x3a6>

    while (exponent < 0 && places < width) {
    30ae:	00 e0       	ldi	r16, 0x00	; 0
    30b0:	10 e0       	ldi	r17, 0x00	; 0
        *buffer++ = '0';
    30b2:	ff ef       	ldi	r31, 0xFF	; 255
    30b4:	ef 1a       	sub	r14, r31
    30b6:	ff 0a       	sbc	r15, r31
    30b8:	f7 01       	movw	r30, r14
    30ba:	31 97       	sbiw	r30, 0x01	; 1
    30bc:	20 e3       	ldi	r18, 0x30	; 48
    30be:	20 83       	st	Z, r18
        --exponent;
    30c0:	01 97       	sbiw	r24, 0x01	; 1
        ++places;
    30c2:	0f 5f       	subi	r16, 0xFF	; 255
    30c4:	1f 4f       	sbci	r17, 0xFF	; 255
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    30c6:	99 23       	and	r25, r25
    30c8:	24 f4       	brge	.+8      	; 0x30d2 <vDisplayWriteStringAtPos+0x3a6>
    30ca:	04 30       	cpi	r16, 0x04	; 4
    30cc:	11 05       	cpc	r17, r1
    30ce:	8c f3       	brlt	.-30     	; 0x30b2 <vDisplayWriteStringAtPos+0x386>
    30d0:	31 c0       	rjmp	.+98     	; 0x3134 <vDisplayWriteStringAtPos+0x408>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    30d2:	04 30       	cpi	r16, 0x04	; 4
    30d4:	11 05       	cpc	r17, r1
    30d6:	74 f5       	brge	.+92     	; 0x3134 <vDisplayWriteStringAtPos+0x408>
    30d8:	37 01       	movw	r6, r14
    30da:	84 e0       	ldi	r24, 0x04	; 4
    30dc:	90 e0       	ldi	r25, 0x00	; 0
    30de:	80 1b       	sub	r24, r16
    30e0:	91 0b       	sbc	r25, r17
    30e2:	e8 0e       	add	r14, r24
    30e4:	f9 1e       	adc	r15, r25
    30e6:	87 01       	movw	r16, r14
    30e8:	6f 89       	ldd	r22, Y+23	; 0x17
    30ea:	78 8d       	ldd	r23, Y+24	; 0x18
    30ec:	89 8d       	ldd	r24, Y+25	; 0x19
    30ee:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10.0;
    30f0:	20 e0       	ldi	r18, 0x00	; 0
    30f2:	30 e0       	ldi	r19, 0x00	; 0
    30f4:	40 e2       	ldi	r20, 0x20	; 32
    30f6:	51 e4       	ldi	r21, 0x41	; 65
    30f8:	0e 94 2e 1f 	call	0x3e5c	; 0x3e5c <__mulsf3>
    30fc:	6f 8b       	std	Y+23, r22	; 0x17
    30fe:	78 8f       	std	Y+24, r23	; 0x18
    3100:	89 8f       	std	Y+25, r24	; 0x19
    3102:	9a 8f       	std	Y+26, r25	; 0x1a
    3104:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <__fixsfsi>
        *buffer++ = digit + '0';
    3108:	20 e3       	ldi	r18, 0x30	; 48
    310a:	26 0f       	add	r18, r22
    310c:	d3 01       	movw	r26, r6
    310e:	2d 93       	st	X+, r18
    3110:	3d 01       	movw	r6, r26
        value = value * 10.0 - digit;
    3112:	07 2e       	mov	r0, r23
    3114:	00 0c       	add	r0, r0
    3116:	88 0b       	sbc	r24, r24
    3118:	99 0b       	sbc	r25, r25
    311a:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <__floatsisf>
    311e:	9b 01       	movw	r18, r22
    3120:	ac 01       	movw	r20, r24
    3122:	6f 89       	ldd	r22, Y+23	; 0x17
    3124:	78 8d       	ldd	r23, Y+24	; 0x18
    3126:	89 8d       	ldd	r24, Y+25	; 0x19
    3128:	9a 8d       	ldd	r25, Y+26	; 0x1a
    312a:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <__subsf3>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    312e:	60 16       	cp	r6, r16
    3130:	71 06       	cpc	r7, r17
    3132:	f1 f6       	brne	.-68     	; 0x30f0 <vDisplayWriteStringAtPos+0x3c4>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
        ++places;
    }
    *buffer = '\0';
    3134:	f7 01       	movw	r30, r14
    3136:	10 82       	st	Z, r1
    3138:	94 01       	movw	r18, r8
    313a:	f4 01       	movw	r30, r8
    313c:	e0 5a       	subi	r30, 0xA0	; 160
    313e:	f1 4d       	sbci	r31, 0xD1	; 209
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    3140:	44 e7       	ldi	r20, 0x74	; 116
    3142:	5e e2       	ldi	r21, 0x2E	; 46
    3144:	80 e0       	ldi	r24, 0x00	; 0
    3146:	90 e0       	ldi	r25, 0x00	; 0
    3148:	05 c0       	rjmp	.+10     	; 0x3154 <vDisplayWriteStringAtPos+0x428>

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    314a:	da 01       	movw	r26, r20
    314c:	6d 91       	ld	r22, X+
    314e:	ad 01       	movw	r20, r26
    3150:	61 93       	st	Z+, r22
				break;

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    3152:	01 96       	adiw	r24, 0x01	; 1
    3154:	d6 01       	movw	r26, r12
    3156:	0d 90       	ld	r0, X+
    3158:	00 20       	and	r0, r0
    315a:	e9 f7       	brne	.-6      	; 0x3156 <vDisplayWriteStringAtPos+0x42a>
    315c:	11 97       	sbiw	r26, 0x01	; 1
    315e:	a4 57       	subi	r26, 0x74	; 116
    3160:	be 42       	sbci	r27, 0x2E	; 46
    3162:	8a 17       	cp	r24, r26
    3164:	9b 07       	cpc	r25, r27
    3166:	88 f3       	brcs	.-30     	; 0x314a <vDisplayWriteStringAtPos+0x41e>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    3168:	4d 01       	movw	r8, r26
    316a:	82 0e       	add	r8, r18
    316c:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    316e:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3170:	d2 01       	movw	r26, r4
    3172:	15 c1       	rjmp	.+554    	; 0x339e <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    3174:	17 01       	movw	r2, r14
    3176:	b4 e0       	ldi	r27, 0x04	; 4
    3178:	2b 0e       	add	r2, r27
    317a:	31 1c       	adc	r3, r1
    317c:	d7 01       	movw	r26, r14
    317e:	8d 91       	ld	r24, X+
    3180:	9d 91       	ld	r25, X+
    3182:	0d 90       	ld	r0, X+
    3184:	bc 91       	ld	r27, X
    3186:	a0 2d       	mov	r26, r0
    3188:	8f 8b       	std	Y+23, r24	; 0x17
    318a:	98 8f       	std	Y+24, r25	; 0x18
    318c:	a9 8f       	std	Y+25, r26	; 0x19
    318e:	ba 8f       	std	Y+26, r27	; 0x1a

void ftoa_sci(char *buffer, double value) {
    int exponent = 0;    
    static const int width = 4;

    if (value == 0.0) {
    3190:	20 e0       	ldi	r18, 0x00	; 0
    3192:	30 e0       	ldi	r19, 0x00	; 0
    3194:	a9 01       	movw	r20, r18
    3196:	bc 01       	movw	r22, r24
    3198:	cd 01       	movw	r24, r26
    319a:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    319e:	81 11       	cpse	r24, r1
    31a0:	05 c0       	rjmp	.+10     	; 0x31ac <vDisplayWriteStringAtPos+0x480>
        buffer[0] = '0';
    31a2:	20 e3       	ldi	r18, 0x30	; 48
    31a4:	f6 01       	movw	r30, r12
    31a6:	20 83       	st	Z, r18
        buffer[1] = '\0';
    31a8:	11 82       	std	Z+1, r1	; 0x01
    31aa:	ca c0       	rjmp	.+404    	; 0x3340 <vDisplayWriteStringAtPos+0x614>
        return;
    }

    if (value < 0.0) {
    31ac:	20 e0       	ldi	r18, 0x00	; 0
    31ae:	30 e0       	ldi	r19, 0x00	; 0
    31b0:	a9 01       	movw	r20, r18
    31b2:	6f 89       	ldd	r22, Y+23	; 0x17
    31b4:	78 8d       	ldd	r23, Y+24	; 0x18
    31b6:	89 8d       	ldd	r24, Y+25	; 0x19
    31b8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31ba:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    31be:	88 23       	and	r24, r24
    31c0:	9c f4       	brge	.+38     	; 0x31e8 <vDisplayWriteStringAtPos+0x4bc>
        *buffer++ = '-';
    31c2:	ed e2       	ldi	r30, 0x2D	; 45
    31c4:	d6 01       	movw	r26, r12
    31c6:	ec 93       	st	X, r30
        value = -value;
    31c8:	8f 89       	ldd	r24, Y+23	; 0x17
    31ca:	98 8d       	ldd	r25, Y+24	; 0x18
    31cc:	a9 8d       	ldd	r26, Y+25	; 0x19
    31ce:	ba 8d       	ldd	r27, Y+26	; 0x1a
    31d0:	b0 58       	subi	r27, 0x80	; 128
    31d2:	8f 8b       	std	Y+23, r24	; 0x17
    31d4:	98 8f       	std	Y+24, r25	; 0x18
    31d6:	a9 8f       	std	Y+25, r26	; 0x19
    31d8:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
        *buffer++ = '-';
    31da:	0f 2e       	mov	r0, r31
    31dc:	f5 e7       	ldi	r31, 0x75	; 117
    31de:	6f 2e       	mov	r6, r31
    31e0:	fe e2       	ldi	r31, 0x2E	; 46
    31e2:	7f 2e       	mov	r7, r31
    31e4:	f0 2d       	mov	r31, r0
    31e6:	01 c0       	rjmp	.+2      	; 0x31ea <vDisplayWriteStringAtPos+0x4be>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
    31e8:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    31ea:	20 e0       	ldi	r18, 0x00	; 0
    31ec:	30 e0       	ldi	r19, 0x00	; 0
    31ee:	40 e8       	ldi	r20, 0x80	; 128
    31f0:	5f e3       	ldi	r21, 0x3F	; 63
    31f2:	6f 89       	ldd	r22, Y+23	; 0x17
    31f4:	78 8d       	ldd	r23, Y+24	; 0x18
    31f6:	89 8d       	ldd	r24, Y+25	; 0x19
    31f8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31fa:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    31fe:	88 23       	and	r24, r24
    3200:	dc f0       	brlt	.+54     	; 0x3238 <vDisplayWriteStringAtPos+0x50c>
    3202:	00 e0       	ldi	r16, 0x00	; 0
    3204:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    3206:	20 e0       	ldi	r18, 0x00	; 0
    3208:	30 e0       	ldi	r19, 0x00	; 0
    320a:	40 e2       	ldi	r20, 0x20	; 32
    320c:	51 e4       	ldi	r21, 0x41	; 65
    320e:	6f 89       	ldd	r22, Y+23	; 0x17
    3210:	78 8d       	ldd	r23, Y+24	; 0x18
    3212:	89 8d       	ldd	r24, Y+25	; 0x19
    3214:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3216:	0e 94 cf 1d 	call	0x3b9e	; 0x3b9e <__divsf3>
    321a:	6f 8b       	std	Y+23, r22	; 0x17
    321c:	78 8f       	std	Y+24, r23	; 0x18
    321e:	89 8f       	std	Y+25, r24	; 0x19
    3220:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    3222:	0f 5f       	subi	r16, 0xFF	; 255
    3224:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3226:	20 e0       	ldi	r18, 0x00	; 0
    3228:	30 e0       	ldi	r19, 0x00	; 0
    322a:	40 e8       	ldi	r20, 0x80	; 128
    322c:	5f e3       	ldi	r21, 0x3F	; 63
    322e:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    3232:	88 23       	and	r24, r24
    3234:	44 f7       	brge	.-48     	; 0x3206 <vDisplayWriteStringAtPos+0x4da>
    3236:	02 c0       	rjmp	.+4      	; 0x323c <vDisplayWriteStringAtPos+0x510>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    3238:	00 e0       	ldi	r16, 0x00	; 0
    323a:	10 e0       	ldi	r17, 0x00	; 0
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    323c:	2d ec       	ldi	r18, 0xCD	; 205
    323e:	3c ec       	ldi	r19, 0xCC	; 204
    3240:	4c ec       	ldi	r20, 0xCC	; 204
    3242:	5d e3       	ldi	r21, 0x3D	; 61
    3244:	6f 89       	ldd	r22, Y+23	; 0x17
    3246:	78 8d       	ldd	r23, Y+24	; 0x18
    3248:	89 8d       	ldd	r24, Y+25	; 0x19
    324a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    324c:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    3250:	88 23       	and	r24, r24
    3252:	c4 f4       	brge	.+48     	; 0x3284 <vDisplayWriteStringAtPos+0x558>
        value *= 10.0;
    3254:	20 e0       	ldi	r18, 0x00	; 0
    3256:	30 e0       	ldi	r19, 0x00	; 0
    3258:	40 e2       	ldi	r20, 0x20	; 32
    325a:	51 e4       	ldi	r21, 0x41	; 65
    325c:	6f 89       	ldd	r22, Y+23	; 0x17
    325e:	78 8d       	ldd	r23, Y+24	; 0x18
    3260:	89 8d       	ldd	r24, Y+25	; 0x19
    3262:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3264:	0e 94 2e 1f 	call	0x3e5c	; 0x3e5c <__mulsf3>
    3268:	6f 8b       	std	Y+23, r22	; 0x17
    326a:	78 8f       	std	Y+24, r23	; 0x18
    326c:	89 8f       	std	Y+25, r24	; 0x19
    326e:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    3270:	01 50       	subi	r16, 0x01	; 1
    3272:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3274:	2d ec       	ldi	r18, 0xCD	; 205
    3276:	3c ec       	ldi	r19, 0xCC	; 204
    3278:	4c ec       	ldi	r20, 0xCC	; 204
    327a:	5d e3       	ldi	r21, 0x3D	; 61
    327c:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    3280:	88 23       	and	r24, r24
    3282:	44 f3       	brlt	.-48     	; 0x3254 <vDisplayWriteStringAtPos+0x528>
        value = -value;
    }

    exponent = normalize(&value);

    int digit = value * 10.0;
    3284:	20 e0       	ldi	r18, 0x00	; 0
    3286:	30 e0       	ldi	r19, 0x00	; 0
    3288:	40 e2       	ldi	r20, 0x20	; 32
    328a:	51 e4       	ldi	r21, 0x41	; 65
    328c:	6f 89       	ldd	r22, Y+23	; 0x17
    328e:	78 8d       	ldd	r23, Y+24	; 0x18
    3290:	89 8d       	ldd	r24, Y+25	; 0x19
    3292:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3294:	0e 94 2e 1f 	call	0x3e5c	; 0x3e5c <__mulsf3>
    3298:	6f 8b       	std	Y+23, r22	; 0x17
    329a:	78 8f       	std	Y+24, r23	; 0x18
    329c:	89 8f       	std	Y+25, r24	; 0x19
    329e:	9a 8f       	std	Y+26, r25	; 0x1a
    32a0:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <__fixsfsi>
    *buffer++ = digit + '0';
    32a4:	20 e3       	ldi	r18, 0x30	; 48
    32a6:	26 0f       	add	r18, r22
    32a8:	d3 01       	movw	r26, r6
    32aa:	2c 93       	st	X, r18
    value = value * 10.0 - digit;
    32ac:	07 2e       	mov	r0, r23
    32ae:	00 0c       	add	r0, r0
    32b0:	88 0b       	sbc	r24, r24
    32b2:	99 0b       	sbc	r25, r25
    32b4:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <__floatsisf>
    32b8:	9b 01       	movw	r18, r22
    32ba:	ac 01       	movw	r20, r24
    32bc:	6f 89       	ldd	r22, Y+23	; 0x17
    32be:	78 8d       	ldd	r23, Y+24	; 0x18
    32c0:	89 8d       	ldd	r24, Y+25	; 0x19
    32c2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    32c4:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <__subsf3>
    --exponent;
    32c8:	f8 01       	movw	r30, r16
    32ca:	31 97       	sbiw	r30, 0x01	; 1
    32cc:	ec 8f       	std	Y+28, r30	; 0x1c
    32ce:	fd 8f       	std	Y+29, r31	; 0x1d

    *buffer++ = '.';
    32d0:	ee e2       	ldi	r30, 0x2E	; 46
    32d2:	d3 01       	movw	r26, r6
    32d4:	11 96       	adiw	r26, 0x01	; 1
    32d6:	ec 93       	st	X, r30
    32d8:	83 01       	movw	r16, r6
    32da:	0e 5f       	subi	r16, 0xFE	; 254
    32dc:	1f 4f       	sbci	r17, 0xFF	; 255
    32de:	73 01       	movw	r14, r6
    32e0:	f6 e0       	ldi	r31, 0x06	; 6
    32e2:	ef 0e       	add	r14, r31
    32e4:	f1 1c       	adc	r15, r1

    for (int i = 0; i < width; i++) {
        int digit = value * 10.0;
    32e6:	20 e0       	ldi	r18, 0x00	; 0
    32e8:	30 e0       	ldi	r19, 0x00	; 0
    32ea:	40 e2       	ldi	r20, 0x20	; 32
    32ec:	51 e4       	ldi	r21, 0x41	; 65
    32ee:	0e 94 2e 1f 	call	0x3e5c	; 0x3e5c <__mulsf3>
    32f2:	6f 8b       	std	Y+23, r22	; 0x17
    32f4:	78 8f       	std	Y+24, r23	; 0x18
    32f6:	89 8f       	std	Y+25, r24	; 0x19
    32f8:	9a 8f       	std	Y+26, r25	; 0x1a
    32fa:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <__fixsfsi>
        *buffer++ = digit + '0';
    32fe:	20 e3       	ldi	r18, 0x30	; 48
    3300:	26 0f       	add	r18, r22
    3302:	d8 01       	movw	r26, r16
    3304:	2d 93       	st	X+, r18
    3306:	8d 01       	movw	r16, r26
        value = value * 10.0 - digit;
    3308:	07 2e       	mov	r0, r23
    330a:	00 0c       	add	r0, r0
    330c:	88 0b       	sbc	r24, r24
    330e:	99 0b       	sbc	r25, r25
    3310:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <__floatsisf>
    3314:	9b 01       	movw	r18, r22
    3316:	ac 01       	movw	r20, r24
    3318:	6f 89       	ldd	r22, Y+23	; 0x17
    331a:	78 8d       	ldd	r23, Y+24	; 0x18
    331c:	89 8d       	ldd	r24, Y+25	; 0x19
    331e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3320:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <__subsf3>
    value = value * 10.0 - digit;
    --exponent;

    *buffer++ = '.';

    for (int i = 0; i < width; i++) {
    3324:	0e 15       	cp	r16, r14
    3326:	1f 05       	cpc	r17, r15
    3328:	f1 f6       	brne	.-68     	; 0x32e6 <vDisplayWriteStringAtPos+0x5ba>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
    }

    *buffer++ = 'e';
    332a:	25 e6       	ldi	r18, 0x65	; 101
    332c:	f3 01       	movw	r30, r6
    332e:	26 83       	std	Z+6, r18	; 0x06
    3330:	b3 01       	movw	r22, r6
    3332:	69 5f       	subi	r22, 0xF9	; 249
    3334:	7f 4f       	sbci	r23, 0xFF	; 255
    3336:	4a e0       	ldi	r20, 0x0A	; 10
    3338:	8c 8d       	ldd	r24, Y+28	; 0x1c
    333a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    333c:	0e 94 db 1f 	call	0x3fb6	; 0x3fb6 <__itoa_ncheck>
    3340:	94 01       	movw	r18, r8
    3342:	f4 01       	movw	r30, r8
    3344:	e0 5a       	subi	r30, 0xA0	; 160
    3346:	f1 4d       	sbci	r31, 0xD1	; 209
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    3348:	44 e7       	ldi	r20, 0x74	; 116
    334a:	5e e2       	ldi	r21, 0x2E	; 46
    334c:	80 e0       	ldi	r24, 0x00	; 0
    334e:	90 e0       	ldi	r25, 0x00	; 0
    3350:	05 c0       	rjmp	.+10     	; 0x335c <vDisplayWriteStringAtPos+0x630>

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    3352:	da 01       	movw	r26, r20
    3354:	6d 91       	ld	r22, X+
    3356:	ad 01       	movw	r20, r26
    3358:	61 93       	st	Z+, r22
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    335a:	01 96       	adiw	r24, 0x01	; 1
    335c:	d6 01       	movw	r26, r12
    335e:	0d 90       	ld	r0, X+
    3360:	00 20       	and	r0, r0
    3362:	e9 f7       	brne	.-6      	; 0x335e <vDisplayWriteStringAtPos+0x632>
    3364:	11 97       	sbiw	r26, 0x01	; 1
    3366:	a4 57       	subi	r26, 0x74	; 116
    3368:	be 42       	sbci	r27, 0x2E	; 46
    336a:	8a 17       	cp	r24, r26
    336c:	9b 07       	cpc	r25, r27
    336e:	88 f3       	brcs	.-30     	; 0x3352 <vDisplayWriteStringAtPos+0x626>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    3370:	4d 01       	movw	r8, r26
    3372:	82 0e       	add	r8, r18
    3374:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    3376:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3378:	d2 01       	movw	r26, r4
    337a:	11 c0       	rjmp	.+34     	; 0x339e <vDisplayWriteStringAtPos+0x672>
				break;
			}
		}
		else {
			str[length] = ch;
			if(str[length] == '\n') {
    337c:	8a 30       	cpi	r24, 0x0A	; 10
    337e:	29 f0       	breq	.+10     	; 0x338a <vDisplayWriteStringAtPos+0x65e>
				length += strlen(buffer);
				break;
			}
		}
		else {
			str[length] = ch;
    3380:	f4 01       	movw	r30, r8
    3382:	e0 5a       	subi	r30, 0xA0	; 160
    3384:	f1 4d       	sbci	r31, 0xD1	; 209
    3386:	80 83       	st	Z, r24
    3388:	04 c0       	rjmp	.+8      	; 0x3392 <vDisplayWriteStringAtPos+0x666>
			if(str[length] == '\n') {
				str[length] = '\0';				
    338a:	f4 01       	movw	r30, r8
    338c:	e0 5a       	subi	r30, 0xA0	; 160
    338e:	f1 4d       	sbci	r31, 0xD1	; 209
    3390:	10 82       	st	Z, r1
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    3392:	11 96       	adiw	r26, 0x01	; 1
		else {
			str[length] = ch;
			if(str[length] == '\n') {
				str[length] = '\0';				
			}
			length++;
    3394:	ef ef       	ldi	r30, 0xFF	; 255
    3396:	8e 1a       	sub	r8, r30
    3398:	9e 0a       	sbc	r9, r30
    339a:	01 c0       	rjmp	.+2      	; 0x339e <vDisplayWriteStringAtPos+0x672>
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    339c:	d2 01       	movw	r26, r4
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    339e:	8c 91       	ld	r24, X
    33a0:	81 11       	cpse	r24, r1
    33a2:	01 cd       	rjmp	.-1534   	; 0x2da6 <vDisplayWriteStringAtPos+0x7a>
				str[length] = '\0';				
			}
			length++;
		}
	}
	if(length + pos >= 20) {
    33a4:	8d a9       	ldd	r24, Y+53	; 0x35
    33a6:	9e a9       	ldd	r25, Y+54	; 0x36
    33a8:	88 0d       	add	r24, r8
    33aa:	99 1d       	adc	r25, r9
    33ac:	44 97       	sbiw	r24, 0x14	; 20
    33ae:	3c f0       	brlt	.+14     	; 0x33be <vDisplayWriteStringAtPos+0x692>
		length = 20-pos;
    33b0:	84 e1       	ldi	r24, 0x14	; 20
    33b2:	90 e0       	ldi	r25, 0x00	; 0
    33b4:	4c 01       	movw	r8, r24
    33b6:	2d a9       	ldd	r18, Y+53	; 0x35
    33b8:	3e a9       	ldd	r19, Y+54	; 0x36
    33ba:	82 1a       	sub	r8, r18
    33bc:	93 0a       	sbc	r9, r19
    33be:	fe 01       	movw	r30, r28
    33c0:	33 96       	adiw	r30, 0x03	; 3
    33c2:	ce 01       	movw	r24, r28
    33c4:	47 96       	adiw	r24, 0x17	; 23
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    33c6:	df 01       	movw	r26, r30
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
    33c8:	1d 92       	st	X+, r1
	}
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
    33ca:	a8 17       	cp	r26, r24
    33cc:	b9 07       	cpc	r27, r25
    33ce:	e1 f7       	brne	.-8      	; 0x33c8 <vDisplayWriteStringAtPos+0x69c>
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
    33d0:	3b 8d       	ldd	r19, Y+27	; 0x1b
    33d2:	39 83       	std	Y+1, r19	; 0x01
	newLine.displayPos = pos;
    33d4:	8d a9       	ldd	r24, Y+53	; 0x35
    33d6:	8a 83       	std	Y+2, r24	; 0x02
	for(int i = 0; i < length;i++) {
    33d8:	18 14       	cp	r1, r8
    33da:	19 04       	cpc	r1, r9
    33dc:	5c f4       	brge	.+22     	; 0x33f4 <vDisplayWriteStringAtPos+0x6c8>
    33de:	ce 01       	movw	r24, r28
    33e0:	88 0d       	add	r24, r8
    33e2:	99 1d       	adc	r25, r9
    33e4:	03 96       	adiw	r24, 0x03	; 3
		newLine.displayBuffer[i] = str[i];
    33e6:	d5 01       	movw	r26, r10
    33e8:	2d 91       	ld	r18, X+
    33ea:	5d 01       	movw	r10, r26
    33ec:	21 93       	st	Z+, r18
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
	newLine.displayPos = pos;
	for(int i = 0; i < length;i++) {
    33ee:	8e 17       	cp	r24, r30
    33f0:	9f 07       	cpc	r25, r31
    33f2:	c9 f7       	brne	.-14     	; 0x33e6 <vDisplayWriteStringAtPos+0x6ba>
		newLine.displayBuffer[i] = str[i];
	}	
	xQueueSend(displayLineQueue, (void *) &newLine, portMAX_DELAY);
    33f4:	00 e0       	ldi	r16, 0x00	; 0
    33f6:	2f ef       	ldi	r18, 0xFF	; 255
    33f8:	3f ef       	ldi	r19, 0xFF	; 255
    33fa:	a9 01       	movw	r20, r18
    33fc:	be 01       	movw	r22, r28
    33fe:	6f 5f       	subi	r22, 0xFF	; 255
    3400:	7f 4f       	sbci	r23, 0xFF	; 255
    3402:	80 91 2d 32 	lds	r24, 0x322D	; 0x80322d <displayLineQueue>
    3406:	90 91 2e 32 	lds	r25, 0x322E	; 0x80322e <displayLineQueue+0x1>
    340a:	0e 94 b8 08 	call	0x1170	; 0x1170 <xQueueGenericSend>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    340e:	1b c0       	rjmp	.+54     	; 0x3446 <vDisplayWriteStringAtPos+0x71a>
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3410:	2d ec       	ldi	r18, 0xCD	; 205
    3412:	3c ec       	ldi	r19, 0xCC	; 204
    3414:	4c ec       	ldi	r20, 0xCC	; 204
    3416:	5d e3       	ldi	r21, 0x3D	; 61
    3418:	6f 89       	ldd	r22, Y+23	; 0x17
    341a:	78 8d       	ldd	r23, Y+24	; 0x18
    341c:	89 8d       	ldd	r24, Y+25	; 0x19
    341e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3420:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    3424:	88 23       	and	r24, r24
    3426:	0c f4       	brge	.+2      	; 0x342a <vDisplayWriteStringAtPos+0x6fe>
    3428:	d6 cd       	rjmp	.-1108   	; 0x2fd6 <vDisplayWriteStringAtPos+0x2aa>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    342a:	80 e0       	ldi	r24, 0x00	; 0
    342c:	90 e0       	ldi	r25, 0x00	; 0
    342e:	26 ce       	rjmp	.-948    	; 0x307c <vDisplayWriteStringAtPos+0x350>
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    3430:	20 e3       	ldi	r18, 0x30	; 48
    3432:	ec 8d       	ldd	r30, Y+28	; 0x1c
    3434:	fd 8d       	ldd	r31, Y+29	; 0x1d
    3436:	20 83       	st	Z, r18

    *buffer++ = '.';
    3438:	7f 01       	movw	r14, r30
    343a:	32 e0       	ldi	r19, 0x02	; 2
    343c:	e3 0e       	add	r14, r19
    343e:	f1 1c       	adc	r15, r1
    3440:	8e e2       	ldi	r24, 0x2E	; 46
    3442:	81 83       	std	Z+1, r24	; 0x01
    3444:	46 ce       	rjmp	.-884    	; 0x30d2 <vDisplayWriteStringAtPos+0x3a6>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    3446:	6d 96       	adiw	r28, 0x1d	; 29
    3448:	cd bf       	out	0x3d, r28	; 61
    344a:	de bf       	out	0x3e, r29	; 62
    344c:	df 91       	pop	r29
    344e:	cf 91       	pop	r28
    3450:	1f 91       	pop	r17
    3452:	0f 91       	pop	r16
    3454:	ff 90       	pop	r15
    3456:	ef 90       	pop	r14
    3458:	df 90       	pop	r13
    345a:	cf 90       	pop	r12
    345c:	bf 90       	pop	r11
    345e:	af 90       	pop	r10
    3460:	9f 90       	pop	r9
    3462:	8f 90       	pop	r8
    3464:	7f 90       	pop	r7
    3466:	6f 90       	pop	r6
    3468:	5f 90       	pop	r5
    346a:	4f 90       	pop	r4
    346c:	3f 90       	pop	r3
    346e:	2f 90       	pop	r2
    3470:	08 95       	ret

00003472 <vPhase_Detection>:
SemaphoreHandle_t xGlobalProtocolBuffer_A_Key;	//A-Resource for ucGlobalProtocolBuffer_A
SemaphoreHandle_t xGlobalProtocolBuffer_B_Key;	//A-Resource for ucGlobalProtocolBuffer_B


void vPhase_Detection(void *pvParameters) // becomes peak array and position -> detects the phase shift
{
    3472:	cf 93       	push	r28
    3474:	df 93       	push	r29
    3476:	cd b7       	in	r28, 0x3d	; 61
    3478:	de b7       	in	r29, 0x3e	; 62
    347a:	c0 54       	subi	r28, 0x40	; 64
    347c:	d1 09       	sbc	r29, r1
    347e:	cd bf       	out	0x3d, r28	; 61
    3480:	de bf       	out	0x3e, r29	; 62
	int	check_phase_1, check_phase_2;
	int phase_H[32], phase_L[32];
	int phase_detect_results;
	int check_peak_position;
	int i = 0, j = 0;
	uint16_t ucqambit , ucvalue , uci, ucj, ucl, ucm, uca=0, ucb=0, ucx=0, ucy=0;
    3482:	41 2c       	mov	r4, r1
    3484:	51 2c       	mov	r5, r1
	int xreference_H,xreference_L,periode_rms;
	int	check_phase_1, check_phase_2;
	int phase_H[32], phase_L[32];
	int phase_detect_results;
	int check_peak_position;
	int i = 0, j = 0;
    3486:	a1 2c       	mov	r10, r1
    3488:	b1 2c       	mov	r11, r1

		/*Phase Detection */
		
		if ((uxBits & Process_Phase_detectionA)||(uxBits & Process_Phase_detectionB))	/* if Bit phase detection is set -> read out peak array*/
		{
			xreference_H = position_array_H[0]*4;
    348a:	0f 2e       	mov	r0, r31
    348c:	f9 ea       	ldi	r31, 0xA9	; 169
    348e:	2f 2e       	mov	r2, r31
    3490:	f1 e3       	ldi	r31, 0x31	; 49
    3492:	3f 2e       	mov	r3, r31
    3494:	f0 2d       	mov	r31, r0
    3496:	0f 2e       	mov	r0, r31
    3498:	f9 ee       	ldi	r31, 0xE9	; 233
    349a:	8f 2e       	mov	r8, r31
    349c:	f1 e3       	ldi	r31, 0x31	; 49
    349e:	9f 2e       	mov	r9, r31
    34a0:	f0 2d       	mov	r31, r0
    34a2:	0f 2e       	mov	r0, r31
    34a4:	f0 e9       	ldi	r31, 0x90	; 144
    34a6:	6f 2e       	mov	r6, r31
    34a8:	fe e2       	ldi	r31, 0x2E	; 46
    34aa:	7f 2e       	mov	r7, r31
    34ac:	f0 2d       	mov	r31, r0
	int i = 0, j = 0;
	uint16_t ucqambit , ucvalue , uci, ucj, ucl, ucm, uca=0, ucb=0, ucx=0, ucy=0;
	char xOutput1, xOutput2;
	for (;;)
	{
		uxBits = xEventGroupWaitBits(
    34ae:	cc 24       	eor	r12, r12
    34b0:	ca 94       	dec	r12
    34b2:	dc 2c       	mov	r13, r12
    34b4:	76 01       	movw	r14, r12
    34b6:	00 e0       	ldi	r16, 0x00	; 0
    34b8:	21 e0       	ldi	r18, 0x01	; 1
    34ba:	43 e0       	ldi	r20, 0x03	; 3
    34bc:	50 e0       	ldi	r21, 0x00	; 0
    34be:	60 e0       	ldi	r22, 0x00	; 0
    34c0:	70 e0       	ldi	r23, 0x00	; 0
    34c2:	80 91 a7 31 	lds	r24, 0x31A7	; 0x8031a7 <xPhaseDetectionEventGroup>
    34c6:	90 91 a8 31 	lds	r25, 0x31A8	; 0x8031a8 <xPhaseDetectionEventGroup+0x1>
    34ca:	0e 94 75 03 	call	0x6ea	; 0x6ea <xEventGroupWaitBits>
		portMAX_DELAY );																/* Wait a maximum for either bit to be set. */


		/*Phase Detection */
		
		if ((uxBits & Process_Phase_detectionA)||(uxBits & Process_Phase_detectionB))	/* if Bit phase detection is set -> read out peak array*/
    34ce:	63 70       	andi	r22, 0x03	; 3
    34d0:	77 27       	eor	r23, r23
    34d2:	67 2b       	or	r22, r23
    34d4:	09 f4       	brne	.+2      	; 0x34d8 <vPhase_Detection+0x66>
    34d6:	83 c0       	rjmp	.+262    	; 0x35de <vPhase_Detection+0x16c>
		{
			xreference_H = position_array_H[0]*4;
    34d8:	d1 01       	movw	r26, r2
    34da:	ed 91       	ld	r30, X+
    34dc:	fc 91       	ld	r31, X
    34de:	7f 01       	movw	r14, r30
    34e0:	ee 0c       	add	r14, r14
    34e2:	ff 1c       	adc	r15, r15
    34e4:	ee 0c       	add	r14, r14
    34e6:	ff 1c       	adc	r15, r15
			xreference_L = position_array_L[0]*4/3;
    34e8:	a1 e2       	ldi	r26, 0x21	; 33
    34ea:	b1 e3       	ldi	r27, 0x31	; 49
    34ec:	2d 91       	ld	r18, X+
    34ee:	3c 91       	ld	r19, X
    34f0:	c9 01       	movw	r24, r18
    34f2:	88 0f       	add	r24, r24
    34f4:	99 1f       	adc	r25, r25
    34f6:	88 0f       	add	r24, r24
    34f8:	99 1f       	adc	r25, r25
    34fa:	63 e0       	ldi	r22, 0x03	; 3
    34fc:	70 e0       	ldi	r23, 0x00	; 0
    34fe:	0e 94 9b 1f 	call	0x3f36	; 0x3f36 <__divmodhi4>
			periode_rms = position_array_H[0] + position_array_L[0];									/*(peak position of referencsignal added together will give the number of sampels for one sinus periode;*/
    3502:	af 01       	movw	r20, r30
    3504:	42 0f       	add	r20, r18
    3506:	53 1f       	adc	r21, r19
				
			check_phase_1 = xreference_L - xreference_H;								/*check differences between phase_H and phase_L to prove that no reading error happened*/
    3508:	6b 01       	movw	r12, r22
    350a:	ce 18       	sub	r12, r14
    350c:	df 08       	sbc	r13, r15
    350e:	e9 ea       	ldi	r30, 0xA9	; 169
    3510:	f1 e3       	ldi	r31, 0x31	; 49
    3512:	de 01       	movw	r26, r28
    3514:	11 96       	adiw	r26, 0x01	; 1
			check_phase_2 = xreference_H - xreference_L;
				
			for (i=0; i<PROTOCOL_BUFFER_SIZE; i++)															/*original variable after testing: peak_array_length*/
			{
		
					position_array_H[i] = position_array_H[i]; /* Debugging*/
    3516:	21 91       	ld	r18, Z+
    3518:	31 91       	ld	r19, Z+
					position_array_L[i] = position_array_L[i]; /* Debugging*/
					phase_H[i] = (periode_rms*(j+1) - position_array_H[i]);					/* calculates the distance from high peak to start of next periode.*/
    351a:	8f ef       	ldi	r24, 0xFF	; 255
    351c:	a8 1a       	sub	r10, r24
    351e:	b8 0a       	sbc	r11, r24
    3520:	4a 9d       	mul	r20, r10
    3522:	c0 01       	movw	r24, r0
    3524:	4b 9d       	mul	r20, r11
    3526:	90 0d       	add	r25, r0
    3528:	5a 9d       	mul	r21, r10
    352a:	90 0d       	add	r25, r0
    352c:	11 24       	eor	r1, r1
    352e:	82 1b       	sub	r24, r18
    3530:	93 0b       	sbc	r25, r19
    3532:	8d 93       	st	X+, r24
    3534:	9d 93       	st	X+, r25
					phase_L[i] = (periode_rms*(j+1) - position_array_L[i]);					/* calculates the distance from low peak to start of next periode.*/
					// Phase High detect
					j++;
					if (j == 5)
    3536:	95 e0       	ldi	r25, 0x05	; 5
    3538:	a9 16       	cp	r10, r25
    353a:	b1 04       	cpc	r11, r1
    353c:	11 f4       	brne	.+4      	; 0x3542 <vPhase_Detection+0xd0>
					{
						j = 0;
    353e:	a1 2c       	mov	r10, r1
    3540:	b1 2c       	mov	r11, r1
			periode_rms = position_array_H[0] + position_array_L[0];									/*(peak position of referencsignal added together will give the number of sampels for one sinus periode;*/
				
			check_phase_1 = xreference_L - xreference_H;								/*check differences between phase_H and phase_L to prove that no reading error happened*/
			check_phase_2 = xreference_H - xreference_L;
				
			for (i=0; i<PROTOCOL_BUFFER_SIZE; i++)															/*original variable after testing: peak_array_length*/
    3542:	e8 15       	cp	r30, r8
    3544:	f9 05       	cpc	r31, r9
    3546:	39 f7       	brne	.-50     	; 0x3516 <vPhase_Detection+0xa4>
					}

			
			
			}
				if (( check_phase_1 < 2 )||( check_phase_2 < 2 ))						/* check if theres no read out error with comparing low peak and high peak position of reference periode.*/
    3548:	a2 e0       	ldi	r26, 0x02	; 2
    354a:	ca 16       	cp	r12, r26
    354c:	d1 04       	cpc	r13, r1
    354e:	3c f0       	brlt	.+14     	; 0x355e <vPhase_Detection+0xec>
    3550:	e6 1a       	sub	r14, r22
    3552:	f7 0a       	sbc	r15, r23
    3554:	b2 e0       	ldi	r27, 0x02	; 2
    3556:	eb 16       	cp	r14, r27
    3558:	f1 04       	cpc	r15, r1
    355a:	0c f0       	brlt	.+2      	; 0x355e <vPhase_Detection+0xec>
    355c:	40 c0       	rjmp	.+128    	; 0x35de <vPhase_Detection+0x16c>
    355e:	a8 e8       	ldi	r26, 0x88	; 136
    3560:	be e2       	ldi	r27, 0x2E	; 46
    3562:	f2 01       	movw	r30, r4
    3564:	ee 0f       	add	r30, r30
    3566:	ff 1f       	adc	r31, r31
    3568:	81 e0       	ldi	r24, 0x01	; 1
    356a:	90 e0       	ldi	r25, 0x00	; 0
    356c:	8c 0f       	add	r24, r28
    356e:	9d 1f       	adc	r25, r29
    3570:	e8 0f       	add	r30, r24
    3572:	f9 1f       	adc	r31, r25
    3574:	2f c0       	rjmp	.+94     	; 0x35d4 <vPhase_Detection+0x162>
					 /*if(xSemaphoreTake( xGlobalProtocolBuffer_A_Key, portMAX_DELAY ))*/  /*taken out for testing */ 					{
						for (uci = 0; uci < 8; uci++)									/*For Schleife mit 8 Wiederholungen fr 8 Byte */
						{
							for (ucj = 0; ucj < 4; ucj++)								/*For Schleife mit 4 Wiederholungen fr 8 Bits (1Byte)*/
							{
								ucvalue = phase_H[ucy];									/* result will get calculated from high peak array (low peak array is only used for checking deviations */
    3576:	21 91       	ld	r18, Z+
    3578:	31 91       	ld	r19, Z+
								ucy++;
								if((ucvalue < 10) && (ucvalue > 1))	/* 180 */
    357a:	b9 01       	movw	r22, r18
    357c:	62 50       	subi	r22, 0x02	; 2
    357e:	71 09       	sbc	r23, r1
    3580:	68 30       	cpi	r22, 0x08	; 8
    3582:	71 05       	cpc	r23, r1
    3584:	88 f0       	brcs	.+34     	; 0x35a8 <vPhase_Detection+0x136>
								{
									ucqambit = 0;
									check_peak_position = ucvalue * 4;
								}
								else if((ucvalue < 15) && (ucvalue > 9)) /* 270 */
    3586:	68 50       	subi	r22, 0x08	; 8
    3588:	71 09       	sbc	r23, r1
    358a:	65 30       	cpi	r22, 0x05	; 5
    358c:	71 05       	cpc	r23, r1
    358e:	70 f0       	brcs	.+28     	; 0x35ac <vPhase_Detection+0x13a>
								{
									ucqambit = 1;
									check_peak_position = ucvalue * 2;
								}
								else if((ucvalue < 19) && (ucvalue > 14)) /* 0 */
    3590:	65 50       	subi	r22, 0x05	; 5
    3592:	71 09       	sbc	r23, r1
    3594:	64 30       	cpi	r22, 0x04	; 4
    3596:	71 05       	cpc	r23, r1
    3598:	58 f0       	brcs	.+22     	; 0x35b0 <vPhase_Detection+0x13e>
								{
									ucqambit = 2;
									check_peak_position = ucvalue * 4 / 3;
								}
								else if((ucvalue < 24) && (ucvalue > 18)) /* 90 */
    359a:	23 51       	subi	r18, 0x13	; 19
    359c:	31 09       	sbc	r19, r1
    359e:	25 30       	cpi	r18, 0x05	; 5
    35a0:	31 05       	cpc	r19, r1
    35a2:	38 f4       	brcc	.+14     	; 0x35b2 <vPhase_Detection+0x140>
								{
									ucqambit = 3;
    35a4:	13 e0       	ldi	r17, 0x03	; 3
    35a6:	05 c0       	rjmp	.+10     	; 0x35b2 <vPhase_Detection+0x140>
							{
								ucvalue = phase_H[ucy];									/* result will get calculated from high peak array (low peak array is only used for checking deviations */
								ucy++;
								if((ucvalue < 10) && (ucvalue > 1))	/* 180 */
								{
									ucqambit = 0;
    35a8:	10 e0       	ldi	r17, 0x00	; 0
    35aa:	03 c0       	rjmp	.+6      	; 0x35b2 <vPhase_Detection+0x140>
									check_peak_position = ucvalue * 4;
								}
								else if((ucvalue < 15) && (ucvalue > 9)) /* 270 */
								{
									ucqambit = 1;
    35ac:	11 e0       	ldi	r17, 0x01	; 1
    35ae:	01 c0       	rjmp	.+2      	; 0x35b2 <vPhase_Detection+0x140>
									check_peak_position = ucvalue * 2;
								}
								else if((ucvalue < 19) && (ucvalue > 14)) /* 0 */
								{
									ucqambit = 2;
    35b0:	12 e0       	ldi	r17, 0x02	; 2
								else if((ucvalue < 24) && (ucvalue > 18)) /* 90 */
								{
									ucqambit = 3;
									check_peak_position = ucvalue;
								}
								xOutput1 = (xOutput1 << 2) | (ucqambit & 0x03);
    35b2:	88 0f       	add	r24, r24
    35b4:	88 0f       	add	r24, r24
    35b6:	91 2f       	mov	r25, r17
    35b8:	93 70       	andi	r25, 0x03	; 3
    35ba:	89 2b       	or	r24, r25
				{
				
					 /*if(xSemaphoreTake( xGlobalProtocolBuffer_A_Key, portMAX_DELAY ))*/  /*taken out for testing */ 					{
						for (uci = 0; uci < 8; uci++)									/*For Schleife mit 8 Wiederholungen fr 8 Byte */
						{
							for (ucj = 0; ucj < 4; ucj++)								/*For Schleife mit 4 Wiederholungen fr 8 Bits (1Byte)*/
    35bc:	4e 17       	cp	r20, r30
    35be:	5f 07       	cpc	r21, r31
    35c0:	d1 f6       	brne	.-76     	; 0x3576 <vPhase_Detection+0x104>
									ucqambit = 3;
									check_peak_position = ucvalue;
								}
								xOutput1 = (xOutput1 << 2) | (ucqambit & 0x03);
							}
							ucGlobalProtocolBuffer_A[uca] = xOutput1;
    35c2:	8d 93       	st	X+, r24
    35c4:	fa 01       	movw	r30, r20
			}
				if (( check_phase_1 < 2 )||( check_phase_2 < 2 ))						/* check if theres no read out error with comparing low peak and high peak position of reference periode.*/
				{
				
					 /*if(xSemaphoreTake( xGlobalProtocolBuffer_A_Key, portMAX_DELAY ))*/  /*taken out for testing */ 					{
						for (uci = 0; uci < 8; uci++)									/*For Schleife mit 8 Wiederholungen fr 8 Byte */
    35c6:	6a 16       	cp	r6, r26
    35c8:	7b 06       	cpc	r7, r27
    35ca:	21 f4       	brne	.+8      	; 0x35d4 <vPhase_Detection+0x162>
    35cc:	90 e2       	ldi	r25, 0x20	; 32
    35ce:	49 0e       	add	r4, r25
    35d0:	51 1c       	adc	r5, r1
    35d2:	05 c0       	rjmp	.+10     	; 0x35de <vPhase_Detection+0x16c>
    35d4:	af 01       	movw	r20, r30
    35d6:	48 5f       	subi	r20, 0xF8	; 248
    35d8:	5f 4f       	sbci	r21, 0xFF	; 255
					phase_L[i] = (periode_rms*(j+1) - position_array_L[i]);					/* calculates the distance from low peak to start of next periode.*/
					// Phase High detect
					j++;
					if (j == 5)
					{
						j = 0;
    35da:	80 e0       	ldi	r24, 0x00	; 0
    35dc:	cc cf       	rjmp	.-104    	; 0x3576 <vPhase_Detection+0x104>
				}
		}
		
		
		
		vTaskDelay(100 / portTICK_RATE_MS);
    35de:	64 e6       	ldi	r22, 0x64	; 100
    35e0:	70 e0       	ldi	r23, 0x00	; 0
    35e2:	80 e0       	ldi	r24, 0x00	; 0
    35e4:	90 e0       	ldi	r25, 0x00	; 0
    35e6:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vTaskDelay>
	}
    35ea:	61 cf       	rjmp	.-318    	; 0x34ae <vPhase_Detection+0x3c>

000035ec <vRead_Peaks>:
#define peak_array_length 32



void vRead_Peaks(void *pvParameters)
{
    35ec:	cf 93       	push	r28
    35ee:	df 93       	push	r29
    35f0:	cd b7       	in	r28, 0x3d	; 61
    35f2:	de b7       	in	r29, 0x3e	; 62
    35f4:	2c 97       	sbiw	r28, 0x0c	; 12
    35f6:	cd bf       	out	0x3d, r28	; 61
    35f8:	de bf       	out	0x3e, r29	; 62
	int high_peak = 127;
	int low_peak_a = 127;
	int low_peak = 127;
	int count_array_a = 0;
	int count_array_b = 0;
	int count_array_position_H = 0, count_array_position_L = 0;
    35fa:	19 86       	std	Y+9, r1	; 0x09
    35fc:	1a 86       	std	Y+10, r1	; 0x0a
    35fe:	1f 82       	std	Y+7, r1	; 0x07
    3600:	18 86       	std	Y+8, r1	; 0x08
	int high_peak_a = 127;
	int high_peak = 127;
	int low_peak_a = 127;
	int low_peak = 127;
	int count_array_a = 0;
	int count_array_b = 0;
    3602:	41 2c       	mov	r4, r1
    3604:	51 2c       	mov	r5, r1
{
	int high_peak_a = 127;
	int high_peak = 127;
	int low_peak_a = 127;
	int low_peak = 127;
	int count_array_a = 0;
    3606:	1b 86       	std	Y+11, r1	; 0x0b
    3608:	1c 86       	std	Y+12, r1	; 0x0c
void vRead_Peaks(void *pvParameters)
{
	int high_peak_a = 127;
	int high_peak = 127;
	int low_peak_a = 127;
	int low_peak = 127;
    360a:	0f 2e       	mov	r0, r31
    360c:	ff e7       	ldi	r31, 0x7F	; 127
    360e:	8f 2e       	mov	r8, r31
    3610:	91 2c       	mov	r9, r1
    3612:	f0 2d       	mov	r31, r0


void vRead_Peaks(void *pvParameters)
{
	int high_peak_a = 127;
	int high_peak = 127;
    3614:	0f 2e       	mov	r0, r31
    3616:	ff e7       	ldi	r31, 0x7F	; 127
    3618:	af 2e       	mov	r10, r31
    361a:	b1 2c       	mov	r11, r1
    361c:	f0 2d       	mov	r31, r0
	//int count_array_a = 0;
	EventBits_t uxBits;
	BaseType_t xResult;
	for (;;)
	{
		uxBits = xEventGroupWaitBits(
    361e:	cc 24       	eor	r12, r12
    3620:	ca 94       	dec	r12
    3622:	dc 2c       	mov	r13, r12
    3624:	76 01       	movw	r14, r12
    3626:	00 e0       	ldi	r16, 0x00	; 0
    3628:	21 e0       	ldi	r18, 0x01	; 1
    362a:	43 e0       	ldi	r20, 0x03	; 3
    362c:	50 e0       	ldi	r21, 0x00	; 0
    362e:	60 e0       	ldi	r22, 0x00	; 0
    3630:	70 e0       	ldi	r23, 0x00	; 0
    3632:	80 91 a4 2f 	lds	r24, 0x2FA4	; 0x802fa4 <xSignalProcessEventGroup>
    3636:	90 91 a5 2f 	lds	r25, 0x2FA5	; 0x802fa5 <xSignalProcessEventGroup+0x1>
    363a:	0e 94 75 03 	call	0x6ea	; 0x6ea <xEventGroupWaitBits>
		Process_Signal_BufferA | Process_Signal_BufferB,		/* The bits within the event group to wait for. */
		pdTRUE,													/* Bits should be cleared before returning. */
		pdFALSE,												/* Don't wait for both bits, either bit will do. */
		portMAX_DELAY );										/* Wait a maximum for either bit to be set. */
		//process signal values
		if (uxBits & Process_Signal_BufferA)											/* if "BufferA" bit is set, read out bufferA*/
    363e:	60 ff       	sbrs	r22, 0
    3640:	09 c1       	rjmp	.+530    	; 0x3854 <vRead_Peaks+0x268>
		{
			i = 0;
			for(i=0;i<xtest_array_length;i++)
    3642:	80 91 81 21 	lds	r24, 0x2181	; 0x802181 <xtest_array_length>
    3646:	90 91 82 21 	lds	r25, 0x2182	; 0x802182 <xtest_array_length+0x1>
    364a:	18 16       	cp	r1, r24
    364c:	19 06       	cpc	r1, r25
    364e:	0c f0       	brlt	.+2      	; 0x3652 <vRead_Peaks+0x66>
    3650:	07 c2       	rjmp	.+1038   	; 0x3a60 <vRead_Peaks+0x474>
    3652:	00 e0       	ldi	r16, 0x00	; 0
    3654:	10 e0       	ldi	r17, 0x00	; 0
			{
				/* HIGH PEAK A*/
				if(count_array_a >= peak_array_length)									/* check if a package is ready to transmit*/
    3656:	8b 85       	ldd	r24, Y+11	; 0x0b
    3658:	9c 85       	ldd	r25, Y+12	; 0x0c
    365a:	80 97       	sbiw	r24, 0x20	; 32
    365c:	6c f0       	brlt	.+26     	; 0x3678 <vRead_Peaks+0x8c>
				{
						position_array_H[count_array_position_H] =position_array_H[count_array_position_H];		/*debugging*/
						position_array_L[count_array_position_L] = position_array_L[count_array_position_L];	/*debugging*/
					count_array_a = 0;
					xResult = xEventGroupSetBits(										/* Set bit 0 and bit 4 in xEventGroup. */
    365e:	41 e0       	ldi	r20, 0x01	; 1
    3660:	50 e0       	ldi	r21, 0x00	; 0
    3662:	60 e0       	ldi	r22, 0x00	; 0
    3664:	70 e0       	ldi	r23, 0x00	; 0
    3666:	80 91 a7 31 	lds	r24, 0x31A7	; 0x8031a7 <xPhaseDetectionEventGroup>
    366a:	90 91 a8 31 	lds	r25, 0x31A8	; 0x8031a8 <xPhaseDetectionEventGroup+0x1>
    366e:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <xEventGroupSetBits>
				/* HIGH PEAK A*/
				if(count_array_a >= peak_array_length)									/* check if a package is ready to transmit*/
				{
						position_array_H[count_array_position_H] =position_array_H[count_array_position_H];		/*debugging*/
						position_array_L[count_array_position_L] = position_array_L[count_array_position_L];	/*debugging*/
					count_array_a = 0;
    3672:	1b 86       	std	Y+11, r1	; 0x0b
    3674:	1c 86       	std	Y+12, r1	; 0x0c
    3676:	e3 c0       	rjmp	.+454    	; 0x383e <vRead_Peaks+0x252>
					Process_Phase_detectionA											/* The bits being set. */
					);
				}
				else
				{
					if (xtest_array[i] > 127)
    3678:	f8 01       	movw	r30, r16
    367a:	ee 0f       	add	r30, r30
    367c:	ff 1f       	adc	r31, r31
    367e:	ee 0f       	add	r30, r30
    3680:	ff 1f       	adc	r31, r31
    3682:	ef 5f       	subi	r30, 0xFF	; 255
    3684:	ff 4d       	sbci	r31, 0xDF	; 223
    3686:	c0 80       	ld	r12, Z
    3688:	d1 80       	ldd	r13, Z+1	; 0x01
    368a:	e2 80       	ldd	r14, Z+2	; 0x02
    368c:	f3 80       	ldd	r15, Z+3	; 0x03
    368e:	20 e0       	ldi	r18, 0x00	; 0
    3690:	30 e0       	ldi	r19, 0x00	; 0
    3692:	4e ef       	ldi	r20, 0xFE	; 254
    3694:	52 e4       	ldi	r21, 0x42	; 66
    3696:	c7 01       	movw	r24, r14
    3698:	b6 01       	movw	r22, r12
    369a:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    369e:	18 16       	cp	r1, r24
    36a0:	0c f0       	brlt	.+2      	; 0x36a4 <vRead_Peaks+0xb8>
    36a2:	69 c0       	rjmp	.+210    	; 0x3776 <vRead_Peaks+0x18a>
					{
						if (xtest_array[i] > high_peak)									/* after test use buffer_a		//		if buffer bigger than current high_peak*/
    36a4:	b5 01       	movw	r22, r10
    36a6:	0b 2c       	mov	r0, r11
    36a8:	00 0c       	add	r0, r0
    36aa:	88 0b       	sbc	r24, r24
    36ac:	99 0b       	sbc	r25, r25
    36ae:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <__floatsisf>
    36b2:	9b 01       	movw	r18, r22
    36b4:	ac 01       	movw	r20, r24
    36b6:	c7 01       	movw	r24, r14
    36b8:	b6 01       	movw	r22, r12
    36ba:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    36be:	18 16       	cp	r1, r24
    36c0:	cc f4       	brge	.+50     	; 0x36f4 <vRead_Peaks+0x108>
						{
							if (xtest_array[i] > 220)
    36c2:	20 e0       	ldi	r18, 0x00	; 0
    36c4:	30 e0       	ldi	r19, 0x00	; 0
    36c6:	4c e5       	ldi	r20, 0x5C	; 92
    36c8:	53 e4       	ldi	r21, 0x43	; 67
    36ca:	c7 01       	movw	r24, r14
    36cc:	b6 01       	movw	r22, r12
    36ce:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    36d2:	18 16       	cp	r1, r24
    36d4:	0c f0       	brlt	.+2      	; 0x36d8 <vRead_Peaks+0xec>
    36d6:	b3 c0       	rjmp	.+358    	; 0x383e <vRead_Peaks+0x252>
							{
								high_peak = xtest_array[i];								// store new peak
    36d8:	c7 01       	movw	r24, r14
    36da:	b6 01       	movw	r22, r12
    36dc:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <__fixsfsi>
    36e0:	5b 01       	movw	r10, r22
    36e2:	0b 83       	std	Y+3, r16	; 0x03
    36e4:	1c 83       	std	Y+4, r17	; 0x04
								position_high_peak_a = i;								// store array position of new peak
								flag_H = 1;
								flag_L = 0;
    36e6:	21 2c       	mov	r2, r1
    36e8:	31 2c       	mov	r3, r1
						{
							if (xtest_array[i] > 220)
							{
								high_peak = xtest_array[i];								// store new peak
								position_high_peak_a = i;								// store array position of new peak
								flag_H = 1;
    36ea:	81 e0       	ldi	r24, 0x01	; 1
    36ec:	90 e0       	ldi	r25, 0x00	; 0
    36ee:	89 83       	std	Y+1, r24	; 0x01
    36f0:	9a 83       	std	Y+2, r25	; 0x02
    36f2:	a5 c0       	rjmp	.+330    	; 0x383e <vRead_Peaks+0x252>
								flag_L = 0;
							}
						}
						else
						{
							if (xtest_array[i] > 170 )
    36f4:	20 e0       	ldi	r18, 0x00	; 0
    36f6:	30 e0       	ldi	r19, 0x00	; 0
    36f8:	4a e2       	ldi	r20, 0x2A	; 42
    36fa:	53 e4       	ldi	r21, 0x43	; 67
    36fc:	c7 01       	movw	r24, r14
    36fe:	b6 01       	movw	r22, r12
    3700:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    3704:	18 16       	cp	r1, r24
    3706:	24 f4       	brge	.+8      	; 0x3710 <vRead_Peaks+0x124>
							{
								count_after_peak++;
    3708:	9f ef       	ldi	r25, 0xFF	; 255
    370a:	69 1a       	sub	r6, r25
    370c:	79 0a       	sbc	r7, r25
    370e:	97 c0       	rjmp	.+302    	; 0x383e <vRead_Peaks+0x252>
							}
							else if(xtest_array[i] < 170)
    3710:	20 e0       	ldi	r18, 0x00	; 0
    3712:	30 e0       	ldi	r19, 0x00	; 0
    3714:	4a e2       	ldi	r20, 0x2A	; 42
    3716:	53 e4       	ldi	r21, 0x43	; 67
    3718:	c7 01       	movw	r24, r14
    371a:	b6 01       	movw	r22, r12
    371c:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    3720:	88 23       	and	r24, r24
    3722:	0c f0       	brlt	.+2      	; 0x3726 <vRead_Peaks+0x13a>
    3724:	8c c0       	rjmp	.+280    	; 0x383e <vRead_Peaks+0x252>
							{
								if(flag_H == 1)
    3726:	89 81       	ldd	r24, Y+1	; 0x01
    3728:	9a 81       	ldd	r25, Y+2	; 0x02
    372a:	01 97       	sbiw	r24, 0x01	; 1
    372c:	09 f0       	breq	.+2      	; 0x3730 <vRead_Peaks+0x144>
    372e:	87 c0       	rjmp	.+270    	; 0x383e <vRead_Peaks+0x252>
								{
									if (count_after_peak > 2)
    3730:	93 e0       	ldi	r25, 0x03	; 3
    3732:	69 16       	cp	r6, r25
    3734:	71 04       	cpc	r7, r1
    3736:	0c f4       	brge	.+2      	; 0x373a <vRead_Peaks+0x14e>
    3738:	82 c0       	rjmp	.+260    	; 0x383e <vRead_Peaks+0x252>
									{
										peak_array_H[count_array_position_H] = high_peak;
										position_array_H[count_array_position_H] = position_high_peak_a;
    373a:	ef 81       	ldd	r30, Y+7	; 0x07
    373c:	f8 85       	ldd	r31, Y+8	; 0x08
    373e:	ee 0f       	add	r30, r30
    3740:	ff 1f       	adc	r31, r31
    3742:	e7 55       	subi	r30, 0x57	; 87
    3744:	fe 4c       	sbci	r31, 0xCE	; 206
    3746:	8b 81       	ldd	r24, Y+3	; 0x03
    3748:	80 83       	st	Z, r24
    374a:	9c 81       	ldd	r25, Y+4	; 0x04
    374c:	91 83       	std	Z+1, r25	; 0x01
										count_array_position_H++;
    374e:	8f 81       	ldd	r24, Y+7	; 0x07
    3750:	98 85       	ldd	r25, Y+8	; 0x08
    3752:	01 96       	adiw	r24, 0x01	; 1
    3754:	8f 83       	std	Y+7, r24	; 0x07
    3756:	98 87       	std	Y+8, r25	; 0x08
										count_array_a++;									/* Count up to activate event bit when 16 peaks got collected*/
    3758:	8b 85       	ldd	r24, Y+11	; 0x0b
    375a:	9c 85       	ldd	r25, Y+12	; 0x0c
    375c:	01 96       	adiw	r24, 0x01	; 1
    375e:	8b 87       	std	Y+11, r24	; 0x0b
    3760:	9c 87       	std	Y+12, r25	; 0x0c
										high_peak = 127;
										flag_H = 0;
    3762:	19 82       	std	Y+1, r1	; 0x01
    3764:	1a 82       	std	Y+2, r1	; 0x02
										count_after_peak = 0;
    3766:	61 2c       	mov	r6, r1
    3768:	71 2c       	mov	r7, r1
									{
										peak_array_H[count_array_position_H] = high_peak;
										position_array_H[count_array_position_H] = position_high_peak_a;
										count_array_position_H++;
										count_array_a++;									/* Count up to activate event bit when 16 peaks got collected*/
										high_peak = 127;
    376a:	0f 2e       	mov	r0, r31
    376c:	ff e7       	ldi	r31, 0x7F	; 127
    376e:	af 2e       	mov	r10, r31
    3770:	f0 2d       	mov	r31, r0
    3772:	b1 2c       	mov	r11, r1
    3774:	64 c0       	rjmp	.+200    	; 0x383e <vRead_Peaks+0x252>
						}
					}
					// LOW PEAK	A
					else
					{
						if (xtest_array[i] < low_peak)										/*if buffer bigger than current high_peak*/
    3776:	b4 01       	movw	r22, r8
    3778:	09 2c       	mov	r0, r9
    377a:	00 0c       	add	r0, r0
    377c:	88 0b       	sbc	r24, r24
    377e:	99 0b       	sbc	r25, r25
    3780:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <__floatsisf>
    3784:	9b 01       	movw	r18, r22
    3786:	ac 01       	movw	r20, r24
    3788:	c7 01       	movw	r24, r14
    378a:	b6 01       	movw	r22, r12
    378c:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    3790:	88 23       	and	r24, r24
    3792:	c4 f4       	brge	.+48     	; 0x37c4 <vRead_Peaks+0x1d8>
						{
							if (xtest_array[i] < 40)
    3794:	20 e0       	ldi	r18, 0x00	; 0
    3796:	30 e0       	ldi	r19, 0x00	; 0
    3798:	40 e2       	ldi	r20, 0x20	; 32
    379a:	52 e4       	ldi	r21, 0x42	; 66
    379c:	c7 01       	movw	r24, r14
    379e:	b6 01       	movw	r22, r12
    37a0:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    37a4:	88 23       	and	r24, r24
    37a6:	0c f0       	brlt	.+2      	; 0x37aa <vRead_Peaks+0x1be>
    37a8:	4a c0       	rjmp	.+148    	; 0x383e <vRead_Peaks+0x252>
							{
								low_peak = xtest_array[i];									/* store new peak*/
    37aa:	c7 01       	movw	r24, r14
    37ac:	b6 01       	movw	r22, r12
    37ae:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <__fixsfsi>
    37b2:	4b 01       	movw	r8, r22
    37b4:	0d 83       	std	Y+5, r16	; 0x05
    37b6:	1e 83       	std	Y+6, r17	; 0x06
								position_low_peak_a = i;									/* store array position of new peak*/
								flag_L = 1;
    37b8:	22 24       	eor	r2, r2
    37ba:	23 94       	inc	r2
    37bc:	31 2c       	mov	r3, r1
								flag_H = 0;
    37be:	19 82       	std	Y+1, r1	; 0x01
    37c0:	1a 82       	std	Y+2, r1	; 0x02
    37c2:	3d c0       	rjmp	.+122    	; 0x383e <vRead_Peaks+0x252>
							}
						}
						else
						{
							if (xtest_array[i] < 85)
    37c4:	20 e0       	ldi	r18, 0x00	; 0
    37c6:	30 e0       	ldi	r19, 0x00	; 0
    37c8:	4a ea       	ldi	r20, 0xAA	; 170
    37ca:	52 e4       	ldi	r21, 0x42	; 66
    37cc:	c7 01       	movw	r24, r14
    37ce:	b6 01       	movw	r22, r12
    37d0:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    37d4:	88 23       	and	r24, r24
    37d6:	24 f4       	brge	.+8      	; 0x37e0 <vRead_Peaks+0x1f4>
							{
								count_after_peak++;
    37d8:	9f ef       	ldi	r25, 0xFF	; 255
    37da:	69 1a       	sub	r6, r25
    37dc:	79 0a       	sbc	r7, r25
    37de:	2f c0       	rjmp	.+94     	; 0x383e <vRead_Peaks+0x252>
							}
							else if (xtest_array[i] > 88)
    37e0:	20 e0       	ldi	r18, 0x00	; 0
    37e2:	30 e0       	ldi	r19, 0x00	; 0
    37e4:	40 eb       	ldi	r20, 0xB0	; 176
    37e6:	52 e4       	ldi	r21, 0x42	; 66
    37e8:	c7 01       	movw	r24, r14
    37ea:	b6 01       	movw	r22, r12
    37ec:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    37f0:	18 16       	cp	r1, r24
    37f2:	2c f5       	brge	.+74     	; 0x383e <vRead_Peaks+0x252>
							{
								if (flag_L == 1)
    37f4:	81 e0       	ldi	r24, 0x01	; 1
    37f6:	28 16       	cp	r2, r24
    37f8:	31 04       	cpc	r3, r1
    37fa:	09 f5       	brne	.+66     	; 0x383e <vRead_Peaks+0x252>
								{
									if (count_after_peak > 2)
    37fc:	93 e0       	ldi	r25, 0x03	; 3
    37fe:	69 16       	cp	r6, r25
    3800:	71 04       	cpc	r7, r1
    3802:	ec f0       	brlt	.+58     	; 0x383e <vRead_Peaks+0x252>
									{
										peak_array_L[count_array_position_L] = low_peak;
										position_array_L[count_array_position_L] = position_low_peak_a;
    3804:	e9 85       	ldd	r30, Y+9	; 0x09
    3806:	fa 85       	ldd	r31, Y+10	; 0x0a
    3808:	ee 0f       	add	r30, r30
    380a:	ff 1f       	adc	r31, r31
    380c:	ef 5d       	subi	r30, 0xDF	; 223
    380e:	fe 4c       	sbci	r31, 0xCE	; 206
    3810:	8d 81       	ldd	r24, Y+5	; 0x05
    3812:	80 83       	st	Z, r24
    3814:	9e 81       	ldd	r25, Y+6	; 0x06
    3816:	91 83       	std	Z+1, r25	; 0x01
										count_array_position_L++;
    3818:	89 85       	ldd	r24, Y+9	; 0x09
    381a:	9a 85       	ldd	r25, Y+10	; 0x0a
    381c:	01 96       	adiw	r24, 0x01	; 1
    381e:	89 87       	std	Y+9, r24	; 0x09
    3820:	9a 87       	std	Y+10, r25	; 0x0a
										count_array_a++;										/* Count up to activate event bit when 16 peaks got collected*/
    3822:	8b 85       	ldd	r24, Y+11	; 0x0b
    3824:	9c 85       	ldd	r25, Y+12	; 0x0c
    3826:	01 96       	adiw	r24, 0x01	; 1
    3828:	8b 87       	std	Y+11, r24	; 0x0b
    382a:	9c 87       	std	Y+12, r25	; 0x0c
										low_peak = 127;
										flag_L = 0;
    382c:	21 2c       	mov	r2, r1
    382e:	31 2c       	mov	r3, r1
										count_after_peak = 0;
    3830:	61 2c       	mov	r6, r1
    3832:	71 2c       	mov	r7, r1
									{
										peak_array_L[count_array_position_L] = low_peak;
										position_array_L[count_array_position_L] = position_low_peak_a;
										count_array_position_L++;
										count_array_a++;										/* Count up to activate event bit when 16 peaks got collected*/
										low_peak = 127;
    3834:	0f 2e       	mov	r0, r31
    3836:	ff e7       	ldi	r31, 0x7F	; 127
    3838:	8f 2e       	mov	r8, r31
    383a:	f0 2d       	mov	r31, r0
    383c:	91 2c       	mov	r9, r1
		portMAX_DELAY );										/* Wait a maximum for either bit to be set. */
		//process signal values
		if (uxBits & Process_Signal_BufferA)											/* if "BufferA" bit is set, read out bufferA*/
		{
			i = 0;
			for(i=0;i<xtest_array_length;i++)
    383e:	0f 5f       	subi	r16, 0xFF	; 255
    3840:	1f 4f       	sbci	r17, 0xFF	; 255
    3842:	80 91 81 21 	lds	r24, 0x2181	; 0x802181 <xtest_array_length>
    3846:	90 91 82 21 	lds	r25, 0x2182	; 0x802182 <xtest_array_length+0x1>
    384a:	08 17       	cp	r16, r24
    384c:	19 07       	cpc	r17, r25
    384e:	0c f4       	brge	.+2      	; 0x3852 <vRead_Peaks+0x266>
    3850:	02 cf       	rjmp	.-508    	; 0x3656 <vRead_Peaks+0x6a>
    3852:	06 c1       	rjmp	.+524    	; 0x3a60 <vRead_Peaks+0x474>
						}
					}
				}
			}
		}
		else if (uxBits & Process_Signal_BufferB)
    3854:	61 ff       	sbrs	r22, 1
    3856:	04 c1       	rjmp	.+520    	; 0x3a60 <vRead_Peaks+0x474>
		{
			for (i=0;i<xtest_array_length;i++)													/* after test will be variable buffer_length*/
    3858:	80 91 81 21 	lds	r24, 0x2181	; 0x802181 <xtest_array_length>
    385c:	90 91 82 21 	lds	r25, 0x2182	; 0x802182 <xtest_array_length+0x1>
    3860:	18 16       	cp	r1, r24
    3862:	19 06       	cpc	r1, r25
    3864:	0c f0       	brlt	.+2      	; 0x3868 <vRead_Peaks+0x27c>
    3866:	fc c0       	rjmp	.+504    	; 0x3a60 <vRead_Peaks+0x474>
    3868:	00 e0       	ldi	r16, 0x00	; 0
    386a:	10 e0       	ldi	r17, 0x00	; 0
			{
				if(count_array_b >= peak_array_length)											/* check if package ready to send*/
    386c:	90 e2       	ldi	r25, 0x20	; 32
    386e:	49 16       	cp	r4, r25
    3870:	51 04       	cpc	r5, r1
    3872:	6c f0       	brlt	.+26     	; 0x388e <vRead_Peaks+0x2a2>
				{
					position_array_H[count_array_position_H] =position_array_H[count_array_position_H];		/*debugging*/
					position_array_L[count_array_position_L] = position_array_L[count_array_position_L];	/*debugging*/
					count_array_b = 0;
					xResult = xEventGroupSetBits(												/* Set bit 0 and bit 4 in xEventGroup. */
    3874:	42 e0       	ldi	r20, 0x02	; 2
    3876:	50 e0       	ldi	r21, 0x00	; 0
    3878:	60 e0       	ldi	r22, 0x00	; 0
    387a:	70 e0       	ldi	r23, 0x00	; 0
    387c:	80 91 a7 31 	lds	r24, 0x31A7	; 0x8031a7 <xPhaseDetectionEventGroup>
    3880:	90 91 a8 31 	lds	r25, 0x31A8	; 0x8031a8 <xPhaseDetectionEventGroup+0x1>
    3884:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <xEventGroupSetBits>
			{
				if(count_array_b >= peak_array_length)											/* check if package ready to send*/
				{
					position_array_H[count_array_position_H] =position_array_H[count_array_position_H];		/*debugging*/
					position_array_L[count_array_position_L] = position_array_L[count_array_position_L];	/*debugging*/
					count_array_b = 0;
    3888:	41 2c       	mov	r4, r1
    388a:	51 2c       	mov	r5, r1
    388c:	df c0       	rjmp	.+446    	; 0x3a4c <vRead_Peaks+0x460>
					);
				}
				else
				{
					/* HIGH PEAK B */
					if (xtest_array[i] > 127)													/* after test: use variable buffer_b */
    388e:	f8 01       	movw	r30, r16
    3890:	ee 0f       	add	r30, r30
    3892:	ff 1f       	adc	r31, r31
    3894:	ee 0f       	add	r30, r30
    3896:	ff 1f       	adc	r31, r31
    3898:	ef 5f       	subi	r30, 0xFF	; 255
    389a:	ff 4d       	sbci	r31, 0xDF	; 223
    389c:	c0 80       	ld	r12, Z
    389e:	d1 80       	ldd	r13, Z+1	; 0x01
    38a0:	e2 80       	ldd	r14, Z+2	; 0x02
    38a2:	f3 80       	ldd	r15, Z+3	; 0x03
    38a4:	20 e0       	ldi	r18, 0x00	; 0
    38a6:	30 e0       	ldi	r19, 0x00	; 0
    38a8:	4e ef       	ldi	r20, 0xFE	; 254
    38aa:	52 e4       	ldi	r21, 0x42	; 66
    38ac:	c7 01       	movw	r24, r14
    38ae:	b6 01       	movw	r22, r12
    38b0:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    38b4:	18 16       	cp	r1, r24
    38b6:	0c f0       	brlt	.+2      	; 0x38ba <vRead_Peaks+0x2ce>
    38b8:	67 c0       	rjmp	.+206    	; 0x3988 <vRead_Peaks+0x39c>
					{
						if (xtest_array[i] > high_peak)											/*if buffer bigger than current high_peak*/
    38ba:	b5 01       	movw	r22, r10
    38bc:	0b 2c       	mov	r0, r11
    38be:	00 0c       	add	r0, r0
    38c0:	88 0b       	sbc	r24, r24
    38c2:	99 0b       	sbc	r25, r25
    38c4:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <__floatsisf>
    38c8:	9b 01       	movw	r18, r22
    38ca:	ac 01       	movw	r20, r24
    38cc:	c7 01       	movw	r24, r14
    38ce:	b6 01       	movw	r22, r12
    38d0:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    38d4:	18 16       	cp	r1, r24
    38d6:	cc f4       	brge	.+50     	; 0x390a <vRead_Peaks+0x31e>
						{
							if (xtest_array[i] > 220)
    38d8:	20 e0       	ldi	r18, 0x00	; 0
    38da:	30 e0       	ldi	r19, 0x00	; 0
    38dc:	4c e5       	ldi	r20, 0x5C	; 92
    38de:	53 e4       	ldi	r21, 0x43	; 67
    38e0:	c7 01       	movw	r24, r14
    38e2:	b6 01       	movw	r22, r12
    38e4:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    38e8:	18 16       	cp	r1, r24
    38ea:	0c f0       	brlt	.+2      	; 0x38ee <vRead_Peaks+0x302>
    38ec:	af c0       	rjmp	.+350    	; 0x3a4c <vRead_Peaks+0x460>
							{
								high_peak = xtest_array[i];										/* store new peak*/
    38ee:	c7 01       	movw	r24, r14
    38f0:	b6 01       	movw	r22, r12
    38f2:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <__fixsfsi>
    38f6:	5b 01       	movw	r10, r22
    38f8:	0b 83       	std	Y+3, r16	; 0x03
    38fa:	1c 83       	std	Y+4, r17	; 0x04
								position_high_peak_a = i;										/* store array position of new peak*/
								flag_H = 1;
								flag_L = 0;
    38fc:	21 2c       	mov	r2, r1
    38fe:	31 2c       	mov	r3, r1
						{
							if (xtest_array[i] > 220)
							{
								high_peak = xtest_array[i];										/* store new peak*/
								position_high_peak_a = i;										/* store array position of new peak*/
								flag_H = 1;
    3900:	81 e0       	ldi	r24, 0x01	; 1
    3902:	90 e0       	ldi	r25, 0x00	; 0
    3904:	89 83       	std	Y+1, r24	; 0x01
    3906:	9a 83       	std	Y+2, r25	; 0x02
    3908:	a1 c0       	rjmp	.+322    	; 0x3a4c <vRead_Peaks+0x460>
								flag_L = 0;
							}
						}
						else
						{
							if (xtest_array[i] > 170 )											
    390a:	20 e0       	ldi	r18, 0x00	; 0
    390c:	30 e0       	ldi	r19, 0x00	; 0
    390e:	4a e2       	ldi	r20, 0x2A	; 42
    3910:	53 e4       	ldi	r21, 0x43	; 67
    3912:	c7 01       	movw	r24, r14
    3914:	b6 01       	movw	r22, r12
    3916:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    391a:	18 16       	cp	r1, r24
    391c:	24 f4       	brge	.+8      	; 0x3926 <vRead_Peaks+0x33a>
							{
								count_after_peak++;
    391e:	9f ef       	ldi	r25, 0xFF	; 255
    3920:	69 1a       	sub	r6, r25
    3922:	79 0a       	sbc	r7, r25
    3924:	93 c0       	rjmp	.+294    	; 0x3a4c <vRead_Peaks+0x460>
							}
							else if(xtest_array[i] < 170)
    3926:	20 e0       	ldi	r18, 0x00	; 0
    3928:	30 e0       	ldi	r19, 0x00	; 0
    392a:	4a e2       	ldi	r20, 0x2A	; 42
    392c:	53 e4       	ldi	r21, 0x43	; 67
    392e:	c7 01       	movw	r24, r14
    3930:	b6 01       	movw	r22, r12
    3932:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    3936:	88 23       	and	r24, r24
    3938:	0c f0       	brlt	.+2      	; 0x393c <vRead_Peaks+0x350>
    393a:	88 c0       	rjmp	.+272    	; 0x3a4c <vRead_Peaks+0x460>
							{
								if(flag_H == 1)
    393c:	89 81       	ldd	r24, Y+1	; 0x01
    393e:	9a 81       	ldd	r25, Y+2	; 0x02
    3940:	01 97       	sbiw	r24, 0x01	; 1
    3942:	09 f0       	breq	.+2      	; 0x3946 <vRead_Peaks+0x35a>
    3944:	83 c0       	rjmp	.+262    	; 0x3a4c <vRead_Peaks+0x460>
								{
									if (count_after_peak > 2)
    3946:	93 e0       	ldi	r25, 0x03	; 3
    3948:	69 16       	cp	r6, r25
    394a:	71 04       	cpc	r7, r1
    394c:	0c f4       	brge	.+2      	; 0x3950 <vRead_Peaks+0x364>
    394e:	7e c0       	rjmp	.+252    	; 0x3a4c <vRead_Peaks+0x460>
									{
										peak_array_H[count_array_position_H] = high_peak;
										position_array_H[count_array_position_H] = position_high_peak_a;
    3950:	ef 81       	ldd	r30, Y+7	; 0x07
    3952:	f8 85       	ldd	r31, Y+8	; 0x08
    3954:	ee 0f       	add	r30, r30
    3956:	ff 1f       	adc	r31, r31
    3958:	e7 55       	subi	r30, 0x57	; 87
    395a:	fe 4c       	sbci	r31, 0xCE	; 206
    395c:	8b 81       	ldd	r24, Y+3	; 0x03
    395e:	80 83       	st	Z, r24
    3960:	9c 81       	ldd	r25, Y+4	; 0x04
    3962:	91 83       	std	Z+1, r25	; 0x01
										count_array_position_H++;
    3964:	8f 81       	ldd	r24, Y+7	; 0x07
    3966:	98 85       	ldd	r25, Y+8	; 0x08
    3968:	01 96       	adiw	r24, 0x01	; 1
    396a:	8f 83       	std	Y+7, r24	; 0x07
    396c:	98 87       	std	Y+8, r25	; 0x08
										count_array_b++;										/* Count up to activate event bit when 16 peaks got collected*/
    396e:	9f ef       	ldi	r25, 0xFF	; 255
    3970:	49 1a       	sub	r4, r25
    3972:	59 0a       	sbc	r5, r25
										high_peak = 127;
										flag_H = 0;
    3974:	19 82       	std	Y+1, r1	; 0x01
    3976:	1a 82       	std	Y+2, r1	; 0x02
										count_after_peak = 0;
    3978:	61 2c       	mov	r6, r1
    397a:	71 2c       	mov	r7, r1
									{
										peak_array_H[count_array_position_H] = high_peak;
										position_array_H[count_array_position_H] = position_high_peak_a;
										count_array_position_H++;
										count_array_b++;										/* Count up to activate event bit when 16 peaks got collected*/
										high_peak = 127;
    397c:	0f 2e       	mov	r0, r31
    397e:	ff e7       	ldi	r31, 0x7F	; 127
    3980:	af 2e       	mov	r10, r31
    3982:	f0 2d       	mov	r31, r0
    3984:	b1 2c       	mov	r11, r1
    3986:	62 c0       	rjmp	.+196    	; 0x3a4c <vRead_Peaks+0x460>
						}
					}
					/* LOW PEAK	B*/
					else
					{
						if (xtest_array[i] < low_peak)											/*if buffer bigger than current high_peak*/
    3988:	b4 01       	movw	r22, r8
    398a:	09 2c       	mov	r0, r9
    398c:	00 0c       	add	r0, r0
    398e:	88 0b       	sbc	r24, r24
    3990:	99 0b       	sbc	r25, r25
    3992:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <__floatsisf>
    3996:	9b 01       	movw	r18, r22
    3998:	ac 01       	movw	r20, r24
    399a:	c7 01       	movw	r24, r14
    399c:	b6 01       	movw	r22, r12
    399e:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    39a2:	88 23       	and	r24, r24
    39a4:	c4 f4       	brge	.+48     	; 0x39d6 <vRead_Peaks+0x3ea>
						{
							if (xtest_array[i] < 40)
    39a6:	20 e0       	ldi	r18, 0x00	; 0
    39a8:	30 e0       	ldi	r19, 0x00	; 0
    39aa:	40 e2       	ldi	r20, 0x20	; 32
    39ac:	52 e4       	ldi	r21, 0x42	; 66
    39ae:	c7 01       	movw	r24, r14
    39b0:	b6 01       	movw	r22, r12
    39b2:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    39b6:	88 23       	and	r24, r24
    39b8:	0c f0       	brlt	.+2      	; 0x39bc <vRead_Peaks+0x3d0>
    39ba:	48 c0       	rjmp	.+144    	; 0x3a4c <vRead_Peaks+0x460>
							{
								low_peak = xtest_array[i];										/* store new peak*/
    39bc:	c7 01       	movw	r24, r14
    39be:	b6 01       	movw	r22, r12
    39c0:	0e 94 41 1e 	call	0x3c82	; 0x3c82 <__fixsfsi>
    39c4:	4b 01       	movw	r8, r22
    39c6:	0d 83       	std	Y+5, r16	; 0x05
    39c8:	1e 83       	std	Y+6, r17	; 0x06
								position_low_peak_a = i;										/* store array position of new peak*/
								flag_L = 1;
    39ca:	22 24       	eor	r2, r2
    39cc:	23 94       	inc	r2
    39ce:	31 2c       	mov	r3, r1
								flag_H = 0;
    39d0:	19 82       	std	Y+1, r1	; 0x01
    39d2:	1a 82       	std	Y+2, r1	; 0x02
    39d4:	3b c0       	rjmp	.+118    	; 0x3a4c <vRead_Peaks+0x460>
							}
						}
						else
						{
							if (xtest_array[i] < 88)
    39d6:	20 e0       	ldi	r18, 0x00	; 0
    39d8:	30 e0       	ldi	r19, 0x00	; 0
    39da:	40 eb       	ldi	r20, 0xB0	; 176
    39dc:	52 e4       	ldi	r21, 0x42	; 66
    39de:	c7 01       	movw	r24, r14
    39e0:	b6 01       	movw	r22, r12
    39e2:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <__cmpsf2>
    39e6:	88 23       	and	r24, r24
    39e8:	24 f4       	brge	.+8      	; 0x39f2 <vRead_Peaks+0x406>
							{
								count_after_peak++;
    39ea:	8f ef       	ldi	r24, 0xFF	; 255
    39ec:	68 1a       	sub	r6, r24
    39ee:	78 0a       	sbc	r7, r24
    39f0:	2d c0       	rjmp	.+90     	; 0x3a4c <vRead_Peaks+0x460>
							}
							else if (xtest_array[i] > 85)
    39f2:	20 e0       	ldi	r18, 0x00	; 0
    39f4:	30 e0       	ldi	r19, 0x00	; 0
    39f6:	4a ea       	ldi	r20, 0xAA	; 170
    39f8:	52 e4       	ldi	r21, 0x42	; 66
    39fa:	c7 01       	movw	r24, r14
    39fc:	b6 01       	movw	r22, r12
    39fe:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__gesf2>
    3a02:	18 16       	cp	r1, r24
    3a04:	1c f5       	brge	.+70     	; 0x3a4c <vRead_Peaks+0x460>
							{
								if (flag_L == 1)
    3a06:	91 e0       	ldi	r25, 0x01	; 1
    3a08:	29 16       	cp	r2, r25
    3a0a:	31 04       	cpc	r3, r1
    3a0c:	f9 f4       	brne	.+62     	; 0x3a4c <vRead_Peaks+0x460>
								{
									if (count_after_peak > 2)
    3a0e:	83 e0       	ldi	r24, 0x03	; 3
    3a10:	68 16       	cp	r6, r24
    3a12:	71 04       	cpc	r7, r1
    3a14:	dc f0       	brlt	.+54     	; 0x3a4c <vRead_Peaks+0x460>
									{
										peak_array_L[count_array_position_L] = low_peak;
										position_array_L[count_array_position_L] = position_low_peak_a;
    3a16:	e9 85       	ldd	r30, Y+9	; 0x09
    3a18:	fa 85       	ldd	r31, Y+10	; 0x0a
    3a1a:	ee 0f       	add	r30, r30
    3a1c:	ff 1f       	adc	r31, r31
    3a1e:	ef 5d       	subi	r30, 0xDF	; 223
    3a20:	fe 4c       	sbci	r31, 0xCE	; 206
    3a22:	9d 81       	ldd	r25, Y+5	; 0x05
    3a24:	90 83       	st	Z, r25
    3a26:	8e 81       	ldd	r24, Y+6	; 0x06
    3a28:	81 83       	std	Z+1, r24	; 0x01
										count_array_position_L++;
    3a2a:	89 85       	ldd	r24, Y+9	; 0x09
    3a2c:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a2e:	01 96       	adiw	r24, 0x01	; 1
    3a30:	89 87       	std	Y+9, r24	; 0x09
    3a32:	9a 87       	std	Y+10, r25	; 0x0a
										count_array_b++;										/* Count up to activate event bit when 16 peaks got collected*/
    3a34:	9f ef       	ldi	r25, 0xFF	; 255
    3a36:	49 1a       	sub	r4, r25
    3a38:	59 0a       	sbc	r5, r25
										low_peak = 127;
										flag_L = 0;
    3a3a:	21 2c       	mov	r2, r1
    3a3c:	31 2c       	mov	r3, r1
										count_after_peak = 0;
    3a3e:	61 2c       	mov	r6, r1
    3a40:	71 2c       	mov	r7, r1
									{
										peak_array_L[count_array_position_L] = low_peak;
										position_array_L[count_array_position_L] = position_low_peak_a;
										count_array_position_L++;
										count_array_b++;										/* Count up to activate event bit when 16 peaks got collected*/
										low_peak = 127;
    3a42:	0f 2e       	mov	r0, r31
    3a44:	ff e7       	ldi	r31, 0x7F	; 127
    3a46:	8f 2e       	mov	r8, r31
    3a48:	f0 2d       	mov	r31, r0
    3a4a:	91 2c       	mov	r9, r1
				}
			}
		}
		else if (uxBits & Process_Signal_BufferB)
		{
			for (i=0;i<xtest_array_length;i++)													/* after test will be variable buffer_length*/
    3a4c:	0f 5f       	subi	r16, 0xFF	; 255
    3a4e:	1f 4f       	sbci	r17, 0xFF	; 255
    3a50:	80 91 81 21 	lds	r24, 0x2181	; 0x802181 <xtest_array_length>
    3a54:	90 91 82 21 	lds	r25, 0x2182	; 0x802182 <xtest_array_length+0x1>
    3a58:	08 17       	cp	r16, r24
    3a5a:	19 07       	cpc	r17, r25
    3a5c:	0c f4       	brge	.+2      	; 0x3a60 <vRead_Peaks+0x474>
    3a5e:	06 cf       	rjmp	.-500    	; 0x386c <vRead_Peaks+0x280>
						}
					}
				}
			}
		}
		vTaskDelay(100 / portTICK_RATE_MS);
    3a60:	64 e6       	ldi	r22, 0x64	; 100
    3a62:	70 e0       	ldi	r23, 0x00	; 0
    3a64:	80 e0       	ldi	r24, 0x00	; 0
    3a66:	90 e0       	ldi	r25, 0x00	; 0
    3a68:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <vTaskDelay>
	}
    3a6c:	d8 cd       	rjmp	.-1104   	; 0x361e <vRead_Peaks+0x32>

00003a6e <getResetReason>:
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
	 // software reset ?
	 if( RST.STATUS & RST_SRF_bm )
    3a6e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3a72:	85 ff       	sbrs	r24, 5
    3a74:	05 c0       	rjmp	.+10     	; 0x3a80 <getResetReason+0x12>
	 {
		 // reset this bit
		 RST.STATUS = RST_SRF_bm;
    3a76:	80 e2       	ldi	r24, 0x20	; 32
    3a78:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_SOFTWARERESET;
    3a7c:	81 e0       	ldi	r24, 0x01	; 1
    3a7e:	08 95       	ret
	 }
	 // power on reset ?
	 else if( RST.STATUS & RST_PORF_bm)
    3a80:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3a84:	80 ff       	sbrs	r24, 0
    3a86:	05 c0       	rjmp	.+10     	; 0x3a92 <getResetReason+0x24>
	 {
		 // reset this bit
		 RST.STATUS = RST_PORF_bm;
    3a88:	81 e0       	ldi	r24, 0x01	; 1
    3a8a:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_POWERONRESET;
    3a8e:	82 e0       	ldi	r24, 0x02	; 2
    3a90:	08 95       	ret
	 }
	 // debugger reset ?
	 else if( RST.STATUS & RST_PDIRF_bm)
    3a92:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3a96:	84 ff       	sbrs	r24, 4
    3a98:	05 c0       	rjmp	.+10     	; 0x3aa4 <getResetReason+0x36>
	 {
		 // reset this bit
		 RST.STATUS = RST_PDIRF_bm;
    3a9a:	80 e1       	ldi	r24, 0x10	; 16
    3a9c:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_DEBUGGERRESET;
    3aa0:	83 e0       	ldi	r24, 0x03	; 3
    3aa2:	08 95       	ret
	 }
	 // external reset ?
	 else if( RST.STATUS & RST_EXTRF_bm)
    3aa4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3aa8:	81 ff       	sbrs	r24, 1
    3aaa:	05 c0       	rjmp	.+10     	; 0x3ab6 <getResetReason+0x48>
	 {
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
    3aac:	82 e0       	ldi	r24, 0x02	; 2
    3aae:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_EXTERNALRESET;
    3ab2:	84 e0       	ldi	r24, 0x04	; 4
    3ab4:	08 95       	ret
 */ 
 #include "avr_compiler.h"
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
    3ab6:	82 e0       	ldi	r24, 0x02	; 2
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
		 returnValue = RESETREASON_EXTERNALRESET;
	 }
	 return returnValue;
    3ab8:	08 95       	ret

00003aba <__subsf3>:
    3aba:	50 58       	subi	r21, 0x80	; 128

00003abc <__addsf3>:
    3abc:	bb 27       	eor	r27, r27
    3abe:	aa 27       	eor	r26, r26
    3ac0:	0e 94 75 1d 	call	0x3aea	; 0x3aea <__addsf3x>
    3ac4:	0c 94 ef 1e 	jmp	0x3dde	; 0x3dde <__fp_round>
    3ac8:	0e 94 e1 1e 	call	0x3dc2	; 0x3dc2 <__fp_pscA>
    3acc:	38 f0       	brcs	.+14     	; 0x3adc <__addsf3+0x20>
    3ace:	0e 94 e8 1e 	call	0x3dd0	; 0x3dd0 <__fp_pscB>
    3ad2:	20 f0       	brcs	.+8      	; 0x3adc <__addsf3+0x20>
    3ad4:	39 f4       	brne	.+14     	; 0x3ae4 <__addsf3+0x28>
    3ad6:	9f 3f       	cpi	r25, 0xFF	; 255
    3ad8:	19 f4       	brne	.+6      	; 0x3ae0 <__addsf3+0x24>
    3ada:	26 f4       	brtc	.+8      	; 0x3ae4 <__addsf3+0x28>
    3adc:	0c 94 de 1e 	jmp	0x3dbc	; 0x3dbc <__fp_nan>
    3ae0:	0e f4       	brtc	.+2      	; 0x3ae4 <__addsf3+0x28>
    3ae2:	e0 95       	com	r30
    3ae4:	e7 fb       	bst	r30, 7
    3ae6:	0c 94 d8 1e 	jmp	0x3db0	; 0x3db0 <__fp_inf>

00003aea <__addsf3x>:
    3aea:	e9 2f       	mov	r30, r25
    3aec:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <__fp_split3>
    3af0:	58 f3       	brcs	.-42     	; 0x3ac8 <__addsf3+0xc>
    3af2:	ba 17       	cp	r27, r26
    3af4:	62 07       	cpc	r22, r18
    3af6:	73 07       	cpc	r23, r19
    3af8:	84 07       	cpc	r24, r20
    3afa:	95 07       	cpc	r25, r21
    3afc:	20 f0       	brcs	.+8      	; 0x3b06 <__addsf3x+0x1c>
    3afe:	79 f4       	brne	.+30     	; 0x3b1e <__addsf3x+0x34>
    3b00:	a6 f5       	brtc	.+104    	; 0x3b6a <__addsf3x+0x80>
    3b02:	0c 94 22 1f 	jmp	0x3e44	; 0x3e44 <__fp_zero>
    3b06:	0e f4       	brtc	.+2      	; 0x3b0a <__addsf3x+0x20>
    3b08:	e0 95       	com	r30
    3b0a:	0b 2e       	mov	r0, r27
    3b0c:	ba 2f       	mov	r27, r26
    3b0e:	a0 2d       	mov	r26, r0
    3b10:	0b 01       	movw	r0, r22
    3b12:	b9 01       	movw	r22, r18
    3b14:	90 01       	movw	r18, r0
    3b16:	0c 01       	movw	r0, r24
    3b18:	ca 01       	movw	r24, r20
    3b1a:	a0 01       	movw	r20, r0
    3b1c:	11 24       	eor	r1, r1
    3b1e:	ff 27       	eor	r31, r31
    3b20:	59 1b       	sub	r21, r25
    3b22:	99 f0       	breq	.+38     	; 0x3b4a <__addsf3x+0x60>
    3b24:	59 3f       	cpi	r21, 0xF9	; 249
    3b26:	50 f4       	brcc	.+20     	; 0x3b3c <__addsf3x+0x52>
    3b28:	50 3e       	cpi	r21, 0xE0	; 224
    3b2a:	68 f1       	brcs	.+90     	; 0x3b86 <__addsf3x+0x9c>
    3b2c:	1a 16       	cp	r1, r26
    3b2e:	f0 40       	sbci	r31, 0x00	; 0
    3b30:	a2 2f       	mov	r26, r18
    3b32:	23 2f       	mov	r18, r19
    3b34:	34 2f       	mov	r19, r20
    3b36:	44 27       	eor	r20, r20
    3b38:	58 5f       	subi	r21, 0xF8	; 248
    3b3a:	f3 cf       	rjmp	.-26     	; 0x3b22 <__addsf3x+0x38>
    3b3c:	46 95       	lsr	r20
    3b3e:	37 95       	ror	r19
    3b40:	27 95       	ror	r18
    3b42:	a7 95       	ror	r26
    3b44:	f0 40       	sbci	r31, 0x00	; 0
    3b46:	53 95       	inc	r21
    3b48:	c9 f7       	brne	.-14     	; 0x3b3c <__addsf3x+0x52>
    3b4a:	7e f4       	brtc	.+30     	; 0x3b6a <__addsf3x+0x80>
    3b4c:	1f 16       	cp	r1, r31
    3b4e:	ba 0b       	sbc	r27, r26
    3b50:	62 0b       	sbc	r22, r18
    3b52:	73 0b       	sbc	r23, r19
    3b54:	84 0b       	sbc	r24, r20
    3b56:	ba f0       	brmi	.+46     	; 0x3b86 <__addsf3x+0x9c>
    3b58:	91 50       	subi	r25, 0x01	; 1
    3b5a:	a1 f0       	breq	.+40     	; 0x3b84 <__addsf3x+0x9a>
    3b5c:	ff 0f       	add	r31, r31
    3b5e:	bb 1f       	adc	r27, r27
    3b60:	66 1f       	adc	r22, r22
    3b62:	77 1f       	adc	r23, r23
    3b64:	88 1f       	adc	r24, r24
    3b66:	c2 f7       	brpl	.-16     	; 0x3b58 <__addsf3x+0x6e>
    3b68:	0e c0       	rjmp	.+28     	; 0x3b86 <__addsf3x+0x9c>
    3b6a:	ba 0f       	add	r27, r26
    3b6c:	62 1f       	adc	r22, r18
    3b6e:	73 1f       	adc	r23, r19
    3b70:	84 1f       	adc	r24, r20
    3b72:	48 f4       	brcc	.+18     	; 0x3b86 <__addsf3x+0x9c>
    3b74:	87 95       	ror	r24
    3b76:	77 95       	ror	r23
    3b78:	67 95       	ror	r22
    3b7a:	b7 95       	ror	r27
    3b7c:	f7 95       	ror	r31
    3b7e:	9e 3f       	cpi	r25, 0xFE	; 254
    3b80:	08 f0       	brcs	.+2      	; 0x3b84 <__addsf3x+0x9a>
    3b82:	b0 cf       	rjmp	.-160    	; 0x3ae4 <__addsf3+0x28>
    3b84:	93 95       	inc	r25
    3b86:	88 0f       	add	r24, r24
    3b88:	08 f0       	brcs	.+2      	; 0x3b8c <__addsf3x+0xa2>
    3b8a:	99 27       	eor	r25, r25
    3b8c:	ee 0f       	add	r30, r30
    3b8e:	97 95       	ror	r25
    3b90:	87 95       	ror	r24
    3b92:	08 95       	ret

00003b94 <__cmpsf2>:
    3b94:	0e 94 b4 1e 	call	0x3d68	; 0x3d68 <__fp_cmp>
    3b98:	08 f4       	brcc	.+2      	; 0x3b9c <__cmpsf2+0x8>
    3b9a:	81 e0       	ldi	r24, 0x01	; 1
    3b9c:	08 95       	ret

00003b9e <__divsf3>:
    3b9e:	0e 94 e3 1d 	call	0x3bc6	; 0x3bc6 <__divsf3x>
    3ba2:	0c 94 ef 1e 	jmp	0x3dde	; 0x3dde <__fp_round>
    3ba6:	0e 94 e8 1e 	call	0x3dd0	; 0x3dd0 <__fp_pscB>
    3baa:	58 f0       	brcs	.+22     	; 0x3bc2 <__divsf3+0x24>
    3bac:	0e 94 e1 1e 	call	0x3dc2	; 0x3dc2 <__fp_pscA>
    3bb0:	40 f0       	brcs	.+16     	; 0x3bc2 <__divsf3+0x24>
    3bb2:	29 f4       	brne	.+10     	; 0x3bbe <__divsf3+0x20>
    3bb4:	5f 3f       	cpi	r21, 0xFF	; 255
    3bb6:	29 f0       	breq	.+10     	; 0x3bc2 <__divsf3+0x24>
    3bb8:	0c 94 d8 1e 	jmp	0x3db0	; 0x3db0 <__fp_inf>
    3bbc:	51 11       	cpse	r21, r1
    3bbe:	0c 94 23 1f 	jmp	0x3e46	; 0x3e46 <__fp_szero>
    3bc2:	0c 94 de 1e 	jmp	0x3dbc	; 0x3dbc <__fp_nan>

00003bc6 <__divsf3x>:
    3bc6:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <__fp_split3>
    3bca:	68 f3       	brcs	.-38     	; 0x3ba6 <__divsf3+0x8>

00003bcc <__divsf3_pse>:
    3bcc:	99 23       	and	r25, r25
    3bce:	b1 f3       	breq	.-20     	; 0x3bbc <__divsf3+0x1e>
    3bd0:	55 23       	and	r21, r21
    3bd2:	91 f3       	breq	.-28     	; 0x3bb8 <__divsf3+0x1a>
    3bd4:	95 1b       	sub	r25, r21
    3bd6:	55 0b       	sbc	r21, r21
    3bd8:	bb 27       	eor	r27, r27
    3bda:	aa 27       	eor	r26, r26
    3bdc:	62 17       	cp	r22, r18
    3bde:	73 07       	cpc	r23, r19
    3be0:	84 07       	cpc	r24, r20
    3be2:	38 f0       	brcs	.+14     	; 0x3bf2 <__divsf3_pse+0x26>
    3be4:	9f 5f       	subi	r25, 0xFF	; 255
    3be6:	5f 4f       	sbci	r21, 0xFF	; 255
    3be8:	22 0f       	add	r18, r18
    3bea:	33 1f       	adc	r19, r19
    3bec:	44 1f       	adc	r20, r20
    3bee:	aa 1f       	adc	r26, r26
    3bf0:	a9 f3       	breq	.-22     	; 0x3bdc <__divsf3_pse+0x10>
    3bf2:	35 d0       	rcall	.+106    	; 0x3c5e <__divsf3_pse+0x92>
    3bf4:	0e 2e       	mov	r0, r30
    3bf6:	3a f0       	brmi	.+14     	; 0x3c06 <__divsf3_pse+0x3a>
    3bf8:	e0 e8       	ldi	r30, 0x80	; 128
    3bfa:	32 d0       	rcall	.+100    	; 0x3c60 <__divsf3_pse+0x94>
    3bfc:	91 50       	subi	r25, 0x01	; 1
    3bfe:	50 40       	sbci	r21, 0x00	; 0
    3c00:	e6 95       	lsr	r30
    3c02:	00 1c       	adc	r0, r0
    3c04:	ca f7       	brpl	.-14     	; 0x3bf8 <__divsf3_pse+0x2c>
    3c06:	2b d0       	rcall	.+86     	; 0x3c5e <__divsf3_pse+0x92>
    3c08:	fe 2f       	mov	r31, r30
    3c0a:	29 d0       	rcall	.+82     	; 0x3c5e <__divsf3_pse+0x92>
    3c0c:	66 0f       	add	r22, r22
    3c0e:	77 1f       	adc	r23, r23
    3c10:	88 1f       	adc	r24, r24
    3c12:	bb 1f       	adc	r27, r27
    3c14:	26 17       	cp	r18, r22
    3c16:	37 07       	cpc	r19, r23
    3c18:	48 07       	cpc	r20, r24
    3c1a:	ab 07       	cpc	r26, r27
    3c1c:	b0 e8       	ldi	r27, 0x80	; 128
    3c1e:	09 f0       	breq	.+2      	; 0x3c22 <__divsf3_pse+0x56>
    3c20:	bb 0b       	sbc	r27, r27
    3c22:	80 2d       	mov	r24, r0
    3c24:	bf 01       	movw	r22, r30
    3c26:	ff 27       	eor	r31, r31
    3c28:	93 58       	subi	r25, 0x83	; 131
    3c2a:	5f 4f       	sbci	r21, 0xFF	; 255
    3c2c:	3a f0       	brmi	.+14     	; 0x3c3c <__divsf3_pse+0x70>
    3c2e:	9e 3f       	cpi	r25, 0xFE	; 254
    3c30:	51 05       	cpc	r21, r1
    3c32:	78 f0       	brcs	.+30     	; 0x3c52 <__divsf3_pse+0x86>
    3c34:	0c 94 d8 1e 	jmp	0x3db0	; 0x3db0 <__fp_inf>
    3c38:	0c 94 23 1f 	jmp	0x3e46	; 0x3e46 <__fp_szero>
    3c3c:	5f 3f       	cpi	r21, 0xFF	; 255
    3c3e:	e4 f3       	brlt	.-8      	; 0x3c38 <__divsf3_pse+0x6c>
    3c40:	98 3e       	cpi	r25, 0xE8	; 232
    3c42:	d4 f3       	brlt	.-12     	; 0x3c38 <__divsf3_pse+0x6c>
    3c44:	86 95       	lsr	r24
    3c46:	77 95       	ror	r23
    3c48:	67 95       	ror	r22
    3c4a:	b7 95       	ror	r27
    3c4c:	f7 95       	ror	r31
    3c4e:	9f 5f       	subi	r25, 0xFF	; 255
    3c50:	c9 f7       	brne	.-14     	; 0x3c44 <__divsf3_pse+0x78>
    3c52:	88 0f       	add	r24, r24
    3c54:	91 1d       	adc	r25, r1
    3c56:	96 95       	lsr	r25
    3c58:	87 95       	ror	r24
    3c5a:	97 f9       	bld	r25, 7
    3c5c:	08 95       	ret
    3c5e:	e1 e0       	ldi	r30, 0x01	; 1
    3c60:	66 0f       	add	r22, r22
    3c62:	77 1f       	adc	r23, r23
    3c64:	88 1f       	adc	r24, r24
    3c66:	bb 1f       	adc	r27, r27
    3c68:	62 17       	cp	r22, r18
    3c6a:	73 07       	cpc	r23, r19
    3c6c:	84 07       	cpc	r24, r20
    3c6e:	ba 07       	cpc	r27, r26
    3c70:	20 f0       	brcs	.+8      	; 0x3c7a <__divsf3_pse+0xae>
    3c72:	62 1b       	sub	r22, r18
    3c74:	73 0b       	sbc	r23, r19
    3c76:	84 0b       	sbc	r24, r20
    3c78:	ba 0b       	sbc	r27, r26
    3c7a:	ee 1f       	adc	r30, r30
    3c7c:	88 f7       	brcc	.-30     	; 0x3c60 <__divsf3_pse+0x94>
    3c7e:	e0 95       	com	r30
    3c80:	08 95       	ret

00003c82 <__fixsfsi>:
    3c82:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <__fixunssfsi>
    3c86:	68 94       	set
    3c88:	b1 11       	cpse	r27, r1
    3c8a:	0c 94 23 1f 	jmp	0x3e46	; 0x3e46 <__fp_szero>
    3c8e:	08 95       	ret

00003c90 <__fixunssfsi>:
    3c90:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <__fp_splitA>
    3c94:	88 f0       	brcs	.+34     	; 0x3cb8 <__fixunssfsi+0x28>
    3c96:	9f 57       	subi	r25, 0x7F	; 127
    3c98:	98 f0       	brcs	.+38     	; 0x3cc0 <__fixunssfsi+0x30>
    3c9a:	b9 2f       	mov	r27, r25
    3c9c:	99 27       	eor	r25, r25
    3c9e:	b7 51       	subi	r27, 0x17	; 23
    3ca0:	b0 f0       	brcs	.+44     	; 0x3cce <__fixunssfsi+0x3e>
    3ca2:	e1 f0       	breq	.+56     	; 0x3cdc <__fixunssfsi+0x4c>
    3ca4:	66 0f       	add	r22, r22
    3ca6:	77 1f       	adc	r23, r23
    3ca8:	88 1f       	adc	r24, r24
    3caa:	99 1f       	adc	r25, r25
    3cac:	1a f0       	brmi	.+6      	; 0x3cb4 <__fixunssfsi+0x24>
    3cae:	ba 95       	dec	r27
    3cb0:	c9 f7       	brne	.-14     	; 0x3ca4 <__fixunssfsi+0x14>
    3cb2:	14 c0       	rjmp	.+40     	; 0x3cdc <__fixunssfsi+0x4c>
    3cb4:	b1 30       	cpi	r27, 0x01	; 1
    3cb6:	91 f0       	breq	.+36     	; 0x3cdc <__fixunssfsi+0x4c>
    3cb8:	0e 94 22 1f 	call	0x3e44	; 0x3e44 <__fp_zero>
    3cbc:	b1 e0       	ldi	r27, 0x01	; 1
    3cbe:	08 95       	ret
    3cc0:	0c 94 22 1f 	jmp	0x3e44	; 0x3e44 <__fp_zero>
    3cc4:	67 2f       	mov	r22, r23
    3cc6:	78 2f       	mov	r23, r24
    3cc8:	88 27       	eor	r24, r24
    3cca:	b8 5f       	subi	r27, 0xF8	; 248
    3ccc:	39 f0       	breq	.+14     	; 0x3cdc <__fixunssfsi+0x4c>
    3cce:	b9 3f       	cpi	r27, 0xF9	; 249
    3cd0:	cc f3       	brlt	.-14     	; 0x3cc4 <__fixunssfsi+0x34>
    3cd2:	86 95       	lsr	r24
    3cd4:	77 95       	ror	r23
    3cd6:	67 95       	ror	r22
    3cd8:	b3 95       	inc	r27
    3cda:	d9 f7       	brne	.-10     	; 0x3cd2 <__fixunssfsi+0x42>
    3cdc:	3e f4       	brtc	.+14     	; 0x3cec <__fixunssfsi+0x5c>
    3cde:	90 95       	com	r25
    3ce0:	80 95       	com	r24
    3ce2:	70 95       	com	r23
    3ce4:	61 95       	neg	r22
    3ce6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ce8:	8f 4f       	sbci	r24, 0xFF	; 255
    3cea:	9f 4f       	sbci	r25, 0xFF	; 255
    3cec:	08 95       	ret

00003cee <__floatunsisf>:
    3cee:	e8 94       	clt
    3cf0:	09 c0       	rjmp	.+18     	; 0x3d04 <__floatsisf+0x12>

00003cf2 <__floatsisf>:
    3cf2:	97 fb       	bst	r25, 7
    3cf4:	3e f4       	brtc	.+14     	; 0x3d04 <__floatsisf+0x12>
    3cf6:	90 95       	com	r25
    3cf8:	80 95       	com	r24
    3cfa:	70 95       	com	r23
    3cfc:	61 95       	neg	r22
    3cfe:	7f 4f       	sbci	r23, 0xFF	; 255
    3d00:	8f 4f       	sbci	r24, 0xFF	; 255
    3d02:	9f 4f       	sbci	r25, 0xFF	; 255
    3d04:	99 23       	and	r25, r25
    3d06:	a9 f0       	breq	.+42     	; 0x3d32 <__floatsisf+0x40>
    3d08:	f9 2f       	mov	r31, r25
    3d0a:	96 e9       	ldi	r25, 0x96	; 150
    3d0c:	bb 27       	eor	r27, r27
    3d0e:	93 95       	inc	r25
    3d10:	f6 95       	lsr	r31
    3d12:	87 95       	ror	r24
    3d14:	77 95       	ror	r23
    3d16:	67 95       	ror	r22
    3d18:	b7 95       	ror	r27
    3d1a:	f1 11       	cpse	r31, r1
    3d1c:	f8 cf       	rjmp	.-16     	; 0x3d0e <__floatsisf+0x1c>
    3d1e:	fa f4       	brpl	.+62     	; 0x3d5e <__floatsisf+0x6c>
    3d20:	bb 0f       	add	r27, r27
    3d22:	11 f4       	brne	.+4      	; 0x3d28 <__floatsisf+0x36>
    3d24:	60 ff       	sbrs	r22, 0
    3d26:	1b c0       	rjmp	.+54     	; 0x3d5e <__floatsisf+0x6c>
    3d28:	6f 5f       	subi	r22, 0xFF	; 255
    3d2a:	7f 4f       	sbci	r23, 0xFF	; 255
    3d2c:	8f 4f       	sbci	r24, 0xFF	; 255
    3d2e:	9f 4f       	sbci	r25, 0xFF	; 255
    3d30:	16 c0       	rjmp	.+44     	; 0x3d5e <__floatsisf+0x6c>
    3d32:	88 23       	and	r24, r24
    3d34:	11 f0       	breq	.+4      	; 0x3d3a <__floatsisf+0x48>
    3d36:	96 e9       	ldi	r25, 0x96	; 150
    3d38:	11 c0       	rjmp	.+34     	; 0x3d5c <__floatsisf+0x6a>
    3d3a:	77 23       	and	r23, r23
    3d3c:	21 f0       	breq	.+8      	; 0x3d46 <__floatsisf+0x54>
    3d3e:	9e e8       	ldi	r25, 0x8E	; 142
    3d40:	87 2f       	mov	r24, r23
    3d42:	76 2f       	mov	r23, r22
    3d44:	05 c0       	rjmp	.+10     	; 0x3d50 <__floatsisf+0x5e>
    3d46:	66 23       	and	r22, r22
    3d48:	71 f0       	breq	.+28     	; 0x3d66 <__floatsisf+0x74>
    3d4a:	96 e8       	ldi	r25, 0x86	; 134
    3d4c:	86 2f       	mov	r24, r22
    3d4e:	70 e0       	ldi	r23, 0x00	; 0
    3d50:	60 e0       	ldi	r22, 0x00	; 0
    3d52:	2a f0       	brmi	.+10     	; 0x3d5e <__floatsisf+0x6c>
    3d54:	9a 95       	dec	r25
    3d56:	66 0f       	add	r22, r22
    3d58:	77 1f       	adc	r23, r23
    3d5a:	88 1f       	adc	r24, r24
    3d5c:	da f7       	brpl	.-10     	; 0x3d54 <__floatsisf+0x62>
    3d5e:	88 0f       	add	r24, r24
    3d60:	96 95       	lsr	r25
    3d62:	87 95       	ror	r24
    3d64:	97 f9       	bld	r25, 7
    3d66:	08 95       	ret

00003d68 <__fp_cmp>:
    3d68:	99 0f       	add	r25, r25
    3d6a:	00 08       	sbc	r0, r0
    3d6c:	55 0f       	add	r21, r21
    3d6e:	aa 0b       	sbc	r26, r26
    3d70:	e0 e8       	ldi	r30, 0x80	; 128
    3d72:	fe ef       	ldi	r31, 0xFE	; 254
    3d74:	16 16       	cp	r1, r22
    3d76:	17 06       	cpc	r1, r23
    3d78:	e8 07       	cpc	r30, r24
    3d7a:	f9 07       	cpc	r31, r25
    3d7c:	c0 f0       	brcs	.+48     	; 0x3dae <__fp_cmp+0x46>
    3d7e:	12 16       	cp	r1, r18
    3d80:	13 06       	cpc	r1, r19
    3d82:	e4 07       	cpc	r30, r20
    3d84:	f5 07       	cpc	r31, r21
    3d86:	98 f0       	brcs	.+38     	; 0x3dae <__fp_cmp+0x46>
    3d88:	62 1b       	sub	r22, r18
    3d8a:	73 0b       	sbc	r23, r19
    3d8c:	84 0b       	sbc	r24, r20
    3d8e:	95 0b       	sbc	r25, r21
    3d90:	39 f4       	brne	.+14     	; 0x3da0 <__fp_cmp+0x38>
    3d92:	0a 26       	eor	r0, r26
    3d94:	61 f0       	breq	.+24     	; 0x3dae <__fp_cmp+0x46>
    3d96:	23 2b       	or	r18, r19
    3d98:	24 2b       	or	r18, r20
    3d9a:	25 2b       	or	r18, r21
    3d9c:	21 f4       	brne	.+8      	; 0x3da6 <__fp_cmp+0x3e>
    3d9e:	08 95       	ret
    3da0:	0a 26       	eor	r0, r26
    3da2:	09 f4       	brne	.+2      	; 0x3da6 <__fp_cmp+0x3e>
    3da4:	a1 40       	sbci	r26, 0x01	; 1
    3da6:	a6 95       	lsr	r26
    3da8:	8f ef       	ldi	r24, 0xFF	; 255
    3daa:	81 1d       	adc	r24, r1
    3dac:	81 1d       	adc	r24, r1
    3dae:	08 95       	ret

00003db0 <__fp_inf>:
    3db0:	97 f9       	bld	r25, 7
    3db2:	9f 67       	ori	r25, 0x7F	; 127
    3db4:	80 e8       	ldi	r24, 0x80	; 128
    3db6:	70 e0       	ldi	r23, 0x00	; 0
    3db8:	60 e0       	ldi	r22, 0x00	; 0
    3dba:	08 95       	ret

00003dbc <__fp_nan>:
    3dbc:	9f ef       	ldi	r25, 0xFF	; 255
    3dbe:	80 ec       	ldi	r24, 0xC0	; 192
    3dc0:	08 95       	ret

00003dc2 <__fp_pscA>:
    3dc2:	00 24       	eor	r0, r0
    3dc4:	0a 94       	dec	r0
    3dc6:	16 16       	cp	r1, r22
    3dc8:	17 06       	cpc	r1, r23
    3dca:	18 06       	cpc	r1, r24
    3dcc:	09 06       	cpc	r0, r25
    3dce:	08 95       	ret

00003dd0 <__fp_pscB>:
    3dd0:	00 24       	eor	r0, r0
    3dd2:	0a 94       	dec	r0
    3dd4:	12 16       	cp	r1, r18
    3dd6:	13 06       	cpc	r1, r19
    3dd8:	14 06       	cpc	r1, r20
    3dda:	05 06       	cpc	r0, r21
    3ddc:	08 95       	ret

00003dde <__fp_round>:
    3dde:	09 2e       	mov	r0, r25
    3de0:	03 94       	inc	r0
    3de2:	00 0c       	add	r0, r0
    3de4:	11 f4       	brne	.+4      	; 0x3dea <__fp_round+0xc>
    3de6:	88 23       	and	r24, r24
    3de8:	52 f0       	brmi	.+20     	; 0x3dfe <__fp_round+0x20>
    3dea:	bb 0f       	add	r27, r27
    3dec:	40 f4       	brcc	.+16     	; 0x3dfe <__fp_round+0x20>
    3dee:	bf 2b       	or	r27, r31
    3df0:	11 f4       	brne	.+4      	; 0x3df6 <__fp_round+0x18>
    3df2:	60 ff       	sbrs	r22, 0
    3df4:	04 c0       	rjmp	.+8      	; 0x3dfe <__fp_round+0x20>
    3df6:	6f 5f       	subi	r22, 0xFF	; 255
    3df8:	7f 4f       	sbci	r23, 0xFF	; 255
    3dfa:	8f 4f       	sbci	r24, 0xFF	; 255
    3dfc:	9f 4f       	sbci	r25, 0xFF	; 255
    3dfe:	08 95       	ret

00003e00 <__fp_split3>:
    3e00:	57 fd       	sbrc	r21, 7
    3e02:	90 58       	subi	r25, 0x80	; 128
    3e04:	44 0f       	add	r20, r20
    3e06:	55 1f       	adc	r21, r21
    3e08:	59 f0       	breq	.+22     	; 0x3e20 <__fp_splitA+0x10>
    3e0a:	5f 3f       	cpi	r21, 0xFF	; 255
    3e0c:	71 f0       	breq	.+28     	; 0x3e2a <__fp_splitA+0x1a>
    3e0e:	47 95       	ror	r20

00003e10 <__fp_splitA>:
    3e10:	88 0f       	add	r24, r24
    3e12:	97 fb       	bst	r25, 7
    3e14:	99 1f       	adc	r25, r25
    3e16:	61 f0       	breq	.+24     	; 0x3e30 <__fp_splitA+0x20>
    3e18:	9f 3f       	cpi	r25, 0xFF	; 255
    3e1a:	79 f0       	breq	.+30     	; 0x3e3a <__fp_splitA+0x2a>
    3e1c:	87 95       	ror	r24
    3e1e:	08 95       	ret
    3e20:	12 16       	cp	r1, r18
    3e22:	13 06       	cpc	r1, r19
    3e24:	14 06       	cpc	r1, r20
    3e26:	55 1f       	adc	r21, r21
    3e28:	f2 cf       	rjmp	.-28     	; 0x3e0e <__fp_split3+0xe>
    3e2a:	46 95       	lsr	r20
    3e2c:	f1 df       	rcall	.-30     	; 0x3e10 <__fp_splitA>
    3e2e:	08 c0       	rjmp	.+16     	; 0x3e40 <__fp_splitA+0x30>
    3e30:	16 16       	cp	r1, r22
    3e32:	17 06       	cpc	r1, r23
    3e34:	18 06       	cpc	r1, r24
    3e36:	99 1f       	adc	r25, r25
    3e38:	f1 cf       	rjmp	.-30     	; 0x3e1c <__fp_splitA+0xc>
    3e3a:	86 95       	lsr	r24
    3e3c:	71 05       	cpc	r23, r1
    3e3e:	61 05       	cpc	r22, r1
    3e40:	08 94       	sec
    3e42:	08 95       	ret

00003e44 <__fp_zero>:
    3e44:	e8 94       	clt

00003e46 <__fp_szero>:
    3e46:	bb 27       	eor	r27, r27
    3e48:	66 27       	eor	r22, r22
    3e4a:	77 27       	eor	r23, r23
    3e4c:	cb 01       	movw	r24, r22
    3e4e:	97 f9       	bld	r25, 7
    3e50:	08 95       	ret

00003e52 <__gesf2>:
    3e52:	0e 94 b4 1e 	call	0x3d68	; 0x3d68 <__fp_cmp>
    3e56:	08 f4       	brcc	.+2      	; 0x3e5a <__gesf2+0x8>
    3e58:	8f ef       	ldi	r24, 0xFF	; 255
    3e5a:	08 95       	ret

00003e5c <__mulsf3>:
    3e5c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <__mulsf3x>
    3e60:	0c 94 ef 1e 	jmp	0x3dde	; 0x3dde <__fp_round>
    3e64:	0e 94 e1 1e 	call	0x3dc2	; 0x3dc2 <__fp_pscA>
    3e68:	38 f0       	brcs	.+14     	; 0x3e78 <__mulsf3+0x1c>
    3e6a:	0e 94 e8 1e 	call	0x3dd0	; 0x3dd0 <__fp_pscB>
    3e6e:	20 f0       	brcs	.+8      	; 0x3e78 <__mulsf3+0x1c>
    3e70:	95 23       	and	r25, r21
    3e72:	11 f0       	breq	.+4      	; 0x3e78 <__mulsf3+0x1c>
    3e74:	0c 94 d8 1e 	jmp	0x3db0	; 0x3db0 <__fp_inf>
    3e78:	0c 94 de 1e 	jmp	0x3dbc	; 0x3dbc <__fp_nan>
    3e7c:	11 24       	eor	r1, r1
    3e7e:	0c 94 23 1f 	jmp	0x3e46	; 0x3e46 <__fp_szero>

00003e82 <__mulsf3x>:
    3e82:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <__fp_split3>
    3e86:	70 f3       	brcs	.-36     	; 0x3e64 <__mulsf3+0x8>

00003e88 <__mulsf3_pse>:
    3e88:	95 9f       	mul	r25, r21
    3e8a:	c1 f3       	breq	.-16     	; 0x3e7c <__mulsf3+0x20>
    3e8c:	95 0f       	add	r25, r21
    3e8e:	50 e0       	ldi	r21, 0x00	; 0
    3e90:	55 1f       	adc	r21, r21
    3e92:	62 9f       	mul	r22, r18
    3e94:	f0 01       	movw	r30, r0
    3e96:	72 9f       	mul	r23, r18
    3e98:	bb 27       	eor	r27, r27
    3e9a:	f0 0d       	add	r31, r0
    3e9c:	b1 1d       	adc	r27, r1
    3e9e:	63 9f       	mul	r22, r19
    3ea0:	aa 27       	eor	r26, r26
    3ea2:	f0 0d       	add	r31, r0
    3ea4:	b1 1d       	adc	r27, r1
    3ea6:	aa 1f       	adc	r26, r26
    3ea8:	64 9f       	mul	r22, r20
    3eaa:	66 27       	eor	r22, r22
    3eac:	b0 0d       	add	r27, r0
    3eae:	a1 1d       	adc	r26, r1
    3eb0:	66 1f       	adc	r22, r22
    3eb2:	82 9f       	mul	r24, r18
    3eb4:	22 27       	eor	r18, r18
    3eb6:	b0 0d       	add	r27, r0
    3eb8:	a1 1d       	adc	r26, r1
    3eba:	62 1f       	adc	r22, r18
    3ebc:	73 9f       	mul	r23, r19
    3ebe:	b0 0d       	add	r27, r0
    3ec0:	a1 1d       	adc	r26, r1
    3ec2:	62 1f       	adc	r22, r18
    3ec4:	83 9f       	mul	r24, r19
    3ec6:	a0 0d       	add	r26, r0
    3ec8:	61 1d       	adc	r22, r1
    3eca:	22 1f       	adc	r18, r18
    3ecc:	74 9f       	mul	r23, r20
    3ece:	33 27       	eor	r19, r19
    3ed0:	a0 0d       	add	r26, r0
    3ed2:	61 1d       	adc	r22, r1
    3ed4:	23 1f       	adc	r18, r19
    3ed6:	84 9f       	mul	r24, r20
    3ed8:	60 0d       	add	r22, r0
    3eda:	21 1d       	adc	r18, r1
    3edc:	82 2f       	mov	r24, r18
    3ede:	76 2f       	mov	r23, r22
    3ee0:	6a 2f       	mov	r22, r26
    3ee2:	11 24       	eor	r1, r1
    3ee4:	9f 57       	subi	r25, 0x7F	; 127
    3ee6:	50 40       	sbci	r21, 0x00	; 0
    3ee8:	9a f0       	brmi	.+38     	; 0x3f10 <__mulsf3_pse+0x88>
    3eea:	f1 f0       	breq	.+60     	; 0x3f28 <__mulsf3_pse+0xa0>
    3eec:	88 23       	and	r24, r24
    3eee:	4a f0       	brmi	.+18     	; 0x3f02 <__mulsf3_pse+0x7a>
    3ef0:	ee 0f       	add	r30, r30
    3ef2:	ff 1f       	adc	r31, r31
    3ef4:	bb 1f       	adc	r27, r27
    3ef6:	66 1f       	adc	r22, r22
    3ef8:	77 1f       	adc	r23, r23
    3efa:	88 1f       	adc	r24, r24
    3efc:	91 50       	subi	r25, 0x01	; 1
    3efe:	50 40       	sbci	r21, 0x00	; 0
    3f00:	a9 f7       	brne	.-22     	; 0x3eec <__mulsf3_pse+0x64>
    3f02:	9e 3f       	cpi	r25, 0xFE	; 254
    3f04:	51 05       	cpc	r21, r1
    3f06:	80 f0       	brcs	.+32     	; 0x3f28 <__mulsf3_pse+0xa0>
    3f08:	0c 94 d8 1e 	jmp	0x3db0	; 0x3db0 <__fp_inf>
    3f0c:	0c 94 23 1f 	jmp	0x3e46	; 0x3e46 <__fp_szero>
    3f10:	5f 3f       	cpi	r21, 0xFF	; 255
    3f12:	e4 f3       	brlt	.-8      	; 0x3f0c <__mulsf3_pse+0x84>
    3f14:	98 3e       	cpi	r25, 0xE8	; 232
    3f16:	d4 f3       	brlt	.-12     	; 0x3f0c <__mulsf3_pse+0x84>
    3f18:	86 95       	lsr	r24
    3f1a:	77 95       	ror	r23
    3f1c:	67 95       	ror	r22
    3f1e:	b7 95       	ror	r27
    3f20:	f7 95       	ror	r31
    3f22:	e7 95       	ror	r30
    3f24:	9f 5f       	subi	r25, 0xFF	; 255
    3f26:	c1 f7       	brne	.-16     	; 0x3f18 <__mulsf3_pse+0x90>
    3f28:	fe 2b       	or	r31, r30
    3f2a:	88 0f       	add	r24, r24
    3f2c:	91 1d       	adc	r25, r1
    3f2e:	96 95       	lsr	r25
    3f30:	87 95       	ror	r24
    3f32:	97 f9       	bld	r25, 7
    3f34:	08 95       	ret

00003f36 <__divmodhi4>:
    3f36:	97 fb       	bst	r25, 7
    3f38:	07 2e       	mov	r0, r23
    3f3a:	16 f4       	brtc	.+4      	; 0x3f40 <__divmodhi4+0xa>
    3f3c:	00 94       	com	r0
    3f3e:	07 d0       	rcall	.+14     	; 0x3f4e <__divmodhi4_neg1>
    3f40:	77 fd       	sbrc	r23, 7
    3f42:	09 d0       	rcall	.+18     	; 0x3f56 <__divmodhi4_neg2>
    3f44:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <__udivmodhi4>
    3f48:	07 fc       	sbrc	r0, 7
    3f4a:	05 d0       	rcall	.+10     	; 0x3f56 <__divmodhi4_neg2>
    3f4c:	3e f4       	brtc	.+14     	; 0x3f5c <__divmodhi4_exit>

00003f4e <__divmodhi4_neg1>:
    3f4e:	90 95       	com	r25
    3f50:	81 95       	neg	r24
    3f52:	9f 4f       	sbci	r25, 0xFF	; 255
    3f54:	08 95       	ret

00003f56 <__divmodhi4_neg2>:
    3f56:	70 95       	com	r23
    3f58:	61 95       	neg	r22
    3f5a:	7f 4f       	sbci	r23, 0xFF	; 255

00003f5c <__divmodhi4_exit>:
    3f5c:	08 95       	ret

00003f5e <__tablejump2__>:
    3f5e:	ee 0f       	add	r30, r30
    3f60:	ff 1f       	adc	r31, r31
    3f62:	88 1f       	adc	r24, r24
    3f64:	8b bf       	out	0x3b, r24	; 59
    3f66:	07 90       	elpm	r0, Z+
    3f68:	f6 91       	elpm	r31, Z
    3f6a:	e0 2d       	mov	r30, r0
    3f6c:	19 94       	eijmp

00003f6e <__udivmodhi4>:
    3f6e:	aa 1b       	sub	r26, r26
    3f70:	bb 1b       	sub	r27, r27
    3f72:	51 e1       	ldi	r21, 0x11	; 17
    3f74:	07 c0       	rjmp	.+14     	; 0x3f84 <__udivmodhi4_ep>

00003f76 <__udivmodhi4_loop>:
    3f76:	aa 1f       	adc	r26, r26
    3f78:	bb 1f       	adc	r27, r27
    3f7a:	a6 17       	cp	r26, r22
    3f7c:	b7 07       	cpc	r27, r23
    3f7e:	10 f0       	brcs	.+4      	; 0x3f84 <__udivmodhi4_ep>
    3f80:	a6 1b       	sub	r26, r22
    3f82:	b7 0b       	sbc	r27, r23

00003f84 <__udivmodhi4_ep>:
    3f84:	88 1f       	adc	r24, r24
    3f86:	99 1f       	adc	r25, r25
    3f88:	5a 95       	dec	r21
    3f8a:	a9 f7       	brne	.-22     	; 0x3f76 <__udivmodhi4_loop>
    3f8c:	80 95       	com	r24
    3f8e:	90 95       	com	r25
    3f90:	bc 01       	movw	r22, r24
    3f92:	cd 01       	movw	r24, r26
    3f94:	08 95       	ret

00003f96 <memcpy>:
    3f96:	fb 01       	movw	r30, r22
    3f98:	dc 01       	movw	r26, r24
    3f9a:	02 c0       	rjmp	.+4      	; 0x3fa0 <memcpy+0xa>
    3f9c:	01 90       	ld	r0, Z+
    3f9e:	0d 92       	st	X+, r0
    3fa0:	41 50       	subi	r20, 0x01	; 1
    3fa2:	50 40       	sbci	r21, 0x00	; 0
    3fa4:	d8 f7       	brcc	.-10     	; 0x3f9c <memcpy+0x6>
    3fa6:	08 95       	ret

00003fa8 <memset>:
    3fa8:	dc 01       	movw	r26, r24
    3faa:	01 c0       	rjmp	.+2      	; 0x3fae <memset+0x6>
    3fac:	6d 93       	st	X+, r22
    3fae:	41 50       	subi	r20, 0x01	; 1
    3fb0:	50 40       	sbci	r21, 0x00	; 0
    3fb2:	e0 f7       	brcc	.-8      	; 0x3fac <memset+0x4>
    3fb4:	08 95       	ret

00003fb6 <__itoa_ncheck>:
    3fb6:	bb 27       	eor	r27, r27
    3fb8:	4a 30       	cpi	r20, 0x0A	; 10
    3fba:	31 f4       	brne	.+12     	; 0x3fc8 <__itoa_ncheck+0x12>
    3fbc:	99 23       	and	r25, r25
    3fbe:	22 f4       	brpl	.+8      	; 0x3fc8 <__itoa_ncheck+0x12>
    3fc0:	bd e2       	ldi	r27, 0x2D	; 45
    3fc2:	90 95       	com	r25
    3fc4:	81 95       	neg	r24
    3fc6:	9f 4f       	sbci	r25, 0xFF	; 255
    3fc8:	0c 94 e7 1f 	jmp	0x3fce	; 0x3fce <__utoa_common>

00003fcc <__utoa_ncheck>:
    3fcc:	bb 27       	eor	r27, r27

00003fce <__utoa_common>:
    3fce:	fb 01       	movw	r30, r22
    3fd0:	55 27       	eor	r21, r21
    3fd2:	aa 27       	eor	r26, r26
    3fd4:	88 0f       	add	r24, r24
    3fd6:	99 1f       	adc	r25, r25
    3fd8:	aa 1f       	adc	r26, r26
    3fda:	a4 17       	cp	r26, r20
    3fdc:	10 f0       	brcs	.+4      	; 0x3fe2 <__utoa_common+0x14>
    3fde:	a4 1b       	sub	r26, r20
    3fe0:	83 95       	inc	r24
    3fe2:	50 51       	subi	r21, 0x10	; 16
    3fe4:	b9 f7       	brne	.-18     	; 0x3fd4 <__utoa_common+0x6>
    3fe6:	a0 5d       	subi	r26, 0xD0	; 208
    3fe8:	aa 33       	cpi	r26, 0x3A	; 58
    3fea:	08 f0       	brcs	.+2      	; 0x3fee <__utoa_common+0x20>
    3fec:	a9 5d       	subi	r26, 0xD9	; 217
    3fee:	a1 93       	st	Z+, r26
    3ff0:	00 97       	sbiw	r24, 0x00	; 0
    3ff2:	79 f7       	brne	.-34     	; 0x3fd2 <__utoa_common+0x4>
    3ff4:	b1 11       	cpse	r27, r1
    3ff6:	b1 93       	st	Z+, r27
    3ff8:	11 92       	st	Z+, r1
    3ffa:	cb 01       	movw	r24, r22
    3ffc:	0c 94 00 20 	jmp	0x4000	; 0x4000 <strrev>

00004000 <strrev>:
    4000:	dc 01       	movw	r26, r24
    4002:	fc 01       	movw	r30, r24
    4004:	67 2f       	mov	r22, r23
    4006:	71 91       	ld	r23, Z+
    4008:	77 23       	and	r23, r23
    400a:	e1 f7       	brne	.-8      	; 0x4004 <strrev+0x4>
    400c:	32 97       	sbiw	r30, 0x02	; 2
    400e:	04 c0       	rjmp	.+8      	; 0x4018 <strrev+0x18>
    4010:	7c 91       	ld	r23, X
    4012:	6d 93       	st	X+, r22
    4014:	70 83       	st	Z, r23
    4016:	62 91       	ld	r22, -Z
    4018:	ae 17       	cp	r26, r30
    401a:	bf 07       	cpc	r27, r31
    401c:	c8 f3       	brcs	.-14     	; 0x4010 <strrev+0x10>
    401e:	08 95       	ret

00004020 <_exit>:
    4020:	f8 94       	cli

00004022 <__stop_program>:
    4022:	ff cf       	rjmp	.-2      	; 0x4022 <__stop_program>
