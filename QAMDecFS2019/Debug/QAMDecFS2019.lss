
QAMDecFS2019.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003a66  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000092  00802000  00003a66  00003afa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00001e87  00802092  00802092  00003b8c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003b8c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003bbc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000790  00000000  00000000  00003bfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ff56  00000000  00000000  0000438c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000051b5  00000000  00000000  000142e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005014  00000000  00000000  00019497  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001918  00000000  00000000  0001e4ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00007508  00000000  00000000  0001fdc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000091b8  00000000  00000000  000272cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000820  00000000  00000000  00030484  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 20 01 	jmp	0x240	; 0x240 <__ctors_end>
       4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
       8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
       c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      10:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      14:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      18:	0c 94 b7 01 	jmp	0x36e	; 0x36e <__vector_6>
      1c:	0c 94 fd 01 	jmp	0x3fa	; 0x3fa <__vector_7>
      20:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      24:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      28:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      2c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      30:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      34:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      38:	0c 94 4a 06 	jmp	0xc94	; 0xc94 <__vector_14>
      3c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      40:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      44:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      48:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      4c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      50:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      54:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      58:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      5c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      60:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      64:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      68:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      6c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      70:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      74:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      78:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      7c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      80:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      84:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      88:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      8c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      90:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      94:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      98:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      9c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      a8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      ac:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      b8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      bc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      c8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      cc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      d8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      dc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      e8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      ec:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      f8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
      fc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     100:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     104:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     108:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     10c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     110:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     114:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     118:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     11c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     120:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     124:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     128:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     12c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     130:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     134:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     138:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     13c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     140:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     144:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     148:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     14c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     150:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     154:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     158:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     15c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     160:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     164:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     168:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     16c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     170:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     174:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     178:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     17c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     180:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     184:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     188:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     18c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     190:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     194:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     198:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     19c:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1a8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1ac:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1b0:	0c 94 c6 13 	jmp	0x278c	; 0x278c <__vector_108>
     1b4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1b8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1bc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1c8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1cc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1d8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1dc:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1e8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1ec:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f0:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f4:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1f8:	0c 94 49 01 	jmp	0x292	; 0x292 <__bad_interrupt>
     1fc:	92 11       	cpse	r25, r2
     1fe:	92 11       	cpse	r25, r2
     200:	92 11       	cpse	r25, r2
     202:	df 11       	cpse	r29, r15
     204:	c7 11       	cpse	r28, r7
     206:	dc 11       	cpse	r29, r12
     208:	92 11       	cpse	r25, r2
     20a:	92 11       	cpse	r25, r2
     20c:	df 11       	cpse	r29, r15
     20e:	c7 11       	cpse	r28, r7

00000210 <__trampolines_start>:
     210:	0c 94 df 11 	jmp	0x23be	; 0x23be <prvTimerTask+0x212>
     214:	0c 94 63 12 	jmp	0x24c6	; 0x24c6 <vLedBlink>
     218:	0c 94 e4 12 	jmp	0x25c8	; 0x25c8 <vRead_DMA>
     21c:	0c 94 35 04 	jmp	0x86a	; 0x86a <vEventGroupSetBitsCallback>
     220:	0c 94 5f 0a 	jmp	0x14be	; 0x14be <prvIdleTask>
     224:	0c 94 92 11 	jmp	0x2324	; 0x2324 <prvTimerTask+0x178>
     228:	0c 94 d6 10 	jmp	0x21ac	; 0x21ac <prvTimerTask>
     22c:	0c 94 dc 11 	jmp	0x23b8	; 0x23b8 <prvTimerTask+0x20c>
     230:	0c 94 f1 19 	jmp	0x33e2	; 0x33e2 <vTask_DMAHandler>
     234:	0c 94 c7 11 	jmp	0x238e	; 0x238e <prvTimerTask+0x1e2>
     238:	0c 94 6f 12 	jmp	0x24de	; 0x24de <vWrite_Display>
     23c:	0c 94 65 15 	jmp	0x2aca	; 0x2aca <vDisplayUpdateTask>

00000240 <__ctors_end>:
     240:	11 24       	eor	r1, r1
     242:	1f be       	out	0x3f, r1	; 63
     244:	cf ef       	ldi	r28, 0xFF	; 255
     246:	cd bf       	out	0x3d, r28	; 61
     248:	df e3       	ldi	r29, 0x3F	; 63
     24a:	de bf       	out	0x3e, r29	; 62
     24c:	00 e0       	ldi	r16, 0x00	; 0
     24e:	0c bf       	out	0x3c, r16	; 60

00000250 <init_mem>:
// !!! Never call this function, it is part of .init-Code
void __attribute__ ((naked, section(".init3"))) init_mem (void);
void init_mem (void)
{
   //  Use inline assembler so it works even with optimization turned off
   __asm volatile (
     250:	e9 e1       	ldi	r30, 0x19	; 25
     252:	ff e3       	ldi	r31, 0x3F	; 63
     254:	8a ea       	ldi	r24, 0xAA	; 170
     256:	90 e4       	ldi	r25, 0x40	; 64
     258:	81 93       	st	Z+, r24
     25a:	e0 30       	cpi	r30, 0x00	; 0
     25c:	f9 07       	cpc	r31, r25
     25e:	e0 f3       	brcs	.-8      	; 0x258 <init_mem+0x8>

00000260 <__do_copy_data>:
     260:	10 e2       	ldi	r17, 0x20	; 32
     262:	a0 e0       	ldi	r26, 0x00	; 0
     264:	b0 e2       	ldi	r27, 0x20	; 32
     266:	e6 e6       	ldi	r30, 0x66	; 102
     268:	fa e3       	ldi	r31, 0x3A	; 58
     26a:	00 e0       	ldi	r16, 0x00	; 0
     26c:	0b bf       	out	0x3b, r16	; 59
     26e:	02 c0       	rjmp	.+4      	; 0x274 <__do_copy_data+0x14>
     270:	07 90       	elpm	r0, Z+
     272:	0d 92       	st	X+, r0
     274:	a2 39       	cpi	r26, 0x92	; 146
     276:	b1 07       	cpc	r27, r17
     278:	d9 f7       	brne	.-10     	; 0x270 <__do_copy_data+0x10>

0000027a <__do_clear_bss>:
     27a:	2f e3       	ldi	r18, 0x3F	; 63
     27c:	a2 e9       	ldi	r26, 0x92	; 146
     27e:	b0 e2       	ldi	r27, 0x20	; 32
     280:	01 c0       	rjmp	.+2      	; 0x284 <.do_clear_bss_start>

00000282 <.do_clear_bss_loop>:
     282:	1d 92       	st	X+, r1

00000284 <.do_clear_bss_start>:
     284:	a9 31       	cpi	r26, 0x19	; 25
     286:	b2 07       	cpc	r27, r18
     288:	e1 f7       	brne	.-8      	; 0x282 <.do_clear_bss_loop>
     28a:	0e 94 35 13 	call	0x266a	; 0x266a <main>
     28e:	0c 94 31 1d 	jmp	0x3a62	; 0x3a62 <_exit>

00000292 <__bad_interrupt>:
     292:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000296 <sys_InitADC>:
void sys_InitADC(void)
{
	
	// Free Running mode: On
	// Conversion mode: Unsigned, 8Bit
	ADCB.CTRLB=(ADCB.CTRLB & (~(ADC_CONMODE_bm | ADC_FREERUN_bm | ADC_RESOLUTION_gm))) | ADC_RESOLUTION_8BIT_gc | ADC_FREERUN_bm;
     296:	e0 e4       	ldi	r30, 0x40	; 64
     298:	f2 e0       	ldi	r31, 0x02	; 2
     29a:	81 81       	ldd	r24, Z+1	; 0x01
     29c:	81 7e       	andi	r24, 0xE1	; 225
     29e:	8c 60       	ori	r24, 0x0C	; 12
     2a0:	81 83       	std	Z+1, r24	; 0x01
	// Reference 1V and configuration of prescaler to 256
	ADCB.PRESCALER=(ADCB.PRESCALER & (~ADC_PRESCALER_gm)) | ADC_PRESCALER_DIV256_gc; //?????
     2a2:	84 81       	ldd	r24, Z+4	; 0x04
     2a4:	88 7f       	andi	r24, 0xF8	; 248
     2a6:	86 60       	ori	r24, 0x06	; 6
     2a8:	84 83       	std	Z+4, r24	; 0x04
	ADCB.REFCTRL = ADC_REFSEL_INT1V_gc | ADC_TEMPREF_bm;;			//internal 1V
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	82 83       	std	Z+2, r24	; 0x02

	// Read and save the ADC offset using channel 0
	ADCB.CH0.CTRL=(ADCB.CH0.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2ae:	80 a1       	ldd	r24, Z+32	; 0x20
     2b0:	80 76       	andi	r24, 0x60	; 96
     2b2:	81 60       	ori	r24, 0x01	; 1
     2b4:	80 a3       	std	Z+32, r24	; 0x20
	ADCB.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN0_gc ;	// PORTB:0
     2b6:	11 a2       	std	Z+33, r1	; 0x21
	
	ADCB.CH1.CTRL=(ADCB.CH1.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2b8:	80 a5       	ldd	r24, Z+40	; 0x28
     2ba:	80 76       	andi	r24, 0x60	; 96
     2bc:	81 60       	ori	r24, 0x01	; 1
     2be:	80 a7       	std	Z+40, r24	; 0x28
	ADCB.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc ;	// PORTB:1	
     2c0:	88 e0       	ldi	r24, 0x08	; 8
     2c2:	81 a7       	std	Z+41, r24	; 0x29
	
	ADCB.CH2.CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_INTERNAL_gc;
     2c4:	10 aa       	std	Z+48, r1	; 0x30
	ADCB.CH2.MUXCTRL = ADC_CH_MUXINT_TEMP_gc;  //Temp Mux
     2c6:	11 aa       	std	Z+49, r1	; 0x31
	
	ADCB.EVCTRL = ADC_SWEEP_012_gc;
     2c8:	80 e8       	ldi	r24, 0x80	; 128
     2ca:	83 83       	std	Z+3, r24	; 0x03
	
	// Enable the ADC in order to read the offset
	ADCB.CTRLA|=ADC_ENABLE_bm;
     2cc:	80 81       	ld	r24, Z
     2ce:	81 60       	ori	r24, 0x01	; 1
     2d0:	80 83       	st	Z, r24
     2d2:	08 95       	ret

000002d4 <vInitDMA>:
void vInitDMA()
{
	uint8_t i = 0;
	
	//ADC8 PB0 Input
	PORTB.DIRCLR = PIN0_bm;
     2d4:	e0 e2       	ldi	r30, 0x20	; 32
     2d6:	f6 e0       	ldi	r31, 0x06	; 6
     2d8:	81 e0       	ldi	r24, 0x01	; 1
     2da:	82 83       	std	Z+2, r24	; 0x02
	PORTB.DIRCLR = PIN1_bm;
     2dc:	82 e0       	ldi	r24, 0x02	; 2
     2de:	82 83       	std	Z+2, r24	; 0x02
	
	sys_InitADC();
     2e0:	0e 94 4b 01 	call	0x296	; 0x296 <sys_InitADC>

	// set TCC1 to 11024Hz overflow, actually 11019.2838Hz (-0.052% error)
	TCC1.CTRLA = 0; // stop if running
     2e4:	e0 e4       	ldi	r30, 0x40	; 64
     2e6:	f8 e0       	ldi	r31, 0x08	; 8
     2e8:	10 82       	st	Z, r1
	TCC1.CNT = 0;
     2ea:	10 a2       	std	Z+32, r1	; 0x20
     2ec:	11 a2       	std	Z+33, r1	; 0x21
	TCC1.PER = 0x0FFF;
     2ee:	8f ef       	ldi	r24, 0xFF	; 255
     2f0:	9f e0       	ldi	r25, 0x0F	; 15
     2f2:	86 a3       	std	Z+38, r24	; 0x26
     2f4:	97 a3       	std	Z+39, r25	; 0x27

	EVSYS.CH0MUX = EVSYS_CHMUX_TCC1_OVF_gc; // trigger on timer overflow
     2f6:	88 ec       	ldi	r24, 0xC8	; 200
     2f8:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>


	// reset DMA controller
	DMA.CTRL = 0;
     2fc:	e0 e0       	ldi	r30, 0x00	; 0
     2fe:	f1 e0       	ldi	r31, 0x01	; 1
     300:	10 82       	st	Z, r1
	DMA.CTRL = DMA_RESET_bm;
     302:	80 e4       	ldi	r24, 0x40	; 64
     304:	80 83       	st	Z, r24
	while ((DMA.CTRL & DMA_RESET_bm) != 0);
     306:	80 81       	ld	r24, Z
     308:	86 fd       	sbrc	r24, 6
     30a:	fd cf       	rjmp	.-6      	; 0x306 <vInitDMA+0x32>
	
	DMA.CTRL			= DMA_CH_ENABLE_bm | DMA_DBUFMODE_CH01_gc; // double buffered with channels 0 and 1
     30c:	e0 e0       	ldi	r30, 0x00	; 0
     30e:	f1 e0       	ldi	r31, 0x01	; 1
     310:	84 e8       	ldi	r24, 0x84	; 132
     312:	80 83       	st	Z, r24
	//Bei Double Buffering wird automatisch aus Channel 0 und 1 ein "Pair" gebildet. 
	//Siehe dazu AVR1304.P8
	
	// channel 0
	// **** TODO: reset dma channels
	DMA.CH0.REPCNT		= 0;
     314:	16 8a       	std	Z+22, r1	; 0x16
	DMA.CH0.CTRLA		=  DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 2 byte 12 bit word
     316:	74 e2       	ldi	r23, 0x24	; 36
     318:	70 8b       	std	Z+16, r23	; 0x10
	DMA.CH0.CTRLB		= 0x1;
     31a:	61 e0       	ldi	r22, 0x01	; 1
     31c:	61 8b       	std	Z+17, r22	; 0x11
	DMA.CH0.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     31e:	5d e9       	ldi	r21, 0x9D	; 157
     320:	52 8b       	std	Z+18, r21	; 0x12
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH0.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc;	//DMA0 gets synched by TCC1
     322:	46 e4       	ldi	r20, 0x46	; 70
     324:	43 8b       	std	Z+19, r20	; 0x13
	DMA.CH0.TRFCNT		= 2048; // always the number of bytes, even if burst length > 1
     326:	20 e0       	ldi	r18, 0x00	; 0
     328:	38 e0       	ldi	r19, 0x08	; 8
     32a:	24 8b       	std	Z+20, r18	; 0x14
     32c:	35 8b       	std	Z+21, r19	; 0x15
	DMA.CH0.DESTADDR0	= (( (uint16_t) buffer_a) >> 0) & 0xFF;
     32e:	84 e0       	ldi	r24, 0x04	; 4
     330:	97 e3       	ldi	r25, 0x37	; 55
     332:	84 8f       	std	Z+28, r24	; 0x1c
	DMA.CH0.DESTADDR1	= (( (uint16_t) buffer_a) >> 8) & 0xFF;
     334:	95 8f       	std	Z+29, r25	; 0x1d
	DMA.CH0.DESTADDR2	= 0;
     336:	16 8e       	std	Z+30, r1	; 0x1e
	DMA.CH0.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     338:	9c e6       	ldi	r25, 0x6C	; 108
     33a:	90 8f       	std	Z+24, r25	; 0x18
	DMA.CH0.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     33c:	82 e0       	ldi	r24, 0x02	; 2
     33e:	81 8f       	std	Z+25, r24	; 0x19
	DMA.CH0.SRCADDR2	= 0;
     340:	12 8e       	std	Z+26, r1	; 0x1a

	// channel 1
	DMA.CH1.REPCNT		= 0;
     342:	16 a2       	std	Z+38, r1	; 0x26
	DMA.CH1.CTRLA		= DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 2 byte 12 bit word
     344:	70 a3       	std	Z+32, r23	; 0x20
	DMA.CH1.CTRLB		= 0x1;
     346:	61 a3       	std	Z+33, r22	; 0x21
	DMA.CH1.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     348:	52 a3       	std	Z+34, r21	; 0x22
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH1.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc; //DMA1 gets synched by TCC1
     34a:	43 a3       	std	Z+35, r20	; 0x23
	DMA.CH1.TRFCNT		= 2048;
     34c:	24 a3       	std	Z+36, r18	; 0x24
     34e:	35 a3       	std	Z+37, r19	; 0x25
	DMA.CH1.DESTADDR0	= (( (uint16_t) buffer_b) >> 0) & 0xFF;
     350:	22 e0       	ldi	r18, 0x02	; 2
     352:	3f e2       	ldi	r19, 0x2F	; 47
     354:	24 a7       	std	Z+44, r18	; 0x2c
	DMA.CH1.DESTADDR1	= (( (uint16_t) buffer_b) >> 8) & 0xFF;
     356:	35 a7       	std	Z+45, r19	; 0x2d
	DMA.CH1.DESTADDR2	= 0;
     358:	16 a6       	std	Z+46, r1	; 0x2e
	DMA.CH1.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     35a:	90 a7       	std	Z+40, r25	; 0x28
	DMA.CH1.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     35c:	81 a7       	std	Z+41, r24	; 0x29
	DMA.CH1.SRCADDR2	= 0;
     35e:	12 a6       	std	Z+42, r1	; 0x2a

	DMA.CH0.CTRLA		|= DMA_CH_ENABLE_bm;
     360:	80 89       	ldd	r24, Z+16	; 0x10
     362:	80 68       	ori	r24, 0x80	; 128
     364:	80 8b       	std	Z+16, r24	; 0x10
	TCC1.CTRLA			= TC_CLKSEL_DIV1024_gc; // start timer, and in turn ADC
     366:	87 e0       	ldi	r24, 0x07	; 7
     368:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
     36c:	08 95       	ret

0000036e <__vector_6>:
// 		DMA.INTFLAGS = DMA_CH0TRNIF_bm;

}

ISR(DMA_CH0_vect)
{
     36e:	1f 92       	push	r1
     370:	0f 92       	push	r0
     372:	0f b6       	in	r0, 0x3f	; 63
     374:	0f 92       	push	r0
     376:	11 24       	eor	r1, r1
     378:	0b b6       	in	r0, 0x3b	; 59
     37a:	0f 92       	push	r0
     37c:	2f 93       	push	r18
     37e:	3f 93       	push	r19
     380:	4f 93       	push	r20
     382:	5f 93       	push	r21
     384:	6f 93       	push	r22
     386:	7f 93       	push	r23
     388:	8f 93       	push	r24
     38a:	9f 93       	push	r25
     38c:	af 93       	push	r26
     38e:	bf 93       	push	r27
     390:	ef 93       	push	r30
     392:	ff 93       	push	r31
     394:	cf 93       	push	r28
     396:	df 93       	push	r29
     398:	1f 92       	push	r1
     39a:	cd b7       	in	r28, 0x3d	; 61
     39c:	de b7       	in	r29, 0x3e	; 62
	
	//Interrupt quittieren
	DMA.CH0.CTRLB |= 0x10;
     39e:	e0 e0       	ldi	r30, 0x00	; 0
     3a0:	f1 e0       	ldi	r31, 0x01	; 1
     3a2:	81 89       	ldd	r24, Z+17	; 0x11
     3a4:	80 61       	ori	r24, 0x10	; 16
     3a6:	81 8b       	std	Z+17, r24	; 0x11
	TCC1.INTFLAGS |= 0x01;
     3a8:	e0 e4       	ldi	r30, 0x40	; 64
     3aa:	f8 e0       	ldi	r31, 0x08	; 8
     3ac:	84 85       	ldd	r24, Z+12	; 0x0c
     3ae:	81 60       	ori	r24, 0x01	; 1
     3b0:	84 87       	std	Z+12, r24	; 0x0c
	//PORTF.OUTTGL = 0x01;
		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     3b2:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     3b4:	9e 01       	movw	r18, r28
     3b6:	2f 5f       	subi	r18, 0xFF	; 255
     3b8:	3f 4f       	sbci	r19, 0xFF	; 255
     3ba:	41 e0       	ldi	r20, 0x01	; 1
     3bc:	50 e0       	ldi	r21, 0x00	; 0
     3be:	60 e0       	ldi	r22, 0x00	; 0
     3c0:	70 e0       	ldi	r23, 0x00	; 0
     3c2:	80 91 08 2d 	lds	r24, 0x2D08	; 0x802d08 <xDMAProcessEventGroup>
     3c6:	90 91 09 2d 	lds	r25, 0x2D09	; 0x802d09 <xDMAProcessEventGroup+0x1>
     3ca:	0e 94 38 04 	call	0x870	; 0x870 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     3ce:	0f 90       	pop	r0
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	ff 91       	pop	r31
     3d6:	ef 91       	pop	r30
     3d8:	bf 91       	pop	r27
     3da:	af 91       	pop	r26
     3dc:	9f 91       	pop	r25
     3de:	8f 91       	pop	r24
     3e0:	7f 91       	pop	r23
     3e2:	6f 91       	pop	r22
     3e4:	5f 91       	pop	r21
     3e6:	4f 91       	pop	r20
     3e8:	3f 91       	pop	r19
     3ea:	2f 91       	pop	r18
     3ec:	0f 90       	pop	r0
     3ee:	0b be       	out	0x3b, r0	; 59
     3f0:	0f 90       	pop	r0
     3f2:	0f be       	out	0x3f, r0	; 63
     3f4:	0f 90       	pop	r0
     3f6:	1f 90       	pop	r1
     3f8:	18 95       	reti

000003fa <__vector_7>:

ISR(DMA_CH1_vect)
{
     3fa:	1f 92       	push	r1
     3fc:	0f 92       	push	r0
     3fe:	0f b6       	in	r0, 0x3f	; 63
     400:	0f 92       	push	r0
     402:	11 24       	eor	r1, r1
     404:	0b b6       	in	r0, 0x3b	; 59
     406:	0f 92       	push	r0
     408:	2f 93       	push	r18
     40a:	3f 93       	push	r19
     40c:	4f 93       	push	r20
     40e:	5f 93       	push	r21
     410:	6f 93       	push	r22
     412:	7f 93       	push	r23
     414:	8f 93       	push	r24
     416:	9f 93       	push	r25
     418:	af 93       	push	r26
     41a:	bf 93       	push	r27
     41c:	ef 93       	push	r30
     41e:	ff 93       	push	r31
     420:	cf 93       	push	r28
     422:	df 93       	push	r29
     424:	1f 92       	push	r1
     426:	cd b7       	in	r28, 0x3d	; 61
     428:	de b7       	in	r29, 0x3e	; 62
	//Interrupt quittieren
	DMA.CH1.CTRLB |= 0x10;
     42a:	e0 e0       	ldi	r30, 0x00	; 0
     42c:	f1 e0       	ldi	r31, 0x01	; 1
     42e:	81 a1       	ldd	r24, Z+33	; 0x21
     430:	80 61       	ori	r24, 0x10	; 16
     432:	81 a3       	std	Z+33, r24	; 0x21
	TCC1.INTFLAGS |= 0x01;
     434:	e0 e4       	ldi	r30, 0x40	; 64
     436:	f8 e0       	ldi	r31, 0x08	; 8
     438:	84 85       	ldd	r24, Z+12	; 0x0c
     43a:	81 60       	ori	r24, 0x01	; 1
     43c:	84 87       	std	Z+12, r24	; 0x0c

		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     43e:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     440:	9e 01       	movw	r18, r28
     442:	2f 5f       	subi	r18, 0xFF	; 255
     444:	3f 4f       	sbci	r19, 0xFF	; 255
     446:	42 e0       	ldi	r20, 0x02	; 2
     448:	50 e0       	ldi	r21, 0x00	; 0
     44a:	60 e0       	ldi	r22, 0x00	; 0
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	80 91 08 2d 	lds	r24, 0x2D08	; 0x802d08 <xDMAProcessEventGroup>
     452:	90 91 09 2d 	lds	r25, 0x2D09	; 0x802d09 <xDMAProcessEventGroup+0x1>
     456:	0e 94 38 04 	call	0x870	; 0x870 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     45a:	0f 90       	pop	r0
     45c:	df 91       	pop	r29
     45e:	cf 91       	pop	r28
     460:	ff 91       	pop	r31
     462:	ef 91       	pop	r30
     464:	bf 91       	pop	r27
     466:	af 91       	pop	r26
     468:	9f 91       	pop	r25
     46a:	8f 91       	pop	r24
     46c:	7f 91       	pop	r23
     46e:	6f 91       	pop	r22
     470:	5f 91       	pop	r21
     472:	4f 91       	pop	r20
     474:	3f 91       	pop	r19
     476:	2f 91       	pop	r18
     478:	0f 90       	pop	r0
     47a:	0b be       	out	0x3b, r0	; 59
     47c:	0f 90       	pop	r0
     47e:	0f be       	out	0x3f, r0	; 63
     480:	0f 90       	pop	r0
     482:	1f 90       	pop	r1
     484:	18 95       	reti

00000486 <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     486:	0f 93       	push	r16
     488:	cf 93       	push	r28
     48a:	df 93       	push	r29
     48c:	1f 92       	push	r1
     48e:	cd b7       	in	r28, 0x3d	; 61
     490:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     492:	2f b7       	in	r18, 0x3f	; 63
     494:	29 83       	std	Y+1, r18	; 0x01
     496:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     498:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     49a:	fc 01       	movw	r30, r24
     49c:	08 ed       	ldi	r16, 0xD8	; 216
     49e:	04 bf       	out	0x34, r16	; 52
     4a0:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     4a2:	89 81       	ldd	r24, Y+1	; 0x01
     4a4:	8f bf       	out	0x3f, r24	; 63
#endif
}
     4a6:	0f 90       	pop	r0
     4a8:	df 91       	pop	r29
     4aa:	cf 91       	pop	r28
     4ac:	0f 91       	pop	r16
     4ae:	08 95       	ret

000004b0 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     4b0:	61 11       	cpse	r22, r1
     4b2:	02 c0       	rjmp	.+4      	; 0x4b8 <CLKSYS_XOSC_Config+0x8>
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	01 c0       	rjmp	.+2      	; 0x4ba <CLKSYS_XOSC_Config+0xa>
     4b8:	90 e2       	ldi	r25, 0x20	; 32
     4ba:	84 2b       	or	r24, r20
     4bc:	89 2b       	or	r24, r25
     4be:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
     4c2:	08 95       	ret

000004c4 <CLKSYS_PLL_Config>:
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     4c4:	6f 71       	andi	r22, 0x1F	; 31
     4c6:	86 2b       	or	r24, r22
     4c8:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
     4cc:	08 95       	ret

000004ce <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     4ce:	e0 e5       	ldi	r30, 0x50	; 80
     4d0:	f0 e0       	ldi	r31, 0x00	; 0
     4d2:	90 81       	ld	r25, Z
     4d4:	28 2f       	mov	r18, r24
     4d6:	20 95       	com	r18
     4d8:	92 23       	and	r25, r18
     4da:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     4dc:	90 81       	ld	r25, Z
	return clkEnabled;
}
     4de:	89 23       	and	r24, r25
     4e0:	08 95       	ret

000004e2 <CLKSYS_Prescalers_Config>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
     4e2:	68 2b       	or	r22, r24
     4e4:	81 e4       	ldi	r24, 0x41	; 65
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	0e 94 43 02 	call	0x486	; 0x486 <CCPWrite>
     4ec:	08 95       	ret

000004ee <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     4ee:	0f 93       	push	r16
     4f0:	1f 93       	push	r17
     4f2:	cf 93       	push	r28
     4f4:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     4f6:	00 e4       	ldi	r16, 0x40	; 64
     4f8:	10 e0       	ldi	r17, 0x00	; 0
     4fa:	f8 01       	movw	r30, r16
     4fc:	60 81       	ld	r22, Z
	CCPWrite( &CLK.CTRL, clkCtrl );
     4fe:	68 7f       	andi	r22, 0xF8	; 248
     500:	68 2b       	or	r22, r24
     502:	80 e4       	ldi	r24, 0x40	; 64
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	0e 94 43 02 	call	0x486	; 0x486 <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     50a:	f8 01       	movw	r30, r16
     50c:	80 81       	ld	r24, Z
	return clkCtrl;
}
     50e:	8c 23       	and	r24, r28
     510:	cf 91       	pop	r28
     512:	1f 91       	pop	r17
     514:	0f 91       	pop	r16
     516:	08 95       	ret

00000518 <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
     518:	fc 01       	movw	r30, r24
     51a:	90 81       	ld	r25, Z
     51c:	90 7f       	andi	r25, 0xF0	; 240
     51e:	69 2b       	or	r22, r25
     520:	60 83       	st	Z, r22
     522:	08 95       	ret

00000524 <TC0_ConfigWGM>:
     524:	fc 01       	movw	r30, r24
     526:	91 81       	ldd	r25, Z+1	; 0x01
     528:	98 7f       	andi	r25, 0xF8	; 248
     52a:	69 2b       	or	r22, r25
     52c:	61 83       	std	Z+1, r22	; 0x01
     52e:	08 95       	ret

00000530 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
     530:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     532:	96 81       	ldd	r25, Z+6	; 0x06
     534:	9c 7f       	andi	r25, 0xFC	; 252
     536:	69 2b       	or	r22, r25
     538:	66 83       	std	Z+6, r22	; 0x06
     53a:	08 95       	ret

0000053c <software_reset>:
	 // TODO from here:
	 //
	 // - log the occurance of any error in flash mem (inc counter)
	 // - print a message

	 software_reset();
     53c:	00 00       	nop
     53e:	88 ed       	ldi	r24, 0xD8	; 216
     540:	84 bf       	out	0x34, r24	; 52
     542:	81 e0       	ldi	r24, 0x01	; 1
     544:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     548:	08 95       	ret

0000054a <vApplicationStackOverflowHook>:
     54a:	0e 94 9e 02 	call	0x53c	; 0x53c <software_reset>
     54e:	08 95       	ret

00000550 <xEventGroupCreate>:
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
}
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	80 e1       	ldi	r24, 0x10	; 16
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
     55c:	ec 01       	movw	r28, r24
     55e:	00 97       	sbiw	r24, 0x00	; 0
     560:	41 f0       	breq	.+16     	; 0x572 <xEventGroupCreate+0x22>
     562:	fc 01       	movw	r30, r24
     564:	11 92       	st	Z+, r1
     566:	11 92       	st	Z+, r1
     568:	11 92       	st	Z+, r1
     56a:	11 92       	st	Z+, r1
     56c:	cf 01       	movw	r24, r30
     56e:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
     572:	ce 01       	movw	r24, r28
     574:	df 91       	pop	r29
     576:	cf 91       	pop	r28
     578:	08 95       	ret

0000057a <xEventGroupWaitBits>:
     57a:	2f 92       	push	r2
     57c:	3f 92       	push	r3
     57e:	4f 92       	push	r4
     580:	5f 92       	push	r5
     582:	6f 92       	push	r6
     584:	7f 92       	push	r7
     586:	8f 92       	push	r8
     588:	9f 92       	push	r9
     58a:	af 92       	push	r10
     58c:	bf 92       	push	r11
     58e:	cf 92       	push	r12
     590:	df 92       	push	r13
     592:	ef 92       	push	r14
     594:	ff 92       	push	r15
     596:	0f 93       	push	r16
     598:	1f 93       	push	r17
     59a:	cf 93       	push	r28
     59c:	df 93       	push	r29
     59e:	ec 01       	movw	r28, r24
     5a0:	4a 01       	movw	r8, r20
     5a2:	5b 01       	movw	r10, r22
     5a4:	62 2e       	mov	r6, r18
     5a6:	70 2e       	mov	r7, r16
     5a8:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
     5ac:	28 80       	ld	r2, Y
     5ae:	39 80       	ldd	r3, Y+1	; 0x01
     5b0:	4a 80       	ldd	r4, Y+2	; 0x02
     5b2:	5b 80       	ldd	r5, Y+3	; 0x03
     5b4:	01 11       	cpse	r16, r1
     5b6:	0d c0       	rjmp	.+26     	; 0x5d2 <xEventGroupWaitBits+0x58>
     5b8:	81 e0       	ldi	r24, 0x01	; 1
     5ba:	b2 01       	movw	r22, r4
     5bc:	a1 01       	movw	r20, r2
     5be:	48 21       	and	r20, r8
     5c0:	59 21       	and	r21, r9
     5c2:	6a 21       	and	r22, r10
     5c4:	7b 21       	and	r23, r11
     5c6:	45 2b       	or	r20, r21
     5c8:	46 2b       	or	r20, r22
     5ca:	47 2b       	or	r20, r23
     5cc:	79 f4       	brne	.+30     	; 0x5ec <xEventGroupWaitBits+0x72>
     5ce:	80 e0       	ldi	r24, 0x00	; 0
     5d0:	0d c0       	rjmp	.+26     	; 0x5ec <xEventGroupWaitBits+0x72>
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	b2 01       	movw	r22, r4
     5d6:	a1 01       	movw	r20, r2
     5d8:	48 21       	and	r20, r8
     5da:	59 21       	and	r21, r9
     5dc:	6a 21       	and	r22, r10
     5de:	7b 21       	and	r23, r11
     5e0:	48 15       	cp	r20, r8
     5e2:	59 05       	cpc	r21, r9
     5e4:	6a 05       	cpc	r22, r10
     5e6:	7b 05       	cpc	r23, r11
     5e8:	09 f0       	breq	.+2      	; 0x5ec <xEventGroupWaitBits+0x72>
     5ea:	80 e0       	ldi	r24, 0x00	; 0
     5ec:	88 23       	and	r24, r24
     5ee:	81 f0       	breq	.+32     	; 0x610 <xEventGroupWaitBits+0x96>
     5f0:	66 20       	and	r6, r6
     5f2:	09 f4       	brne	.+2      	; 0x5f6 <xEventGroupWaitBits+0x7c>
     5f4:	70 c0       	rjmp	.+224    	; 0x6d6 <xEventGroupWaitBits+0x15c>
     5f6:	80 94       	com	r8
     5f8:	90 94       	com	r9
     5fa:	a0 94       	com	r10
     5fc:	b0 94       	com	r11
     5fe:	82 20       	and	r8, r2
     600:	93 20       	and	r9, r3
     602:	a4 20       	and	r10, r4
     604:	b5 20       	and	r11, r5
     606:	88 82       	st	Y, r8
     608:	99 82       	std	Y+1, r9	; 0x01
     60a:	aa 82       	std	Y+2, r10	; 0x02
     60c:	bb 82       	std	Y+3, r11	; 0x03
     60e:	63 c0       	rjmp	.+198    	; 0x6d6 <xEventGroupWaitBits+0x15c>
     610:	c1 14       	cp	r12, r1
     612:	d1 04       	cpc	r13, r1
     614:	e1 04       	cpc	r14, r1
     616:	f1 04       	cpc	r15, r1
     618:	09 f4       	brne	.+2      	; 0x61c <xEventGroupWaitBits+0xa2>
     61a:	5d c0       	rjmp	.+186    	; 0x6d6 <xEventGroupWaitBits+0x15c>
     61c:	66 20       	and	r6, r6
     61e:	29 f0       	breq	.+10     	; 0x62a <xEventGroupWaitBits+0xb0>
     620:	40 e0       	ldi	r20, 0x00	; 0
     622:	50 e0       	ldi	r21, 0x00	; 0
     624:	60 e0       	ldi	r22, 0x00	; 0
     626:	71 e0       	ldi	r23, 0x01	; 1
     628:	03 c0       	rjmp	.+6      	; 0x630 <xEventGroupWaitBits+0xb6>
     62a:	40 e0       	ldi	r20, 0x00	; 0
     62c:	50 e0       	ldi	r21, 0x00	; 0
     62e:	ba 01       	movw	r22, r20
     630:	71 10       	cpse	r7, r1
     632:	74 60       	ori	r23, 0x04	; 4
     634:	48 29       	or	r20, r8
     636:	59 29       	or	r21, r9
     638:	6a 29       	or	r22, r10
     63a:	7b 29       	or	r23, r11
     63c:	97 01       	movw	r18, r14
     63e:	86 01       	movw	r16, r12
     640:	ce 01       	movw	r24, r28
     642:	04 96       	adiw	r24, 0x04	; 4
     644:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <vTaskPlaceOnUnorderedEventList>
     648:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
     64c:	81 11       	cpse	r24, r1
     64e:	02 c0       	rjmp	.+4      	; 0x654 <xEventGroupWaitBits+0xda>
     650:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
     654:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <uxTaskResetEventItemValue>
     658:	91 fd       	sbrc	r25, 1
     65a:	39 c0       	rjmp	.+114    	; 0x6ce <xEventGroupWaitBits+0x154>
     65c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     660:	ff 93       	push	r31
     662:	f8 7f       	andi	r31, 0xF8	; 248
     664:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     668:	68 81       	ld	r22, Y
     66a:	79 81       	ldd	r23, Y+1	; 0x01
     66c:	8a 81       	ldd	r24, Y+2	; 0x02
     66e:	9b 81       	ldd	r25, Y+3	; 0x03
     670:	71 10       	cpse	r7, r1
     672:	0d c0       	rjmp	.+26     	; 0x68e <xEventGroupWaitBits+0x114>
     674:	21 e0       	ldi	r18, 0x01	; 1
     676:	75 01       	movw	r14, r10
     678:	64 01       	movw	r12, r8
     67a:	c6 22       	and	r12, r22
     67c:	d7 22       	and	r13, r23
     67e:	e8 22       	and	r14, r24
     680:	f9 22       	and	r15, r25
     682:	cd 28       	or	r12, r13
     684:	ce 28       	or	r12, r14
     686:	cf 28       	or	r12, r15
     688:	79 f4       	brne	.+30     	; 0x6a8 <xEventGroupWaitBits+0x12e>
     68a:	20 e0       	ldi	r18, 0x00	; 0
     68c:	0d c0       	rjmp	.+26     	; 0x6a8 <xEventGroupWaitBits+0x12e>
     68e:	21 e0       	ldi	r18, 0x01	; 1
     690:	75 01       	movw	r14, r10
     692:	64 01       	movw	r12, r8
     694:	c6 22       	and	r12, r22
     696:	d7 22       	and	r13, r23
     698:	e8 22       	and	r14, r24
     69a:	f9 22       	and	r15, r25
     69c:	c8 14       	cp	r12, r8
     69e:	d9 04       	cpc	r13, r9
     6a0:	ea 04       	cpc	r14, r10
     6a2:	fb 04       	cpc	r15, r11
     6a4:	09 f0       	breq	.+2      	; 0x6a8 <xEventGroupWaitBits+0x12e>
     6a6:	20 e0       	ldi	r18, 0x00	; 0
     6a8:	22 23       	and	r18, r18
     6aa:	71 f0       	breq	.+28     	; 0x6c8 <xEventGroupWaitBits+0x14e>
     6ac:	66 20       	and	r6, r6
     6ae:	61 f0       	breq	.+24     	; 0x6c8 <xEventGroupWaitBits+0x14e>
     6b0:	80 94       	com	r8
     6b2:	90 94       	com	r9
     6b4:	a0 94       	com	r10
     6b6:	b0 94       	com	r11
     6b8:	86 22       	and	r8, r22
     6ba:	97 22       	and	r9, r23
     6bc:	a8 22       	and	r10, r24
     6be:	b9 22       	and	r11, r25
     6c0:	88 82       	st	Y, r8
     6c2:	99 82       	std	Y+1, r9	; 0x01
     6c4:	aa 82       	std	Y+2, r10	; 0x02
     6c6:	bb 82       	std	Y+3, r11	; 0x03
     6c8:	ff 91       	pop	r31
     6ca:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     6ce:	1b 01       	movw	r2, r22
     6d0:	2c 01       	movw	r4, r24
     6d2:	55 24       	eor	r5, r5
     6d4:	02 c0       	rjmp	.+4      	; 0x6da <xEventGroupWaitBits+0x160>
     6d6:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
     6da:	c2 01       	movw	r24, r4
     6dc:	b1 01       	movw	r22, r2
     6de:	df 91       	pop	r29
     6e0:	cf 91       	pop	r28
     6e2:	1f 91       	pop	r17
     6e4:	0f 91       	pop	r16
     6e6:	ff 90       	pop	r15
     6e8:	ef 90       	pop	r14
     6ea:	df 90       	pop	r13
     6ec:	cf 90       	pop	r12
     6ee:	bf 90       	pop	r11
     6f0:	af 90       	pop	r10
     6f2:	9f 90       	pop	r9
     6f4:	8f 90       	pop	r8
     6f6:	7f 90       	pop	r7
     6f8:	6f 90       	pop	r6
     6fa:	5f 90       	pop	r5
     6fc:	4f 90       	pop	r4
     6fe:	3f 90       	pop	r3
     700:	2f 90       	pop	r2
     702:	08 95       	ret

00000704 <xEventGroupClearBits>:
     704:	0f 93       	push	r16
     706:	1f 93       	push	r17
     708:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     70c:	ff 93       	push	r31
     70e:	f8 7f       	andi	r31, 0xF8	; 248
     710:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     714:	fc 01       	movw	r30, r24
     716:	00 81       	ld	r16, Z
     718:	11 81       	ldd	r17, Z+1	; 0x01
     71a:	22 81       	ldd	r18, Z+2	; 0x02
     71c:	33 81       	ldd	r19, Z+3	; 0x03
     71e:	40 95       	com	r20
     720:	50 95       	com	r21
     722:	60 95       	com	r22
     724:	70 95       	com	r23
     726:	40 23       	and	r20, r16
     728:	51 23       	and	r21, r17
     72a:	62 23       	and	r22, r18
     72c:	73 23       	and	r23, r19
     72e:	40 83       	st	Z, r20
     730:	51 83       	std	Z+1, r21	; 0x01
     732:	62 83       	std	Z+2, r22	; 0x02
     734:	73 83       	std	Z+3, r23	; 0x03
     736:	ff 91       	pop	r31
     738:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     73c:	c9 01       	movw	r24, r18
     73e:	b8 01       	movw	r22, r16
     740:	1f 91       	pop	r17
     742:	0f 91       	pop	r16
     744:	08 95       	ret

00000746 <xEventGroupSetBits>:
     746:	4f 92       	push	r4
     748:	5f 92       	push	r5
     74a:	6f 92       	push	r6
     74c:	7f 92       	push	r7
     74e:	af 92       	push	r10
     750:	bf 92       	push	r11
     752:	cf 92       	push	r12
     754:	df 92       	push	r13
     756:	ef 92       	push	r14
     758:	ff 92       	push	r15
     75a:	0f 93       	push	r16
     75c:	1f 93       	push	r17
     75e:	cf 93       	push	r28
     760:	df 93       	push	r29
     762:	ec 01       	movw	r28, r24
     764:	6a 01       	movw	r12, r20
     766:	7b 01       	movw	r14, r22
     768:	8c 01       	movw	r16, r24
     76a:	09 5f       	subi	r16, 0xF9	; 249
     76c:	1f 4f       	sbci	r17, 0xFF	; 255
     76e:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
     772:	eb 85       	ldd	r30, Y+11	; 0x0b
     774:	fc 85       	ldd	r31, Y+12	; 0x0c
     776:	88 81       	ld	r24, Y
     778:	99 81       	ldd	r25, Y+1	; 0x01
     77a:	aa 81       	ldd	r26, Y+2	; 0x02
     77c:	bb 81       	ldd	r27, Y+3	; 0x03
     77e:	c8 2a       	or	r12, r24
     780:	d9 2a       	or	r13, r25
     782:	ea 2a       	or	r14, r26
     784:	fb 2a       	or	r15, r27
     786:	c8 82       	st	Y, r12
     788:	d9 82       	std	Y+1, r13	; 0x01
     78a:	ea 82       	std	Y+2, r14	; 0x02
     78c:	fb 82       	std	Y+3, r15	; 0x03
     78e:	0e 17       	cp	r16, r30
     790:	1f 07       	cpc	r17, r31
     792:	09 f4       	brne	.+2      	; 0x796 <xEventGroupSetBits+0x50>
     794:	42 c0       	rjmp	.+132    	; 0x81a <xEventGroupSetBits+0xd4>
     796:	c1 2c       	mov	r12, r1
     798:	d1 2c       	mov	r13, r1
     79a:	76 01       	movw	r14, r12
     79c:	a4 80       	ldd	r10, Z+4	; 0x04
     79e:	b5 80       	ldd	r11, Z+5	; 0x05
     7a0:	80 81       	ld	r24, Z
     7a2:	91 81       	ldd	r25, Z+1	; 0x01
     7a4:	a2 81       	ldd	r26, Z+2	; 0x02
     7a6:	b3 81       	ldd	r27, Z+3	; 0x03
     7a8:	ac 01       	movw	r20, r24
     7aa:	bd 01       	movw	r22, r26
     7ac:	77 27       	eor	r23, r23
     7ae:	b2 fd       	sbrc	r27, 2
     7b0:	0f c0       	rjmp	.+30     	; 0x7d0 <xEventGroupSetBits+0x8a>
     7b2:	48 80       	ld	r4, Y
     7b4:	59 80       	ldd	r5, Y+1	; 0x01
     7b6:	6a 80       	ldd	r6, Y+2	; 0x02
     7b8:	7b 80       	ldd	r7, Y+3	; 0x03
     7ba:	44 22       	and	r4, r20
     7bc:	55 22       	and	r5, r21
     7be:	66 22       	and	r6, r22
     7c0:	77 22       	and	r7, r23
     7c2:	21 e0       	ldi	r18, 0x01	; 1
     7c4:	45 28       	or	r4, r5
     7c6:	46 28       	or	r4, r6
     7c8:	47 28       	or	r4, r7
     7ca:	89 f4       	brne	.+34     	; 0x7ee <xEventGroupSetBits+0xa8>
     7cc:	20 e0       	ldi	r18, 0x00	; 0
     7ce:	0f c0       	rjmp	.+30     	; 0x7ee <xEventGroupSetBits+0xa8>
     7d0:	48 80       	ld	r4, Y
     7d2:	59 80       	ldd	r5, Y+1	; 0x01
     7d4:	6a 80       	ldd	r6, Y+2	; 0x02
     7d6:	7b 80       	ldd	r7, Y+3	; 0x03
     7d8:	44 22       	and	r4, r20
     7da:	55 22       	and	r5, r21
     7dc:	66 22       	and	r6, r22
     7de:	77 22       	and	r7, r23
     7e0:	21 e0       	ldi	r18, 0x01	; 1
     7e2:	44 16       	cp	r4, r20
     7e4:	55 06       	cpc	r5, r21
     7e6:	66 06       	cpc	r6, r22
     7e8:	77 06       	cpc	r7, r23
     7ea:	09 f0       	breq	.+2      	; 0x7ee <xEventGroupSetBits+0xa8>
     7ec:	20 e0       	ldi	r18, 0x00	; 0
     7ee:	22 23       	and	r18, r18
     7f0:	71 f0       	breq	.+28     	; 0x80e <xEventGroupSetBits+0xc8>
     7f2:	b0 ff       	sbrs	r27, 0
     7f4:	04 c0       	rjmp	.+8      	; 0x7fe <xEventGroupSetBits+0xb8>
     7f6:	c4 2a       	or	r12, r20
     7f8:	d5 2a       	or	r13, r21
     7fa:	e6 2a       	or	r14, r22
     7fc:	f7 2a       	or	r15, r23
     7fe:	48 81       	ld	r20, Y
     800:	59 81       	ldd	r21, Y+1	; 0x01
     802:	6a 81       	ldd	r22, Y+2	; 0x02
     804:	7b 81       	ldd	r23, Y+3	; 0x03
     806:	72 60       	ori	r23, 0x02	; 2
     808:	cf 01       	movw	r24, r30
     80a:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <vTaskRemoveFromUnorderedEventList>
     80e:	ea 2d       	mov	r30, r10
     810:	fb 2d       	mov	r31, r11
     812:	0e 17       	cp	r16, r30
     814:	1f 07       	cpc	r17, r31
     816:	11 f6       	brne	.-124    	; 0x79c <xEventGroupSetBits+0x56>
     818:	03 c0       	rjmp	.+6      	; 0x820 <xEventGroupSetBits+0xda>
     81a:	c1 2c       	mov	r12, r1
     81c:	d1 2c       	mov	r13, r1
     81e:	76 01       	movw	r14, r12
     820:	c0 94       	com	r12
     822:	d0 94       	com	r13
     824:	e0 94       	com	r14
     826:	f0 94       	com	r15
     828:	88 81       	ld	r24, Y
     82a:	99 81       	ldd	r25, Y+1	; 0x01
     82c:	aa 81       	ldd	r26, Y+2	; 0x02
     82e:	bb 81       	ldd	r27, Y+3	; 0x03
     830:	c8 22       	and	r12, r24
     832:	d9 22       	and	r13, r25
     834:	ea 22       	and	r14, r26
     836:	fb 22       	and	r15, r27
     838:	c8 82       	st	Y, r12
     83a:	d9 82       	std	Y+1, r13	; 0x01
     83c:	ea 82       	std	Y+2, r14	; 0x02
     83e:	fb 82       	std	Y+3, r15	; 0x03
     840:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
     844:	68 81       	ld	r22, Y
     846:	79 81       	ldd	r23, Y+1	; 0x01
     848:	8a 81       	ldd	r24, Y+2	; 0x02
     84a:	9b 81       	ldd	r25, Y+3	; 0x03
     84c:	df 91       	pop	r29
     84e:	cf 91       	pop	r28
     850:	1f 91       	pop	r17
     852:	0f 91       	pop	r16
     854:	ff 90       	pop	r15
     856:	ef 90       	pop	r14
     858:	df 90       	pop	r13
     85a:	cf 90       	pop	r12
     85c:	bf 90       	pop	r11
     85e:	af 90       	pop	r10
     860:	7f 90       	pop	r7
     862:	6f 90       	pop	r6
     864:	5f 90       	pop	r5
     866:	4f 90       	pop	r4
     868:	08 95       	ret

0000086a <vEventGroupSetBitsCallback>:
     86a:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
     86e:	08 95       	ret

00000870 <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
     870:	0f 93       	push	r16
     872:	1f 93       	push	r17
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
     874:	89 01       	movw	r16, r18
     876:	9a 01       	movw	r18, r20
     878:	ab 01       	movw	r20, r22
     87a:	bc 01       	movw	r22, r24
     87c:	85 e3       	ldi	r24, 0x35	; 53
     87e:	94 e0       	ldi	r25, 0x04	; 4
     880:	0e 94 05 12 	call	0x240a	; 0x240a <xTimerPendFunctionCallFromISR>

		return xReturn;
	}
     884:	1f 91       	pop	r17
     886:	0f 91       	pop	r16
     888:	08 95       	ret

0000088a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
     88e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     890:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     894:	20 91 92 20 	lds	r18, 0x2092	; 0x802092 <__data_end>
     898:	30 91 93 20 	lds	r19, 0x2093	; 0x802093 <__data_end+0x1>
     89c:	c9 01       	movw	r24, r18
     89e:	8c 0f       	add	r24, r28
     8a0:	9d 1f       	adc	r25, r29
     8a2:	88 3b       	cpi	r24, 0xB8	; 184
     8a4:	4b e0       	ldi	r20, 0x0B	; 11
     8a6:	94 07       	cpc	r25, r20
     8a8:	58 f4       	brcc	.+22     	; 0x8c0 <pvPortMalloc+0x36>
     8aa:	28 17       	cp	r18, r24
     8ac:	39 07       	cpc	r19, r25
     8ae:	58 f4       	brcc	.+22     	; 0x8c6 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     8b0:	e9 01       	movw	r28, r18
     8b2:	cc 56       	subi	r28, 0x6C	; 108
     8b4:	df 4d       	sbci	r29, 0xDF	; 223
			xNextFreeByte += xWantedSize;			
     8b6:	80 93 92 20 	sts	0x2092, r24	; 0x802092 <__data_end>
     8ba:	90 93 93 20 	sts	0x2093, r25	; 0x802093 <__data_end+0x1>
     8be:	05 c0       	rjmp	.+10     	; 0x8ca <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     8c0:	c0 e0       	ldi	r28, 0x00	; 0
     8c2:	d0 e0       	ldi	r29, 0x00	; 0
     8c4:	02 c0       	rjmp	.+4      	; 0x8ca <pvPortMalloc+0x40>
     8c6:	c0 e0       	ldi	r28, 0x00	; 0
     8c8:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     8ca:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     8ce:	ce 01       	movw	r24, r28
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	08 95       	ret

000008d6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     8d6:	08 95       	ret

000008d8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     8d8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8da:	03 96       	adiw	r24, 0x03	; 3
     8dc:	81 83       	std	Z+1, r24	; 0x01
     8de:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8e0:	4f ef       	ldi	r20, 0xFF	; 255
     8e2:	5f ef       	ldi	r21, 0xFF	; 255
     8e4:	ba 01       	movw	r22, r20
     8e6:	43 83       	std	Z+3, r20	; 0x03
     8e8:	54 83       	std	Z+4, r21	; 0x04
     8ea:	65 83       	std	Z+5, r22	; 0x05
     8ec:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8ee:	87 83       	std	Z+7, r24	; 0x07
     8f0:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8f2:	81 87       	std	Z+9, r24	; 0x09
     8f4:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8f6:	10 82       	st	Z, r1
     8f8:	08 95       	ret

000008fa <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8fa:	fc 01       	movw	r30, r24
     8fc:	12 86       	std	Z+10, r1	; 0x0a
     8fe:	13 86       	std	Z+11, r1	; 0x0b
     900:	08 95       	ret

00000902 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
     906:	9c 01       	movw	r18, r24
     908:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     90a:	dc 01       	movw	r26, r24
     90c:	11 96       	adiw	r26, 0x01	; 1
     90e:	cd 91       	ld	r28, X+
     910:	dc 91       	ld	r29, X
     912:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     914:	c4 83       	std	Z+4, r28	; 0x04
     916:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     918:	8e 81       	ldd	r24, Y+6	; 0x06
     91a:	9f 81       	ldd	r25, Y+7	; 0x07
     91c:	86 83       	std	Z+6, r24	; 0x06
     91e:	97 83       	std	Z+7, r25	; 0x07

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     920:	8e 81       	ldd	r24, Y+6	; 0x06
     922:	9f 81       	ldd	r25, Y+7	; 0x07
     924:	dc 01       	movw	r26, r24
     926:	14 96       	adiw	r26, 0x04	; 4
     928:	6d 93       	st	X+, r22
     92a:	7c 93       	st	X, r23
     92c:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxPrevious = pxNewListItem;
     92e:	6e 83       	std	Y+6, r22	; 0x06
     930:	7f 83       	std	Y+7, r23	; 0x07

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     932:	22 87       	std	Z+10, r18	; 0x0a
     934:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     936:	f9 01       	movw	r30, r18
     938:	80 81       	ld	r24, Z
     93a:	8f 5f       	subi	r24, 0xFF	; 255
     93c:	80 83       	st	Z, r24
}
     93e:	df 91       	pop	r29
     940:	cf 91       	pop	r28
     942:	08 95       	ret

00000944 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     944:	0f 93       	push	r16
     946:	1f 93       	push	r17
     948:	cf 93       	push	r28
     94a:	df 93       	push	r29
     94c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     94e:	08 81       	ld	r16, Y
     950:	19 81       	ldd	r17, Y+1	; 0x01
     952:	2a 81       	ldd	r18, Y+2	; 0x02
     954:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     956:	0f 3f       	cpi	r16, 0xFF	; 255
     958:	4f ef       	ldi	r20, 0xFF	; 255
     95a:	14 07       	cpc	r17, r20
     95c:	24 07       	cpc	r18, r20
     95e:	34 07       	cpc	r19, r20
     960:	21 f4       	brne	.+8      	; 0x96a <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     962:	fc 01       	movw	r30, r24
     964:	a1 85       	ldd	r26, Z+9	; 0x09
     966:	b2 85       	ldd	r27, Z+10	; 0x0a
     968:	11 c0       	rjmp	.+34     	; 0x98c <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     96a:	dc 01       	movw	r26, r24
     96c:	13 96       	adiw	r26, 0x03	; 3
     96e:	01 c0       	rjmp	.+2      	; 0x972 <vListInsert+0x2e>
     970:	df 01       	movw	r26, r30
     972:	14 96       	adiw	r26, 0x04	; 4
     974:	ed 91       	ld	r30, X+
     976:	fc 91       	ld	r31, X
     978:	15 97       	sbiw	r26, 0x05	; 5
     97a:	40 81       	ld	r20, Z
     97c:	51 81       	ldd	r21, Z+1	; 0x01
     97e:	62 81       	ldd	r22, Z+2	; 0x02
     980:	73 81       	ldd	r23, Z+3	; 0x03
     982:	04 17       	cp	r16, r20
     984:	15 07       	cpc	r17, r21
     986:	26 07       	cpc	r18, r22
     988:	37 07       	cpc	r19, r23
     98a:	90 f7       	brcc	.-28     	; 0x970 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     98c:	14 96       	adiw	r26, 0x04	; 4
     98e:	ed 91       	ld	r30, X+
     990:	fc 91       	ld	r31, X
     992:	15 97       	sbiw	r26, 0x05	; 5
     994:	ec 83       	std	Y+4, r30	; 0x04
     996:	fd 83       	std	Y+5, r31	; 0x05
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     998:	c6 83       	std	Z+6, r28	; 0x06
     99a:	d7 83       	std	Z+7, r29	; 0x07
	pxNewListItem->pxPrevious = pxIterator;
     99c:	ae 83       	std	Y+6, r26	; 0x06
     99e:	bf 83       	std	Y+7, r27	; 0x07
	pxIterator->pxNext = pxNewListItem;
     9a0:	14 96       	adiw	r26, 0x04	; 4
     9a2:	cd 93       	st	X+, r28
     9a4:	dc 93       	st	X, r29
     9a6:	15 97       	sbiw	r26, 0x05	; 5

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9a8:	8a 87       	std	Y+10, r24	; 0x0a
     9aa:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     9ac:	fc 01       	movw	r30, r24
     9ae:	20 81       	ld	r18, Z
     9b0:	2f 5f       	subi	r18, 0xFF	; 255
     9b2:	20 83       	st	Z, r18
}
     9b4:	df 91       	pop	r29
     9b6:	cf 91       	pop	r28
     9b8:	1f 91       	pop	r17
     9ba:	0f 91       	pop	r16
     9bc:	08 95       	ret

000009be <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
     9c2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     9c4:	a2 85       	ldd	r26, Z+10	; 0x0a
     9c6:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9c8:	c4 81       	ldd	r28, Z+4	; 0x04
     9ca:	d5 81       	ldd	r29, Z+5	; 0x05
     9cc:	86 81       	ldd	r24, Z+6	; 0x06
     9ce:	97 81       	ldd	r25, Z+7	; 0x07
     9d0:	8e 83       	std	Y+6, r24	; 0x06
     9d2:	9f 83       	std	Y+7, r25	; 0x07
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     9d4:	c6 81       	ldd	r28, Z+6	; 0x06
     9d6:	d7 81       	ldd	r29, Z+7	; 0x07
     9d8:	84 81       	ldd	r24, Z+4	; 0x04
     9da:	95 81       	ldd	r25, Z+5	; 0x05
     9dc:	8c 83       	std	Y+4, r24	; 0x04
     9de:	9d 83       	std	Y+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9e0:	11 96       	adiw	r26, 0x01	; 1
     9e2:	8d 91       	ld	r24, X+
     9e4:	9c 91       	ld	r25, X
     9e6:	12 97       	sbiw	r26, 0x02	; 2
     9e8:	e8 17       	cp	r30, r24
     9ea:	f9 07       	cpc	r31, r25
     9ec:	31 f4       	brne	.+12     	; 0x9fa <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9ee:	86 81       	ldd	r24, Z+6	; 0x06
     9f0:	97 81       	ldd	r25, Z+7	; 0x07
     9f2:	11 96       	adiw	r26, 0x01	; 1
     9f4:	8d 93       	st	X+, r24
     9f6:	9c 93       	st	X, r25
     9f8:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9fa:	12 86       	std	Z+10, r1	; 0x0a
     9fc:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     9fe:	8c 91       	ld	r24, X
     a00:	81 50       	subi	r24, 0x01	; 1
     a02:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     a04:	8c 91       	ld	r24, X
}
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	08 95       	ret

00000a0c <_portSetInterruptMaskFromIsr>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a0c:	e0 ea       	ldi	r30, 0xA0	; 160
     a0e:	f0 e0       	ldi	r31, 0x00	; 0
     a10:	82 81       	ldd	r24, Z+2	; 0x02
     a12:	92 81       	ldd	r25, Z+2	; 0x02
     a14:	98 7f       	andi	r25, 0xF8	; 248
     a16:	92 83       	std	Z+2, r25	; 0x02
     a18:	08 95       	ret

00000a1a <pxPortInitialiseStack>:
     a1a:	cf 92       	push	r12
     a1c:	df 92       	push	r13
     a1e:	ef 92       	push	r14
     a20:	ff 92       	push	r15
     a22:	31 e1       	ldi	r19, 0x11	; 17
     a24:	fc 01       	movw	r30, r24
     a26:	30 83       	st	Z, r19
     a28:	31 97       	sbiw	r30, 0x01	; 1
     a2a:	22 e2       	ldi	r18, 0x22	; 34
     a2c:	20 83       	st	Z, r18
     a2e:	31 97       	sbiw	r30, 0x01	; 1
     a30:	a3 e3       	ldi	r26, 0x33	; 51
     a32:	a0 83       	st	Z, r26
     a34:	6b 01       	movw	r12, r22
     a36:	e1 2c       	mov	r14, r1
     a38:	f1 2c       	mov	r15, r1
     a3a:	31 97       	sbiw	r30, 0x01	; 1
     a3c:	60 83       	st	Z, r22
     a3e:	31 97       	sbiw	r30, 0x01	; 1
     a40:	d0 82       	st	Z, r13
     a42:	31 97       	sbiw	r30, 0x01	; 1
     a44:	e0 82       	st	Z, r14
     a46:	31 97       	sbiw	r30, 0x01	; 1
     a48:	61 e3       	ldi	r22, 0x31	; 49
     a4a:	60 83       	st	Z, r22
     a4c:	31 97       	sbiw	r30, 0x01	; 1
     a4e:	60 e8       	ldi	r22, 0x80	; 128
     a50:	60 83       	st	Z, r22
     a52:	31 97       	sbiw	r30, 0x01	; 1
     a54:	67 e8       	ldi	r22, 0x87	; 135
     a56:	60 83       	st	Z, r22
     a58:	31 97       	sbiw	r30, 0x01	; 1
     a5a:	10 82       	st	Z, r1
     a5c:	31 97       	sbiw	r30, 0x01	; 1
     a5e:	10 82       	st	Z, r1
     a60:	31 97       	sbiw	r30, 0x01	; 1
     a62:	62 e0       	ldi	r22, 0x02	; 2
     a64:	60 83       	st	Z, r22
     a66:	31 97       	sbiw	r30, 0x01	; 1
     a68:	63 e0       	ldi	r22, 0x03	; 3
     a6a:	60 83       	st	Z, r22
     a6c:	31 97       	sbiw	r30, 0x01	; 1
     a6e:	64 e0       	ldi	r22, 0x04	; 4
     a70:	60 83       	st	Z, r22
     a72:	31 97       	sbiw	r30, 0x01	; 1
     a74:	65 e0       	ldi	r22, 0x05	; 5
     a76:	60 83       	st	Z, r22
     a78:	31 97       	sbiw	r30, 0x01	; 1
     a7a:	66 e0       	ldi	r22, 0x06	; 6
     a7c:	60 83       	st	Z, r22
     a7e:	31 97       	sbiw	r30, 0x01	; 1
     a80:	67 e0       	ldi	r22, 0x07	; 7
     a82:	60 83       	st	Z, r22
     a84:	31 97       	sbiw	r30, 0x01	; 1
     a86:	68 e0       	ldi	r22, 0x08	; 8
     a88:	60 83       	st	Z, r22
     a8a:	31 97       	sbiw	r30, 0x01	; 1
     a8c:	69 e0       	ldi	r22, 0x09	; 9
     a8e:	60 83       	st	Z, r22
     a90:	31 97       	sbiw	r30, 0x01	; 1
     a92:	60 e1       	ldi	r22, 0x10	; 16
     a94:	60 83       	st	Z, r22
     a96:	31 97       	sbiw	r30, 0x01	; 1
     a98:	30 83       	st	Z, r19
     a9a:	31 97       	sbiw	r30, 0x01	; 1
     a9c:	32 e1       	ldi	r19, 0x12	; 18
     a9e:	30 83       	st	Z, r19
     aa0:	31 97       	sbiw	r30, 0x01	; 1
     aa2:	33 e1       	ldi	r19, 0x13	; 19
     aa4:	30 83       	st	Z, r19
     aa6:	31 97       	sbiw	r30, 0x01	; 1
     aa8:	34 e1       	ldi	r19, 0x14	; 20
     aaa:	30 83       	st	Z, r19
     aac:	31 97       	sbiw	r30, 0x01	; 1
     aae:	35 e1       	ldi	r19, 0x15	; 21
     ab0:	30 83       	st	Z, r19
     ab2:	31 97       	sbiw	r30, 0x01	; 1
     ab4:	36 e1       	ldi	r19, 0x16	; 22
     ab6:	30 83       	st	Z, r19
     ab8:	31 97       	sbiw	r30, 0x01	; 1
     aba:	37 e1       	ldi	r19, 0x17	; 23
     abc:	30 83       	st	Z, r19
     abe:	31 97       	sbiw	r30, 0x01	; 1
     ac0:	38 e1       	ldi	r19, 0x18	; 24
     ac2:	30 83       	st	Z, r19
     ac4:	31 97       	sbiw	r30, 0x01	; 1
     ac6:	39 e1       	ldi	r19, 0x19	; 25
     ac8:	30 83       	st	Z, r19
     aca:	31 97       	sbiw	r30, 0x01	; 1
     acc:	30 e2       	ldi	r19, 0x20	; 32
     ace:	30 83       	st	Z, r19
     ad0:	31 97       	sbiw	r30, 0x01	; 1
     ad2:	31 e2       	ldi	r19, 0x21	; 33
     ad4:	30 83       	st	Z, r19
     ad6:	31 97       	sbiw	r30, 0x01	; 1
     ad8:	20 83       	st	Z, r18
     ada:	31 97       	sbiw	r30, 0x01	; 1
     adc:	23 e2       	ldi	r18, 0x23	; 35
     ade:	20 83       	st	Z, r18
     ae0:	6a 01       	movw	r12, r20
     ae2:	31 97       	sbiw	r30, 0x01	; 1
     ae4:	40 83       	st	Z, r20
     ae6:	31 97       	sbiw	r30, 0x01	; 1
     ae8:	d0 82       	st	Z, r13
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	26 e2       	ldi	r18, 0x26	; 38
     aee:	20 83       	st	Z, r18
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	27 e2       	ldi	r18, 0x27	; 39
     af4:	20 83       	st	Z, r18
     af6:	31 97       	sbiw	r30, 0x01	; 1
     af8:	28 e2       	ldi	r18, 0x28	; 40
     afa:	20 83       	st	Z, r18
     afc:	31 97       	sbiw	r30, 0x01	; 1
     afe:	29 e2       	ldi	r18, 0x29	; 41
     b00:	20 83       	st	Z, r18
     b02:	31 97       	sbiw	r30, 0x01	; 1
     b04:	20 e3       	ldi	r18, 0x30	; 48
     b06:	20 83       	st	Z, r18
     b08:	88 97       	sbiw	r24, 0x28	; 40
     b0a:	ff 90       	pop	r15
     b0c:	ef 90       	pop	r14
     b0e:	df 90       	pop	r13
     b10:	cf 90       	pop	r12
     b12:	08 95       	ret

00000b14 <xPortStartScheduler>:
     b14:	83 ef       	ldi	r24, 0xF3	; 243
     b16:	91 e0       	ldi	r25, 0x01	; 1
     b18:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     b1c:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
     b20:	65 e0       	ldi	r22, 0x05	; 5
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	98 e0       	ldi	r25, 0x08	; 8
     b26:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
     b2a:	61 e0       	ldi	r22, 0x01	; 1
     b2c:	80 e0       	ldi	r24, 0x00	; 0
     b2e:	98 e0       	ldi	r25, 0x08	; 8
     b30:	0e 94 98 02 	call	0x530	; 0x530 <TC0_SetOverflowIntLevel>
     b34:	a0 91 ba 2c 	lds	r26, 0x2CBA	; 0x802cba <pxCurrentTCB>
     b38:	b0 91 bb 2c 	lds	r27, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
     b3c:	0d 90       	ld	r0, X+
     b3e:	0d be       	out	0x3d, r0	; 61
     b40:	0d 90       	ld	r0, X+
     b42:	0e be       	out	0x3e, r0	; 62
     b44:	ef 91       	pop	r30
     b46:	df 91       	pop	r29
     b48:	cf 91       	pop	r28
     b4a:	bf 91       	pop	r27
     b4c:	af 91       	pop	r26
     b4e:	9f 91       	pop	r25
     b50:	8f 91       	pop	r24
     b52:	7f 91       	pop	r23
     b54:	6f 91       	pop	r22
     b56:	5f 91       	pop	r21
     b58:	4f 91       	pop	r20
     b5a:	3f 91       	pop	r19
     b5c:	2f 91       	pop	r18
     b5e:	1f 91       	pop	r17
     b60:	0f 91       	pop	r16
     b62:	ff 90       	pop	r15
     b64:	ef 90       	pop	r14
     b66:	df 90       	pop	r13
     b68:	cf 90       	pop	r12
     b6a:	bf 90       	pop	r11
     b6c:	af 90       	pop	r10
     b6e:	9f 90       	pop	r9
     b70:	8f 90       	pop	r8
     b72:	7f 90       	pop	r7
     b74:	6f 90       	pop	r6
     b76:	5f 90       	pop	r5
     b78:	4f 90       	pop	r4
     b7a:	3f 90       	pop	r3
     b7c:	2f 90       	pop	r2
     b7e:	1f 90       	pop	r1
     b80:	0f 90       	pop	r0
     b82:	ff 91       	pop	r31
     b84:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b88:	ff 91       	pop	r31
     b8a:	ff bf       	out	0x3f, r31	; 63
     b8c:	ff 91       	pop	r31
     b8e:	08 95       	ret
     b90:	81 e0       	ldi	r24, 0x01	; 1
     b92:	08 95       	ret

00000b94 <vPortYield>:
// 
//
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b94:	ff 93       	push	r31
     b96:	ff b7       	in	r31, 0x3f	; 63
     b98:	ff 93       	push	r31
     b9a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b9e:	ff 93       	push	r31
     ba0:	f8 7f       	andi	r31, 0xF8	; 248
     ba2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ba6:	0f 92       	push	r0
     ba8:	1f 92       	push	r1
     baa:	11 24       	eor	r1, r1
     bac:	2f 92       	push	r2
     bae:	3f 92       	push	r3
     bb0:	4f 92       	push	r4
     bb2:	5f 92       	push	r5
     bb4:	6f 92       	push	r6
     bb6:	7f 92       	push	r7
     bb8:	8f 92       	push	r8
     bba:	9f 92       	push	r9
     bbc:	af 92       	push	r10
     bbe:	bf 92       	push	r11
     bc0:	cf 92       	push	r12
     bc2:	df 92       	push	r13
     bc4:	ef 92       	push	r14
     bc6:	ff 92       	push	r15
     bc8:	0f 93       	push	r16
     bca:	1f 93       	push	r17
     bcc:	2f 93       	push	r18
     bce:	3f 93       	push	r19
     bd0:	4f 93       	push	r20
     bd2:	5f 93       	push	r21
     bd4:	6f 93       	push	r22
     bd6:	7f 93       	push	r23
     bd8:	8f 93       	push	r24
     bda:	9f 93       	push	r25
     bdc:	af 93       	push	r26
     bde:	bf 93       	push	r27
     be0:	cf 93       	push	r28
     be2:	df 93       	push	r29
     be4:	ef 93       	push	r30
     be6:	a0 91 ba 2c 	lds	r26, 0x2CBA	; 0x802cba <pxCurrentTCB>
     bea:	b0 91 bb 2c 	lds	r27, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
     bee:	0d b6       	in	r0, 0x3d	; 61
     bf0:	0d 92       	st	X+, r0
     bf2:	0e b6       	in	r0, 0x3e	; 62
     bf4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     bf6:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bfa:	a0 91 ba 2c 	lds	r26, 0x2CBA	; 0x802cba <pxCurrentTCB>
     bfe:	b0 91 bb 2c 	lds	r27, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
     c02:	0d 90       	ld	r0, X+
     c04:	0d be       	out	0x3d, r0	; 61
     c06:	0d 90       	ld	r0, X+
     c08:	0e be       	out	0x3e, r0	; 62
     c0a:	ef 91       	pop	r30
     c0c:	df 91       	pop	r29
     c0e:	cf 91       	pop	r28
     c10:	bf 91       	pop	r27
     c12:	af 91       	pop	r26
     c14:	9f 91       	pop	r25
     c16:	8f 91       	pop	r24
     c18:	7f 91       	pop	r23
     c1a:	6f 91       	pop	r22
     c1c:	5f 91       	pop	r21
     c1e:	4f 91       	pop	r20
     c20:	3f 91       	pop	r19
     c22:	2f 91       	pop	r18
     c24:	1f 91       	pop	r17
     c26:	0f 91       	pop	r16
     c28:	ff 90       	pop	r15
     c2a:	ef 90       	pop	r14
     c2c:	df 90       	pop	r13
     c2e:	cf 90       	pop	r12
     c30:	bf 90       	pop	r11
     c32:	af 90       	pop	r10
     c34:	9f 90       	pop	r9
     c36:	8f 90       	pop	r8
     c38:	7f 90       	pop	r7
     c3a:	6f 90       	pop	r6
     c3c:	5f 90       	pop	r5
     c3e:	4f 90       	pop	r4
     c40:	3f 90       	pop	r3
     c42:	2f 90       	pop	r2
     c44:	1f 90       	pop	r1
     c46:	0f 90       	pop	r0
     c48:	ff 91       	pop	r31
     c4a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     c4e:	ff 91       	pop	r31
     c50:	ff bf       	out	0x3f, r31	; 63
     c52:	ff 91       	pop	r31
	asm volatile ( "ret" );
     c54:	08 95       	ret

00000c56 <portTaskSwitchContext>:
	//-----------------------------------------------------------
	//
	// The task switch is deferred until there is no more nesting.
	//
	void portTaskSwitchContext(signed portBASE_TYPE xSwitchRequired)
	{
     c56:	cf 93       	push	r28
		intTaskSwitchPending |= xSwitchRequired;					
     c58:	90 91 04 3f 	lds	r25, 0x3F04	; 0x803f04 <intTaskSwitchPending>
     c5c:	89 2b       	or	r24, r25
     c5e:	80 93 04 3f 	sts	0x3F04, r24	; 0x803f04 <intTaskSwitchPending>
																
		if(NOT_NESTING() && intTaskSwitchPending)					
     c62:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c66:	91 30       	cpi	r25, 0x01	; 1
     c68:	41 f0       	breq	.+16     	; 0xc7a <portTaskSwitchContext+0x24>
     c6a:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c6e:	92 30       	cpi	r25, 0x02	; 2
     c70:	21 f0       	breq	.+8      	; 0xc7a <portTaskSwitchContext+0x24>
     c72:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c76:	94 30       	cpi	r25, 0x04	; 4
     c78:	59 f4       	brne	.+22     	; 0xc90 <portTaskSwitchContext+0x3a>
     c7a:	88 23       	and	r24, r24
     c7c:	49 f0       	breq	.+18     	; 0xc90 <portTaskSwitchContext+0x3a>
		{															
			register unsigned portBASE_TYPE uxSavedPmicCtrlReg; 				
			extern void vTaskSwitchContext(void);   				
																
			// Critical section used, because vTaskSwitchContext handles FreeRTOS internal data structures.
 			uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR(); 
     c7e:	0e 94 06 05 	call	0xa0c	; 0xa0c <_portSetInterruptMaskFromIsr>
     c82:	c8 2f       	mov	r28, r24
			intTaskSwitchPending = 0;								
     c84:	10 92 04 3f 	sts	0x3F04, r1	; 0x803f04 <intTaskSwitchPending>
			vTaskSwitchContext();                   				
     c88:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <vTaskSwitchContext>
			portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedPmicCtrlReg);
     c8c:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		}                                          					
	}
     c90:	cf 91       	pop	r28
     c92:	08 95       	ret

00000c94 <__vector_14>:
	// the context is saved at the start of vPortYieldFromTick().  The tick
	// count is incremented after the context is saved.
	//
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
     c94:	ff 93       	push	r31
     c96:	ff b7       	in	r31, 0x3f	; 63
     c98:	ff 93       	push	r31
     c9a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     c9e:	ff 93       	push	r31
     ca0:	f8 7f       	andi	r31, 0xF8	; 248
     ca2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ca6:	0f 92       	push	r0
     ca8:	1f 92       	push	r1
     caa:	11 24       	eor	r1, r1
     cac:	2f 92       	push	r2
     cae:	3f 92       	push	r3
     cb0:	4f 92       	push	r4
     cb2:	5f 92       	push	r5
     cb4:	6f 92       	push	r6
     cb6:	7f 92       	push	r7
     cb8:	8f 92       	push	r8
     cba:	9f 92       	push	r9
     cbc:	af 92       	push	r10
     cbe:	bf 92       	push	r11
     cc0:	cf 92       	push	r12
     cc2:	df 92       	push	r13
     cc4:	ef 92       	push	r14
     cc6:	ff 92       	push	r15
     cc8:	0f 93       	push	r16
     cca:	1f 93       	push	r17
     ccc:	2f 93       	push	r18
     cce:	3f 93       	push	r19
     cd0:	4f 93       	push	r20
     cd2:	5f 93       	push	r21
     cd4:	6f 93       	push	r22
     cd6:	7f 93       	push	r23
     cd8:	8f 93       	push	r24
     cda:	9f 93       	push	r25
     cdc:	af 93       	push	r26
     cde:	bf 93       	push	r27
     ce0:	cf 93       	push	r28
     ce2:	df 93       	push	r29
     ce4:	ef 93       	push	r30
     ce6:	a0 91 ba 2c 	lds	r26, 0x2CBA	; 0x802cba <pxCurrentTCB>
     cea:	b0 91 bb 2c 	lds	r27, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
     cee:	0d b6       	in	r0, 0x3d	; 61
     cf0:	0d 92       	st	X+, r0
     cf2:	0e b6       	in	r0, 0x3e	; 62
     cf4:	0d 92       	st	X+, r0
	//
	static void portTaskIncrementTick( void )
	{
		register unsigned portBASE_TYPE uxSavedPmicCtrlReg;

 		uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR();
     cf6:	0e 94 06 05 	call	0xa0c	; 0xa0c <_portSetInterruptMaskFromIsr>
     cfa:	c8 2f       	mov	r28, r24
		xTaskIncrementTick();
     cfc:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <xTaskIncrementTick>
 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedPmicCtrlReg );
     d00:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
		portTaskIncrementTick();
		//always try a task switch, but only if on kernel interrupt level
		portEND_SWITCHING_ISR(pdTRUE); 
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	0e 94 2b 06 	call	0xc56	; 0xc56 <portTaskSwitchContext>
     d0a:	a0 91 ba 2c 	lds	r26, 0x2CBA	; 0x802cba <pxCurrentTCB>
     d0e:	b0 91 bb 2c 	lds	r27, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
     d12:	0d 90       	ld	r0, X+
     d14:	0d be       	out	0x3d, r0	; 61
     d16:	0d 90       	ld	r0, X+
     d18:	0e be       	out	0x3e, r0	; 62
     d1a:	ef 91       	pop	r30
     d1c:	df 91       	pop	r29
     d1e:	cf 91       	pop	r28
     d20:	bf 91       	pop	r27
     d22:	af 91       	pop	r26
     d24:	9f 91       	pop	r25
     d26:	8f 91       	pop	r24
     d28:	7f 91       	pop	r23
     d2a:	6f 91       	pop	r22
     d2c:	5f 91       	pop	r21
     d2e:	4f 91       	pop	r20
     d30:	3f 91       	pop	r19
     d32:	2f 91       	pop	r18
     d34:	1f 91       	pop	r17
     d36:	0f 91       	pop	r16
     d38:	ff 90       	pop	r15
     d3a:	ef 90       	pop	r14
     d3c:	df 90       	pop	r13
     d3e:	cf 90       	pop	r12
     d40:	bf 90       	pop	r11
     d42:	af 90       	pop	r10
     d44:	9f 90       	pop	r9
     d46:	8f 90       	pop	r8
     d48:	7f 90       	pop	r7
     d4a:	6f 90       	pop	r6
     d4c:	5f 90       	pop	r5
     d4e:	4f 90       	pop	r4
     d50:	3f 90       	pop	r3
     d52:	2f 90       	pop	r2
     d54:	1f 90       	pop	r1
     d56:	0f 90       	pop	r0
     d58:	ff 91       	pop	r31
     d5a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d5e:	ff 91       	pop	r31
     d60:	ff bf       	out	0x3f, r31	; 63
     d62:	ff 91       	pop	r31
     d64:	18 95       	reti

00000d66 <prvIsQueueEmpty>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
     d66:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d6a:	ff 93       	push	r31
     d6c:	f8 7f       	andi	r31, 0xF8	; 248
     d6e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d72:	fc 01       	movw	r30, r24
     d74:	96 8d       	ldd	r25, Z+30	; 0x1e
     d76:	ff 91       	pop	r31
     d78:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	91 11       	cpse	r25, r1
     d80:	80 e0       	ldi	r24, 0x00	; 0
     d82:	08 95       	ret

00000d84 <prvIsQueueFull>:
     d84:	dc 01       	movw	r26, r24
     d86:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d8a:	ff 93       	push	r31
     d8c:	f8 7f       	andi	r31, 0xF8	; 248
     d8e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d92:	5e 96       	adiw	r26, 0x1e	; 30
     d94:	9c 91       	ld	r25, X
     d96:	5e 97       	sbiw	r26, 0x1e	; 30
     d98:	ff 91       	pop	r31
     d9a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d9e:	81 e0       	ldi	r24, 0x01	; 1
     da0:	5f 96       	adiw	r26, 0x1f	; 31
     da2:	2c 91       	ld	r18, X
     da4:	29 13       	cpse	r18, r25
     da6:	80 e0       	ldi	r24, 0x00	; 0
     da8:	08 95       	ret

00000daa <prvCopyDataToQueue>:
     daa:	0f 93       	push	r16
     dac:	1f 93       	push	r17
     dae:	cf 93       	push	r28
     db0:	df 93       	push	r29
     db2:	ec 01       	movw	r28, r24
     db4:	04 2f       	mov	r16, r20
     db6:	1e 8d       	ldd	r17, Y+30	; 0x1e
     db8:	48 a1       	ldd	r20, Y+32	; 0x20
     dba:	44 23       	and	r20, r20
     dbc:	b9 f1       	breq	.+110    	; 0xe2c <prvCopyDataToQueue+0x82>
     dbe:	01 11       	cpse	r16, r1
     dc0:	16 c0       	rjmp	.+44     	; 0xdee <prvCopyDataToQueue+0x44>
     dc2:	50 e0       	ldi	r21, 0x00	; 0
     dc4:	8c 81       	ldd	r24, Y+4	; 0x04
     dc6:	9d 81       	ldd	r25, Y+5	; 0x05
     dc8:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <memcpy>
     dcc:	28 a1       	ldd	r18, Y+32	; 0x20
     dce:	8c 81       	ldd	r24, Y+4	; 0x04
     dd0:	9d 81       	ldd	r25, Y+5	; 0x05
     dd2:	82 0f       	add	r24, r18
     dd4:	91 1d       	adc	r25, r1
     dd6:	8c 83       	std	Y+4, r24	; 0x04
     dd8:	9d 83       	std	Y+5, r25	; 0x05
     dda:	2a 81       	ldd	r18, Y+2	; 0x02
     ddc:	3b 81       	ldd	r19, Y+3	; 0x03
     dde:	82 17       	cp	r24, r18
     de0:	93 07       	cpc	r25, r19
     de2:	20 f1       	brcs	.+72     	; 0xe2c <prvCopyDataToQueue+0x82>
     de4:	88 81       	ld	r24, Y
     de6:	99 81       	ldd	r25, Y+1	; 0x01
     de8:	8c 83       	std	Y+4, r24	; 0x04
     dea:	9d 83       	std	Y+5, r25	; 0x05
     dec:	1f c0       	rjmp	.+62     	; 0xe2c <prvCopyDataToQueue+0x82>
     dee:	50 e0       	ldi	r21, 0x00	; 0
     df0:	8e 81       	ldd	r24, Y+6	; 0x06
     df2:	9f 81       	ldd	r25, Y+7	; 0x07
     df4:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <memcpy>
     df8:	88 a1       	ldd	r24, Y+32	; 0x20
     dfa:	90 e0       	ldi	r25, 0x00	; 0
     dfc:	91 95       	neg	r25
     dfe:	81 95       	neg	r24
     e00:	91 09       	sbc	r25, r1
     e02:	2e 81       	ldd	r18, Y+6	; 0x06
     e04:	3f 81       	ldd	r19, Y+7	; 0x07
     e06:	28 0f       	add	r18, r24
     e08:	39 1f       	adc	r19, r25
     e0a:	2e 83       	std	Y+6, r18	; 0x06
     e0c:	3f 83       	std	Y+7, r19	; 0x07
     e0e:	48 81       	ld	r20, Y
     e10:	59 81       	ldd	r21, Y+1	; 0x01
     e12:	24 17       	cp	r18, r20
     e14:	35 07       	cpc	r19, r21
     e16:	30 f4       	brcc	.+12     	; 0xe24 <prvCopyDataToQueue+0x7a>
     e18:	2a 81       	ldd	r18, Y+2	; 0x02
     e1a:	3b 81       	ldd	r19, Y+3	; 0x03
     e1c:	82 0f       	add	r24, r18
     e1e:	93 1f       	adc	r25, r19
     e20:	8e 83       	std	Y+6, r24	; 0x06
     e22:	9f 83       	std	Y+7, r25	; 0x07
     e24:	02 30       	cpi	r16, 0x02	; 2
     e26:	11 f4       	brne	.+4      	; 0xe2c <prvCopyDataToQueue+0x82>
     e28:	11 11       	cpse	r17, r1
     e2a:	11 50       	subi	r17, 0x01	; 1
     e2c:	1f 5f       	subi	r17, 0xFF	; 255
     e2e:	1e 8f       	std	Y+30, r17	; 0x1e
     e30:	80 e0       	ldi	r24, 0x00	; 0
     e32:	df 91       	pop	r29
     e34:	cf 91       	pop	r28
     e36:	1f 91       	pop	r17
     e38:	0f 91       	pop	r16
     e3a:	08 95       	ret

00000e3c <prvCopyDataFromQueue>:
     e3c:	fc 01       	movw	r30, r24
     e3e:	40 a1       	ldd	r20, Z+32	; 0x20
     e40:	44 23       	and	r20, r20
     e42:	a9 f0       	breq	.+42     	; 0xe6e <prvCopyDataFromQueue+0x32>
     e44:	50 e0       	ldi	r21, 0x00	; 0
     e46:	26 81       	ldd	r18, Z+6	; 0x06
     e48:	37 81       	ldd	r19, Z+7	; 0x07
     e4a:	24 0f       	add	r18, r20
     e4c:	35 1f       	adc	r19, r21
     e4e:	26 83       	std	Z+6, r18	; 0x06
     e50:	37 83       	std	Z+7, r19	; 0x07
     e52:	82 81       	ldd	r24, Z+2	; 0x02
     e54:	93 81       	ldd	r25, Z+3	; 0x03
     e56:	28 17       	cp	r18, r24
     e58:	39 07       	cpc	r19, r25
     e5a:	20 f0       	brcs	.+8      	; 0xe64 <prvCopyDataFromQueue+0x28>
     e5c:	80 81       	ld	r24, Z
     e5e:	91 81       	ldd	r25, Z+1	; 0x01
     e60:	86 83       	std	Z+6, r24	; 0x06
     e62:	97 83       	std	Z+7, r25	; 0x07
     e64:	cb 01       	movw	r24, r22
     e66:	66 81       	ldd	r22, Z+6	; 0x06
     e68:	77 81       	ldd	r23, Z+7	; 0x07
     e6a:	0e 94 ec 1c 	call	0x39d8	; 0x39d8 <memcpy>
     e6e:	08 95       	ret

00000e70 <prvUnlockQueue>:
     e70:	ef 92       	push	r14
     e72:	ff 92       	push	r15
     e74:	0f 93       	push	r16
     e76:	1f 93       	push	r17
     e78:	cf 93       	push	r28
     e7a:	8c 01       	movw	r16, r24
     e7c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e80:	ff 93       	push	r31
     e82:	f8 7f       	andi	r31, 0xF8	; 248
     e84:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e88:	fc 01       	movw	r30, r24
     e8a:	c2 a1       	ldd	r28, Z+34	; 0x22
     e8c:	1c 16       	cp	r1, r28
     e8e:	ac f4       	brge	.+42     	; 0xeba <prvUnlockQueue+0x4a>
     e90:	83 89       	ldd	r24, Z+19	; 0x13
     e92:	81 11       	cpse	r24, r1
     e94:	06 c0       	rjmp	.+12     	; 0xea2 <prvUnlockQueue+0x32>
     e96:	11 c0       	rjmp	.+34     	; 0xeba <prvUnlockQueue+0x4a>
     e98:	f8 01       	movw	r30, r16
     e9a:	83 89       	ldd	r24, Z+19	; 0x13
     e9c:	81 11       	cpse	r24, r1
     e9e:	05 c0       	rjmp	.+10     	; 0xeaa <prvUnlockQueue+0x3a>
     ea0:	0c c0       	rjmp	.+24     	; 0xeba <prvUnlockQueue+0x4a>
     ea2:	78 01       	movw	r14, r16
     ea4:	f3 e1       	ldi	r31, 0x13	; 19
     ea6:	ef 0e       	add	r14, r31
     ea8:	f1 1c       	adc	r15, r1
     eaa:	c7 01       	movw	r24, r14
     eac:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
     eb0:	81 11       	cpse	r24, r1
     eb2:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vTaskMissedYield>
     eb6:	c1 50       	subi	r28, 0x01	; 1
     eb8:	79 f7       	brne	.-34     	; 0xe98 <prvUnlockQueue+0x28>
     eba:	8f ef       	ldi	r24, 0xFF	; 255
     ebc:	f8 01       	movw	r30, r16
     ebe:	82 a3       	std	Z+34, r24	; 0x22
     ec0:	ff 91       	pop	r31
     ec2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ec6:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     eca:	ff 93       	push	r31
     ecc:	f8 7f       	andi	r31, 0xF8	; 248
     ece:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ed2:	f8 01       	movw	r30, r16
     ed4:	c1 a1       	ldd	r28, Z+33	; 0x21
     ed6:	1c 16       	cp	r1, r28
     ed8:	ac f4       	brge	.+42     	; 0xf04 <prvUnlockQueue+0x94>
     eda:	80 85       	ldd	r24, Z+8	; 0x08
     edc:	81 11       	cpse	r24, r1
     ede:	06 c0       	rjmp	.+12     	; 0xeec <prvUnlockQueue+0x7c>
     ee0:	11 c0       	rjmp	.+34     	; 0xf04 <prvUnlockQueue+0x94>
     ee2:	f8 01       	movw	r30, r16
     ee4:	80 85       	ldd	r24, Z+8	; 0x08
     ee6:	81 11       	cpse	r24, r1
     ee8:	05 c0       	rjmp	.+10     	; 0xef4 <prvUnlockQueue+0x84>
     eea:	0c c0       	rjmp	.+24     	; 0xf04 <prvUnlockQueue+0x94>
     eec:	78 01       	movw	r14, r16
     eee:	f8 e0       	ldi	r31, 0x08	; 8
     ef0:	ef 0e       	add	r14, r31
     ef2:	f1 1c       	adc	r15, r1
     ef4:	c7 01       	movw	r24, r14
     ef6:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
     efa:	81 11       	cpse	r24, r1
     efc:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <vTaskMissedYield>
     f00:	c1 50       	subi	r28, 0x01	; 1
     f02:	79 f7       	brne	.-34     	; 0xee2 <prvUnlockQueue+0x72>
     f04:	8f ef       	ldi	r24, 0xFF	; 255
     f06:	f8 01       	movw	r30, r16
     f08:	81 a3       	std	Z+33, r24	; 0x21
     f0a:	ff 91       	pop	r31
     f0c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f10:	cf 91       	pop	r28
     f12:	1f 91       	pop	r17
     f14:	0f 91       	pop	r16
     f16:	ff 90       	pop	r15
     f18:	ef 90       	pop	r14
     f1a:	08 95       	ret

00000f1c <xQueueGenericReset>:
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	ec 01       	movw	r28, r24
     f22:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f26:	ff 93       	push	r31
     f28:	f8 7f       	andi	r31, 0xF8	; 248
     f2a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f2e:	48 81       	ld	r20, Y
     f30:	59 81       	ldd	r21, Y+1	; 0x01
     f32:	28 a1       	ldd	r18, Y+32	; 0x20
     f34:	30 e0       	ldi	r19, 0x00	; 0
     f36:	7f 8d       	ldd	r23, Y+31	; 0x1f
     f38:	72 9f       	mul	r23, r18
     f3a:	c0 01       	movw	r24, r0
     f3c:	73 9f       	mul	r23, r19
     f3e:	90 0d       	add	r25, r0
     f40:	11 24       	eor	r1, r1
     f42:	fa 01       	movw	r30, r20
     f44:	e8 0f       	add	r30, r24
     f46:	f9 1f       	adc	r31, r25
     f48:	ea 83       	std	Y+2, r30	; 0x02
     f4a:	fb 83       	std	Y+3, r31	; 0x03
     f4c:	1e 8e       	std	Y+30, r1	; 0x1e
     f4e:	4c 83       	std	Y+4, r20	; 0x04
     f50:	5d 83       	std	Y+5, r21	; 0x05
     f52:	82 1b       	sub	r24, r18
     f54:	93 0b       	sbc	r25, r19
     f56:	84 0f       	add	r24, r20
     f58:	95 1f       	adc	r25, r21
     f5a:	8e 83       	std	Y+6, r24	; 0x06
     f5c:	9f 83       	std	Y+7, r25	; 0x07
     f5e:	8f ef       	ldi	r24, 0xFF	; 255
     f60:	89 a3       	std	Y+33, r24	; 0x21
     f62:	8a a3       	std	Y+34, r24	; 0x22
     f64:	61 11       	cpse	r22, r1
     f66:	0c c0       	rjmp	.+24     	; 0xf80 <xQueueGenericReset+0x64>
     f68:	88 85       	ldd	r24, Y+8	; 0x08
     f6a:	88 23       	and	r24, r24
     f6c:	89 f0       	breq	.+34     	; 0xf90 <xQueueGenericReset+0x74>
     f6e:	ce 01       	movw	r24, r28
     f70:	08 96       	adiw	r24, 0x08	; 8
     f72:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
     f76:	88 23       	and	r24, r24
     f78:	59 f0       	breq	.+22     	; 0xf90 <xQueueGenericReset+0x74>
     f7a:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
     f7e:	08 c0       	rjmp	.+16     	; 0xf90 <xQueueGenericReset+0x74>
     f80:	ce 01       	movw	r24, r28
     f82:	08 96       	adiw	r24, 0x08	; 8
     f84:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
     f88:	ce 01       	movw	r24, r28
     f8a:	43 96       	adiw	r24, 0x13	; 19
     f8c:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
     f90:	ff 91       	pop	r31
     f92:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f96:	81 e0       	ldi	r24, 0x01	; 1
     f98:	df 91       	pop	r29
     f9a:	cf 91       	pop	r28
     f9c:	08 95       	ret

00000f9e <xQueueGenericCreate>:
     f9e:	ff 92       	push	r15
     fa0:	0f 93       	push	r16
     fa2:	1f 93       	push	r17
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	08 2f       	mov	r16, r24
     faa:	16 2f       	mov	r17, r22
     fac:	f4 2e       	mov	r15, r20
     fae:	66 23       	and	r22, r22
     fb0:	c9 f0       	breq	.+50     	; 0xfe4 <xQueueGenericCreate+0x46>
     fb2:	86 9f       	mul	r24, r22
     fb4:	c0 01       	movw	r24, r0
     fb6:	11 24       	eor	r1, r1
     fb8:	85 96       	adiw	r24, 0x25	; 37
     fba:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
     fbe:	ec 01       	movw	r28, r24
     fc0:	00 97       	sbiw	r24, 0x00	; 0
     fc2:	49 f4       	brne	.+18     	; 0xfd6 <xQueueGenericCreate+0x38>
     fc4:	16 c0       	rjmp	.+44     	; 0xff2 <xQueueGenericCreate+0x54>
     fc6:	0f 8f       	std	Y+31, r16	; 0x1f
     fc8:	18 a3       	std	Y+32, r17	; 0x20
     fca:	61 e0       	ldi	r22, 0x01	; 1
     fcc:	ce 01       	movw	r24, r28
     fce:	0e 94 8e 07 	call	0xf1c	; 0xf1c <xQueueGenericReset>
     fd2:	fc a2       	std	Y+36, r15	; 0x24
     fd4:	0e c0       	rjmp	.+28     	; 0xff2 <xQueueGenericCreate+0x54>
     fd6:	85 96       	adiw	r24, 0x25	; 37
     fd8:	88 83       	st	Y, r24
     fda:	99 83       	std	Y+1, r25	; 0x01
     fdc:	f4 cf       	rjmp	.-24     	; 0xfc6 <xQueueGenericCreate+0x28>
     fde:	c8 83       	st	Y, r28
     fe0:	d9 83       	std	Y+1, r29	; 0x01
     fe2:	f1 cf       	rjmp	.-30     	; 0xfc6 <xQueueGenericCreate+0x28>
     fe4:	85 e2       	ldi	r24, 0x25	; 37
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
     fec:	ec 01       	movw	r28, r24
     fee:	89 2b       	or	r24, r25
     ff0:	b1 f7       	brne	.-20     	; 0xfde <xQueueGenericCreate+0x40>
     ff2:	ce 01       	movw	r24, r28
     ff4:	df 91       	pop	r29
     ff6:	cf 91       	pop	r28
     ff8:	1f 91       	pop	r17
     ffa:	0f 91       	pop	r16
     ffc:	ff 90       	pop	r15
     ffe:	08 95       	ret

00001000 <xQueueGenericSend>:
    1000:	af 92       	push	r10
    1002:	bf 92       	push	r11
    1004:	cf 92       	push	r12
    1006:	df 92       	push	r13
    1008:	ef 92       	push	r14
    100a:	ff 92       	push	r15
    100c:	0f 93       	push	r16
    100e:	1f 93       	push	r17
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	cd b7       	in	r28, 0x3d	; 61
    1016:	de b7       	in	r29, 0x3e	; 62
    1018:	29 97       	sbiw	r28, 0x09	; 9
    101a:	cd bf       	out	0x3d, r28	; 61
    101c:	de bf       	out	0x3e, r29	; 62
    101e:	7c 01       	movw	r14, r24
    1020:	5b 01       	movw	r10, r22
    1022:	2e 83       	std	Y+6, r18	; 0x06
    1024:	3f 83       	std	Y+7, r19	; 0x07
    1026:	48 87       	std	Y+8, r20	; 0x08
    1028:	59 87       	std	Y+9, r21	; 0x09
    102a:	10 e0       	ldi	r17, 0x00	; 0
    102c:	6c 01       	movw	r12, r24
    102e:	88 e0       	ldi	r24, 0x08	; 8
    1030:	c8 0e       	add	r12, r24
    1032:	d1 1c       	adc	r13, r1
    1034:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1038:	ff 93       	push	r31
    103a:	f8 7f       	andi	r31, 0xF8	; 248
    103c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1040:	f7 01       	movw	r30, r14
    1042:	96 8d       	ldd	r25, Z+30	; 0x1e
    1044:	87 8d       	ldd	r24, Z+31	; 0x1f
    1046:	98 17       	cp	r25, r24
    1048:	10 f0       	brcs	.+4      	; 0x104e <xQueueGenericSend+0x4e>
    104a:	02 30       	cpi	r16, 0x02	; 2
    104c:	d1 f4       	brne	.+52     	; 0x1082 <xQueueGenericSend+0x82>
    104e:	40 2f       	mov	r20, r16
    1050:	b5 01       	movw	r22, r10
    1052:	c7 01       	movw	r24, r14
    1054:	0e 94 d5 06 	call	0xdaa	; 0xdaa <prvCopyDataToQueue>
    1058:	f7 01       	movw	r30, r14
    105a:	93 89       	ldd	r25, Z+19	; 0x13
    105c:	99 23       	and	r25, r25
    105e:	49 f0       	breq	.+18     	; 0x1072 <xQueueGenericSend+0x72>
    1060:	c7 01       	movw	r24, r14
    1062:	43 96       	adiw	r24, 0x13	; 19
    1064:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
    1068:	88 23       	and	r24, r24
    106a:	31 f0       	breq	.+12     	; 0x1078 <xQueueGenericSend+0x78>
    106c:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1070:	03 c0       	rjmp	.+6      	; 0x1078 <xQueueGenericSend+0x78>
    1072:	81 11       	cpse	r24, r1
    1074:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1078:	ff 91       	pop	r31
    107a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	57 c0       	rjmp	.+174    	; 0x1130 <xQueueGenericSend+0x130>
    1082:	8e 81       	ldd	r24, Y+6	; 0x06
    1084:	9f 81       	ldd	r25, Y+7	; 0x07
    1086:	a8 85       	ldd	r26, Y+8	; 0x08
    1088:	b9 85       	ldd	r27, Y+9	; 0x09
    108a:	89 2b       	or	r24, r25
    108c:	8a 2b       	or	r24, r26
    108e:	8b 2b       	or	r24, r27
    1090:	29 f4       	brne	.+10     	; 0x109c <xQueueGenericSend+0x9c>
    1092:	ff 91       	pop	r31
    1094:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1098:	80 e0       	ldi	r24, 0x00	; 0
    109a:	4a c0       	rjmp	.+148    	; 0x1130 <xQueueGenericSend+0x130>
    109c:	11 11       	cpse	r17, r1
    109e:	05 c0       	rjmp	.+10     	; 0x10aa <xQueueGenericSend+0xaa>
    10a0:	ce 01       	movw	r24, r28
    10a2:	01 96       	adiw	r24, 0x01	; 1
    10a4:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskInternalSetTimeOutState>
    10a8:	11 e0       	ldi	r17, 0x01	; 1
    10aa:	ff 91       	pop	r31
    10ac:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10b0:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    10b4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10b8:	ff 93       	push	r31
    10ba:	f8 7f       	andi	r31, 0xF8	; 248
    10bc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10c0:	f7 01       	movw	r30, r14
    10c2:	81 a1       	ldd	r24, Z+33	; 0x21
    10c4:	8f 3f       	cpi	r24, 0xFF	; 255
    10c6:	09 f4       	brne	.+2      	; 0x10ca <xQueueGenericSend+0xca>
    10c8:	11 a2       	std	Z+33, r1	; 0x21
    10ca:	f7 01       	movw	r30, r14
    10cc:	82 a1       	ldd	r24, Z+34	; 0x22
    10ce:	8f 3f       	cpi	r24, 0xFF	; 255
    10d0:	09 f4       	brne	.+2      	; 0x10d4 <xQueueGenericSend+0xd4>
    10d2:	12 a2       	std	Z+34, r1	; 0x22
    10d4:	ff 91       	pop	r31
    10d6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10da:	be 01       	movw	r22, r28
    10dc:	6a 5f       	subi	r22, 0xFA	; 250
    10de:	7f 4f       	sbci	r23, 0xFF	; 255
    10e0:	ce 01       	movw	r24, r28
    10e2:	01 96       	adiw	r24, 0x01	; 1
    10e4:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <xTaskCheckForTimeOut>
    10e8:	81 11       	cpse	r24, r1
    10ea:	1c c0       	rjmp	.+56     	; 0x1124 <xQueueGenericSend+0x124>
    10ec:	c7 01       	movw	r24, r14
    10ee:	0e 94 c2 06 	call	0xd84	; 0xd84 <prvIsQueueFull>
    10f2:	88 23       	and	r24, r24
    10f4:	89 f0       	breq	.+34     	; 0x1118 <xQueueGenericSend+0x118>
    10f6:	4e 81       	ldd	r20, Y+6	; 0x06
    10f8:	5f 81       	ldd	r21, Y+7	; 0x07
    10fa:	68 85       	ldd	r22, Y+8	; 0x08
    10fc:	79 85       	ldd	r23, Y+9	; 0x09
    10fe:	c6 01       	movw	r24, r12
    1100:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <vTaskPlaceOnEventList>
    1104:	c7 01       	movw	r24, r14
    1106:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    110a:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    110e:	81 11       	cpse	r24, r1
    1110:	91 cf       	rjmp	.-222    	; 0x1034 <xQueueGenericSend+0x34>
    1112:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1116:	8e cf       	rjmp	.-228    	; 0x1034 <xQueueGenericSend+0x34>
    1118:	c7 01       	movw	r24, r14
    111a:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    111e:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    1122:	88 cf       	rjmp	.-240    	; 0x1034 <xQueueGenericSend+0x34>
    1124:	c7 01       	movw	r24, r14
    1126:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    112a:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    112e:	80 e0       	ldi	r24, 0x00	; 0
    1130:	29 96       	adiw	r28, 0x09	; 9
    1132:	cd bf       	out	0x3d, r28	; 61
    1134:	de bf       	out	0x3e, r29	; 62
    1136:	df 91       	pop	r29
    1138:	cf 91       	pop	r28
    113a:	1f 91       	pop	r17
    113c:	0f 91       	pop	r16
    113e:	ff 90       	pop	r15
    1140:	ef 90       	pop	r14
    1142:	df 90       	pop	r13
    1144:	cf 90       	pop	r12
    1146:	bf 90       	pop	r11
    1148:	af 90       	pop	r10
    114a:	08 95       	ret

0000114c <xQueueGenericSendFromISR>:
    114c:	af 92       	push	r10
    114e:	bf 92       	push	r11
    1150:	cf 92       	push	r12
    1152:	df 92       	push	r13
    1154:	ff 92       	push	r15
    1156:	0f 93       	push	r16
    1158:	1f 93       	push	r17
    115a:	cf 93       	push	r28
    115c:	df 93       	push	r29
    115e:	ec 01       	movw	r28, r24
    1160:	6b 01       	movw	r12, r22
    1162:	5a 01       	movw	r10, r20
    1164:	02 2f       	mov	r16, r18
    1166:	0e 94 06 05 	call	0xa0c	; 0xa0c <_portSetInterruptMaskFromIsr>
    116a:	f8 2e       	mov	r15, r24
    116c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    116e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1170:	98 17       	cp	r25, r24
    1172:	10 f0       	brcs	.+4      	; 0x1178 <xQueueGenericSendFromISR+0x2c>
    1174:	02 30       	cpi	r16, 0x02	; 2
    1176:	e1 f4       	brne	.+56     	; 0x11b0 <xQueueGenericSendFromISR+0x64>
    1178:	1a a1       	ldd	r17, Y+34	; 0x22
    117a:	40 2f       	mov	r20, r16
    117c:	b6 01       	movw	r22, r12
    117e:	ce 01       	movw	r24, r28
    1180:	0e 94 d5 06 	call	0xdaa	; 0xdaa <prvCopyDataToQueue>
    1184:	1f 3f       	cpi	r17, 0xFF	; 255
    1186:	81 f4       	brne	.+32     	; 0x11a8 <xQueueGenericSendFromISR+0x5c>
    1188:	8b 89       	ldd	r24, Y+19	; 0x13
    118a:	88 23       	and	r24, r24
    118c:	99 f0       	breq	.+38     	; 0x11b4 <xQueueGenericSendFromISR+0x68>
    118e:	ce 01       	movw	r24, r28
    1190:	43 96       	adiw	r24, 0x13	; 19
    1192:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
    1196:	88 23       	and	r24, r24
    1198:	79 f0       	breq	.+30     	; 0x11b8 <xQueueGenericSendFromISR+0x6c>
    119a:	a1 14       	cp	r10, r1
    119c:	b1 04       	cpc	r11, r1
    119e:	71 f0       	breq	.+28     	; 0x11bc <xQueueGenericSendFromISR+0x70>
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	f5 01       	movw	r30, r10
    11a4:	80 83       	st	Z, r24
    11a6:	0b c0       	rjmp	.+22     	; 0x11be <xQueueGenericSendFromISR+0x72>
    11a8:	1f 5f       	subi	r17, 0xFF	; 255
    11aa:	1a a3       	std	Y+34, r17	; 0x22
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	07 c0       	rjmp	.+14     	; 0x11be <xQueueGenericSendFromISR+0x72>
    11b0:	80 e0       	ldi	r24, 0x00	; 0
    11b2:	05 c0       	rjmp	.+10     	; 0x11be <xQueueGenericSendFromISR+0x72>
    11b4:	81 e0       	ldi	r24, 0x01	; 1
    11b6:	03 c0       	rjmp	.+6      	; 0x11be <xQueueGenericSendFromISR+0x72>
    11b8:	81 e0       	ldi	r24, 0x01	; 1
    11ba:	01 c0       	rjmp	.+2      	; 0x11be <xQueueGenericSendFromISR+0x72>
    11bc:	81 e0       	ldi	r24, 0x01	; 1
    11be:	f0 92 a2 00 	sts	0x00A2, r15	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	1f 91       	pop	r17
    11c8:	0f 91       	pop	r16
    11ca:	ff 90       	pop	r15
    11cc:	df 90       	pop	r13
    11ce:	cf 90       	pop	r12
    11d0:	bf 90       	pop	r11
    11d2:	af 90       	pop	r10
    11d4:	08 95       	ret

000011d6 <xQueueReceive>:
    11d6:	af 92       	push	r10
    11d8:	bf 92       	push	r11
    11da:	cf 92       	push	r12
    11dc:	df 92       	push	r13
    11de:	ef 92       	push	r14
    11e0:	ff 92       	push	r15
    11e2:	0f 93       	push	r16
    11e4:	1f 93       	push	r17
    11e6:	cf 93       	push	r28
    11e8:	df 93       	push	r29
    11ea:	cd b7       	in	r28, 0x3d	; 61
    11ec:	de b7       	in	r29, 0x3e	; 62
    11ee:	29 97       	sbiw	r28, 0x09	; 9
    11f0:	cd bf       	out	0x3d, r28	; 61
    11f2:	de bf       	out	0x3e, r29	; 62
    11f4:	8c 01       	movw	r16, r24
    11f6:	5b 01       	movw	r10, r22
    11f8:	2e 83       	std	Y+6, r18	; 0x06
    11fa:	3f 83       	std	Y+7, r19	; 0x07
    11fc:	48 87       	std	Y+8, r20	; 0x08
    11fe:	59 87       	std	Y+9, r21	; 0x09
    1200:	e1 2c       	mov	r14, r1
    1202:	6c 01       	movw	r12, r24
    1204:	83 e1       	ldi	r24, 0x13	; 19
    1206:	c8 0e       	add	r12, r24
    1208:	d1 1c       	adc	r13, r1
    120a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    120e:	ff 93       	push	r31
    1210:	f8 7f       	andi	r31, 0xF8	; 248
    1212:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1216:	f8 01       	movw	r30, r16
    1218:	f6 8c       	ldd	r15, Z+30	; 0x1e
    121a:	ff 20       	and	r15, r15
    121c:	b1 f0       	breq	.+44     	; 0x124a <xQueueReceive+0x74>
    121e:	b5 01       	movw	r22, r10
    1220:	c8 01       	movw	r24, r16
    1222:	0e 94 1e 07 	call	0xe3c	; 0xe3c <prvCopyDataFromQueue>
    1226:	fa 94       	dec	r15
    1228:	f8 01       	movw	r30, r16
    122a:	f6 8e       	std	Z+30, r15	; 0x1e
    122c:	80 85       	ldd	r24, Z+8	; 0x08
    122e:	88 23       	and	r24, r24
    1230:	39 f0       	breq	.+14     	; 0x1240 <xQueueReceive+0x6a>
    1232:	c8 01       	movw	r24, r16
    1234:	08 96       	adiw	r24, 0x08	; 8
    1236:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <xTaskRemoveFromEventList>
    123a:	81 11       	cpse	r24, r1
    123c:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1240:	ff 91       	pop	r31
    1242:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	5e c0       	rjmp	.+188    	; 0x1306 <xQueueReceive+0x130>
    124a:	8e 81       	ldd	r24, Y+6	; 0x06
    124c:	9f 81       	ldd	r25, Y+7	; 0x07
    124e:	a8 85       	ldd	r26, Y+8	; 0x08
    1250:	b9 85       	ldd	r27, Y+9	; 0x09
    1252:	89 2b       	or	r24, r25
    1254:	8a 2b       	or	r24, r26
    1256:	8b 2b       	or	r24, r27
    1258:	29 f4       	brne	.+10     	; 0x1264 <xQueueReceive+0x8e>
    125a:	ff 91       	pop	r31
    125c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1260:	80 e0       	ldi	r24, 0x00	; 0
    1262:	51 c0       	rjmp	.+162    	; 0x1306 <xQueueReceive+0x130>
    1264:	e1 10       	cpse	r14, r1
    1266:	06 c0       	rjmp	.+12     	; 0x1274 <xQueueReceive+0x9e>
    1268:	ce 01       	movw	r24, r28
    126a:	01 96       	adiw	r24, 0x01	; 1
    126c:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskInternalSetTimeOutState>
    1270:	ee 24       	eor	r14, r14
    1272:	e3 94       	inc	r14
    1274:	ff 91       	pop	r31
    1276:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    127a:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    127e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1282:	ff 93       	push	r31
    1284:	f8 7f       	andi	r31, 0xF8	; 248
    1286:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    128a:	f8 01       	movw	r30, r16
    128c:	81 a1       	ldd	r24, Z+33	; 0x21
    128e:	8f 3f       	cpi	r24, 0xFF	; 255
    1290:	09 f4       	brne	.+2      	; 0x1294 <xQueueReceive+0xbe>
    1292:	11 a2       	std	Z+33, r1	; 0x21
    1294:	f8 01       	movw	r30, r16
    1296:	82 a1       	ldd	r24, Z+34	; 0x22
    1298:	8f 3f       	cpi	r24, 0xFF	; 255
    129a:	09 f4       	brne	.+2      	; 0x129e <xQueueReceive+0xc8>
    129c:	12 a2       	std	Z+34, r1	; 0x22
    129e:	ff 91       	pop	r31
    12a0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12a4:	be 01       	movw	r22, r28
    12a6:	6a 5f       	subi	r22, 0xFA	; 250
    12a8:	7f 4f       	sbci	r23, 0xFF	; 255
    12aa:	ce 01       	movw	r24, r28
    12ac:	01 96       	adiw	r24, 0x01	; 1
    12ae:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <xTaskCheckForTimeOut>
    12b2:	81 11       	cpse	r24, r1
    12b4:	1c c0       	rjmp	.+56     	; 0x12ee <xQueueReceive+0x118>
    12b6:	c8 01       	movw	r24, r16
    12b8:	0e 94 b3 06 	call	0xd66	; 0xd66 <prvIsQueueEmpty>
    12bc:	88 23       	and	r24, r24
    12be:	89 f0       	breq	.+34     	; 0x12e2 <xQueueReceive+0x10c>
    12c0:	4e 81       	ldd	r20, Y+6	; 0x06
    12c2:	5f 81       	ldd	r21, Y+7	; 0x07
    12c4:	68 85       	ldd	r22, Y+8	; 0x08
    12c6:	79 85       	ldd	r23, Y+9	; 0x09
    12c8:	c6 01       	movw	r24, r12
    12ca:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <vTaskPlaceOnEventList>
    12ce:	c8 01       	movw	r24, r16
    12d0:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    12d4:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    12d8:	81 11       	cpse	r24, r1
    12da:	97 cf       	rjmp	.-210    	; 0x120a <xQueueReceive+0x34>
    12dc:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    12e0:	94 cf       	rjmp	.-216    	; 0x120a <xQueueReceive+0x34>
    12e2:	c8 01       	movw	r24, r16
    12e4:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    12e8:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    12ec:	8e cf       	rjmp	.-228    	; 0x120a <xQueueReceive+0x34>
    12ee:	c8 01       	movw	r24, r16
    12f0:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
    12f4:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    12f8:	c8 01       	movw	r24, r16
    12fa:	0e 94 b3 06 	call	0xd66	; 0xd66 <prvIsQueueEmpty>
    12fe:	88 23       	and	r24, r24
    1300:	09 f4       	brne	.+2      	; 0x1304 <xQueueReceive+0x12e>
    1302:	83 cf       	rjmp	.-250    	; 0x120a <xQueueReceive+0x34>
    1304:	80 e0       	ldi	r24, 0x00	; 0
    1306:	29 96       	adiw	r28, 0x09	; 9
    1308:	cd bf       	out	0x3d, r28	; 61
    130a:	de bf       	out	0x3e, r29	; 62
    130c:	df 91       	pop	r29
    130e:	cf 91       	pop	r28
    1310:	1f 91       	pop	r17
    1312:	0f 91       	pop	r16
    1314:	ff 90       	pop	r15
    1316:	ef 90       	pop	r14
    1318:	df 90       	pop	r13
    131a:	cf 90       	pop	r12
    131c:	bf 90       	pop	r11
    131e:	af 90       	pop	r10
    1320:	08 95       	ret

00001322 <uxQueueMessagesWaiting>:
    1322:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1326:	ff 93       	push	r31
    1328:	f8 7f       	andi	r31, 0xF8	; 248
    132a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    132e:	fc 01       	movw	r30, r24
    1330:	86 8d       	ldd	r24, Z+30	; 0x1e
    1332:	ff 91       	pop	r31
    1334:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1338:	08 95       	ret

0000133a <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1340:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1344:	ff 93       	push	r31
    1346:	f8 7f       	andi	r31, 0xF8	; 248
    1348:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    134c:	89 a1       	ldd	r24, Y+33	; 0x21
    134e:	8f 3f       	cpi	r24, 0xFF	; 255
    1350:	09 f4       	brne	.+2      	; 0x1354 <vQueueWaitForMessageRestricted+0x1a>
    1352:	19 a2       	std	Y+33, r1	; 0x21
    1354:	8a a1       	ldd	r24, Y+34	; 0x22
    1356:	8f 3f       	cpi	r24, 0xFF	; 255
    1358:	09 f4       	brne	.+2      	; 0x135c <vQueueWaitForMessageRestricted+0x22>
    135a:	1a a2       	std	Y+34, r1	; 0x22
    135c:	ff 91       	pop	r31
    135e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1362:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1364:	81 11       	cpse	r24, r1
    1366:	04 c0       	rjmp	.+8      	; 0x1370 <vQueueWaitForMessageRestricted+0x36>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1368:	ce 01       	movw	r24, r28
    136a:	43 96       	adiw	r24, 0x13	; 19
    136c:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1370:	ce 01       	movw	r24, r28
    1372:	0e 94 38 07 	call	0xe70	; 0xe70 <prvUnlockQueue>
	}
    1376:	df 91       	pop	r29
    1378:	cf 91       	pop	r28
    137a:	08 95       	ret

0000137c <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
    137c:	e0 91 76 2c 	lds	r30, 0x2C76	; 0x802c76 <pxDelayedTaskList>
    1380:	f0 91 77 2c 	lds	r31, 0x2C77	; 0x802c77 <pxDelayedTaskList+0x1>
    1384:	80 81       	ld	r24, Z
    1386:	81 11       	cpse	r24, r1
    1388:	0c c0       	rjmp	.+24     	; 0x13a2 <prvResetNextTaskUnblockTime+0x26>
    138a:	8f ef       	ldi	r24, 0xFF	; 255
    138c:	9f ef       	ldi	r25, 0xFF	; 255
    138e:	dc 01       	movw	r26, r24
    1390:	80 93 4f 2c 	sts	0x2C4F, r24	; 0x802c4f <xNextTaskUnblockTime>
    1394:	90 93 50 2c 	sts	0x2C50, r25	; 0x802c50 <xNextTaskUnblockTime+0x1>
    1398:	a0 93 51 2c 	sts	0x2C51, r26	; 0x802c51 <xNextTaskUnblockTime+0x2>
    139c:	b0 93 52 2c 	sts	0x2C52, r27	; 0x802c52 <xNextTaskUnblockTime+0x3>
    13a0:	08 95       	ret
    13a2:	e0 91 76 2c 	lds	r30, 0x2C76	; 0x802c76 <pxDelayedTaskList>
    13a6:	f0 91 77 2c 	lds	r31, 0x2C77	; 0x802c77 <pxDelayedTaskList+0x1>
    13aa:	07 80       	ldd	r0, Z+7	; 0x07
    13ac:	f0 85       	ldd	r31, Z+8	; 0x08
    13ae:	e0 2d       	mov	r30, r0
    13b0:	00 84       	ldd	r0, Z+8	; 0x08
    13b2:	f1 85       	ldd	r31, Z+9	; 0x09
    13b4:	e0 2d       	mov	r30, r0
    13b6:	82 81       	ldd	r24, Z+2	; 0x02
    13b8:	93 81       	ldd	r25, Z+3	; 0x03
    13ba:	a4 81       	ldd	r26, Z+4	; 0x04
    13bc:	b5 81       	ldd	r27, Z+5	; 0x05
    13be:	80 93 4f 2c 	sts	0x2C4F, r24	; 0x802c4f <xNextTaskUnblockTime>
    13c2:	90 93 50 2c 	sts	0x2C50, r25	; 0x802c50 <xNextTaskUnblockTime+0x1>
    13c6:	a0 93 51 2c 	sts	0x2C51, r26	; 0x802c51 <xNextTaskUnblockTime+0x2>
    13ca:	b0 93 52 2c 	sts	0x2C52, r27	; 0x802c52 <xNextTaskUnblockTime+0x3>
    13ce:	08 95       	ret

000013d0 <prvAddCurrentTaskToDelayedList>:
    13d0:	8f 92       	push	r8
    13d2:	9f 92       	push	r9
    13d4:	af 92       	push	r10
    13d6:	bf 92       	push	r11
    13d8:	cf 92       	push	r12
    13da:	df 92       	push	r13
    13dc:	ef 92       	push	r14
    13de:	ff 92       	push	r15
    13e0:	cf 93       	push	r28
    13e2:	6b 01       	movw	r12, r22
    13e4:	7c 01       	movw	r14, r24
    13e6:	c4 2f       	mov	r28, r20
    13e8:	80 90 59 2c 	lds	r8, 0x2C59	; 0x802c59 <xTickCount>
    13ec:	90 90 5a 2c 	lds	r9, 0x2C5A	; 0x802c5a <xTickCount+0x1>
    13f0:	a0 90 5b 2c 	lds	r10, 0x2C5B	; 0x802c5b <xTickCount+0x2>
    13f4:	b0 90 5c 2c 	lds	r11, 0x2C5C	; 0x802c5c <xTickCount+0x3>
    13f8:	80 91 ba 2c 	lds	r24, 0x2CBA	; 0x802cba <pxCurrentTCB>
    13fc:	90 91 bb 2c 	lds	r25, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1400:	02 96       	adiw	r24, 0x02	; 2
    1402:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1406:	8f ef       	ldi	r24, 0xFF	; 255
    1408:	c8 16       	cp	r12, r24
    140a:	d8 06       	cpc	r13, r24
    140c:	e8 06       	cpc	r14, r24
    140e:	f8 06       	cpc	r15, r24
    1410:	69 f4       	brne	.+26     	; 0x142c <prvAddCurrentTaskToDelayedList+0x5c>
    1412:	cc 23       	and	r28, r28
    1414:	59 f0       	breq	.+22     	; 0x142c <prvAddCurrentTaskToDelayedList+0x5c>
    1416:	60 91 ba 2c 	lds	r22, 0x2CBA	; 0x802cba <pxCurrentTCB>
    141a:	70 91 bb 2c 	lds	r23, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    141e:	6e 5f       	subi	r22, 0xFE	; 254
    1420:	7f 4f       	sbci	r23, 0xFF	; 255
    1422:	8e e5       	ldi	r24, 0x5E	; 94
    1424:	9c e2       	ldi	r25, 0x2C	; 44
    1426:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    142a:	3f c0       	rjmp	.+126    	; 0x14aa <prvAddCurrentTaskToDelayedList+0xda>
    142c:	c8 0c       	add	r12, r8
    142e:	d9 1c       	adc	r13, r9
    1430:	ea 1c       	adc	r14, r10
    1432:	fb 1c       	adc	r15, r11
    1434:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1438:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    143c:	c2 82       	std	Z+2, r12	; 0x02
    143e:	d3 82       	std	Z+3, r13	; 0x03
    1440:	e4 82       	std	Z+4, r14	; 0x04
    1442:	f5 82       	std	Z+5, r15	; 0x05
    1444:	c8 14       	cp	r12, r8
    1446:	d9 04       	cpc	r13, r9
    1448:	ea 04       	cpc	r14, r10
    144a:	fb 04       	cpc	r15, r11
    144c:	68 f4       	brcc	.+26     	; 0x1468 <prvAddCurrentTaskToDelayedList+0x98>
    144e:	60 91 ba 2c 	lds	r22, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1452:	70 91 bb 2c 	lds	r23, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1456:	80 91 74 2c 	lds	r24, 0x2C74	; 0x802c74 <pxOverflowDelayedTaskList>
    145a:	90 91 75 2c 	lds	r25, 0x2C75	; 0x802c75 <pxOverflowDelayedTaskList+0x1>
    145e:	6e 5f       	subi	r22, 0xFE	; 254
    1460:	7f 4f       	sbci	r23, 0xFF	; 255
    1462:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1466:	21 c0       	rjmp	.+66     	; 0x14aa <prvAddCurrentTaskToDelayedList+0xda>
    1468:	60 91 ba 2c 	lds	r22, 0x2CBA	; 0x802cba <pxCurrentTCB>
    146c:	70 91 bb 2c 	lds	r23, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1470:	80 91 76 2c 	lds	r24, 0x2C76	; 0x802c76 <pxDelayedTaskList>
    1474:	90 91 77 2c 	lds	r25, 0x2C77	; 0x802c77 <pxDelayedTaskList+0x1>
    1478:	6e 5f       	subi	r22, 0xFE	; 254
    147a:	7f 4f       	sbci	r23, 0xFF	; 255
    147c:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1480:	80 91 4f 2c 	lds	r24, 0x2C4F	; 0x802c4f <xNextTaskUnblockTime>
    1484:	90 91 50 2c 	lds	r25, 0x2C50	; 0x802c50 <xNextTaskUnblockTime+0x1>
    1488:	a0 91 51 2c 	lds	r26, 0x2C51	; 0x802c51 <xNextTaskUnblockTime+0x2>
    148c:	b0 91 52 2c 	lds	r27, 0x2C52	; 0x802c52 <xNextTaskUnblockTime+0x3>
    1490:	c8 16       	cp	r12, r24
    1492:	d9 06       	cpc	r13, r25
    1494:	ea 06       	cpc	r14, r26
    1496:	fb 06       	cpc	r15, r27
    1498:	40 f4       	brcc	.+16     	; 0x14aa <prvAddCurrentTaskToDelayedList+0xda>
    149a:	c0 92 4f 2c 	sts	0x2C4F, r12	; 0x802c4f <xNextTaskUnblockTime>
    149e:	d0 92 50 2c 	sts	0x2C50, r13	; 0x802c50 <xNextTaskUnblockTime+0x1>
    14a2:	e0 92 51 2c 	sts	0x2C51, r14	; 0x802c51 <xNextTaskUnblockTime+0x2>
    14a6:	f0 92 52 2c 	sts	0x2C52, r15	; 0x802c52 <xNextTaskUnblockTime+0x3>
    14aa:	cf 91       	pop	r28
    14ac:	ff 90       	pop	r15
    14ae:	ef 90       	pop	r14
    14b0:	df 90       	pop	r13
    14b2:	cf 90       	pop	r12
    14b4:	bf 90       	pop	r11
    14b6:	af 90       	pop	r10
    14b8:	9f 90       	pop	r9
    14ba:	8f 90       	pop	r8
    14bc:	08 95       	ret

000014be <prvIdleTask>:
    14be:	ce e8       	ldi	r28, 0x8E	; 142
    14c0:	dc e2       	ldi	r29, 0x2C	; 44
    14c2:	88 81       	ld	r24, Y
    14c4:	82 30       	cpi	r24, 0x02	; 2
    14c6:	10 f0       	brcs	.+4      	; 0x14cc <prvIdleTask+0xe>
    14c8:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    14cc:	0e 94 34 13 	call	0x2668	; 0x2668 <vApplicationIdleHook>
    14d0:	f8 cf       	rjmp	.-16     	; 0x14c2 <prvIdleTask+0x4>

000014d2 <xTaskCreate>:
    14d2:	4f 92       	push	r4
    14d4:	5f 92       	push	r5
    14d6:	6f 92       	push	r6
    14d8:	7f 92       	push	r7
    14da:	8f 92       	push	r8
    14dc:	9f 92       	push	r9
    14de:	af 92       	push	r10
    14e0:	bf 92       	push	r11
    14e2:	cf 92       	push	r12
    14e4:	df 92       	push	r13
    14e6:	ef 92       	push	r14
    14e8:	ff 92       	push	r15
    14ea:	0f 93       	push	r16
    14ec:	cf 93       	push	r28
    14ee:	df 93       	push	r29
    14f0:	4c 01       	movw	r8, r24
    14f2:	6b 01       	movw	r12, r22
    14f4:	5a 01       	movw	r10, r20
    14f6:	29 01       	movw	r4, r18
    14f8:	ca 01       	movw	r24, r20
    14fa:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
    14fe:	3c 01       	movw	r6, r24
    1500:	89 2b       	or	r24, r25
    1502:	09 f4       	brne	.+2      	; 0x1506 <xTaskCreate+0x34>
    1504:	ea c0       	rjmp	.+468    	; 0x16da <xTaskCreate+0x208>
    1506:	8c e2       	ldi	r24, 0x2C	; 44
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
    150e:	ec 01       	movw	r28, r24
    1510:	89 2b       	or	r24, r25
    1512:	b1 f0       	breq	.+44     	; 0x1540 <xTaskCreate+0x6e>
    1514:	6b 8e       	std	Y+27, r6	; 0x1b
    1516:	7c 8e       	std	Y+28, r7	; 0x1c
    1518:	a5 01       	movw	r20, r10
    151a:	65 ea       	ldi	r22, 0xA5	; 165
    151c:	70 e0       	ldi	r23, 0x00	; 0
    151e:	c3 01       	movw	r24, r6
    1520:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <memset>
    1524:	21 e0       	ldi	r18, 0x01	; 1
    1526:	a2 1a       	sub	r10, r18
    1528:	b1 08       	sbc	r11, r1
    152a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    152c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    152e:	a8 0e       	add	r10, r24
    1530:	b9 1e       	adc	r11, r25
    1532:	d6 01       	movw	r26, r12
    1534:	8c 91       	ld	r24, X
    1536:	8d 8f       	std	Y+29, r24	; 0x1d
    1538:	8c 91       	ld	r24, X
    153a:	81 11       	cpse	r24, r1
    153c:	05 c0       	rjmp	.+10     	; 0x1548 <xTaskCreate+0x76>
    153e:	18 c0       	rjmp	.+48     	; 0x1570 <xTaskCreate+0x9e>
    1540:	c3 01       	movw	r24, r6
    1542:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortFree>
    1546:	c9 c0       	rjmp	.+402    	; 0x16da <xTaskCreate+0x208>
    1548:	ae 01       	movw	r20, r28
    154a:	42 5e       	subi	r20, 0xE2	; 226
    154c:	5f 4f       	sbci	r21, 0xFF	; 255
    154e:	f6 01       	movw	r30, r12
    1550:	31 96       	adiw	r30, 0x01	; 1
    1552:	b8 e0       	ldi	r27, 0x08	; 8
    1554:	cb 0e       	add	r12, r27
    1556:	d1 1c       	adc	r13, r1
    1558:	cf 01       	movw	r24, r30
    155a:	21 91       	ld	r18, Z+
    155c:	da 01       	movw	r26, r20
    155e:	2d 93       	st	X+, r18
    1560:	ad 01       	movw	r20, r26
    1562:	dc 01       	movw	r26, r24
    1564:	8c 91       	ld	r24, X
    1566:	88 23       	and	r24, r24
    1568:	19 f0       	breq	.+6      	; 0x1570 <xTaskCreate+0x9e>
    156a:	ec 15       	cp	r30, r12
    156c:	fd 05       	cpc	r31, r13
    156e:	a1 f7       	brne	.-24     	; 0x1558 <xTaskCreate+0x86>
    1570:	1c a2       	std	Y+36, r1	; 0x24
    1572:	04 30       	cpi	r16, 0x04	; 4
    1574:	08 f0       	brcs	.+2      	; 0x1578 <xTaskCreate+0xa6>
    1576:	03 e0       	ldi	r16, 0x03	; 3
    1578:	0a 8f       	std	Y+26, r16	; 0x1a
    157a:	6e 01       	movw	r12, r28
    157c:	b2 e0       	ldi	r27, 0x02	; 2
    157e:	cb 0e       	add	r12, r27
    1580:	d1 1c       	adc	r13, r1
    1582:	c6 01       	movw	r24, r12
    1584:	0e 94 7d 04 	call	0x8fa	; 0x8fa <vListInitialiseItem>
    1588:	ce 01       	movw	r24, r28
    158a:	0e 96       	adiw	r24, 0x0e	; 14
    158c:	0e 94 7d 04 	call	0x8fa	; 0x8fa <vListInitialiseItem>
    1590:	ca 87       	std	Y+10, r28	; 0x0a
    1592:	db 87       	std	Y+11, r29	; 0x0b
    1594:	84 e0       	ldi	r24, 0x04	; 4
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	a0 e0       	ldi	r26, 0x00	; 0
    159a:	b0 e0       	ldi	r27, 0x00	; 0
    159c:	80 1b       	sub	r24, r16
    159e:	91 09       	sbc	r25, r1
    15a0:	a1 09       	sbc	r26, r1
    15a2:	b1 09       	sbc	r27, r1
    15a4:	8e 87       	std	Y+14, r24	; 0x0e
    15a6:	9f 87       	std	Y+15, r25	; 0x0f
    15a8:	a8 8b       	std	Y+16, r26	; 0x10
    15aa:	b9 8b       	std	Y+17, r27	; 0x11
    15ac:	ce 8b       	std	Y+22, r28	; 0x16
    15ae:	df 8b       	std	Y+23, r29	; 0x17
    15b0:	1f a2       	std	Y+39, r1	; 0x27
    15b2:	18 a6       	std	Y+40, r1	; 0x28
    15b4:	19 a6       	std	Y+41, r1	; 0x29
    15b6:	1a a6       	std	Y+42, r1	; 0x2a
    15b8:	1b a6       	std	Y+43, r1	; 0x2b
    15ba:	a2 01       	movw	r20, r4
    15bc:	b4 01       	movw	r22, r8
    15be:	c5 01       	movw	r24, r10
    15c0:	0e 94 0d 05 	call	0xa1a	; 0xa1a <pxPortInitialiseStack>
    15c4:	88 83       	st	Y, r24
    15c6:	99 83       	std	Y+1, r25	; 0x01
    15c8:	e1 14       	cp	r14, r1
    15ca:	f1 04       	cpc	r15, r1
    15cc:	19 f0       	breq	.+6      	; 0x15d4 <xTaskCreate+0x102>
    15ce:	f7 01       	movw	r30, r14
    15d0:	c0 83       	st	Z, r28
    15d2:	d1 83       	std	Z+1, r29	; 0x01
    15d4:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15d8:	ff 93       	push	r31
    15da:	f8 7f       	andi	r31, 0xF8	; 248
    15dc:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15e0:	80 91 5d 2c 	lds	r24, 0x2C5D	; 0x802c5d <uxCurrentNumberOfTasks>
    15e4:	8f 5f       	subi	r24, 0xFF	; 255
    15e6:	80 93 5d 2c 	sts	0x2C5D, r24	; 0x802c5d <uxCurrentNumberOfTasks>
    15ea:	80 91 ba 2c 	lds	r24, 0x2CBA	; 0x802cba <pxCurrentTCB>
    15ee:	90 91 bb 2c 	lds	r25, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    15f2:	89 2b       	or	r24, r25
    15f4:	a9 f5       	brne	.+106    	; 0x1660 <xTaskCreate+0x18e>
    15f6:	c0 93 ba 2c 	sts	0x2CBA, r28	; 0x802cba <pxCurrentTCB>
    15fa:	d0 93 bb 2c 	sts	0x2CBB, r29	; 0x802cbb <pxCurrentTCB+0x1>
    15fe:	80 91 5d 2c 	lds	r24, 0x2C5D	; 0x802c5d <uxCurrentNumberOfTasks>
    1602:	81 30       	cpi	r24, 0x01	; 1
    1604:	e9 f5       	brne	.+122    	; 0x1680 <xTaskCreate+0x1ae>
    1606:	8e e8       	ldi	r24, 0x8E	; 142
    1608:	9c e2       	ldi	r25, 0x2C	; 44
    160a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    160e:	89 e9       	ldi	r24, 0x99	; 153
    1610:	9c e2       	ldi	r25, 0x2C	; 44
    1612:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1616:	84 ea       	ldi	r24, 0xA4	; 164
    1618:	9c e2       	ldi	r25, 0x2C	; 44
    161a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    161e:	8f ea       	ldi	r24, 0xAF	; 175
    1620:	9c e2       	ldi	r25, 0x2C	; 44
    1622:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1626:	83 e8       	ldi	r24, 0x83	; 131
    1628:	9c e2       	ldi	r25, 0x2C	; 44
    162a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    162e:	88 e7       	ldi	r24, 0x78	; 120
    1630:	9c e2       	ldi	r25, 0x2C	; 44
    1632:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1636:	89 e6       	ldi	r24, 0x69	; 105
    1638:	9c e2       	ldi	r25, 0x2C	; 44
    163a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    163e:	8e e5       	ldi	r24, 0x5E	; 94
    1640:	9c e2       	ldi	r25, 0x2C	; 44
    1642:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1646:	83 e8       	ldi	r24, 0x83	; 131
    1648:	9c e2       	ldi	r25, 0x2C	; 44
    164a:	80 93 76 2c 	sts	0x2C76, r24	; 0x802c76 <pxDelayedTaskList>
    164e:	90 93 77 2c 	sts	0x2C77, r25	; 0x802c77 <pxDelayedTaskList+0x1>
    1652:	88 e7       	ldi	r24, 0x78	; 120
    1654:	9c e2       	ldi	r25, 0x2C	; 44
    1656:	80 93 74 2c 	sts	0x2C74, r24	; 0x802c74 <pxOverflowDelayedTaskList>
    165a:	90 93 75 2c 	sts	0x2C75, r25	; 0x802c75 <pxOverflowDelayedTaskList+0x1>
    165e:	10 c0       	rjmp	.+32     	; 0x1680 <xTaskCreate+0x1ae>
    1660:	80 91 57 2c 	lds	r24, 0x2C57	; 0x802c57 <xSchedulerRunning>
    1664:	81 11       	cpse	r24, r1
    1666:	0c c0       	rjmp	.+24     	; 0x1680 <xTaskCreate+0x1ae>
    1668:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    166c:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1670:	92 8d       	ldd	r25, Z+26	; 0x1a
    1672:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1674:	89 17       	cp	r24, r25
    1676:	20 f0       	brcs	.+8      	; 0x1680 <xTaskCreate+0x1ae>
    1678:	c0 93 ba 2c 	sts	0x2CBA, r28	; 0x802cba <pxCurrentTCB>
    167c:	d0 93 bb 2c 	sts	0x2CBB, r29	; 0x802cbb <pxCurrentTCB+0x1>
    1680:	80 91 53 2c 	lds	r24, 0x2C53	; 0x802c53 <uxTaskNumber>
    1684:	8f 5f       	subi	r24, 0xFF	; 255
    1686:	80 93 53 2c 	sts	0x2C53, r24	; 0x802c53 <uxTaskNumber>
    168a:	8d a3       	std	Y+37, r24	; 0x25
    168c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    168e:	90 91 58 2c 	lds	r25, 0x2C58	; 0x802c58 <uxTopReadyPriority>
    1692:	98 17       	cp	r25, r24
    1694:	10 f4       	brcc	.+4      	; 0x169a <xTaskCreate+0x1c8>
    1696:	80 93 58 2c 	sts	0x2C58, r24	; 0x802c58 <uxTopReadyPriority>
    169a:	fb e0       	ldi	r31, 0x0B	; 11
    169c:	8f 9f       	mul	r24, r31
    169e:	c0 01       	movw	r24, r0
    16a0:	11 24       	eor	r1, r1
    16a2:	b6 01       	movw	r22, r12
    16a4:	82 57       	subi	r24, 0x72	; 114
    16a6:	93 4d       	sbci	r25, 0xD3	; 211
    16a8:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    16ac:	ff 91       	pop	r31
    16ae:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    16b2:	80 91 57 2c 	lds	r24, 0x2C57	; 0x802c57 <xSchedulerRunning>
    16b6:	88 23       	and	r24, r24
    16b8:	61 f0       	breq	.+24     	; 0x16d2 <xTaskCreate+0x200>
    16ba:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    16be:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    16c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    16c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16c6:	98 17       	cp	r25, r24
    16c8:	30 f4       	brcc	.+12     	; 0x16d6 <xTaskCreate+0x204>
    16ca:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    16ce:	81 e0       	ldi	r24, 0x01	; 1
    16d0:	05 c0       	rjmp	.+10     	; 0x16dc <xTaskCreate+0x20a>
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	03 c0       	rjmp	.+6      	; 0x16dc <xTaskCreate+0x20a>
    16d6:	81 e0       	ldi	r24, 0x01	; 1
    16d8:	01 c0       	rjmp	.+2      	; 0x16dc <xTaskCreate+0x20a>
    16da:	8f ef       	ldi	r24, 0xFF	; 255
    16dc:	df 91       	pop	r29
    16de:	cf 91       	pop	r28
    16e0:	0f 91       	pop	r16
    16e2:	ff 90       	pop	r15
    16e4:	ef 90       	pop	r14
    16e6:	df 90       	pop	r13
    16e8:	cf 90       	pop	r12
    16ea:	bf 90       	pop	r11
    16ec:	af 90       	pop	r10
    16ee:	9f 90       	pop	r9
    16f0:	8f 90       	pop	r8
    16f2:	7f 90       	pop	r7
    16f4:	6f 90       	pop	r6
    16f6:	5f 90       	pop	r5
    16f8:	4f 90       	pop	r4
    16fa:	08 95       	ret

000016fc <vTaskStartScheduler>:
    16fc:	ef 92       	push	r14
    16fe:	ff 92       	push	r15
    1700:	0f 93       	push	r16
    1702:	0f 2e       	mov	r0, r31
    1704:	fd e4       	ldi	r31, 0x4D	; 77
    1706:	ef 2e       	mov	r14, r31
    1708:	fc e2       	ldi	r31, 0x2C	; 44
    170a:	ff 2e       	mov	r15, r31
    170c:	f0 2d       	mov	r31, r0
    170e:	00 e0       	ldi	r16, 0x00	; 0
    1710:	20 e0       	ldi	r18, 0x00	; 0
    1712:	30 e0       	ldi	r19, 0x00	; 0
    1714:	48 ec       	ldi	r20, 0xC8	; 200
    1716:	50 e0       	ldi	r21, 0x00	; 0
    1718:	60 e0       	ldi	r22, 0x00	; 0
    171a:	70 e2       	ldi	r23, 0x20	; 32
    171c:	8f e5       	ldi	r24, 0x5F	; 95
    171e:	9a e0       	ldi	r25, 0x0A	; 10
    1720:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
    1724:	81 30       	cpi	r24, 0x01	; 1
    1726:	09 f5       	brne	.+66     	; 0x176a <vTaskStartScheduler+0x6e>
    1728:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <xTimerCreateTimerTask>
    172c:	81 30       	cpi	r24, 0x01	; 1
    172e:	e9 f4       	brne	.+58     	; 0x176a <vTaskStartScheduler+0x6e>
    1730:	e0 ea       	ldi	r30, 0xA0	; 160
    1732:	f0 e0       	ldi	r31, 0x00	; 0
    1734:	82 81       	ldd	r24, Z+2	; 0x02
    1736:	88 7f       	andi	r24, 0xF8	; 248
    1738:	82 83       	std	Z+2, r24	; 0x02
    173a:	8f ef       	ldi	r24, 0xFF	; 255
    173c:	9f ef       	ldi	r25, 0xFF	; 255
    173e:	dc 01       	movw	r26, r24
    1740:	80 93 4f 2c 	sts	0x2C4F, r24	; 0x802c4f <xNextTaskUnblockTime>
    1744:	90 93 50 2c 	sts	0x2C50, r25	; 0x802c50 <xNextTaskUnblockTime+0x1>
    1748:	a0 93 51 2c 	sts	0x2C51, r26	; 0x802c51 <xNextTaskUnblockTime+0x2>
    174c:	b0 93 52 2c 	sts	0x2C52, r27	; 0x802c52 <xNextTaskUnblockTime+0x3>
    1750:	81 e0       	ldi	r24, 0x01	; 1
    1752:	80 93 57 2c 	sts	0x2C57, r24	; 0x802c57 <xSchedulerRunning>
    1756:	10 92 59 2c 	sts	0x2C59, r1	; 0x802c59 <xTickCount>
    175a:	10 92 5a 2c 	sts	0x2C5A, r1	; 0x802c5a <xTickCount+0x1>
    175e:	10 92 5b 2c 	sts	0x2C5B, r1	; 0x802c5b <xTickCount+0x2>
    1762:	10 92 5c 2c 	sts	0x2C5C, r1	; 0x802c5c <xTickCount+0x3>
    1766:	0e 94 8a 05 	call	0xb14	; 0xb14 <xPortStartScheduler>
    176a:	0f 91       	pop	r16
    176c:	ff 90       	pop	r15
    176e:	ef 90       	pop	r14
    1770:	08 95       	ret

00001772 <vTaskSuspendAll>:
    1772:	80 91 4c 2c 	lds	r24, 0x2C4C	; 0x802c4c <uxSchedulerSuspended>
    1776:	8f 5f       	subi	r24, 0xFF	; 255
    1778:	80 93 4c 2c 	sts	0x2C4C, r24	; 0x802c4c <uxSchedulerSuspended>
    177c:	08 95       	ret

0000177e <xTaskGetTickCount>:
    177e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1782:	ff 93       	push	r31
    1784:	f8 7f       	andi	r31, 0xF8	; 248
    1786:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    178a:	60 91 59 2c 	lds	r22, 0x2C59	; 0x802c59 <xTickCount>
    178e:	70 91 5a 2c 	lds	r23, 0x2C5A	; 0x802c5a <xTickCount+0x1>
    1792:	80 91 5b 2c 	lds	r24, 0x2C5B	; 0x802c5b <xTickCount+0x2>
    1796:	90 91 5c 2c 	lds	r25, 0x2C5C	; 0x802c5c <xTickCount+0x3>
    179a:	ff 91       	pop	r31
    179c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    17a0:	08 95       	ret

000017a2 <xTaskIncrementTick>:
    17a2:	af 92       	push	r10
    17a4:	bf 92       	push	r11
    17a6:	cf 92       	push	r12
    17a8:	df 92       	push	r13
    17aa:	ef 92       	push	r14
    17ac:	ff 92       	push	r15
    17ae:	0f 93       	push	r16
    17b0:	1f 93       	push	r17
    17b2:	cf 93       	push	r28
    17b4:	df 93       	push	r29
    17b6:	80 91 4c 2c 	lds	r24, 0x2C4C	; 0x802c4c <uxSchedulerSuspended>
    17ba:	81 11       	cpse	r24, r1
    17bc:	ad c0       	rjmp	.+346    	; 0x1918 <xTaskIncrementTick+0x176>
    17be:	c0 90 59 2c 	lds	r12, 0x2C59	; 0x802c59 <xTickCount>
    17c2:	d0 90 5a 2c 	lds	r13, 0x2C5A	; 0x802c5a <xTickCount+0x1>
    17c6:	e0 90 5b 2c 	lds	r14, 0x2C5B	; 0x802c5b <xTickCount+0x2>
    17ca:	f0 90 5c 2c 	lds	r15, 0x2C5C	; 0x802c5c <xTickCount+0x3>
    17ce:	8f ef       	ldi	r24, 0xFF	; 255
    17d0:	c8 1a       	sub	r12, r24
    17d2:	d8 0a       	sbc	r13, r24
    17d4:	e8 0a       	sbc	r14, r24
    17d6:	f8 0a       	sbc	r15, r24
    17d8:	c0 92 59 2c 	sts	0x2C59, r12	; 0x802c59 <xTickCount>
    17dc:	d0 92 5a 2c 	sts	0x2C5A, r13	; 0x802c5a <xTickCount+0x1>
    17e0:	e0 92 5b 2c 	sts	0x2C5B, r14	; 0x802c5b <xTickCount+0x2>
    17e4:	f0 92 5c 2c 	sts	0x2C5C, r15	; 0x802c5c <xTickCount+0x3>
    17e8:	c1 14       	cp	r12, r1
    17ea:	d1 04       	cpc	r13, r1
    17ec:	e1 04       	cpc	r14, r1
    17ee:	f1 04       	cpc	r15, r1
    17f0:	b9 f4       	brne	.+46     	; 0x1820 <xTaskIncrementTick+0x7e>
    17f2:	80 91 76 2c 	lds	r24, 0x2C76	; 0x802c76 <pxDelayedTaskList>
    17f6:	90 91 77 2c 	lds	r25, 0x2C77	; 0x802c77 <pxDelayedTaskList+0x1>
    17fa:	20 91 74 2c 	lds	r18, 0x2C74	; 0x802c74 <pxOverflowDelayedTaskList>
    17fe:	30 91 75 2c 	lds	r19, 0x2C75	; 0x802c75 <pxOverflowDelayedTaskList+0x1>
    1802:	20 93 76 2c 	sts	0x2C76, r18	; 0x802c76 <pxDelayedTaskList>
    1806:	30 93 77 2c 	sts	0x2C77, r19	; 0x802c77 <pxDelayedTaskList+0x1>
    180a:	80 93 74 2c 	sts	0x2C74, r24	; 0x802c74 <pxOverflowDelayedTaskList>
    180e:	90 93 75 2c 	sts	0x2C75, r25	; 0x802c75 <pxOverflowDelayedTaskList+0x1>
    1812:	80 91 54 2c 	lds	r24, 0x2C54	; 0x802c54 <xNumOfOverflows>
    1816:	8f 5f       	subi	r24, 0xFF	; 255
    1818:	80 93 54 2c 	sts	0x2C54, r24	; 0x802c54 <xNumOfOverflows>
    181c:	0e 94 be 09 	call	0x137c	; 0x137c <prvResetNextTaskUnblockTime>
    1820:	80 91 4f 2c 	lds	r24, 0x2C4F	; 0x802c4f <xNextTaskUnblockTime>
    1824:	90 91 50 2c 	lds	r25, 0x2C50	; 0x802c50 <xNextTaskUnblockTime+0x1>
    1828:	a0 91 51 2c 	lds	r26, 0x2C51	; 0x802c51 <xNextTaskUnblockTime+0x2>
    182c:	b0 91 52 2c 	lds	r27, 0x2C52	; 0x802c52 <xNextTaskUnblockTime+0x3>
    1830:	c8 16       	cp	r12, r24
    1832:	d9 06       	cpc	r13, r25
    1834:	ea 06       	cpc	r14, r26
    1836:	fb 06       	cpc	r15, r27
    1838:	10 f4       	brcc	.+4      	; 0x183e <xTaskIncrementTick+0x9c>
    183a:	b1 2c       	mov	r11, r1
    183c:	5c c0       	rjmp	.+184    	; 0x18f6 <xTaskIncrementTick+0x154>
    183e:	b1 2c       	mov	r11, r1
    1840:	0f 2e       	mov	r0, r31
    1842:	fb e0       	ldi	r31, 0x0B	; 11
    1844:	af 2e       	mov	r10, r31
    1846:	f0 2d       	mov	r31, r0
    1848:	e0 91 76 2c 	lds	r30, 0x2C76	; 0x802c76 <pxDelayedTaskList>
    184c:	f0 91 77 2c 	lds	r31, 0x2C77	; 0x802c77 <pxDelayedTaskList+0x1>
    1850:	80 81       	ld	r24, Z
    1852:	81 11       	cpse	r24, r1
    1854:	0c c0       	rjmp	.+24     	; 0x186e <xTaskIncrementTick+0xcc>
    1856:	8f ef       	ldi	r24, 0xFF	; 255
    1858:	9f ef       	ldi	r25, 0xFF	; 255
    185a:	dc 01       	movw	r26, r24
    185c:	80 93 4f 2c 	sts	0x2C4F, r24	; 0x802c4f <xNextTaskUnblockTime>
    1860:	90 93 50 2c 	sts	0x2C50, r25	; 0x802c50 <xNextTaskUnblockTime+0x1>
    1864:	a0 93 51 2c 	sts	0x2C51, r26	; 0x802c51 <xNextTaskUnblockTime+0x2>
    1868:	b0 93 52 2c 	sts	0x2C52, r27	; 0x802c52 <xNextTaskUnblockTime+0x3>
    186c:	44 c0       	rjmp	.+136    	; 0x18f6 <xTaskIncrementTick+0x154>
    186e:	e0 91 76 2c 	lds	r30, 0x2C76	; 0x802c76 <pxDelayedTaskList>
    1872:	f0 91 77 2c 	lds	r31, 0x2C77	; 0x802c77 <pxDelayedTaskList+0x1>
    1876:	07 80       	ldd	r0, Z+7	; 0x07
    1878:	f0 85       	ldd	r31, Z+8	; 0x08
    187a:	e0 2d       	mov	r30, r0
    187c:	c0 85       	ldd	r28, Z+8	; 0x08
    187e:	d1 85       	ldd	r29, Z+9	; 0x09
    1880:	8a 81       	ldd	r24, Y+2	; 0x02
    1882:	9b 81       	ldd	r25, Y+3	; 0x03
    1884:	ac 81       	ldd	r26, Y+4	; 0x04
    1886:	bd 81       	ldd	r27, Y+5	; 0x05
    1888:	c8 16       	cp	r12, r24
    188a:	d9 06       	cpc	r13, r25
    188c:	ea 06       	cpc	r14, r26
    188e:	fb 06       	cpc	r15, r27
    1890:	48 f4       	brcc	.+18     	; 0x18a4 <xTaskIncrementTick+0x102>
    1892:	80 93 4f 2c 	sts	0x2C4F, r24	; 0x802c4f <xNextTaskUnblockTime>
    1896:	90 93 50 2c 	sts	0x2C50, r25	; 0x802c50 <xNextTaskUnblockTime+0x1>
    189a:	a0 93 51 2c 	sts	0x2C51, r26	; 0x802c51 <xNextTaskUnblockTime+0x2>
    189e:	b0 93 52 2c 	sts	0x2C52, r27	; 0x802c52 <xNextTaskUnblockTime+0x3>
    18a2:	29 c0       	rjmp	.+82     	; 0x18f6 <xTaskIncrementTick+0x154>
    18a4:	8e 01       	movw	r16, r28
    18a6:	0e 5f       	subi	r16, 0xFE	; 254
    18a8:	1f 4f       	sbci	r17, 0xFF	; 255
    18aa:	c8 01       	movw	r24, r16
    18ac:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    18b0:	88 8d       	ldd	r24, Y+24	; 0x18
    18b2:	99 8d       	ldd	r25, Y+25	; 0x19
    18b4:	89 2b       	or	r24, r25
    18b6:	21 f0       	breq	.+8      	; 0x18c0 <xTaskIncrementTick+0x11e>
    18b8:	ce 01       	movw	r24, r28
    18ba:	0e 96       	adiw	r24, 0x0e	; 14
    18bc:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    18c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    18c2:	90 91 58 2c 	lds	r25, 0x2C58	; 0x802c58 <uxTopReadyPriority>
    18c6:	98 17       	cp	r25, r24
    18c8:	10 f4       	brcc	.+4      	; 0x18ce <xTaskIncrementTick+0x12c>
    18ca:	80 93 58 2c 	sts	0x2C58, r24	; 0x802c58 <uxTopReadyPriority>
    18ce:	a8 9e       	mul	r10, r24
    18d0:	c0 01       	movw	r24, r0
    18d2:	11 24       	eor	r1, r1
    18d4:	b8 01       	movw	r22, r16
    18d6:	82 57       	subi	r24, 0x72	; 114
    18d8:	93 4d       	sbci	r25, 0xD3	; 211
    18da:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    18de:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    18e2:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    18e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    18ea:	98 17       	cp	r25, r24
    18ec:	08 f4       	brcc	.+2      	; 0x18f0 <xTaskIncrementTick+0x14e>
    18ee:	ac cf       	rjmp	.-168    	; 0x1848 <xTaskIncrementTick+0xa6>
    18f0:	bb 24       	eor	r11, r11
    18f2:	b3 94       	inc	r11
    18f4:	a9 cf       	rjmp	.-174    	; 0x1848 <xTaskIncrementTick+0xa6>
    18f6:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    18fa:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    18fe:	e2 8d       	ldd	r30, Z+26	; 0x1a
    1900:	8b e0       	ldi	r24, 0x0B	; 11
    1902:	e8 9f       	mul	r30, r24
    1904:	f0 01       	movw	r30, r0
    1906:	11 24       	eor	r1, r1
    1908:	e2 57       	subi	r30, 0x72	; 114
    190a:	f3 4d       	sbci	r31, 0xD3	; 211
    190c:	80 81       	ld	r24, Z
    190e:	82 30       	cpi	r24, 0x02	; 2
    1910:	48 f0       	brcs	.+18     	; 0x1924 <xTaskIncrementTick+0x182>
    1912:	bb 24       	eor	r11, r11
    1914:	b3 94       	inc	r11
    1916:	06 c0       	rjmp	.+12     	; 0x1924 <xTaskIncrementTick+0x182>
    1918:	80 91 56 2c 	lds	r24, 0x2C56	; 0x802c56 <uxPendedTicks>
    191c:	8f 5f       	subi	r24, 0xFF	; 255
    191e:	80 93 56 2c 	sts	0x2C56, r24	; 0x802c56 <uxPendedTicks>
    1922:	b1 2c       	mov	r11, r1
    1924:	80 91 55 2c 	lds	r24, 0x2C55	; 0x802c55 <xYieldPending>
    1928:	88 23       	and	r24, r24
    192a:	11 f0       	breq	.+4      	; 0x1930 <xTaskIncrementTick+0x18e>
    192c:	bb 24       	eor	r11, r11
    192e:	b3 94       	inc	r11
    1930:	8b 2d       	mov	r24, r11
    1932:	df 91       	pop	r29
    1934:	cf 91       	pop	r28
    1936:	1f 91       	pop	r17
    1938:	0f 91       	pop	r16
    193a:	ff 90       	pop	r15
    193c:	ef 90       	pop	r14
    193e:	df 90       	pop	r13
    1940:	cf 90       	pop	r12
    1942:	bf 90       	pop	r11
    1944:	af 90       	pop	r10
    1946:	08 95       	ret

00001948 <xTaskResumeAll>:
    1948:	cf 92       	push	r12
    194a:	df 92       	push	r13
    194c:	ef 92       	push	r14
    194e:	ff 92       	push	r15
    1950:	0f 93       	push	r16
    1952:	1f 93       	push	r17
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    195c:	ff 93       	push	r31
    195e:	f8 7f       	andi	r31, 0xF8	; 248
    1960:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1964:	80 91 4c 2c 	lds	r24, 0x2C4C	; 0x802c4c <uxSchedulerSuspended>
    1968:	81 50       	subi	r24, 0x01	; 1
    196a:	80 93 4c 2c 	sts	0x2C4C, r24	; 0x802c4c <uxSchedulerSuspended>
    196e:	80 91 4c 2c 	lds	r24, 0x2C4C	; 0x802c4c <uxSchedulerSuspended>
    1972:	81 11       	cpse	r24, r1
    1974:	5c c0       	rjmp	.+184    	; 0x1a2e <xTaskResumeAll+0xe6>
    1976:	80 91 5d 2c 	lds	r24, 0x2C5D	; 0x802c5d <uxCurrentNumberOfTasks>
    197a:	81 11       	cpse	r24, r1
    197c:	2c c0       	rjmp	.+88     	; 0x19d6 <xTaskResumeAll+0x8e>
    197e:	5a c0       	rjmp	.+180    	; 0x1a34 <xTaskResumeAll+0xec>
    1980:	d7 01       	movw	r26, r14
    1982:	17 96       	adiw	r26, 0x07	; 7
    1984:	ed 91       	ld	r30, X+
    1986:	fc 91       	ld	r31, X
    1988:	18 97       	sbiw	r26, 0x08	; 8
    198a:	c0 85       	ldd	r28, Z+8	; 0x08
    198c:	d1 85       	ldd	r29, Z+9	; 0x09
    198e:	ce 01       	movw	r24, r28
    1990:	0e 96       	adiw	r24, 0x0e	; 14
    1992:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1996:	8e 01       	movw	r16, r28
    1998:	0e 5f       	subi	r16, 0xFE	; 254
    199a:	1f 4f       	sbci	r17, 0xFF	; 255
    199c:	c8 01       	movw	r24, r16
    199e:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    19a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19a4:	90 91 58 2c 	lds	r25, 0x2C58	; 0x802c58 <uxTopReadyPriority>
    19a8:	98 17       	cp	r25, r24
    19aa:	10 f4       	brcc	.+4      	; 0x19b0 <xTaskResumeAll+0x68>
    19ac:	80 93 58 2c 	sts	0x2C58, r24	; 0x802c58 <uxTopReadyPriority>
    19b0:	d8 9e       	mul	r13, r24
    19b2:	c0 01       	movw	r24, r0
    19b4:	11 24       	eor	r1, r1
    19b6:	b8 01       	movw	r22, r16
    19b8:	82 57       	subi	r24, 0x72	; 114
    19ba:	93 4d       	sbci	r25, 0xD3	; 211
    19bc:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    19c0:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    19c4:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    19c8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    19cc:	98 17       	cp	r25, r24
    19ce:	88 f0       	brcs	.+34     	; 0x19f2 <xTaskResumeAll+0xaa>
    19d0:	c0 92 55 2c 	sts	0x2C55, r12	; 0x802c55 <xYieldPending>
    19d4:	0e c0       	rjmp	.+28     	; 0x19f2 <xTaskResumeAll+0xaa>
    19d6:	c0 e0       	ldi	r28, 0x00	; 0
    19d8:	d0 e0       	ldi	r29, 0x00	; 0
    19da:	0f 2e       	mov	r0, r31
    19dc:	f9 e6       	ldi	r31, 0x69	; 105
    19de:	ef 2e       	mov	r14, r31
    19e0:	fc e2       	ldi	r31, 0x2C	; 44
    19e2:	ff 2e       	mov	r15, r31
    19e4:	f0 2d       	mov	r31, r0
    19e6:	0f 2e       	mov	r0, r31
    19e8:	fb e0       	ldi	r31, 0x0B	; 11
    19ea:	df 2e       	mov	r13, r31
    19ec:	f0 2d       	mov	r31, r0
    19ee:	cc 24       	eor	r12, r12
    19f0:	c3 94       	inc	r12
    19f2:	f7 01       	movw	r30, r14
    19f4:	80 81       	ld	r24, Z
    19f6:	81 11       	cpse	r24, r1
    19f8:	c3 cf       	rjmp	.-122    	; 0x1980 <xTaskResumeAll+0x38>
    19fa:	cd 2b       	or	r28, r29
    19fc:	11 f0       	breq	.+4      	; 0x1a02 <xTaskResumeAll+0xba>
    19fe:	0e 94 be 09 	call	0x137c	; 0x137c <prvResetNextTaskUnblockTime>
    1a02:	c0 91 56 2c 	lds	r28, 0x2C56	; 0x802c56 <uxPendedTicks>
    1a06:	cc 23       	and	r28, r28
    1a08:	51 f0       	breq	.+20     	; 0x1a1e <xTaskResumeAll+0xd6>
    1a0a:	d1 e0       	ldi	r29, 0x01	; 1
    1a0c:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <xTaskIncrementTick>
    1a10:	81 11       	cpse	r24, r1
    1a12:	d0 93 55 2c 	sts	0x2C55, r29	; 0x802c55 <xYieldPending>
    1a16:	c1 50       	subi	r28, 0x01	; 1
    1a18:	c9 f7       	brne	.-14     	; 0x1a0c <xTaskResumeAll+0xc4>
    1a1a:	10 92 56 2c 	sts	0x2C56, r1	; 0x802c56 <uxPendedTicks>
    1a1e:	80 91 55 2c 	lds	r24, 0x2C55	; 0x802c55 <xYieldPending>
    1a22:	88 23       	and	r24, r24
    1a24:	31 f0       	breq	.+12     	; 0x1a32 <xTaskResumeAll+0xea>
    1a26:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1a2a:	81 e0       	ldi	r24, 0x01	; 1
    1a2c:	03 c0       	rjmp	.+6      	; 0x1a34 <xTaskResumeAll+0xec>
    1a2e:	80 e0       	ldi	r24, 0x00	; 0
    1a30:	01 c0       	rjmp	.+2      	; 0x1a34 <xTaskResumeAll+0xec>
    1a32:	80 e0       	ldi	r24, 0x00	; 0
    1a34:	ff 91       	pop	r31
    1a36:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1a3a:	df 91       	pop	r29
    1a3c:	cf 91       	pop	r28
    1a3e:	1f 91       	pop	r17
    1a40:	0f 91       	pop	r16
    1a42:	ff 90       	pop	r15
    1a44:	ef 90       	pop	r14
    1a46:	df 90       	pop	r13
    1a48:	cf 90       	pop	r12
    1a4a:	08 95       	ret

00001a4c <vTaskDelay>:
    1a4c:	cf 92       	push	r12
    1a4e:	df 92       	push	r13
    1a50:	ef 92       	push	r14
    1a52:	ff 92       	push	r15
    1a54:	6b 01       	movw	r12, r22
    1a56:	7c 01       	movw	r14, r24
    1a58:	67 2b       	or	r22, r23
    1a5a:	68 2b       	or	r22, r24
    1a5c:	69 2b       	or	r22, r25
    1a5e:	59 f0       	breq	.+22     	; 0x1a76 <vTaskDelay+0x2a>
    1a60:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    1a64:	40 e0       	ldi	r20, 0x00	; 0
    1a66:	c7 01       	movw	r24, r14
    1a68:	b6 01       	movw	r22, r12
    1a6a:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1a6e:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    1a72:	81 11       	cpse	r24, r1
    1a74:	02 c0       	rjmp	.+4      	; 0x1a7a <vTaskDelay+0x2e>
    1a76:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    1a7a:	ff 90       	pop	r15
    1a7c:	ef 90       	pop	r14
    1a7e:	df 90       	pop	r13
    1a80:	cf 90       	pop	r12
    1a82:	08 95       	ret

00001a84 <vTaskSwitchContext>:
    1a84:	80 91 4c 2c 	lds	r24, 0x2C4C	; 0x802c4c <uxSchedulerSuspended>
    1a88:	88 23       	and	r24, r24
    1a8a:	21 f0       	breq	.+8      	; 0x1a94 <vTaskSwitchContext+0x10>
    1a8c:	81 e0       	ldi	r24, 0x01	; 1
    1a8e:	80 93 55 2c 	sts	0x2C55, r24	; 0x802c55 <xYieldPending>
    1a92:	08 95       	ret
    1a94:	10 92 55 2c 	sts	0x2C55, r1	; 0x802c55 <xYieldPending>
    1a98:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1a9c:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1aa0:	03 8c       	ldd	r0, Z+27	; 0x1b
    1aa2:	f4 8d       	ldd	r31, Z+28	; 0x1c
    1aa4:	e0 2d       	mov	r30, r0
    1aa6:	80 81       	ld	r24, Z
    1aa8:	91 81       	ldd	r25, Z+1	; 0x01
    1aaa:	a2 81       	ldd	r26, Z+2	; 0x02
    1aac:	b3 81       	ldd	r27, Z+3	; 0x03
    1aae:	85 3a       	cpi	r24, 0xA5	; 165
    1ab0:	95 4a       	sbci	r25, 0xA5	; 165
    1ab2:	a5 4a       	sbci	r26, 0xA5	; 165
    1ab4:	b5 4a       	sbci	r27, 0xA5	; 165
    1ab6:	d9 f4       	brne	.+54     	; 0x1aee <vTaskSwitchContext+0x6a>
    1ab8:	84 81       	ldd	r24, Z+4	; 0x04
    1aba:	95 81       	ldd	r25, Z+5	; 0x05
    1abc:	a6 81       	ldd	r26, Z+6	; 0x06
    1abe:	b7 81       	ldd	r27, Z+7	; 0x07
    1ac0:	85 3a       	cpi	r24, 0xA5	; 165
    1ac2:	95 4a       	sbci	r25, 0xA5	; 165
    1ac4:	a5 4a       	sbci	r26, 0xA5	; 165
    1ac6:	b5 4a       	sbci	r27, 0xA5	; 165
    1ac8:	91 f4       	brne	.+36     	; 0x1aee <vTaskSwitchContext+0x6a>
    1aca:	80 85       	ldd	r24, Z+8	; 0x08
    1acc:	91 85       	ldd	r25, Z+9	; 0x09
    1ace:	a2 85       	ldd	r26, Z+10	; 0x0a
    1ad0:	b3 85       	ldd	r27, Z+11	; 0x0b
    1ad2:	85 3a       	cpi	r24, 0xA5	; 165
    1ad4:	95 4a       	sbci	r25, 0xA5	; 165
    1ad6:	a5 4a       	sbci	r26, 0xA5	; 165
    1ad8:	b5 4a       	sbci	r27, 0xA5	; 165
    1ada:	49 f4       	brne	.+18     	; 0x1aee <vTaskSwitchContext+0x6a>
    1adc:	84 85       	ldd	r24, Z+12	; 0x0c
    1ade:	95 85       	ldd	r25, Z+13	; 0x0d
    1ae0:	a6 85       	ldd	r26, Z+14	; 0x0e
    1ae2:	b7 85       	ldd	r27, Z+15	; 0x0f
    1ae4:	85 3a       	cpi	r24, 0xA5	; 165
    1ae6:	95 4a       	sbci	r25, 0xA5	; 165
    1ae8:	a5 4a       	sbci	r26, 0xA5	; 165
    1aea:	b5 4a       	sbci	r27, 0xA5	; 165
    1aec:	61 f0       	breq	.+24     	; 0x1b06 <vTaskSwitchContext+0x82>
    1aee:	60 91 ba 2c 	lds	r22, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1af2:	70 91 bb 2c 	lds	r23, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1af6:	80 91 ba 2c 	lds	r24, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1afa:	90 91 bb 2c 	lds	r25, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1afe:	63 5e       	subi	r22, 0xE3	; 227
    1b00:	7f 4f       	sbci	r23, 0xFF	; 255
    1b02:	0e 94 a5 02 	call	0x54a	; 0x54a <vApplicationStackOverflowHook>
    1b06:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxTopReadyPriority>
    1b0a:	28 2f       	mov	r18, r24
    1b0c:	30 e0       	ldi	r19, 0x00	; 0
    1b0e:	9b e0       	ldi	r25, 0x0B	; 11
    1b10:	89 9f       	mul	r24, r25
    1b12:	f0 01       	movw	r30, r0
    1b14:	11 24       	eor	r1, r1
    1b16:	e2 57       	subi	r30, 0x72	; 114
    1b18:	f3 4d       	sbci	r31, 0xD3	; 211
    1b1a:	90 81       	ld	r25, Z
    1b1c:	91 11       	cpse	r25, r1
    1b1e:	0e c0       	rjmp	.+28     	; 0x1b3c <vTaskSwitchContext+0xb8>
    1b20:	4b e0       	ldi	r20, 0x0B	; 11
    1b22:	81 50       	subi	r24, 0x01	; 1
    1b24:	28 2f       	mov	r18, r24
    1b26:	30 e0       	ldi	r19, 0x00	; 0
    1b28:	42 9f       	mul	r20, r18
    1b2a:	f0 01       	movw	r30, r0
    1b2c:	43 9f       	mul	r20, r19
    1b2e:	f0 0d       	add	r31, r0
    1b30:	11 24       	eor	r1, r1
    1b32:	e2 57       	subi	r30, 0x72	; 114
    1b34:	f3 4d       	sbci	r31, 0xD3	; 211
    1b36:	90 81       	ld	r25, Z
    1b38:	99 23       	and	r25, r25
    1b3a:	99 f3       	breq	.-26     	; 0x1b22 <vTaskSwitchContext+0x9e>
    1b3c:	9b e0       	ldi	r25, 0x0B	; 11
    1b3e:	92 9f       	mul	r25, r18
    1b40:	a0 01       	movw	r20, r0
    1b42:	93 9f       	mul	r25, r19
    1b44:	50 0d       	add	r21, r0
    1b46:	11 24       	eor	r1, r1
    1b48:	da 01       	movw	r26, r20
    1b4a:	a2 57       	subi	r26, 0x72	; 114
    1b4c:	b3 4d       	sbci	r27, 0xD3	; 211
    1b4e:	11 96       	adiw	r26, 0x01	; 1
    1b50:	ed 91       	ld	r30, X+
    1b52:	fc 91       	ld	r31, X
    1b54:	12 97       	sbiw	r26, 0x02	; 2
    1b56:	04 80       	ldd	r0, Z+4	; 0x04
    1b58:	f5 81       	ldd	r31, Z+5	; 0x05
    1b5a:	e0 2d       	mov	r30, r0
    1b5c:	11 96       	adiw	r26, 0x01	; 1
    1b5e:	ed 93       	st	X+, r30
    1b60:	fc 93       	st	X, r31
    1b62:	12 97       	sbiw	r26, 0x02	; 2
    1b64:	4f 56       	subi	r20, 0x6F	; 111
    1b66:	53 4d       	sbci	r21, 0xD3	; 211
    1b68:	e4 17       	cp	r30, r20
    1b6a:	f5 07       	cpc	r31, r21
    1b6c:	29 f4       	brne	.+10     	; 0x1b78 <vTaskSwitchContext+0xf4>
    1b6e:	44 81       	ldd	r20, Z+4	; 0x04
    1b70:	55 81       	ldd	r21, Z+5	; 0x05
    1b72:	fd 01       	movw	r30, r26
    1b74:	41 83       	std	Z+1, r20	; 0x01
    1b76:	52 83       	std	Z+2, r21	; 0x02
    1b78:	9b e0       	ldi	r25, 0x0B	; 11
    1b7a:	92 9f       	mul	r25, r18
    1b7c:	f0 01       	movw	r30, r0
    1b7e:	93 9f       	mul	r25, r19
    1b80:	f0 0d       	add	r31, r0
    1b82:	11 24       	eor	r1, r1
    1b84:	e2 57       	subi	r30, 0x72	; 114
    1b86:	f3 4d       	sbci	r31, 0xD3	; 211
    1b88:	01 80       	ldd	r0, Z+1	; 0x01
    1b8a:	f2 81       	ldd	r31, Z+2	; 0x02
    1b8c:	e0 2d       	mov	r30, r0
    1b8e:	20 85       	ldd	r18, Z+8	; 0x08
    1b90:	31 85       	ldd	r19, Z+9	; 0x09
    1b92:	20 93 ba 2c 	sts	0x2CBA, r18	; 0x802cba <pxCurrentTCB>
    1b96:	30 93 bb 2c 	sts	0x2CBB, r19	; 0x802cbb <pxCurrentTCB+0x1>
    1b9a:	80 93 58 2c 	sts	0x2C58, r24	; 0x802c58 <uxTopReadyPriority>
    1b9e:	08 95       	ret

00001ba0 <vTaskPlaceOnEventList>:
    1ba0:	cf 92       	push	r12
    1ba2:	df 92       	push	r13
    1ba4:	ef 92       	push	r14
    1ba6:	ff 92       	push	r15
    1ba8:	6a 01       	movw	r12, r20
    1baa:	7b 01       	movw	r14, r22
    1bac:	60 91 ba 2c 	lds	r22, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1bb0:	70 91 bb 2c 	lds	r23, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1bb4:	62 5f       	subi	r22, 0xF2	; 242
    1bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb8:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1bbc:	41 e0       	ldi	r20, 0x01	; 1
    1bbe:	c7 01       	movw	r24, r14
    1bc0:	b6 01       	movw	r22, r12
    1bc2:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1bc6:	ff 90       	pop	r15
    1bc8:	ef 90       	pop	r14
    1bca:	df 90       	pop	r13
    1bcc:	cf 90       	pop	r12
    1bce:	08 95       	ret

00001bd0 <vTaskPlaceOnUnorderedEventList>:
    1bd0:	cf 92       	push	r12
    1bd2:	df 92       	push	r13
    1bd4:	ef 92       	push	r14
    1bd6:	ff 92       	push	r15
    1bd8:	0f 93       	push	r16
    1bda:	1f 93       	push	r17
    1bdc:	68 01       	movw	r12, r16
    1bde:	79 01       	movw	r14, r18
    1be0:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1be4:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1be8:	70 68       	ori	r23, 0x80	; 128
    1bea:	46 87       	std	Z+14, r20	; 0x0e
    1bec:	57 87       	std	Z+15, r21	; 0x0f
    1bee:	60 8b       	std	Z+16, r22	; 0x10
    1bf0:	71 8b       	std	Z+17, r23	; 0x11
    1bf2:	60 91 ba 2c 	lds	r22, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1bf6:	70 91 bb 2c 	lds	r23, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1bfa:	62 5f       	subi	r22, 0xF2	; 242
    1bfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bfe:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1c02:	41 e0       	ldi	r20, 0x01	; 1
    1c04:	c7 01       	movw	r24, r14
    1c06:	b6 01       	movw	r22, r12
    1c08:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1c0c:	1f 91       	pop	r17
    1c0e:	0f 91       	pop	r16
    1c10:	ff 90       	pop	r15
    1c12:	ef 90       	pop	r14
    1c14:	df 90       	pop	r13
    1c16:	cf 90       	pop	r12
    1c18:	08 95       	ret

00001c1a <vTaskPlaceOnEventListRestricted>:
    1c1a:	cf 92       	push	r12
    1c1c:	df 92       	push	r13
    1c1e:	ef 92       	push	r14
    1c20:	ff 92       	push	r15
    1c22:	cf 93       	push	r28
    1c24:	6a 01       	movw	r12, r20
    1c26:	7b 01       	movw	r14, r22
    1c28:	c2 2f       	mov	r28, r18
    1c2a:	60 91 ba 2c 	lds	r22, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1c2e:	70 91 bb 2c 	lds	r23, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1c32:	62 5f       	subi	r22, 0xF2	; 242
    1c34:	7f 4f       	sbci	r23, 0xFF	; 255
    1c36:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1c3a:	cc 23       	and	r28, r28
    1c3c:	21 f0       	breq	.+8      	; 0x1c46 <vTaskPlaceOnEventListRestricted+0x2c>
    1c3e:	cc 24       	eor	r12, r12
    1c40:	ca 94       	dec	r12
    1c42:	dc 2c       	mov	r13, r12
    1c44:	76 01       	movw	r14, r12
    1c46:	4c 2f       	mov	r20, r28
    1c48:	c7 01       	movw	r24, r14
    1c4a:	b6 01       	movw	r22, r12
    1c4c:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvAddCurrentTaskToDelayedList>
    1c50:	cf 91       	pop	r28
    1c52:	ff 90       	pop	r15
    1c54:	ef 90       	pop	r14
    1c56:	df 90       	pop	r13
    1c58:	cf 90       	pop	r12
    1c5a:	08 95       	ret

00001c5c <xTaskRemoveFromEventList>:
    1c5c:	0f 93       	push	r16
    1c5e:	1f 93       	push	r17
    1c60:	cf 93       	push	r28
    1c62:	df 93       	push	r29
    1c64:	dc 01       	movw	r26, r24
    1c66:	17 96       	adiw	r26, 0x07	; 7
    1c68:	ed 91       	ld	r30, X+
    1c6a:	fc 91       	ld	r31, X
    1c6c:	18 97       	sbiw	r26, 0x08	; 8
    1c6e:	c0 85       	ldd	r28, Z+8	; 0x08
    1c70:	d1 85       	ldd	r29, Z+9	; 0x09
    1c72:	8e 01       	movw	r16, r28
    1c74:	02 5f       	subi	r16, 0xF2	; 242
    1c76:	1f 4f       	sbci	r17, 0xFF	; 255
    1c78:	c8 01       	movw	r24, r16
    1c7a:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1c7e:	80 91 4c 2c 	lds	r24, 0x2C4C	; 0x802c4c <uxSchedulerSuspended>
    1c82:	81 11       	cpse	r24, r1
    1c84:	16 c0       	rjmp	.+44     	; 0x1cb2 <xTaskRemoveFromEventList+0x56>
    1c86:	0c 50       	subi	r16, 0x0C	; 12
    1c88:	11 09       	sbc	r17, r1
    1c8a:	c8 01       	movw	r24, r16
    1c8c:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1c90:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c92:	90 91 58 2c 	lds	r25, 0x2C58	; 0x802c58 <uxTopReadyPriority>
    1c96:	98 17       	cp	r25, r24
    1c98:	10 f4       	brcc	.+4      	; 0x1c9e <xTaskRemoveFromEventList+0x42>
    1c9a:	80 93 58 2c 	sts	0x2C58, r24	; 0x802c58 <uxTopReadyPriority>
    1c9e:	bb e0       	ldi	r27, 0x0B	; 11
    1ca0:	8b 9f       	mul	r24, r27
    1ca2:	c0 01       	movw	r24, r0
    1ca4:	11 24       	eor	r1, r1
    1ca6:	b8 01       	movw	r22, r16
    1ca8:	82 57       	subi	r24, 0x72	; 114
    1caa:	93 4d       	sbci	r25, 0xD3	; 211
    1cac:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1cb0:	05 c0       	rjmp	.+10     	; 0x1cbc <xTaskRemoveFromEventList+0x60>
    1cb2:	b8 01       	movw	r22, r16
    1cb4:	89 e6       	ldi	r24, 0x69	; 105
    1cb6:	9c e2       	ldi	r25, 0x2C	; 44
    1cb8:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1cbc:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1cc0:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1cc4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1cc6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cc8:	89 17       	cp	r24, r25
    1cca:	20 f4       	brcc	.+8      	; 0x1cd4 <xTaskRemoveFromEventList+0x78>
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	80 93 55 2c 	sts	0x2C55, r24	; 0x802c55 <xYieldPending>
    1cd2:	01 c0       	rjmp	.+2      	; 0x1cd6 <xTaskRemoveFromEventList+0x7a>
    1cd4:	80 e0       	ldi	r24, 0x00	; 0
    1cd6:	df 91       	pop	r29
    1cd8:	cf 91       	pop	r28
    1cda:	1f 91       	pop	r17
    1cdc:	0f 91       	pop	r16
    1cde:	08 95       	ret

00001ce0 <vTaskRemoveFromUnorderedEventList>:
    1ce0:	0f 93       	push	r16
    1ce2:	1f 93       	push	r17
    1ce4:	cf 93       	push	r28
    1ce6:	df 93       	push	r29
    1ce8:	70 68       	ori	r23, 0x80	; 128
    1cea:	fc 01       	movw	r30, r24
    1cec:	40 83       	st	Z, r20
    1cee:	51 83       	std	Z+1, r21	; 0x01
    1cf0:	62 83       	std	Z+2, r22	; 0x02
    1cf2:	73 83       	std	Z+3, r23	; 0x03
    1cf4:	c0 85       	ldd	r28, Z+8	; 0x08
    1cf6:	d1 85       	ldd	r29, Z+9	; 0x09
    1cf8:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1cfc:	8e 01       	movw	r16, r28
    1cfe:	0e 5f       	subi	r16, 0xFE	; 254
    1d00:	1f 4f       	sbci	r17, 0xFF	; 255
    1d02:	c8 01       	movw	r24, r16
    1d04:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    1d08:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d0a:	90 91 58 2c 	lds	r25, 0x2C58	; 0x802c58 <uxTopReadyPriority>
    1d0e:	98 17       	cp	r25, r24
    1d10:	10 f4       	brcc	.+4      	; 0x1d16 <vTaskRemoveFromUnorderedEventList+0x36>
    1d12:	80 93 58 2c 	sts	0x2C58, r24	; 0x802c58 <uxTopReadyPriority>
    1d16:	fb e0       	ldi	r31, 0x0B	; 11
    1d18:	8f 9f       	mul	r24, r31
    1d1a:	c0 01       	movw	r24, r0
    1d1c:	11 24       	eor	r1, r1
    1d1e:	b8 01       	movw	r22, r16
    1d20:	82 57       	subi	r24, 0x72	; 114
    1d22:	93 4d       	sbci	r25, 0xD3	; 211
    1d24:	0e 94 81 04 	call	0x902	; 0x902 <vListInsertEnd>
    1d28:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1d2c:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1d30:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d32:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d34:	89 17       	cp	r24, r25
    1d36:	18 f4       	brcc	.+6      	; 0x1d3e <vTaskRemoveFromUnorderedEventList+0x5e>
    1d38:	81 e0       	ldi	r24, 0x01	; 1
    1d3a:	80 93 55 2c 	sts	0x2C55, r24	; 0x802c55 <xYieldPending>
    1d3e:	df 91       	pop	r29
    1d40:	cf 91       	pop	r28
    1d42:	1f 91       	pop	r17
    1d44:	0f 91       	pop	r16
    1d46:	08 95       	ret

00001d48 <vTaskInternalSetTimeOutState>:
    1d48:	20 91 54 2c 	lds	r18, 0x2C54	; 0x802c54 <xNumOfOverflows>
    1d4c:	fc 01       	movw	r30, r24
    1d4e:	20 83       	st	Z, r18
    1d50:	40 91 59 2c 	lds	r20, 0x2C59	; 0x802c59 <xTickCount>
    1d54:	50 91 5a 2c 	lds	r21, 0x2C5A	; 0x802c5a <xTickCount+0x1>
    1d58:	60 91 5b 2c 	lds	r22, 0x2C5B	; 0x802c5b <xTickCount+0x2>
    1d5c:	70 91 5c 2c 	lds	r23, 0x2C5C	; 0x802c5c <xTickCount+0x3>
    1d60:	41 83       	std	Z+1, r20	; 0x01
    1d62:	52 83       	std	Z+2, r21	; 0x02
    1d64:	63 83       	std	Z+3, r22	; 0x03
    1d66:	74 83       	std	Z+4, r23	; 0x04
    1d68:	08 95       	ret

00001d6a <xTaskCheckForTimeOut>:
    1d6a:	cf 92       	push	r12
    1d6c:	df 92       	push	r13
    1d6e:	ef 92       	push	r14
    1d70:	ff 92       	push	r15
    1d72:	0f 93       	push	r16
    1d74:	1f 93       	push	r17
    1d76:	cf 93       	push	r28
    1d78:	df 93       	push	r29
    1d7a:	db 01       	movw	r26, r22
    1d7c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d80:	ff 93       	push	r31
    1d82:	f8 7f       	andi	r31, 0xF8	; 248
    1d84:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d88:	40 91 59 2c 	lds	r20, 0x2C59	; 0x802c59 <xTickCount>
    1d8c:	50 91 5a 2c 	lds	r21, 0x2C5A	; 0x802c5a <xTickCount+0x1>
    1d90:	60 91 5b 2c 	lds	r22, 0x2C5B	; 0x802c5b <xTickCount+0x2>
    1d94:	70 91 5c 2c 	lds	r23, 0x2C5C	; 0x802c5c <xTickCount+0x3>
    1d98:	0d 91       	ld	r16, X+
    1d9a:	1d 91       	ld	r17, X+
    1d9c:	2d 91       	ld	r18, X+
    1d9e:	3c 91       	ld	r19, X
    1da0:	13 97       	sbiw	r26, 0x03	; 3
    1da2:	0f 3f       	cpi	r16, 0xFF	; 255
    1da4:	cf ef       	ldi	r28, 0xFF	; 255
    1da6:	1c 07       	cpc	r17, r28
    1da8:	2c 07       	cpc	r18, r28
    1daa:	3c 07       	cpc	r19, r28
    1dac:	69 f1       	breq	.+90     	; 0x1e08 <xTaskCheckForTimeOut+0x9e>
    1dae:	fc 01       	movw	r30, r24
    1db0:	c1 80       	ldd	r12, Z+1	; 0x01
    1db2:	d2 80       	ldd	r13, Z+2	; 0x02
    1db4:	e3 80       	ldd	r14, Z+3	; 0x03
    1db6:	f4 80       	ldd	r15, Z+4	; 0x04
    1db8:	e0 91 54 2c 	lds	r30, 0x2C54	; 0x802c54 <xNumOfOverflows>
    1dbc:	ec 01       	movw	r28, r24
    1dbe:	f8 81       	ld	r31, Y
    1dc0:	fe 17       	cp	r31, r30
    1dc2:	29 f0       	breq	.+10     	; 0x1dce <xTaskCheckForTimeOut+0x64>
    1dc4:	4c 15       	cp	r20, r12
    1dc6:	5d 05       	cpc	r21, r13
    1dc8:	6e 05       	cpc	r22, r14
    1dca:	7f 05       	cpc	r23, r15
    1dcc:	f8 f4       	brcc	.+62     	; 0x1e0c <xTaskCheckForTimeOut+0xa2>
    1dce:	4c 19       	sub	r20, r12
    1dd0:	5d 09       	sbc	r21, r13
    1dd2:	6e 09       	sbc	r22, r14
    1dd4:	7f 09       	sbc	r23, r15
    1dd6:	40 17       	cp	r20, r16
    1dd8:	51 07       	cpc	r21, r17
    1dda:	62 07       	cpc	r22, r18
    1ddc:	73 07       	cpc	r23, r19
    1dde:	68 f4       	brcc	.+26     	; 0x1dfa <xTaskCheckForTimeOut+0x90>
    1de0:	fd 01       	movw	r30, r26
    1de2:	04 1b       	sub	r16, r20
    1de4:	15 0b       	sbc	r17, r21
    1de6:	26 0b       	sbc	r18, r22
    1de8:	37 0b       	sbc	r19, r23
    1dea:	00 83       	st	Z, r16
    1dec:	11 83       	std	Z+1, r17	; 0x01
    1dee:	22 83       	std	Z+2, r18	; 0x02
    1df0:	33 83       	std	Z+3, r19	; 0x03
    1df2:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskInternalSetTimeOutState>
    1df6:	80 e0       	ldi	r24, 0x00	; 0
    1df8:	0a c0       	rjmp	.+20     	; 0x1e0e <xTaskCheckForTimeOut+0xa4>
    1dfa:	1d 92       	st	X+, r1
    1dfc:	1d 92       	st	X+, r1
    1dfe:	1d 92       	st	X+, r1
    1e00:	1c 92       	st	X, r1
    1e02:	13 97       	sbiw	r26, 0x03	; 3
    1e04:	81 e0       	ldi	r24, 0x01	; 1
    1e06:	03 c0       	rjmp	.+6      	; 0x1e0e <xTaskCheckForTimeOut+0xa4>
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	01 c0       	rjmp	.+2      	; 0x1e0e <xTaskCheckForTimeOut+0xa4>
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	ff 91       	pop	r31
    1e10:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1e14:	df 91       	pop	r29
    1e16:	cf 91       	pop	r28
    1e18:	1f 91       	pop	r17
    1e1a:	0f 91       	pop	r16
    1e1c:	ff 90       	pop	r15
    1e1e:	ef 90       	pop	r14
    1e20:	df 90       	pop	r13
    1e22:	cf 90       	pop	r12
    1e24:	08 95       	ret

00001e26 <vTaskMissedYield>:
    1e26:	81 e0       	ldi	r24, 0x01	; 1
    1e28:	80 93 55 2c 	sts	0x2C55, r24	; 0x802c55 <xYieldPending>
    1e2c:	08 95       	ret

00001e2e <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    1e2e:	80 91 57 2c 	lds	r24, 0x2C57	; 0x802c57 <xSchedulerRunning>
    1e32:	88 23       	and	r24, r24
    1e34:	31 f0       	breq	.+12     	; 0x1e42 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1e36:	80 91 4c 2c 	lds	r24, 0x2C4C	; 0x802c4c <uxSchedulerSuspended>
    1e3a:	88 23       	and	r24, r24
    1e3c:	21 f0       	breq	.+8      	; 0x1e46 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1e3e:	80 e0       	ldi	r24, 0x00	; 0
    1e40:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1e42:	81 e0       	ldi	r24, 0x01	; 1
    1e44:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    1e46:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    1e48:	08 95       	ret

00001e4a <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    1e4a:	cf 92       	push	r12
    1e4c:	df 92       	push	r13
    1e4e:	ef 92       	push	r14
    1e50:	ff 92       	push	r15
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1e52:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1e56:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1e5a:	66 85       	ldd	r22, Z+14	; 0x0e
    1e5c:	77 85       	ldd	r23, Z+15	; 0x0f
    1e5e:	80 89       	ldd	r24, Z+16	; 0x10
    1e60:	91 89       	ldd	r25, Z+17	; 0x11

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e62:	e0 91 ba 2c 	lds	r30, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1e66:	f0 91 bb 2c 	lds	r31, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1e6a:	a0 91 ba 2c 	lds	r26, 0x2CBA	; 0x802cba <pxCurrentTCB>
    1e6e:	b0 91 bb 2c 	lds	r27, 0x2CBB	; 0x802cbb <pxCurrentTCB+0x1>
    1e72:	5a 96       	adiw	r26, 0x1a	; 26
    1e74:	2c 91       	ld	r18, X
    1e76:	c1 2c       	mov	r12, r1
    1e78:	d1 2c       	mov	r13, r1
    1e7a:	76 01       	movw	r14, r12
    1e7c:	68 94       	set
    1e7e:	c2 f8       	bld	r12, 2
    1e80:	c2 1a       	sub	r12, r18
    1e82:	d1 08       	sbc	r13, r1
    1e84:	e1 08       	sbc	r14, r1
    1e86:	f1 08       	sbc	r15, r1
    1e88:	c6 86       	std	Z+14, r12	; 0x0e
    1e8a:	d7 86       	std	Z+15, r13	; 0x0f
    1e8c:	e0 8a       	std	Z+16, r14	; 0x10
    1e8e:	f1 8a       	std	Z+17, r15	; 0x11

	return uxReturn;
}
    1e90:	ff 90       	pop	r15
    1e92:	ef 90       	pop	r14
    1e94:	df 90       	pop	r13
    1e96:	cf 90       	pop	r12
    1e98:	08 95       	ret

00001e9a <prvInsertTimerInActiveList>:

	taskENTER_CRITICAL();
	{
		pxTimer->pvTimerID = pvNewID;
	}
	taskEXIT_CRITICAL();
    1e9a:	cf 92       	push	r12
    1e9c:	df 92       	push	r13
    1e9e:	ef 92       	push	r14
    1ea0:	ff 92       	push	r15
    1ea2:	0f 93       	push	r16
    1ea4:	1f 93       	push	r17
    1ea6:	fc 01       	movw	r30, r24
    1ea8:	42 83       	std	Z+2, r20	; 0x02
    1eaa:	53 83       	std	Z+3, r21	; 0x03
    1eac:	64 83       	std	Z+4, r22	; 0x04
    1eae:	75 83       	std	Z+5, r23	; 0x05
    1eb0:	82 87       	std	Z+10, r24	; 0x0a
    1eb2:	93 87       	std	Z+11, r25	; 0x0b
    1eb4:	04 17       	cp	r16, r20
    1eb6:	15 07       	cpc	r17, r21
    1eb8:	26 07       	cpc	r18, r22
    1eba:	37 07       	cpc	r19, r23
    1ebc:	c0 f0       	brcs	.+48     	; 0x1eee <prvInsertTimerInActiveList+0x54>
    1ebe:	0c 19       	sub	r16, r12
    1ec0:	1d 09       	sbc	r17, r13
    1ec2:	2e 09       	sbc	r18, r14
    1ec4:	3f 09       	sbc	r19, r15
    1ec6:	86 85       	ldd	r24, Z+14	; 0x0e
    1ec8:	97 85       	ldd	r25, Z+15	; 0x0f
    1eca:	a0 89       	ldd	r26, Z+16	; 0x10
    1ecc:	b1 89       	ldd	r27, Z+17	; 0x11
    1ece:	08 17       	cp	r16, r24
    1ed0:	19 07       	cpc	r17, r25
    1ed2:	2a 07       	cpc	r18, r26
    1ed4:	3b 07       	cpc	r19, r27
    1ed6:	00 f5       	brcc	.+64     	; 0x1f18 <prvInsertTimerInActiveList+0x7e>
    1ed8:	bf 01       	movw	r22, r30
    1eda:	6e 5f       	subi	r22, 0xFE	; 254
    1edc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ede:	80 91 c4 2c 	lds	r24, 0x2CC4	; 0x802cc4 <pxOverflowTimerList>
    1ee2:	90 91 c5 2c 	lds	r25, 0x2CC5	; 0x802cc5 <pxOverflowTimerList+0x1>
    1ee6:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1eea:	80 e0       	ldi	r24, 0x00	; 0
    1eec:	18 c0       	rjmp	.+48     	; 0x1f1e <prvInsertTimerInActiveList+0x84>
    1eee:	0c 15       	cp	r16, r12
    1ef0:	1d 05       	cpc	r17, r13
    1ef2:	2e 05       	cpc	r18, r14
    1ef4:	3f 05       	cpc	r19, r15
    1ef6:	28 f4       	brcc	.+10     	; 0x1f02 <prvInsertTimerInActiveList+0x68>
    1ef8:	4c 15       	cp	r20, r12
    1efa:	5d 05       	cpc	r21, r13
    1efc:	6e 05       	cpc	r22, r14
    1efe:	7f 05       	cpc	r23, r15
    1f00:	68 f4       	brcc	.+26     	; 0x1f1c <prvInsertTimerInActiveList+0x82>
    1f02:	bf 01       	movw	r22, r30
    1f04:	6e 5f       	subi	r22, 0xFE	; 254
    1f06:	7f 4f       	sbci	r23, 0xFF	; 255
    1f08:	80 91 c6 2c 	lds	r24, 0x2CC6	; 0x802cc6 <pxCurrentTimerList>
    1f0c:	90 91 c7 2c 	lds	r25, 0x2CC7	; 0x802cc7 <pxCurrentTimerList+0x1>
    1f10:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    1f14:	80 e0       	ldi	r24, 0x00	; 0
    1f16:	03 c0       	rjmp	.+6      	; 0x1f1e <prvInsertTimerInActiveList+0x84>
    1f18:	81 e0       	ldi	r24, 0x01	; 1
    1f1a:	01 c0       	rjmp	.+2      	; 0x1f1e <prvInsertTimerInActiveList+0x84>
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	1f 91       	pop	r17
    1f20:	0f 91       	pop	r16
    1f22:	ff 90       	pop	r15
    1f24:	ef 90       	pop	r14
    1f26:	df 90       	pop	r13
    1f28:	cf 90       	pop	r12
    1f2a:	08 95       	ret

00001f2c <prvCheckForValidListAndQueue>:
    1f2c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f30:	ff 93       	push	r31
    1f32:	f8 7f       	andi	r31, 0xF8	; 248
    1f34:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f38:	80 91 c2 2c 	lds	r24, 0x2CC2	; 0x802cc2 <xTimerQueue>
    1f3c:	90 91 c3 2c 	lds	r25, 0x2CC3	; 0x802cc3 <xTimerQueue+0x1>
    1f40:	89 2b       	or	r24, r25
    1f42:	e9 f4       	brne	.+58     	; 0x1f7e <prvCheckForValidListAndQueue+0x52>
    1f44:	83 ed       	ldi	r24, 0xD3	; 211
    1f46:	9c e2       	ldi	r25, 0x2C	; 44
    1f48:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1f4c:	88 ec       	ldi	r24, 0xC8	; 200
    1f4e:	9c e2       	ldi	r25, 0x2C	; 44
    1f50:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <vListInitialise>
    1f54:	83 ed       	ldi	r24, 0xD3	; 211
    1f56:	9c e2       	ldi	r25, 0x2C	; 44
    1f58:	80 93 c6 2c 	sts	0x2CC6, r24	; 0x802cc6 <pxCurrentTimerList>
    1f5c:	90 93 c7 2c 	sts	0x2CC7, r25	; 0x802cc7 <pxCurrentTimerList+0x1>
    1f60:	88 ec       	ldi	r24, 0xC8	; 200
    1f62:	9c e2       	ldi	r25, 0x2C	; 44
    1f64:	80 93 c4 2c 	sts	0x2CC4, r24	; 0x802cc4 <pxOverflowTimerList>
    1f68:	90 93 c5 2c 	sts	0x2CC5, r25	; 0x802cc5 <pxOverflowTimerList+0x1>
    1f6c:	40 e0       	ldi	r20, 0x00	; 0
    1f6e:	69 e0       	ldi	r22, 0x09	; 9
    1f70:	85 e0       	ldi	r24, 0x05	; 5
    1f72:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericCreate>
    1f76:	80 93 c2 2c 	sts	0x2CC2, r24	; 0x802cc2 <xTimerQueue>
    1f7a:	90 93 c3 2c 	sts	0x2CC3, r25	; 0x802cc3 <xTimerQueue+0x1>
    1f7e:	ff 91       	pop	r31
    1f80:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f84:	08 95       	ret

00001f86 <xTimerCreateTimerTask>:
    1f86:	ef 92       	push	r14
    1f88:	ff 92       	push	r15
    1f8a:	0f 93       	push	r16
    1f8c:	0e 94 96 0f 	call	0x1f2c	; 0x1f2c <prvCheckForValidListAndQueue>
    1f90:	80 91 c2 2c 	lds	r24, 0x2CC2	; 0x802cc2 <xTimerQueue>
    1f94:	90 91 c3 2c 	lds	r25, 0x2CC3	; 0x802cc3 <xTimerQueue+0x1>
    1f98:	89 2b       	or	r24, r25
    1f9a:	91 f0       	breq	.+36     	; 0x1fc0 <xTimerCreateTimerTask+0x3a>
    1f9c:	0f 2e       	mov	r0, r31
    1f9e:	f0 ec       	ldi	r31, 0xC0	; 192
    1fa0:	ef 2e       	mov	r14, r31
    1fa2:	fc e2       	ldi	r31, 0x2C	; 44
    1fa4:	ff 2e       	mov	r15, r31
    1fa6:	f0 2d       	mov	r31, r0
    1fa8:	03 e0       	ldi	r16, 0x03	; 3
    1faa:	20 e0       	ldi	r18, 0x00	; 0
    1fac:	30 e0       	ldi	r19, 0x00	; 0
    1fae:	48 ec       	ldi	r20, 0xC8	; 200
    1fb0:	50 e0       	ldi	r21, 0x00	; 0
    1fb2:	65 e0       	ldi	r22, 0x05	; 5
    1fb4:	70 e2       	ldi	r23, 0x20	; 32
    1fb6:	86 ed       	ldi	r24, 0xD6	; 214
    1fb8:	90 e1       	ldi	r25, 0x10	; 16
    1fba:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
    1fbe:	01 c0       	rjmp	.+2      	; 0x1fc2 <xTimerCreateTimerTask+0x3c>
    1fc0:	80 e0       	ldi	r24, 0x00	; 0
    1fc2:	0f 91       	pop	r16
    1fc4:	ff 90       	pop	r15
    1fc6:	ef 90       	pop	r14
    1fc8:	08 95       	ret

00001fca <xTimerGenericCommand>:
    1fca:	8f 92       	push	r8
    1fcc:	9f 92       	push	r9
    1fce:	af 92       	push	r10
    1fd0:	bf 92       	push	r11
    1fd2:	cf 92       	push	r12
    1fd4:	df 92       	push	r13
    1fd6:	ef 92       	push	r14
    1fd8:	ff 92       	push	r15
    1fda:	0f 93       	push	r16
    1fdc:	1f 93       	push	r17
    1fde:	cf 93       	push	r28
    1fe0:	df 93       	push	r29
    1fe2:	cd b7       	in	r28, 0x3d	; 61
    1fe4:	de b7       	in	r29, 0x3e	; 62
    1fe6:	29 97       	sbiw	r28, 0x09	; 9
    1fe8:	cd bf       	out	0x3d, r28	; 61
    1fea:	de bf       	out	0x3e, r29	; 62
    1fec:	e0 91 c2 2c 	lds	r30, 0x2CC2	; 0x802cc2 <xTimerQueue>
    1ff0:	f0 91 c3 2c 	lds	r31, 0x2CC3	; 0x802cc3 <xTimerQueue+0x1>
    1ff4:	30 97       	sbiw	r30, 0x00	; 0
    1ff6:	89 f1       	breq	.+98     	; 0x205a <xTimerGenericCommand+0x90>
    1ff8:	69 83       	std	Y+1, r22	; 0x01
    1ffa:	2a 83       	std	Y+2, r18	; 0x02
    1ffc:	3b 83       	std	Y+3, r19	; 0x03
    1ffe:	4c 83       	std	Y+4, r20	; 0x04
    2000:	5d 83       	std	Y+5, r21	; 0x05
    2002:	8e 83       	std	Y+6, r24	; 0x06
    2004:	9f 83       	std	Y+7, r25	; 0x07
    2006:	66 30       	cpi	r22, 0x06	; 6
    2008:	fc f4       	brge	.+62     	; 0x2048 <xTimerGenericCommand+0x7e>
    200a:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <xTaskGetSchedulerState>
    200e:	82 30       	cpi	r24, 0x02	; 2
    2010:	69 f4       	brne	.+26     	; 0x202c <xTimerGenericCommand+0x62>
    2012:	00 e0       	ldi	r16, 0x00	; 0
    2014:	a7 01       	movw	r20, r14
    2016:	96 01       	movw	r18, r12
    2018:	be 01       	movw	r22, r28
    201a:	6f 5f       	subi	r22, 0xFF	; 255
    201c:	7f 4f       	sbci	r23, 0xFF	; 255
    201e:	80 91 c2 2c 	lds	r24, 0x2CC2	; 0x802cc2 <xTimerQueue>
    2022:	90 91 c3 2c 	lds	r25, 0x2CC3	; 0x802cc3 <xTimerQueue+0x1>
    2026:	0e 94 00 08 	call	0x1000	; 0x1000 <xQueueGenericSend>
    202a:	18 c0       	rjmp	.+48     	; 0x205c <xTimerGenericCommand+0x92>
    202c:	00 e0       	ldi	r16, 0x00	; 0
    202e:	20 e0       	ldi	r18, 0x00	; 0
    2030:	30 e0       	ldi	r19, 0x00	; 0
    2032:	a9 01       	movw	r20, r18
    2034:	be 01       	movw	r22, r28
    2036:	6f 5f       	subi	r22, 0xFF	; 255
    2038:	7f 4f       	sbci	r23, 0xFF	; 255
    203a:	80 91 c2 2c 	lds	r24, 0x2CC2	; 0x802cc2 <xTimerQueue>
    203e:	90 91 c3 2c 	lds	r25, 0x2CC3	; 0x802cc3 <xTimerQueue+0x1>
    2042:	0e 94 00 08 	call	0x1000	; 0x1000 <xQueueGenericSend>
    2046:	0a c0       	rjmp	.+20     	; 0x205c <xTimerGenericCommand+0x92>
    2048:	20 e0       	ldi	r18, 0x00	; 0
    204a:	a8 01       	movw	r20, r16
    204c:	be 01       	movw	r22, r28
    204e:	6f 5f       	subi	r22, 0xFF	; 255
    2050:	7f 4f       	sbci	r23, 0xFF	; 255
    2052:	cf 01       	movw	r24, r30
    2054:	0e 94 a6 08 	call	0x114c	; 0x114c <xQueueGenericSendFromISR>
    2058:	01 c0       	rjmp	.+2      	; 0x205c <xTimerGenericCommand+0x92>
    205a:	80 e0       	ldi	r24, 0x00	; 0
    205c:	29 96       	adiw	r28, 0x09	; 9
    205e:	cd bf       	out	0x3d, r28	; 61
    2060:	de bf       	out	0x3e, r29	; 62
    2062:	df 91       	pop	r29
    2064:	cf 91       	pop	r28
    2066:	1f 91       	pop	r17
    2068:	0f 91       	pop	r16
    206a:	ff 90       	pop	r15
    206c:	ef 90       	pop	r14
    206e:	df 90       	pop	r13
    2070:	cf 90       	pop	r12
    2072:	bf 90       	pop	r11
    2074:	af 90       	pop	r10
    2076:	9f 90       	pop	r9
    2078:	8f 90       	pop	r8
    207a:	08 95       	ret

0000207c <prvSampleTimeNow>:
    207c:	2f 92       	push	r2
    207e:	3f 92       	push	r3
    2080:	4f 92       	push	r4
    2082:	5f 92       	push	r5
    2084:	6f 92       	push	r6
    2086:	7f 92       	push	r7
    2088:	8f 92       	push	r8
    208a:	9f 92       	push	r9
    208c:	af 92       	push	r10
    208e:	bf 92       	push	r11
    2090:	cf 92       	push	r12
    2092:	df 92       	push	r13
    2094:	ef 92       	push	r14
    2096:	ff 92       	push	r15
    2098:	0f 93       	push	r16
    209a:	1f 93       	push	r17
    209c:	cf 93       	push	r28
    209e:	df 93       	push	r29
    20a0:	1c 01       	movw	r2, r24
    20a2:	0e 94 bf 0b 	call	0x177e	; 0x177e <xTaskGetTickCount>
    20a6:	2b 01       	movw	r4, r22
    20a8:	3c 01       	movw	r6, r24
    20aa:	80 91 bc 2c 	lds	r24, 0x2CBC	; 0x802cbc <xLastTime.4745>
    20ae:	90 91 bd 2c 	lds	r25, 0x2CBD	; 0x802cbd <xLastTime.4745+0x1>
    20b2:	a0 91 be 2c 	lds	r26, 0x2CBE	; 0x802cbe <xLastTime.4745+0x2>
    20b6:	b0 91 bf 2c 	lds	r27, 0x2CBF	; 0x802cbf <xLastTime.4745+0x3>
    20ba:	48 16       	cp	r4, r24
    20bc:	59 06       	cpc	r5, r25
    20be:	6a 06       	cpc	r6, r26
    20c0:	7b 06       	cpc	r7, r27
    20c2:	08 f0       	brcs	.+2      	; 0x20c6 <prvSampleTimeNow+0x4a>
    20c4:	54 c0       	rjmp	.+168    	; 0x216e <prvSampleTimeNow+0xf2>
    20c6:	3c c0       	rjmp	.+120    	; 0x2140 <prvSampleTimeNow+0xc4>
    20c8:	07 80       	ldd	r0, Z+7	; 0x07
    20ca:	f0 85       	ldd	r31, Z+8	; 0x08
    20cc:	e0 2d       	mov	r30, r0
    20ce:	80 80       	ld	r8, Z
    20d0:	91 80       	ldd	r9, Z+1	; 0x01
    20d2:	a2 80       	ldd	r10, Z+2	; 0x02
    20d4:	b3 80       	ldd	r11, Z+3	; 0x03
    20d6:	c0 85       	ldd	r28, Z+8	; 0x08
    20d8:	d1 85       	ldd	r29, Z+9	; 0x09
    20da:	8e 01       	movw	r16, r28
    20dc:	0e 5f       	subi	r16, 0xFE	; 254
    20de:	1f 4f       	sbci	r17, 0xFF	; 255
    20e0:	c8 01       	movw	r24, r16
    20e2:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    20e6:	ed 89       	ldd	r30, Y+21	; 0x15
    20e8:	fe 89       	ldd	r31, Y+22	; 0x16
    20ea:	ce 01       	movw	r24, r28
    20ec:	19 95       	eicall
    20ee:	8a 89       	ldd	r24, Y+18	; 0x12
    20f0:	81 30       	cpi	r24, 0x01	; 1
    20f2:	31 f5       	brne	.+76     	; 0x2140 <prvSampleTimeNow+0xc4>
    20f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    20f6:	9f 85       	ldd	r25, Y+15	; 0x0f
    20f8:	a8 89       	ldd	r26, Y+16	; 0x10
    20fa:	b9 89       	ldd	r27, Y+17	; 0x11
    20fc:	88 0d       	add	r24, r8
    20fe:	99 1d       	adc	r25, r9
    2100:	aa 1d       	adc	r26, r10
    2102:	bb 1d       	adc	r27, r11
    2104:	88 16       	cp	r8, r24
    2106:	99 06       	cpc	r9, r25
    2108:	aa 06       	cpc	r10, r26
    210a:	bb 06       	cpc	r11, r27
    210c:	70 f4       	brcc	.+28     	; 0x212a <prvSampleTimeNow+0xae>
    210e:	8a 83       	std	Y+2, r24	; 0x02
    2110:	9b 83       	std	Y+3, r25	; 0x03
    2112:	ac 83       	std	Y+4, r26	; 0x04
    2114:	bd 83       	std	Y+5, r27	; 0x05
    2116:	ca 87       	std	Y+10, r28	; 0x0a
    2118:	db 87       	std	Y+11, r29	; 0x0b
    211a:	b8 01       	movw	r22, r16
    211c:	80 91 c6 2c 	lds	r24, 0x2CC6	; 0x802cc6 <pxCurrentTimerList>
    2120:	90 91 c7 2c 	lds	r25, 0x2CC7	; 0x802cc7 <pxCurrentTimerList+0x1>
    2124:	0e 94 a2 04 	call	0x944	; 0x944 <vListInsert>
    2128:	0b c0       	rjmp	.+22     	; 0x2140 <prvSampleTimeNow+0xc4>
    212a:	c1 2c       	mov	r12, r1
    212c:	d1 2c       	mov	r13, r1
    212e:	76 01       	movw	r14, r12
    2130:	00 e0       	ldi	r16, 0x00	; 0
    2132:	10 e0       	ldi	r17, 0x00	; 0
    2134:	a5 01       	movw	r20, r10
    2136:	94 01       	movw	r18, r8
    2138:	60 e0       	ldi	r22, 0x00	; 0
    213a:	ce 01       	movw	r24, r28
    213c:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <xTimerGenericCommand>
    2140:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTimerList>
    2144:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTimerList+0x1>
    2148:	80 81       	ld	r24, Z
    214a:	81 11       	cpse	r24, r1
    214c:	bd cf       	rjmp	.-134    	; 0x20c8 <prvSampleTimeNow+0x4c>
    214e:	80 91 c4 2c 	lds	r24, 0x2CC4	; 0x802cc4 <pxOverflowTimerList>
    2152:	90 91 c5 2c 	lds	r25, 0x2CC5	; 0x802cc5 <pxOverflowTimerList+0x1>
    2156:	80 93 c6 2c 	sts	0x2CC6, r24	; 0x802cc6 <pxCurrentTimerList>
    215a:	90 93 c7 2c 	sts	0x2CC7, r25	; 0x802cc7 <pxCurrentTimerList+0x1>
    215e:	e0 93 c4 2c 	sts	0x2CC4, r30	; 0x802cc4 <pxOverflowTimerList>
    2162:	f0 93 c5 2c 	sts	0x2CC5, r31	; 0x802cc5 <pxOverflowTimerList+0x1>
    2166:	81 e0       	ldi	r24, 0x01	; 1
    2168:	f1 01       	movw	r30, r2
    216a:	80 83       	st	Z, r24
    216c:	02 c0       	rjmp	.+4      	; 0x2172 <prvSampleTimeNow+0xf6>
    216e:	f1 01       	movw	r30, r2
    2170:	10 82       	st	Z, r1
    2172:	40 92 bc 2c 	sts	0x2CBC, r4	; 0x802cbc <xLastTime.4745>
    2176:	50 92 bd 2c 	sts	0x2CBD, r5	; 0x802cbd <xLastTime.4745+0x1>
    217a:	60 92 be 2c 	sts	0x2CBE, r6	; 0x802cbe <xLastTime.4745+0x2>
    217e:	70 92 bf 2c 	sts	0x2CBF, r7	; 0x802cbf <xLastTime.4745+0x3>
    2182:	c3 01       	movw	r24, r6
    2184:	b2 01       	movw	r22, r4
    2186:	df 91       	pop	r29
    2188:	cf 91       	pop	r28
    218a:	1f 91       	pop	r17
    218c:	0f 91       	pop	r16
    218e:	ff 90       	pop	r15
    2190:	ef 90       	pop	r14
    2192:	df 90       	pop	r13
    2194:	cf 90       	pop	r12
    2196:	bf 90       	pop	r11
    2198:	af 90       	pop	r10
    219a:	9f 90       	pop	r9
    219c:	8f 90       	pop	r8
    219e:	7f 90       	pop	r7
    21a0:	6f 90       	pop	r6
    21a2:	5f 90       	pop	r5
    21a4:	4f 90       	pop	r4
    21a6:	3f 90       	pop	r3
    21a8:	2f 90       	pop	r2
    21aa:	08 95       	ret

000021ac <prvTimerTask>:
    21ac:	cf 93       	push	r28
    21ae:	df 93       	push	r29
    21b0:	cd b7       	in	r28, 0x3d	; 61
    21b2:	de b7       	in	r29, 0x3e	; 62
    21b4:	2e 97       	sbiw	r28, 0x0e	; 14
    21b6:	cd bf       	out	0x3d, r28	; 61
    21b8:	de bf       	out	0x3e, r29	; 62
    21ba:	ce 01       	movw	r24, r28
    21bc:	01 96       	adiw	r24, 0x01	; 1
    21be:	1c 01       	movw	r2, r24
    21c0:	a8 2e       	mov	r10, r24
    21c2:	b3 2c       	mov	r11, r3
    21c4:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTimerList>
    21c8:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTimerList+0x1>
    21cc:	80 81       	ld	r24, Z
    21ce:	88 23       	and	r24, r24
    21d0:	09 f4       	brne	.+2      	; 0x21d4 <prvTimerTask+0x28>
    21d2:	03 c1       	rjmp	.+518    	; 0x23da <prvTimerTask+0x22e>
    21d4:	07 80       	ldd	r0, Z+7	; 0x07
    21d6:	f0 85       	ldd	r31, Z+8	; 0x08
    21d8:	e0 2d       	mov	r30, r0
    21da:	40 80       	ld	r4, Z
    21dc:	51 80       	ldd	r5, Z+1	; 0x01
    21de:	62 80       	ldd	r6, Z+2	; 0x02
    21e0:	73 80       	ldd	r7, Z+3	; 0x03
    21e2:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    21e6:	c1 01       	movw	r24, r2
    21e8:	0e 94 3e 10 	call	0x207c	; 0x207c <prvSampleTimeNow>
    21ec:	6b 87       	std	Y+11, r22	; 0x0b
    21ee:	7c 87       	std	Y+12, r23	; 0x0c
    21f0:	8d 87       	std	Y+13, r24	; 0x0d
    21f2:	9e 87       	std	Y+14, r25	; 0x0e
    21f4:	89 81       	ldd	r24, Y+1	; 0x01
    21f6:	81 11       	cpse	r24, r1
    21f8:	5e c0       	rjmp	.+188    	; 0x22b6 <prvTimerTask+0x10a>
    21fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    21fc:	9c 85       	ldd	r25, Y+12	; 0x0c
    21fe:	ad 85       	ldd	r26, Y+13	; 0x0d
    2200:	be 85       	ldd	r27, Y+14	; 0x0e
    2202:	84 15       	cp	r24, r4
    2204:	95 05       	cpc	r25, r5
    2206:	a6 05       	cpc	r26, r6
    2208:	b7 05       	cpc	r27, r7
    220a:	e8 f1       	brcs	.+122    	; 0x2286 <prvTimerTask+0xda>
    220c:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    2210:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTimerList>
    2214:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTimerList+0x1>
    2218:	07 80       	ldd	r0, Z+7	; 0x07
    221a:	f0 85       	ldd	r31, Z+8	; 0x08
    221c:	e0 2d       	mov	r30, r0
    221e:	80 84       	ldd	r8, Z+8	; 0x08
    2220:	91 84       	ldd	r9, Z+9	; 0x09
    2222:	c4 01       	movw	r24, r8
    2224:	02 96       	adiw	r24, 0x02	; 2
    2226:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    222a:	d4 01       	movw	r26, r8
    222c:	52 96       	adiw	r26, 0x12	; 18
    222e:	8c 91       	ld	r24, X
    2230:	52 97       	sbiw	r26, 0x12	; 18
    2232:	81 30       	cpi	r24, 0x01	; 1
    2234:	01 f5       	brne	.+64     	; 0x2276 <prvTimerTask+0xca>
    2236:	1e 96       	adiw	r26, 0x0e	; 14
    2238:	4d 91       	ld	r20, X+
    223a:	5d 91       	ld	r21, X+
    223c:	6d 91       	ld	r22, X+
    223e:	7c 91       	ld	r23, X
    2240:	51 97       	sbiw	r26, 0x11	; 17
    2242:	44 0d       	add	r20, r4
    2244:	55 1d       	adc	r21, r5
    2246:	66 1d       	adc	r22, r6
    2248:	77 1d       	adc	r23, r7
    224a:	73 01       	movw	r14, r6
    224c:	62 01       	movw	r12, r4
    224e:	0b 85       	ldd	r16, Y+11	; 0x0b
    2250:	1c 85       	ldd	r17, Y+12	; 0x0c
    2252:	2d 85       	ldd	r18, Y+13	; 0x0d
    2254:	3e 85       	ldd	r19, Y+14	; 0x0e
    2256:	c4 01       	movw	r24, r8
    2258:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <prvInsertTimerInActiveList>
    225c:	88 23       	and	r24, r24
    225e:	59 f0       	breq	.+22     	; 0x2276 <prvTimerTask+0xca>
    2260:	c1 2c       	mov	r12, r1
    2262:	d1 2c       	mov	r13, r1
    2264:	76 01       	movw	r14, r12
    2266:	00 e0       	ldi	r16, 0x00	; 0
    2268:	10 e0       	ldi	r17, 0x00	; 0
    226a:	a3 01       	movw	r20, r6
    226c:	92 01       	movw	r18, r4
    226e:	60 e0       	ldi	r22, 0x00	; 0
    2270:	c4 01       	movw	r24, r8
    2272:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <xTimerGenericCommand>
    2276:	d4 01       	movw	r26, r8
    2278:	55 96       	adiw	r26, 0x15	; 21
    227a:	ed 91       	ld	r30, X+
    227c:	fc 91       	ld	r31, X
    227e:	56 97       	sbiw	r26, 0x16	; 22
    2280:	c4 01       	movw	r24, r8
    2282:	19 95       	eicall
    2284:	9c c0       	rjmp	.+312    	; 0x23be <prvTimerTask+0x212>
    2286:	20 e0       	ldi	r18, 0x00	; 0
    2288:	b3 01       	movw	r22, r6
    228a:	a2 01       	movw	r20, r4
    228c:	8b 85       	ldd	r24, Y+11	; 0x0b
    228e:	9c 85       	ldd	r25, Y+12	; 0x0c
    2290:	ad 85       	ldd	r26, Y+13	; 0x0d
    2292:	be 85       	ldd	r27, Y+14	; 0x0e
    2294:	48 1b       	sub	r20, r24
    2296:	59 0b       	sbc	r21, r25
    2298:	6a 0b       	sbc	r22, r26
    229a:	7b 0b       	sbc	r23, r27
    229c:	80 91 c2 2c 	lds	r24, 0x2CC2	; 0x802cc2 <xTimerQueue>
    22a0:	90 91 c3 2c 	lds	r25, 0x2CC3	; 0x802cc3 <xTimerQueue+0x1>
    22a4:	0e 94 9d 09 	call	0x133a	; 0x133a <vQueueWaitForMessageRestricted>
    22a8:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    22ac:	81 11       	cpse	r24, r1
    22ae:	87 c0       	rjmp	.+270    	; 0x23be <prvTimerTask+0x212>
    22b0:	0e 94 ca 05 	call	0xb94	; 0xb94 <vPortYield>
    22b4:	84 c0       	rjmp	.+264    	; 0x23be <prvTimerTask+0x212>
    22b6:	0e 94 a4 0c 	call	0x1948	; 0x1948 <xTaskResumeAll>
    22ba:	81 c0       	rjmp	.+258    	; 0x23be <prvTimerTask+0x212>
    22bc:	89 81       	ldd	r24, Y+1	; 0x01
    22be:	88 23       	and	r24, r24
    22c0:	6c f4       	brge	.+26     	; 0x22dc <prvTimerTask+0x130>
    22c2:	4e 81       	ldd	r20, Y+6	; 0x06
    22c4:	5f 81       	ldd	r21, Y+7	; 0x07
    22c6:	68 85       	ldd	r22, Y+8	; 0x08
    22c8:	79 85       	ldd	r23, Y+9	; 0x09
    22ca:	ea 81       	ldd	r30, Y+2	; 0x02
    22cc:	fb 81       	ldd	r31, Y+3	; 0x03
    22ce:	8c 81       	ldd	r24, Y+4	; 0x04
    22d0:	9d 81       	ldd	r25, Y+5	; 0x05
    22d2:	19 95       	eicall
    22d4:	89 81       	ldd	r24, Y+1	; 0x01
    22d6:	88 23       	and	r24, r24
    22d8:	0c f4       	brge	.+2      	; 0x22dc <prvTimerTask+0x130>
    22da:	71 c0       	rjmp	.+226    	; 0x23be <prvTimerTask+0x212>
    22dc:	8e 80       	ldd	r8, Y+6	; 0x06
    22de:	9f 80       	ldd	r9, Y+7	; 0x07
    22e0:	d4 01       	movw	r26, r8
    22e2:	1c 96       	adiw	r26, 0x0c	; 12
    22e4:	8d 91       	ld	r24, X+
    22e6:	9c 91       	ld	r25, X
    22e8:	1d 97       	sbiw	r26, 0x0d	; 13
    22ea:	89 2b       	or	r24, r25
    22ec:	21 f0       	breq	.+8      	; 0x22f6 <prvTimerTask+0x14a>
    22ee:	c4 01       	movw	r24, r8
    22f0:	02 96       	adiw	r24, 0x02	; 2
    22f2:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
    22f6:	ce 01       	movw	r24, r28
    22f8:	0a 96       	adiw	r24, 0x0a	; 10
    22fa:	0e 94 3e 10 	call	0x207c	; 0x207c <prvSampleTimeNow>
    22fe:	8b 01       	movw	r16, r22
    2300:	9c 01       	movw	r18, r24
    2302:	89 81       	ldd	r24, Y+1	; 0x01
    2304:	08 2e       	mov	r0, r24
    2306:	00 0c       	add	r0, r0
    2308:	99 0b       	sbc	r25, r25
    230a:	aa 0b       	sbc	r26, r26
    230c:	bb 0b       	sbc	r27, r27
    230e:	8a 30       	cpi	r24, 0x0A	; 10
    2310:	91 05       	cpc	r25, r1
    2312:	08 f0       	brcs	.+2      	; 0x2316 <prvTimerTask+0x16a>
    2314:	54 c0       	rjmp	.+168    	; 0x23be <prvTimerTask+0x212>
    2316:	fc 01       	movw	r30, r24
    2318:	88 27       	eor	r24, r24
    231a:	e2 50       	subi	r30, 0x02	; 2
    231c:	ff 4f       	sbci	r31, 0xFF	; 255
    231e:	8f 4f       	sbci	r24, 0xFF	; 255
    2320:	0c 94 e4 1c 	jmp	0x39c8	; 0x39c8 <__tablejump2__>
    2324:	ca 80       	ldd	r12, Y+2	; 0x02
    2326:	db 80       	ldd	r13, Y+3	; 0x03
    2328:	ec 80       	ldd	r14, Y+4	; 0x04
    232a:	fd 80       	ldd	r15, Y+5	; 0x05
    232c:	f4 01       	movw	r30, r8
    232e:	46 85       	ldd	r20, Z+14	; 0x0e
    2330:	57 85       	ldd	r21, Z+15	; 0x0f
    2332:	60 89       	ldd	r22, Z+16	; 0x10
    2334:	71 89       	ldd	r23, Z+17	; 0x11
    2336:	4c 0d       	add	r20, r12
    2338:	5d 1d       	adc	r21, r13
    233a:	6e 1d       	adc	r22, r14
    233c:	7f 1d       	adc	r23, r15
    233e:	c4 01       	movw	r24, r8
    2340:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <prvInsertTimerInActiveList>
    2344:	88 23       	and	r24, r24
    2346:	d9 f1       	breq	.+118    	; 0x23be <prvTimerTask+0x212>
    2348:	d4 01       	movw	r26, r8
    234a:	55 96       	adiw	r26, 0x15	; 21
    234c:	ed 91       	ld	r30, X+
    234e:	fc 91       	ld	r31, X
    2350:	56 97       	sbiw	r26, 0x16	; 22
    2352:	c4 01       	movw	r24, r8
    2354:	19 95       	eicall
    2356:	f4 01       	movw	r30, r8
    2358:	82 89       	ldd	r24, Z+18	; 0x12
    235a:	81 30       	cpi	r24, 0x01	; 1
    235c:	81 f5       	brne	.+96     	; 0x23be <prvTimerTask+0x212>
    235e:	4a 81       	ldd	r20, Y+2	; 0x02
    2360:	5b 81       	ldd	r21, Y+3	; 0x03
    2362:	6c 81       	ldd	r22, Y+4	; 0x04
    2364:	7d 81       	ldd	r23, Y+5	; 0x05
    2366:	86 85       	ldd	r24, Z+14	; 0x0e
    2368:	97 85       	ldd	r25, Z+15	; 0x0f
    236a:	a0 89       	ldd	r26, Z+16	; 0x10
    236c:	b1 89       	ldd	r27, Z+17	; 0x11
    236e:	9a 01       	movw	r18, r20
    2370:	ab 01       	movw	r20, r22
    2372:	28 0f       	add	r18, r24
    2374:	39 1f       	adc	r19, r25
    2376:	4a 1f       	adc	r20, r26
    2378:	5b 1f       	adc	r21, r27
    237a:	c1 2c       	mov	r12, r1
    237c:	d1 2c       	mov	r13, r1
    237e:	76 01       	movw	r14, r12
    2380:	00 e0       	ldi	r16, 0x00	; 0
    2382:	10 e0       	ldi	r17, 0x00	; 0
    2384:	60 e0       	ldi	r22, 0x00	; 0
    2386:	c4 01       	movw	r24, r8
    2388:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <xTimerGenericCommand>
    238c:	18 c0       	rjmp	.+48     	; 0x23be <prvTimerTask+0x212>
    238e:	4a 81       	ldd	r20, Y+2	; 0x02
    2390:	5b 81       	ldd	r21, Y+3	; 0x03
    2392:	6c 81       	ldd	r22, Y+4	; 0x04
    2394:	7d 81       	ldd	r23, Y+5	; 0x05
    2396:	d4 01       	movw	r26, r8
    2398:	1e 96       	adiw	r26, 0x0e	; 14
    239a:	4d 93       	st	X+, r20
    239c:	5d 93       	st	X+, r21
    239e:	6d 93       	st	X+, r22
    23a0:	7c 93       	st	X, r23
    23a2:	51 97       	sbiw	r26, 0x11	; 17
    23a4:	40 0f       	add	r20, r16
    23a6:	51 1f       	adc	r21, r17
    23a8:	62 1f       	adc	r22, r18
    23aa:	73 1f       	adc	r23, r19
    23ac:	68 01       	movw	r12, r16
    23ae:	79 01       	movw	r14, r18
    23b0:	c4 01       	movw	r24, r8
    23b2:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <prvInsertTimerInActiveList>
    23b6:	03 c0       	rjmp	.+6      	; 0x23be <prvTimerTask+0x212>
    23b8:	c4 01       	movw	r24, r8
    23ba:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <vPortFree>
    23be:	20 e0       	ldi	r18, 0x00	; 0
    23c0:	30 e0       	ldi	r19, 0x00	; 0
    23c2:	a9 01       	movw	r20, r18
    23c4:	6a 2d       	mov	r22, r10
    23c6:	7b 2d       	mov	r23, r11
    23c8:	80 91 c2 2c 	lds	r24, 0x2CC2	; 0x802cc2 <xTimerQueue>
    23cc:	90 91 c3 2c 	lds	r25, 0x2CC3	; 0x802cc3 <xTimerQueue+0x1>
    23d0:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <xQueueReceive>
    23d4:	81 11       	cpse	r24, r1
    23d6:	72 cf       	rjmp	.-284    	; 0x22bc <prvTimerTask+0x110>
    23d8:	f5 ce       	rjmp	.-534    	; 0x21c4 <prvTimerTask+0x18>
    23da:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskSuspendAll>
    23de:	c1 01       	movw	r24, r2
    23e0:	0e 94 3e 10 	call	0x207c	; 0x207c <prvSampleTimeNow>
    23e4:	6b 87       	std	Y+11, r22	; 0x0b
    23e6:	7c 87       	std	Y+12, r23	; 0x0c
    23e8:	8d 87       	std	Y+13, r24	; 0x0d
    23ea:	9e 87       	std	Y+14, r25	; 0x0e
    23ec:	89 81       	ldd	r24, Y+1	; 0x01
    23ee:	81 11       	cpse	r24, r1
    23f0:	62 cf       	rjmp	.-316    	; 0x22b6 <prvTimerTask+0x10a>
    23f2:	e0 91 c4 2c 	lds	r30, 0x2CC4	; 0x802cc4 <pxOverflowTimerList>
    23f6:	f0 91 c5 2c 	lds	r31, 0x2CC5	; 0x802cc5 <pxOverflowTimerList+0x1>
    23fa:	80 81       	ld	r24, Z
    23fc:	21 e0       	ldi	r18, 0x01	; 1
    23fe:	81 11       	cpse	r24, r1
    2400:	20 e0       	ldi	r18, 0x00	; 0
    2402:	41 2c       	mov	r4, r1
    2404:	51 2c       	mov	r5, r1
    2406:	32 01       	movw	r6, r4
    2408:	3f cf       	rjmp	.-386    	; 0x2288 <prvTimerTask+0xdc>

0000240a <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
    240a:	0f 93       	push	r16
    240c:	1f 93       	push	r17
    240e:	cf 93       	push	r28
    2410:	df 93       	push	r29
    2412:	cd b7       	in	r28, 0x3d	; 61
    2414:	de b7       	in	r29, 0x3e	; 62
    2416:	29 97       	sbiw	r28, 0x09	; 9
    2418:	cd bf       	out	0x3d, r28	; 61
    241a:	de bf       	out	0x3e, r29	; 62
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    241c:	ee ef       	ldi	r30, 0xFE	; 254
    241e:	e9 83       	std	Y+1, r30	; 0x01
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    2420:	8a 83       	std	Y+2, r24	; 0x02
    2422:	9b 83       	std	Y+3, r25	; 0x03
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    2424:	6c 83       	std	Y+4, r22	; 0x04
    2426:	7d 83       	std	Y+5, r23	; 0x05
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    2428:	2e 83       	std	Y+6, r18	; 0x06
    242a:	3f 83       	std	Y+7, r19	; 0x07
    242c:	48 87       	std	Y+8, r20	; 0x08
    242e:	59 87       	std	Y+9, r21	; 0x09

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2430:	20 e0       	ldi	r18, 0x00	; 0
    2432:	a8 01       	movw	r20, r16
    2434:	be 01       	movw	r22, r28
    2436:	6f 5f       	subi	r22, 0xFF	; 255
    2438:	7f 4f       	sbci	r23, 0xFF	; 255
    243a:	80 91 c2 2c 	lds	r24, 0x2CC2	; 0x802cc2 <xTimerQueue>
    243e:	90 91 c3 2c 	lds	r25, 0x2CC3	; 0x802cc3 <xTimerQueue+0x1>
    2442:	0e 94 a6 08 	call	0x114c	; 0x114c <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
    2446:	29 96       	adiw	r28, 0x09	; 9
    2448:	cd bf       	out	0x3d, r28	; 61
    244a:	de bf       	out	0x3e, r29	; 62
    244c:	df 91       	pop	r29
    244e:	cf 91       	pop	r28
    2450:	1f 91       	pop	r17
    2452:	0f 91       	pop	r16
    2454:	08 95       	ret

00002456 <vInitClock>:
#include "clksys_driver.h"


void vInitClock(void)
{
	CLKSYS_Enable( OSC_RC2MEN_bm );
    2456:	e0 e5       	ldi	r30, 0x50	; 80
    2458:	f0 e0       	ldi	r31, 0x00	; 0
    245a:	80 81       	ld	r24, Z
    245c:	81 60       	ori	r24, 0x01	; 1
    245e:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC2MRDY_bm ) == 0 );
    2460:	81 81       	ldd	r24, Z+1	; 0x01
    2462:	80 ff       	sbrs	r24, 0
    2464:	fd cf       	rjmp	.-6      	; 0x2460 <vInitClock+0xa>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC2M_gc );
    2466:	80 e0       	ldi	r24, 0x00	; 0
    2468:	0e 94 77 02 	call	0x4ee	; 0x4ee <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
    246c:	8e e1       	ldi	r24, 0x1E	; 30
    246e:	0e 94 67 02 	call	0x4ce	; 0x4ce <CLKSYS_Disable>
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    2472:	60 e0       	ldi	r22, 0x00	; 0
    2474:	80 e0       	ldi	r24, 0x00	; 0
    2476:	0e 94 71 02 	call	0x4e2	; 0x4e2 <CLKSYS_Prescalers_Config>
	CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,false,OSC_XOSCSEL_XTAL_256CLK_gc );
    247a:	43 e0       	ldi	r20, 0x03	; 3
    247c:	60 e0       	ldi	r22, 0x00	; 0
    247e:	80 e4       	ldi	r24, 0x40	; 64
    2480:	0e 94 58 02 	call	0x4b0	; 0x4b0 <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
    2484:	e0 e5       	ldi	r30, 0x50	; 80
    2486:	f0 e0       	ldi	r31, 0x00	; 0
    2488:	80 81       	ld	r24, Z
    248a:	88 60       	ori	r24, 0x08	; 8
    248c:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    248e:	81 81       	ldd	r24, Z+1	; 0x01
    2490:	83 ff       	sbrs	r24, 3
    2492:	fd cf       	rjmp	.-6      	; 0x248e <vInitClock+0x38>
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 4 );
    2494:	64 e0       	ldi	r22, 0x04	; 4
    2496:	80 ec       	ldi	r24, 0xC0	; 192
    2498:	0e 94 62 02 	call	0x4c4	; 0x4c4 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    249c:	e0 e5       	ldi	r30, 0x50	; 80
    249e:	f0 e0       	ldi	r31, 0x00	; 0
    24a0:	80 81       	ld	r24, Z
    24a2:	80 61       	ori	r24, 0x10	; 16
    24a4:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    24a6:	60 e0       	ldi	r22, 0x00	; 0
    24a8:	80 e0       	ldi	r24, 0x00	; 0
    24aa:	0e 94 71 02 	call	0x4e2	; 0x4e2 <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    24ae:	e0 e5       	ldi	r30, 0x50	; 80
    24b0:	f0 e0       	ldi	r31, 0x00	; 0
    24b2:	81 81       	ldd	r24, Z+1	; 0x01
    24b4:	84 ff       	sbrs	r24, 4
    24b6:	fd cf       	rjmp	.-6      	; 0x24b2 <vInitClock+0x5c>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    24b8:	84 e0       	ldi	r24, 0x04	; 4
    24ba:	0e 94 77 02 	call	0x4ee	; 0x4ee <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm);
    24be:	87 e0       	ldi	r24, 0x07	; 7
    24c0:	0e 94 67 02 	call	0x4ce	; 0x4ce <CLKSYS_Disable>
    24c4:	08 95       	ret

000024c6 <vLedBlink>:
	return 0;
}

void vLedBlink(void *pvParameters) {
	(void) pvParameters;
	PORTF.DIRSET = PIN0_bm; /*LED1*/
    24c6:	e0 ea       	ldi	r30, 0xA0	; 160
    24c8:	f6 e0       	ldi	r31, 0x06	; 6
    24ca:	81 e0       	ldi	r24, 0x01	; 1
    24cc:	81 83       	std	Z+1, r24	; 0x01
	PORTF.OUT = 0x01;
    24ce:	84 83       	std	Z+4, r24	; 0x04
	for(;;) {
		//PORTF.OUTTGL = 0x01;				
		vTaskDelay(100 / portTICK_RATE_MS);
    24d0:	64 e6       	ldi	r22, 0x64	; 100
    24d2:	70 e0       	ldi	r23, 0x00	; 0
    24d4:	80 e0       	ldi	r24, 0x00	; 0
    24d6:	90 e0       	ldi	r25, 0x00	; 0
    24d8:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
    24dc:	f9 cf       	rjmp	.-14     	; 0x24d0 <vLedBlink+0xa>

000024de <vWrite_Display>:
void vWrite_Display(void *pvParameters){
	EventBits_t uxBits;
	for (;;)
	{
			vDisplayClear();
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    24de:	0f 2e       	mov	r0, r31
    24e0:	fd e0       	ldi	r31, 0x0D	; 13
    24e2:	ef 2e       	mov	r14, r31
    24e4:	f0 e2       	ldi	r31, 0x20	; 32
    24e6:	ff 2e       	mov	r15, r31
    24e8:	f0 2d       	mov	r31, r0
			vDisplayWriteStringAtPos(1,0,"buffer_a:b %d : %d",buffer_a[1],buffer_b[1]);
    24ea:	0f 2e       	mov	r0, r31
    24ec:	f2 e0       	ldi	r31, 0x02	; 2
    24ee:	af 2e       	mov	r10, r31
    24f0:	ff e2       	ldi	r31, 0x2F	; 47
    24f2:	bf 2e       	mov	r11, r31
    24f4:	f0 2d       	mov	r31, r0
    24f6:	0f 2e       	mov	r0, r31
    24f8:	f4 e0       	ldi	r31, 0x04	; 4
    24fa:	cf 2e       	mov	r12, r31
    24fc:	f7 e3       	ldi	r31, 0x37	; 55
    24fe:	df 2e       	mov	r13, r31
    2500:	f0 2d       	mov	r31, r0
    2502:	0d e1       	ldi	r16, 0x1D	; 29
    2504:	10 e2       	ldi	r17, 0x20	; 32
    2506:	55 24       	eor	r5, r5
    2508:	53 94       	inc	r5
			vDisplayWriteStringAtPos(2,0,"peak: %d  : %d ",high_peak_a,high_peak_b);
    250a:	c0 e3       	ldi	r28, 0x30	; 48
    250c:	d0 e2       	ldi	r29, 0x20	; 32
    250e:	68 94       	set
    2510:	66 24       	eor	r6, r6
    2512:	61 f8       	bld	r6, 1
			vDisplayWriteStringAtPos(3,0,"a:%d   b:%d",count_array_a,count_array_b);
    2514:	0f 2e       	mov	r0, r31
    2516:	f0 e4       	ldi	r31, 0x40	; 64
    2518:	8f 2e       	mov	r8, r31
    251a:	f0 e2       	ldi	r31, 0x20	; 32
    251c:	9f 2e       	mov	r9, r31
    251e:	f0 2d       	mov	r31, r0
    2520:	0f 2e       	mov	r0, r31
    2522:	f3 e0       	ldi	r31, 0x03	; 3
    2524:	7f 2e       	mov	r7, r31
    2526:	f0 2d       	mov	r31, r0
}
void vWrite_Display(void *pvParameters){
	EventBits_t uxBits;
	for (;;)
	{
			vDisplayClear();
    2528:	0e 94 43 16 	call	0x2c86	; 0x2c86 <vDisplayClear>
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    252c:	ff 92       	push	r15
    252e:	ef 92       	push	r14
    2530:	1f 92       	push	r1
    2532:	1f 92       	push	r1
    2534:	1f 92       	push	r1
    2536:	1f 92       	push	r1
    2538:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(1,0,"buffer_a:b %d : %d",buffer_a[1],buffer_b[1]);
    253c:	f5 01       	movw	r30, r10
    253e:	91 81       	ldd	r25, Z+1	; 0x01
    2540:	f6 01       	movw	r30, r12
    2542:	81 81       	ldd	r24, Z+1	; 0x01
    2544:	1f 92       	push	r1
    2546:	9f 93       	push	r25
    2548:	1f 92       	push	r1
    254a:	8f 93       	push	r24
    254c:	1f 93       	push	r17
    254e:	0f 93       	push	r16
    2550:	1f 92       	push	r1
    2552:	1f 92       	push	r1
    2554:	1f 92       	push	r1
    2556:	5f 92       	push	r5
    2558:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(2,0,"peak: %d  : %d ",high_peak_a,high_peak_b);
    255c:	80 91 0c 3f 	lds	r24, 0x3F0C	; 0x803f0c <high_peak_b+0x1>
    2560:	8f 93       	push	r24
    2562:	80 91 0b 3f 	lds	r24, 0x3F0B	; 0x803f0b <high_peak_b>
    2566:	8f 93       	push	r24
    2568:	80 91 08 3f 	lds	r24, 0x3F08	; 0x803f08 <high_peak_a+0x1>
    256c:	8f 93       	push	r24
    256e:	80 91 07 3f 	lds	r24, 0x3F07	; 0x803f07 <high_peak_a>
    2572:	8f 93       	push	r24
    2574:	df 93       	push	r29
    2576:	cf 93       	push	r28
    2578:	1f 92       	push	r1
    257a:	1f 92       	push	r1
    257c:	1f 92       	push	r1
    257e:	6f 92       	push	r6
    2580:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(3,0,"a:%d   b:%d",count_array_a,count_array_b);
    2584:	80 91 01 2f 	lds	r24, 0x2F01	; 0x802f01 <count_array_b+0x1>
    2588:	8f 93       	push	r24
    258a:	80 91 00 2f 	lds	r24, 0x2F00	; 0x802f00 <count_array_b>
    258e:	8f 93       	push	r24
    2590:	80 91 03 37 	lds	r24, 0x3703	; 0x803703 <count_array_a+0x1>
    2594:	8f 93       	push	r24
    2596:	80 91 02 37 	lds	r24, 0x3702	; 0x803702 <count_array_a>
    259a:	8f 93       	push	r24
    259c:	9f 92       	push	r9
    259e:	8f 92       	push	r8
    25a0:	1f 92       	push	r1
    25a2:	1f 92       	push	r1
    25a4:	1f 92       	push	r1
    25a6:	7f 92       	push	r7
    25a8:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <vDisplayWriteStringAtPos>
			vTaskStartScheduler();
    25ac:	ed b7       	in	r30, 0x3d	; 61
    25ae:	fe b7       	in	r31, 0x3e	; 62
    25b0:	b4 96       	adiw	r30, 0x24	; 36
    25b2:	ed bf       	out	0x3d, r30	; 61
    25b4:	fe bf       	out	0x3e, r31	; 62
    25b6:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <vTaskStartScheduler>
			vTaskDelay(100 / portTICK_RATE_MS);
    25ba:	64 e6       	ldi	r22, 0x64	; 100
    25bc:	70 e0       	ldi	r23, 0x00	; 0
    25be:	80 e0       	ldi	r24, 0x00	; 0
    25c0:	90 e0       	ldi	r25, 0x00	; 0
    25c2:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
    25c6:	b0 cf       	rjmp	.-160    	; 0x2528 <vWrite_Display+0x4a>

000025c8 <vRead_DMA>:
	int pos_peak,neg_peak = 0;
	int i = 0;
	EventBits_t uxBits;
	for (;;)
	{			
				uxBits = xEventGroupWaitBits(
    25c8:	cc 24       	eor	r12, r12
    25ca:	ca 94       	dec	r12
    25cc:	dc 2c       	mov	r13, r12
    25ce:	76 01       	movw	r14, r12
    25d0:	00 e0       	ldi	r16, 0x00	; 0
    25d2:	21 e0       	ldi	r18, 0x01	; 1
    25d4:	43 e0       	ldi	r20, 0x03	; 3
    25d6:	50 e0       	ldi	r21, 0x00	; 0
    25d8:	60 e0       	ldi	r22, 0x00	; 0
    25da:	70 e0       	ldi	r23, 0x00	; 0
    25dc:	80 91 04 2e 	lds	r24, 0x2E04	; 0x802e04 <xSignalProcessEventGroup>
    25e0:	90 91 05 2e 	lds	r25, 0x2E05	; 0x802e05 <xSignalProcessEventGroup+0x1>
    25e4:	0e 94 bd 02 	call	0x57a	; 0x57a <xEventGroupWaitBits>
				pdTRUE,        /* Bits should be cleared before returning. */
				pdFALSE,       /* Don't wait for both bits, either bit will do. */
				portMAX_DELAY );/* Wait a maximum for either bit to be set. */
								
		//process signal values
			if (uxBits & Process_Signal_BufferA) // if "BufferA" bit is set, read out bufferA
    25e8:	60 ff       	sbrs	r22, 0
    25ea:	1c c0       	rjmp	.+56     	; 0x2624 <vRead_DMA+0x5c>
    25ec:	40 91 07 3f 	lds	r20, 0x3F07	; 0x803f07 <high_peak_a>
    25f0:	50 91 08 3f 	lds	r21, 0x3F08	; 0x803f08 <high_peak_a+0x1>
    25f4:	80 e0       	ldi	r24, 0x00	; 0
    25f6:	90 e0       	ldi	r25, 0x00	; 0
			{
				for(i=0;i<200;i++)
				{
					if (buffer_a[i] > high_peak_a)
    25f8:	fc 01       	movw	r30, r24
    25fa:	ec 5f       	subi	r30, 0xFC	; 252
    25fc:	f8 4c       	sbci	r31, 0xC8	; 200
    25fe:	20 81       	ld	r18, Z
    2600:	30 e0       	ldi	r19, 0x00	; 0
    2602:	42 17       	cp	r20, r18
    2604:	53 07       	cpc	r21, r19
    2606:	2c f4       	brge	.+10     	; 0x2612 <vRead_DMA+0x4a>
						{
							high_peak_a = buffer_a[i];
    2608:	fc 01       	movw	r30, r24
    260a:	ec 5f       	subi	r30, 0xFC	; 252
    260c:	f8 4c       	sbci	r31, 0xC8	; 200
    260e:	40 81       	ld	r20, Z
    2610:	50 e0       	ldi	r21, 0x00	; 0
				portMAX_DELAY );/* Wait a maximum for either bit to be set. */
								
		//process signal values
			if (uxBits & Process_Signal_BufferA) // if "BufferA" bit is set, read out bufferA
			{
				for(i=0;i<200;i++)
    2612:	01 96       	adiw	r24, 0x01	; 1
    2614:	88 3c       	cpi	r24, 0xC8	; 200
    2616:	91 05       	cpc	r25, r1
    2618:	79 f7       	brne	.-34     	; 0x25f8 <vRead_DMA+0x30>
    261a:	40 93 07 3f 	sts	0x3F07, r20	; 0x803f07 <high_peak_a>
    261e:	50 93 08 3f 	sts	0x3F08, r21	; 0x803f08 <high_peak_a+0x1>
    2622:	1b c0       	rjmp	.+54     	; 0x265a <vRead_DMA+0x92>
    2624:	40 91 0b 3f 	lds	r20, 0x3F0B	; 0x803f0b <high_peak_b>
    2628:	50 91 0c 3f 	lds	r21, 0x3F0C	; 0x803f0c <high_peak_b+0x1>
				pdTRUE,        /* Bits should be cleared before returning. */
				pdFALSE,       /* Don't wait for both bits, either bit will do. */
				portMAX_DELAY );/* Wait a maximum for either bit to be set. */
								
		//process signal values
			if (uxBits & Process_Signal_BufferA) // if "BufferA" bit is set, read out bufferA
    262c:	80 e0       	ldi	r24, 0x00	; 0
    262e:	90 e0       	ldi	r25, 0x00	; 0
			}
			else
			{
				for (i=0;i<200;i++)
				{
					if (buffer_b[i] > high_peak_b)
    2630:	fc 01       	movw	r30, r24
    2632:	ee 5f       	subi	r30, 0xFE	; 254
    2634:	f0 4d       	sbci	r31, 0xD0	; 208
    2636:	20 81       	ld	r18, Z
    2638:	30 e0       	ldi	r19, 0x00	; 0
    263a:	42 17       	cp	r20, r18
    263c:	53 07       	cpc	r21, r19
    263e:	2c f4       	brge	.+10     	; 0x264a <vRead_DMA+0x82>
						{
							high_peak_b = buffer_b[i];
    2640:	fc 01       	movw	r30, r24
    2642:	ee 5f       	subi	r30, 0xFE	; 254
    2644:	f0 4d       	sbci	r31, 0xD0	; 208
    2646:	40 81       	ld	r20, Z
    2648:	50 e0       	ldi	r21, 0x00	; 0
						}				
				}
			}
			else
			{
				for (i=0;i<200;i++)
    264a:	01 96       	adiw	r24, 0x01	; 1
    264c:	88 3c       	cpi	r24, 0xC8	; 200
    264e:	91 05       	cpc	r25, r1
    2650:	79 f7       	brne	.-34     	; 0x2630 <vRead_DMA+0x68>
    2652:	40 93 0b 3f 	sts	0x3F0B, r20	; 0x803f0b <high_peak_b>
    2656:	50 93 0c 3f 	sts	0x3F0C, r21	; 0x803f0c <high_peak_b+0x1>
						{
							high_peak_b = buffer_b[i];
						}
				}
			}
		vTaskDelay(100 / portTICK_RATE_MS);
    265a:	64 e6       	ldi	r22, 0x64	; 100
    265c:	70 e0       	ldi	r23, 0x00	; 0
    265e:	80 e0       	ldi	r24, 0x00	; 0
    2660:	90 e0       	ldi	r25, 0x00	; 0
    2662:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
	}
    2666:	b0 cf       	rjmp	.-160    	; 0x25c8 <vRead_DMA>

00002668 <vApplicationIdleHook>:
TaskHandle_t TaskDMAHandler;

int high_peak_a, high_peak_b,low_peak_a,low_peak_b;

void vApplicationIdleHook( void )
{	
    2668:	08 95       	ret

0000266a <main>:
	
}

int main(void)
{
    266a:	ef 92       	push	r14
    266c:	ff 92       	push	r15
    266e:	0f 93       	push	r16
    2670:	cf 93       	push	r28
    resetReason_t reason = getResetReason();
    2672:	0e 94 80 1a 	call	0x3500	; 0x3500 <getResetReason>
    2676:	c8 2f       	mov	r28, r24

	vInitClock();
    2678:	0e 94 2b 12 	call	0x2456	; 0x2456 <vInitClock>
	vInitDisplay();
    267c:	0e 94 c7 14 	call	0x298e	; 0x298e <vInitDisplay>
	
	xTaskCreate( vLedBlink, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+10, NULL, 1, &ledTask);
    2680:	0f 2e       	mov	r0, r31
    2682:	f9 e0       	ldi	r31, 0x09	; 9
    2684:	ef 2e       	mov	r14, r31
    2686:	ff e3       	ldi	r31, 0x3F	; 63
    2688:	ff 2e       	mov	r15, r31
    268a:	f0 2d       	mov	r31, r0
    268c:	01 e0       	ldi	r16, 0x01	; 1
    268e:	20 e0       	ldi	r18, 0x00	; 0
    2690:	30 e0       	ldi	r19, 0x00	; 0
    2692:	42 ed       	ldi	r20, 0xD2	; 210
    2694:	50 e0       	ldi	r21, 0x00	; 0
    2696:	6c e4       	ldi	r22, 0x4C	; 76
    2698:	70 e2       	ldi	r23, 0x20	; 32
    269a:	83 e6       	ldi	r24, 0x63	; 99
    269c:	92 e1       	ldi	r25, 0x12	; 18
    269e:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xTaskCreate( vRead_DMA, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+10, NULL, 1, &my_read_DMA);
    26a2:	0f 2e       	mov	r0, r31
    26a4:	ff e0       	ldi	r31, 0x0F	; 15
    26a6:	ef 2e       	mov	r14, r31
    26a8:	ff e3       	ldi	r31, 0x3F	; 63
    26aa:	ff 2e       	mov	r15, r31
    26ac:	f0 2d       	mov	r31, r0
    26ae:	20 e0       	ldi	r18, 0x00	; 0
    26b0:	30 e0       	ldi	r19, 0x00	; 0
    26b2:	42 ed       	ldi	r20, 0xD2	; 210
    26b4:	50 e0       	ldi	r21, 0x00	; 0
    26b6:	6c e4       	ldi	r22, 0x4C	; 76
    26b8:	70 e2       	ldi	r23, 0x20	; 32
    26ba:	84 ee       	ldi	r24, 0xE4	; 228
    26bc:	92 e1       	ldi	r25, 0x12	; 18
    26be:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xTaskCreate( vWrite_Display, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+10, NULL, 1, &my_Display);
    26c2:	0f 2e       	mov	r0, r31
    26c4:	f1 e1       	ldi	r31, 0x11	; 17
    26c6:	ef 2e       	mov	r14, r31
    26c8:	ff e3       	ldi	r31, 0x3F	; 63
    26ca:	ff 2e       	mov	r15, r31
    26cc:	f0 2d       	mov	r31, r0
    26ce:	20 e0       	ldi	r18, 0x00	; 0
    26d0:	30 e0       	ldi	r19, 0x00	; 0
    26d2:	42 ed       	ldi	r20, 0xD2	; 210
    26d4:	50 e0       	ldi	r21, 0x00	; 0
    26d6:	6c e4       	ldi	r22, 0x4C	; 76
    26d8:	70 e2       	ldi	r23, 0x20	; 32
    26da:	8f e6       	ldi	r24, 0x6F	; 111
    26dc:	92 e1       	ldi	r25, 0x12	; 18
    26de:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xTaskCreate( vTask_DMAHandler, (const char *) "dmaHandler", configMINIMAL_STACK_SIZE + 100, NULL, 1, &TaskDMAHandler);		
    26e2:	0f 2e       	mov	r0, r31
    26e4:	f3 e1       	ldi	r31, 0x13	; 19
    26e6:	ef 2e       	mov	r14, r31
    26e8:	ff e3       	ldi	r31, 0x3F	; 63
    26ea:	ff 2e       	mov	r15, r31
    26ec:	f0 2d       	mov	r31, r0
    26ee:	20 e0       	ldi	r18, 0x00	; 0
    26f0:	30 e0       	ldi	r19, 0x00	; 0
    26f2:	4c e2       	ldi	r20, 0x2C	; 44
    26f4:	51 e0       	ldi	r21, 0x01	; 1
    26f6:	65 e5       	ldi	r22, 0x55	; 85
    26f8:	70 e2       	ldi	r23, 0x20	; 32
    26fa:	81 ef       	ldi	r24, 0xF1	; 241
    26fc:	99 e1       	ldi	r25, 0x19	; 25
    26fe:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
	xSignalProcessEventGroup = xEventGroupCreate();
    2702:	0e 94 a8 02 	call	0x550	; 0x550 <xEventGroupCreate>
    2706:	80 93 04 2e 	sts	0x2E04, r24	; 0x802e04 <xSignalProcessEventGroup>
    270a:	90 93 05 2e 	sts	0x2E05, r25	; 0x802e05 <xSignalProcessEventGroup+0x1>
	vInitDMA();			
    270e:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <vInitDMA>

	vDisplayClear();
    2712:	0e 94 43 16 	call	0x2c86	; 0x2c86 <vDisplayClear>
	vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    2716:	8d e0       	ldi	r24, 0x0D	; 13
    2718:	90 e2       	ldi	r25, 0x20	; 32
    271a:	9f 93       	push	r25
    271c:	8f 93       	push	r24
    271e:	1f 92       	push	r1
    2720:	1f 92       	push	r1
    2722:	1f 92       	push	r1
    2724:	1f 92       	push	r1
    2726:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(1,0,"EDUBoard 1.0");
    272a:	80 e6       	ldi	r24, 0x60	; 96
    272c:	90 e2       	ldi	r25, 0x20	; 32
    272e:	9f 93       	push	r25
    2730:	8f 93       	push	r24
    2732:	1f 92       	push	r1
    2734:	1f 92       	push	r1
    2736:	1f 92       	push	r1
    2738:	81 e0       	ldi	r24, 0x01	; 1
    273a:	8f 93       	push	r24
    273c:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(2,0,"Template");
    2740:	8d e6       	ldi	r24, 0x6D	; 109
    2742:	90 e2       	ldi	r25, 0x20	; 32
    2744:	9f 93       	push	r25
    2746:	8f 93       	push	r24
    2748:	1f 92       	push	r1
    274a:	1f 92       	push	r1
    274c:	1f 92       	push	r1
    274e:	82 e0       	ldi	r24, 0x02	; 2
    2750:	8f 93       	push	r24
    2752:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(3,0,"ResetReason: %d", reason);
    2756:	1f 92       	push	r1
    2758:	cf 93       	push	r28
    275a:	86 e7       	ldi	r24, 0x76	; 118
    275c:	90 e2       	ldi	r25, 0x20	; 32
    275e:	9f 93       	push	r25
    2760:	8f 93       	push	r24
    2762:	1f 92       	push	r1
    2764:	1f 92       	push	r1
    2766:	1f 92       	push	r1
    2768:	83 e0       	ldi	r24, 0x03	; 3
    276a:	8f 93       	push	r24
    276c:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <vDisplayWriteStringAtPos>
	vTaskStartScheduler();
    2770:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <vTaskStartScheduler>
    2774:	8d b7       	in	r24, 0x3d	; 61
    2776:	9e b7       	in	r25, 0x3e	; 62
    2778:	4a 96       	adiw	r24, 0x1a	; 26
    277a:	8d bf       	out	0x3d, r24	; 61
    277c:	9e bf       	out	0x3e, r25	; 62
	return 0;
}
    277e:	80 e0       	ldi	r24, 0x00	; 0
    2780:	90 e0       	ldi	r25, 0x00	; 0
    2782:	cf 91       	pop	r28
    2784:	0f 91       	pop	r16
    2786:	ff 90       	pop	r15
    2788:	ef 90       	pop	r14
    278a:	08 95       	ret

0000278c <__vector_108>:
 void displayHome() {
	 command(0x02);
 }
 void _displayClear() {
	 command(0x01);
	 delayUS(2000);
    278c:	1f 92       	push	r1
    278e:	0f 92       	push	r0
    2790:	0f b6       	in	r0, 0x3f	; 63
    2792:	0f 92       	push	r0
    2794:	11 24       	eor	r1, r1
    2796:	0b b6       	in	r0, 0x3b	; 59
    2798:	0f 92       	push	r0
    279a:	2f 93       	push	r18
    279c:	3f 93       	push	r19
    279e:	4f 93       	push	r20
    27a0:	5f 93       	push	r21
    27a2:	6f 93       	push	r22
    27a4:	7f 93       	push	r23
    27a6:	8f 93       	push	r24
    27a8:	9f 93       	push	r25
    27aa:	af 93       	push	r26
    27ac:	bf 93       	push	r27
    27ae:	ef 93       	push	r30
    27b0:	ff 93       	push	r31
    27b2:	cf 93       	push	r28
    27b4:	df 93       	push	r29
    27b6:	1f 92       	push	r1
    27b8:	cd b7       	in	r28, 0x3d	; 61
    27ba:	de b7       	in	r29, 0x3e	; 62
    27bc:	19 82       	std	Y+1, r1	; 0x01
    27be:	9e 01       	movw	r18, r28
    27c0:	2f 5f       	subi	r18, 0xFF	; 255
    27c2:	3f 4f       	sbci	r19, 0xFF	; 255
    27c4:	41 e0       	ldi	r20, 0x01	; 1
    27c6:	50 e0       	ldi	r21, 0x00	; 0
    27c8:	60 e0       	ldi	r22, 0x00	; 0
    27ca:	70 e0       	ldi	r23, 0x00	; 0
    27cc:	80 91 17 3f 	lds	r24, 0x3F17	; 0x803f17 <egDisplayTiming>
    27d0:	90 91 18 3f 	lds	r25, 0x3F18	; 0x803f18 <egDisplayTiming+0x1>
    27d4:	0e 94 38 04 	call	0x870	; 0x870 <xEventGroupSetBitsFromISR>
    27d8:	60 e0       	ldi	r22, 0x00	; 0
    27da:	80 e0       	ldi	r24, 0x00	; 0
    27dc:	9b e0       	ldi	r25, 0x0B	; 11
    27de:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
    27e2:	10 92 06 0b 	sts	0x0B06, r1	; 0x800b06 <__TEXT_REGION_LENGTH__+0x700b06>
    27e6:	0f 90       	pop	r0
    27e8:	df 91       	pop	r29
    27ea:	cf 91       	pop	r28
    27ec:	ff 91       	pop	r31
    27ee:	ef 91       	pop	r30
    27f0:	bf 91       	pop	r27
    27f2:	af 91       	pop	r26
    27f4:	9f 91       	pop	r25
    27f6:	8f 91       	pop	r24
    27f8:	7f 91       	pop	r23
    27fa:	6f 91       	pop	r22
    27fc:	5f 91       	pop	r21
    27fe:	4f 91       	pop	r20
    2800:	3f 91       	pop	r19
    2802:	2f 91       	pop	r18
    2804:	0f 90       	pop	r0
    2806:	0b be       	out	0x3b, r0	; 59
    2808:	0f 90       	pop	r0
    280a:	0f be       	out	0x3f, r0	; 63
    280c:	0f 90       	pop	r0
    280e:	1f 90       	pop	r1
    2810:	18 95       	reti

00002812 <delayUS>:
    2812:	cf 92       	push	r12
    2814:	df 92       	push	r13
    2816:	ef 92       	push	r14
    2818:	ff 92       	push	r15
    281a:	0f 93       	push	r16
    281c:	6b 01       	movw	r12, r22
    281e:	7c 01       	movw	r14, r24
    2820:	82 e0       	ldi	r24, 0x02	; 2
    2822:	c8 16       	cp	r12, r24
    2824:	d1 04       	cpc	r13, r1
    2826:	e1 04       	cpc	r14, r1
    2828:	f1 04       	cpc	r15, r1
    282a:	08 f4       	brcc	.+2      	; 0x282e <delayUS+0x1c>
    282c:	4e c0       	rjmp	.+156    	; 0x28ca <delayUS+0xb8>
    282e:	e0 e0       	ldi	r30, 0x00	; 0
    2830:	fb e0       	ldi	r31, 0x0B	; 11
    2832:	81 e0       	ldi	r24, 0x01	; 1
    2834:	86 83       	std	Z+6, r24	; 0x06
    2836:	10 a2       	std	Z+32, r1	; 0x20
    2838:	11 a2       	std	Z+33, r1	; 0x21
    283a:	60 e0       	ldi	r22, 0x00	; 0
    283c:	80 e0       	ldi	r24, 0x00	; 0
    283e:	9b e0       	ldi	r25, 0x0B	; 11
    2840:	0e 94 92 02 	call	0x524	; 0x524 <TC0_ConfigWGM>
    2844:	8e ef       	ldi	r24, 0xFE	; 254
    2846:	c8 16       	cp	r12, r24
    2848:	8f ef       	ldi	r24, 0xFF	; 255
    284a:	d8 06       	cpc	r13, r24
    284c:	e1 04       	cpc	r14, r1
    284e:	f1 04       	cpc	r15, r1
    2850:	70 f4       	brcc	.+28     	; 0x286e <delayUS+0x5c>
    2852:	f6 94       	lsr	r15
    2854:	e7 94       	ror	r14
    2856:	d7 94       	ror	r13
    2858:	c7 94       	ror	r12
    285a:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    285e:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2862:	65 e0       	ldi	r22, 0x05	; 5
    2864:	80 e0       	ldi	r24, 0x00	; 0
    2866:	9b e0       	ldi	r25, 0x0B	; 11
    2868:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
    286c:	19 c0       	rjmp	.+50     	; 0x28a0 <delayUS+0x8e>
    286e:	80 e4       	ldi	r24, 0x40	; 64
    2870:	c8 16       	cp	r12, r24
    2872:	82 e4       	ldi	r24, 0x42	; 66
    2874:	d8 06       	cpc	r13, r24
    2876:	8f e0       	ldi	r24, 0x0F	; 15
    2878:	e8 06       	cpc	r14, r24
    287a:	f1 04       	cpc	r15, r1
    287c:	88 f4       	brcc	.+34     	; 0x28a0 <delayUS+0x8e>
    287e:	68 94       	set
    2880:	14 f8       	bld	r1, 4
    2882:	f6 94       	lsr	r15
    2884:	e7 94       	ror	r14
    2886:	d7 94       	ror	r13
    2888:	c7 94       	ror	r12
    288a:	16 94       	lsr	r1
    288c:	d1 f7       	brne	.-12     	; 0x2882 <delayUS+0x70>
    288e:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2892:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2896:	67 e0       	ldi	r22, 0x07	; 7
    2898:	80 e0       	ldi	r24, 0x00	; 0
    289a:	9b e0       	ldi	r25, 0x0B	; 11
    289c:	0e 94 8c 02 	call	0x518	; 0x518 <TC0_ConfigClockSource>
    28a0:	0f 2e       	mov	r0, r31
    28a2:	f4 ef       	ldi	r31, 0xF4	; 244
    28a4:	cf 2e       	mov	r12, r31
    28a6:	dd 24       	eor	r13, r13
    28a8:	d3 94       	inc	r13
    28aa:	e1 2c       	mov	r14, r1
    28ac:	f1 2c       	mov	r15, r1
    28ae:	f0 2d       	mov	r31, r0
    28b0:	00 e0       	ldi	r16, 0x00	; 0
    28b2:	21 e0       	ldi	r18, 0x01	; 1
    28b4:	41 e0       	ldi	r20, 0x01	; 1
    28b6:	50 e0       	ldi	r21, 0x00	; 0
    28b8:	60 e0       	ldi	r22, 0x00	; 0
    28ba:	70 e0       	ldi	r23, 0x00	; 0
    28bc:	80 91 17 3f 	lds	r24, 0x3F17	; 0x803f17 <egDisplayTiming>
    28c0:	90 91 18 3f 	lds	r25, 0x3F18	; 0x803f18 <egDisplayTiming+0x1>
    28c4:	0e 94 bd 02 	call	0x57a	; 0x57a <xEventGroupWaitBits>
    28c8:	11 c0       	rjmp	.+34     	; 0x28ec <delayUS+0xda>
    28ca:	e0 e0       	ldi	r30, 0x00	; 0
    28cc:	fb e0       	ldi	r31, 0x0B	; 11
    28ce:	81 e0       	ldi	r24, 0x01	; 1
    28d0:	86 83       	std	Z+6, r24	; 0x06
    28d2:	10 a2       	std	Z+32, r1	; 0x20
    28d4:	11 a2       	std	Z+33, r1	; 0x21
    28d6:	60 e0       	ldi	r22, 0x00	; 0
    28d8:	80 e0       	ldi	r24, 0x00	; 0
    28da:	9b e0       	ldi	r25, 0x0B	; 11
    28dc:	0e 94 92 02 	call	0x524	; 0x524 <TC0_ConfigWGM>
    28e0:	c1 2c       	mov	r12, r1
    28e2:	d1 2c       	mov	r13, r1
    28e4:	76 01       	movw	r14, r12
    28e6:	68 94       	set
    28e8:	c1 f8       	bld	r12, 1
    28ea:	b3 cf       	rjmp	.-154    	; 0x2852 <delayUS+0x40>
    28ec:	0f 91       	pop	r16
    28ee:	ff 90       	pop	r15
    28f0:	ef 90       	pop	r14
    28f2:	df 90       	pop	r13
    28f4:	cf 90       	pop	r12
    28f6:	08 95       	ret

000028f8 <setPort>:
    28f8:	82 95       	swap	r24
    28fa:	80 7f       	andi	r24, 0xF0	; 240
    28fc:	e0 e0       	ldi	r30, 0x00	; 0
    28fe:	f6 e0       	ldi	r31, 0x06	; 6
    2900:	94 81       	ldd	r25, Z+4	; 0x04
    2902:	28 2f       	mov	r18, r24
    2904:	2f 60       	ori	r18, 0x0F	; 15
    2906:	92 23       	and	r25, r18
    2908:	94 83       	std	Z+4, r25	; 0x04
    290a:	94 81       	ldd	r25, Z+4	; 0x04
    290c:	89 2b       	or	r24, r25
    290e:	84 83       	std	Z+4, r24	; 0x04
    2910:	08 95       	ret

00002912 <Nybble>:
    2912:	1f 93       	push	r17
    2914:	cf 93       	push	r28
    2916:	df 93       	push	r29
    2918:	c0 e6       	ldi	r28, 0x60	; 96
    291a:	d6 e0       	ldi	r29, 0x06	; 6
    291c:	14 e0       	ldi	r17, 0x04	; 4
    291e:	1d 83       	std	Y+5, r17	; 0x05
    2920:	61 e0       	ldi	r22, 0x01	; 1
    2922:	70 e0       	ldi	r23, 0x00	; 0
    2924:	80 e0       	ldi	r24, 0x00	; 0
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	0e 94 09 14 	call	0x2812	; 0x2812 <delayUS>
    292c:	1e 83       	std	Y+6, r17	; 0x06
    292e:	df 91       	pop	r29
    2930:	cf 91       	pop	r28
    2932:	1f 91       	pop	r17
    2934:	08 95       	ret

00002936 <command>:
    2936:	cf 93       	push	r28
    2938:	c8 2f       	mov	r28, r24
    293a:	82 95       	swap	r24
    293c:	8f 70       	andi	r24, 0x0F	; 15
    293e:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <setPort>
    2942:	e0 e6       	ldi	r30, 0x60	; 96
    2944:	f6 e0       	ldi	r31, 0x06	; 6
    2946:	81 e0       	ldi	r24, 0x01	; 1
    2948:	86 83       	std	Z+6, r24	; 0x06
    294a:	82 e0       	ldi	r24, 0x02	; 2
    294c:	86 83       	std	Z+6, r24	; 0x06
    294e:	0e 94 89 14 	call	0x2912	; 0x2912 <Nybble>
    2952:	8c 2f       	mov	r24, r28
    2954:	8f 70       	andi	r24, 0x0F	; 15
    2956:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <setPort>
    295a:	0e 94 89 14 	call	0x2912	; 0x2912 <Nybble>
    295e:	cf 91       	pop	r28
    2960:	08 95       	ret

00002962 <write>:
    2962:	cf 93       	push	r28
    2964:	c8 2f       	mov	r28, r24
    2966:	82 95       	swap	r24
    2968:	8f 70       	andi	r24, 0x0F	; 15
    296a:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <setPort>
    296e:	e0 e6       	ldi	r30, 0x60	; 96
    2970:	f6 e0       	ldi	r31, 0x06	; 6
    2972:	81 e0       	ldi	r24, 0x01	; 1
    2974:	85 83       	std	Z+5, r24	; 0x05
    2976:	82 e0       	ldi	r24, 0x02	; 2
    2978:	86 83       	std	Z+6, r24	; 0x06
    297a:	0e 94 89 14 	call	0x2912	; 0x2912 <Nybble>
    297e:	8c 2f       	mov	r24, r28
    2980:	8f 70       	andi	r24, 0x0F	; 15
    2982:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <setPort>
    2986:	0e 94 89 14 	call	0x2912	; 0x2912 <Nybble>
    298a:	cf 91       	pop	r28
    298c:	08 95       	ret

0000298e <vInitDisplay>:
 }
 
 void vInitDisplay() {
    298e:	ef 92       	push	r14
    2990:	ff 92       	push	r15
    2992:	0f 93       	push	r16
	PORTA.DIRSET = PIN4_bm;
    2994:	e0 e0       	ldi	r30, 0x00	; 0
    2996:	f6 e0       	ldi	r31, 0x06	; 6
    2998:	80 e1       	ldi	r24, 0x10	; 16
    299a:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN5_bm;
    299c:	80 e2       	ldi	r24, 0x20	; 32
    299e:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN6_bm;
    29a0:	80 e4       	ldi	r24, 0x40	; 64
    29a2:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN7_bm;
    29a4:	80 e8       	ldi	r24, 0x80	; 128
    29a6:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN0_bm;
    29a8:	a0 e6       	ldi	r26, 0x60	; 96
    29aa:	b6 e0       	ldi	r27, 0x06	; 6
    29ac:	81 e0       	ldi	r24, 0x01	; 1
    29ae:	11 96       	adiw	r26, 0x01	; 1
    29b0:	8c 93       	st	X, r24
    29b2:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN1_bm;
    29b4:	82 e0       	ldi	r24, 0x02	; 2
    29b6:	11 96       	adiw	r26, 0x01	; 1
    29b8:	8c 93       	st	X, r24
    29ba:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN2_bm;
    29bc:	84 e0       	ldi	r24, 0x04	; 4
    29be:	11 96       	adiw	r26, 0x01	; 1
    29c0:	8c 93       	st	X, r24
    29c2:	11 97       	sbiw	r26, 0x01	; 1
	PORTA.OUT &= 0x0F;
    29c4:	84 81       	ldd	r24, Z+4	; 0x04
    29c6:	8f 70       	andi	r24, 0x0F	; 15
    29c8:	84 83       	std	Z+4, r24	; 0x04
	PORTD.OUT &= 0xF8;
    29ca:	14 96       	adiw	r26, 0x04	; 4
    29cc:	8c 91       	ld	r24, X
    29ce:	14 97       	sbiw	r26, 0x04	; 4
    29d0:	88 7f       	andi	r24, 0xF8	; 248
    29d2:	14 96       	adiw	r26, 0x04	; 4
    29d4:	8c 93       	st	X, r24

	if((displayLineQueue = xQueueCreate(DISPLAY_QUEUE_DEPTH, sizeof(displayLine_t))) == NULL)
    29d6:	40 e0       	ldi	r20, 0x00	; 0
    29d8:	66 e1       	ldi	r22, 0x16	; 22
    29da:	88 e0       	ldi	r24, 0x08	; 8
    29dc:	0e 94 cf 07 	call	0xf9e	; 0xf9e <xQueueGenericCreate>
    29e0:	80 93 15 3f 	sts	0x3F15, r24	; 0x803f15 <displayLineQueue>
    29e4:	90 93 16 3f 	sts	0x3F16, r25	; 0x803f16 <displayLineQueue+0x1>
	{
		//error(ERR_QUEUE_CREATE_HANDLE_NULL);
	}
	
	egDisplayTiming = xEventGroupCreate();
    29e8:	0e 94 a8 02 	call	0x550	; 0x550 <xEventGroupCreate>
    29ec:	80 93 17 3f 	sts	0x3F17, r24	; 0x803f17 <egDisplayTiming>
    29f0:	90 93 18 3f 	sts	0x3F18, r25	; 0x803f18 <egDisplayTiming+0x1>
	

	xTaskCreate(vDisplayUpdateTask, (const char*) "dispUpdate", configMINIMAL_STACK_SIZE+150, NULL, 1, NULL);	
    29f4:	e1 2c       	mov	r14, r1
    29f6:	f1 2c       	mov	r15, r1
    29f8:	01 e0       	ldi	r16, 0x01	; 1
    29fa:	20 e0       	ldi	r18, 0x00	; 0
    29fc:	30 e0       	ldi	r19, 0x00	; 0
    29fe:	4e e5       	ldi	r20, 0x5E	; 94
    2a00:	51 e0       	ldi	r21, 0x01	; 1
    2a02:	66 e8       	ldi	r22, 0x86	; 134
    2a04:	70 e2       	ldi	r23, 0x20	; 32
    2a06:	85 e6       	ldi	r24, 0x65	; 101
    2a08:	95 e1       	ldi	r25, 0x15	; 21
    2a0a:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <xTaskCreate>
 }
    2a0e:	0f 91       	pop	r16
    2a10:	ff 90       	pop	r15
    2a12:	ef 90       	pop	r14
    2a14:	08 95       	ret

00002a16 <_displaySetPos>:
 
 void _displaySetPos(int line, int pos) {
	 switch(line) {
    2a16:	81 30       	cpi	r24, 0x01	; 1
    2a18:	91 05       	cpc	r25, r1
    2a1a:	79 f0       	breq	.+30     	; 0x2a3a <_displaySetPos+0x24>
    2a1c:	1c f4       	brge	.+6      	; 0x2a24 <_displaySetPos+0xe>
    2a1e:	89 2b       	or	r24, r25
    2a20:	39 f0       	breq	.+14     	; 0x2a30 <_displaySetPos+0x1a>
    2a22:	19 c0       	rjmp	.+50     	; 0x2a56 <_displaySetPos+0x40>
    2a24:	82 30       	cpi	r24, 0x02	; 2
    2a26:	91 05       	cpc	r25, r1
    2a28:	69 f0       	breq	.+26     	; 0x2a44 <_displaySetPos+0x2e>
    2a2a:	03 97       	sbiw	r24, 0x03	; 3
    2a2c:	81 f0       	breq	.+32     	; 0x2a4e <_displaySetPos+0x38>
    2a2e:	13 c0       	rjmp	.+38     	; 0x2a56 <_displaySetPos+0x40>
		 case 0:
		 command(0x80 + 0x00 + pos);
    2a30:	80 e8       	ldi	r24, 0x80	; 128
    2a32:	86 0f       	add	r24, r22
    2a34:	0e 94 9b 14 	call	0x2936	; 0x2936 <command>
		 break;
    2a38:	0e c0       	rjmp	.+28     	; 0x2a56 <_displaySetPos+0x40>
		 case 1:
		 command(0x80 + 0x40 + pos);
    2a3a:	80 ec       	ldi	r24, 0xC0	; 192
    2a3c:	86 0f       	add	r24, r22
    2a3e:	0e 94 9b 14 	call	0x2936	; 0x2936 <command>
		 break;
    2a42:	09 c0       	rjmp	.+18     	; 0x2a56 <_displaySetPos+0x40>
		 case 2:
		 command(0x80 + 0x14 + pos);
    2a44:	84 e9       	ldi	r24, 0x94	; 148
    2a46:	86 0f       	add	r24, r22
    2a48:	0e 94 9b 14 	call	0x2936	; 0x2936 <command>
		 break;
    2a4c:	04 c0       	rjmp	.+8      	; 0x2a56 <_displaySetPos+0x40>
		 case 3:
		 command(0x80 + 0x54 + pos);
    2a4e:	84 ed       	ldi	r24, 0xD4	; 212
    2a50:	86 0f       	add	r24, r22
    2a52:	0e 94 9b 14 	call	0x2936	; 0x2936 <command>
		 break;
	 }
	 delayUS(39);
    2a56:	67 e2       	ldi	r22, 0x27	; 39
    2a58:	70 e0       	ldi	r23, 0x00	; 0
    2a5a:	80 e0       	ldi	r24, 0x00	; 0
    2a5c:	90 e0       	ldi	r25, 0x00	; 0
    2a5e:	0e 94 09 14 	call	0x2812	; 0x2812 <delayUS>
    2a62:	08 95       	ret

00002a64 <_displayWriteChar>:
 }

 void _displayWriteChar(char c) {
	 write(c);
    2a64:	0e 94 b1 14 	call	0x2962	; 0x2962 <write>
	 delayUS(43);
    2a68:	6b e2       	ldi	r22, 0x2B	; 43
    2a6a:	70 e0       	ldi	r23, 0x00	; 0
    2a6c:	80 e0       	ldi	r24, 0x00	; 0
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
    2a70:	0e 94 09 14 	call	0x2812	; 0x2812 <delayUS>
    2a74:	08 95       	ret

00002a76 <_displayWriteString>:
 }
 
 void _displayWriteString(char* s) {
    2a76:	0f 93       	push	r16
    2a78:	1f 93       	push	r17
    2a7a:	cf 93       	push	r28
    2a7c:	df 93       	push	r29
    2a7e:	fc 01       	movw	r30, r24
	 for(int i = 0; i < 20; i++) {
		 if(s[i] == '\0') {
    2a80:	80 81       	ld	r24, Z
    2a82:	81 11       	cpse	r24, r1
    2a84:	0a c0       	rjmp	.+20     	; 0x2a9a <_displayWriteString+0x24>
    2a86:	11 c0       	rjmp	.+34     	; 0x2aaa <_displayWriteString+0x34>
    2a88:	89 91       	ld	r24, Y+
    2a8a:	88 23       	and	r24, r24
    2a8c:	71 f0       	breq	.+28     	; 0x2aaa <_displayWriteString+0x34>
			 break;
		 }
		 _displayWriteChar(s[i]);
    2a8e:	0e 94 32 15 	call	0x2a64	; 0x2a64 <_displayWriteChar>
	 write(c);
	 delayUS(43);
 }
 
 void _displayWriteString(char* s) {
	 for(int i = 0; i < 20; i++) {
    2a92:	0c 17       	cp	r16, r28
    2a94:	1d 07       	cpc	r17, r29
    2a96:	c1 f7       	brne	.-16     	; 0x2a88 <_displayWriteString+0x12>
    2a98:	08 c0       	rjmp	.+16     	; 0x2aaa <_displayWriteString+0x34>
    2a9a:	8f 01       	movw	r16, r30
		 if(s[i] == '\0') {
			 break;
		 }
		 _displayWriteChar(s[i]);
    2a9c:	0e 94 32 15 	call	0x2a64	; 0x2a64 <_displayWriteChar>
    2aa0:	e8 01       	movw	r28, r16
    2aa2:	21 96       	adiw	r28, 0x01	; 1
    2aa4:	0c 5e       	subi	r16, 0xEC	; 236
    2aa6:	1f 4f       	sbci	r17, 0xFF	; 255
    2aa8:	ef cf       	rjmp	.-34     	; 0x2a88 <_displayWriteString+0x12>
	 }
 }
    2aaa:	df 91       	pop	r29
    2aac:	cf 91       	pop	r28
    2aae:	1f 91       	pop	r17
    2ab0:	0f 91       	pop	r16
    2ab2:	08 95       	ret

00002ab4 <_displayWriteStringAtPos>:

 void _displayWriteStringAtPos(int line, int pos, char* s) {
    2ab4:	cf 93       	push	r28
    2ab6:	df 93       	push	r29
    2ab8:	ea 01       	movw	r28, r20
	 _displaySetPos(line, pos);
    2aba:	0e 94 0b 15 	call	0x2a16	; 0x2a16 <_displaySetPos>
	 _displayWriteString(s);
    2abe:	ce 01       	movw	r24, r28
    2ac0:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <_displayWriteString>
 }
    2ac4:	df 91       	pop	r29
    2ac6:	cf 91       	pop	r28
    2ac8:	08 95       	ret

00002aca <vDisplayUpdateTask>:

 void vDisplayUpdateTask(void *pvParameters) {
    2aca:	cf 93       	push	r28
    2acc:	df 93       	push	r29
    2ace:	cd b7       	in	r28, 0x3d	; 61
    2ad0:	de b7       	in	r29, 0x3e	; 62
    2ad2:	c6 56       	subi	r28, 0x66	; 102
    2ad4:	d1 09       	sbc	r29, r1
    2ad6:	cd bf       	out	0x3d, r28	; 61
    2ad8:	de bf       	out	0x3e, r29	; 62
    2ada:	5e 01       	movw	r10, r28
    2adc:	41 e5       	ldi	r20, 0x51	; 81
    2ade:	a4 0e       	add	r10, r20
    2ae0:	b1 1c       	adc	r11, r1
    2ae2:	fe 01       	movw	r30, r28
    2ae4:	31 96       	adiw	r30, 0x01	; 1
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
			displayLines[i][j] = 0x20;
    2ae6:	20 e2       	ldi	r18, 0x20	; 32
    2ae8:	08 c0       	rjmp	.+16     	; 0x2afa <vDisplayUpdateTask+0x30>
    2aea:	21 93       	st	Z+, r18
 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
    2aec:	e8 17       	cp	r30, r24
    2aee:	f9 07       	cpc	r31, r25
    2af0:	e1 f7       	brne	.-8      	; 0x2aea <vDisplayUpdateTask+0x20>
    2af2:	fc 01       	movw	r30, r24

 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
    2af4:	a8 16       	cp	r10, r24
    2af6:	b9 06       	cpc	r11, r25
    2af8:	19 f0       	breq	.+6      	; 0x2b00 <vDisplayUpdateTask+0x36>
    2afa:	cf 01       	movw	r24, r30
    2afc:	44 96       	adiw	r24, 0x14	; 20
    2afe:	f5 cf       	rjmp	.-22     	; 0x2aea <vDisplayUpdateTask+0x20>
			displayLines[i][j] = 0x20;
		}
	 }
	 displayLine_t newLine;

	 delayUS(40000);
    2b00:	60 e4       	ldi	r22, 0x40	; 64
    2b02:	7c e9       	ldi	r23, 0x9C	; 156
    2b04:	80 e0       	ldi	r24, 0x00	; 0
    2b06:	90 e0       	ldi	r25, 0x00	; 0
    2b08:	0e 94 09 14 	call	0x2812	; 0x2812 <delayUS>
	 setPort(0x03);
    2b0c:	83 e0       	ldi	r24, 0x03	; 3
    2b0e:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <setPort>
	 delayUS(5000);
    2b12:	68 e8       	ldi	r22, 0x88	; 136
    2b14:	73 e1       	ldi	r23, 0x13	; 19
    2b16:	80 e0       	ldi	r24, 0x00	; 0
    2b18:	90 e0       	ldi	r25, 0x00	; 0
    2b1a:	0e 94 09 14 	call	0x2812	; 0x2812 <delayUS>
	 Nybble();
    2b1e:	0e 94 89 14 	call	0x2912	; 0x2912 <Nybble>
	 delayUS(160);
    2b22:	60 ea       	ldi	r22, 0xA0	; 160
    2b24:	70 e0       	ldi	r23, 0x00	; 0
    2b26:	80 e0       	ldi	r24, 0x00	; 0
    2b28:	90 e0       	ldi	r25, 0x00	; 0
    2b2a:	0e 94 09 14 	call	0x2812	; 0x2812 <delayUS>
	 Nybble();
    2b2e:	0e 94 89 14 	call	0x2912	; 0x2912 <Nybble>
	 delayUS(160);
    2b32:	60 ea       	ldi	r22, 0xA0	; 160
    2b34:	70 e0       	ldi	r23, 0x00	; 0
    2b36:	80 e0       	ldi	r24, 0x00	; 0
    2b38:	90 e0       	ldi	r25, 0x00	; 0
    2b3a:	0e 94 09 14 	call	0x2812	; 0x2812 <delayUS>
	 Nybble();
    2b3e:	0e 94 89 14 	call	0x2912	; 0x2912 <Nybble>
	 delayUS(160);
    2b42:	60 ea       	ldi	r22, 0xA0	; 160
    2b44:	70 e0       	ldi	r23, 0x00	; 0
    2b46:	80 e0       	ldi	r24, 0x00	; 0
    2b48:	90 e0       	ldi	r25, 0x00	; 0
    2b4a:	0e 94 09 14 	call	0x2812	; 0x2812 <delayUS>
	 setPort(0x02);
    2b4e:	82 e0       	ldi	r24, 0x02	; 2
    2b50:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <setPort>
	 Nybble();
    2b54:	0e 94 89 14 	call	0x2912	; 0x2912 <Nybble>
	 command(0x28);
    2b58:	88 e2       	ldi	r24, 0x28	; 40
    2b5a:	0e 94 9b 14 	call	0x2936	; 0x2936 <command>
	 command(0x10);
    2b5e:	80 e1       	ldi	r24, 0x10	; 16
    2b60:	0e 94 9b 14 	call	0x2936	; 0x2936 <command>
	 command(0x0C); //Cursor and Blinking off
    2b64:	8c e0       	ldi	r24, 0x0C	; 12
    2b66:	0e 94 9b 14 	call	0x2936	; 0x2936 <command>
	 command(0x06);
    2b6a:	86 e0       	ldi	r24, 0x06	; 6
    2b6c:	0e 94 9b 14 	call	0x2936	; 0x2936 <command>
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2b70:	10 e2       	ldi	r17, 0x20	; 32
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2b72:	6e 01       	movw	r12, r28
    2b74:	51 e5       	ldi	r21, 0x51	; 81
    2b76:	c5 0e       	add	r12, r21
    2b78:	d1 1c       	adc	r13, r1
    2b7a:	0f 2e       	mov	r0, r31
    2b7c:	f4 e1       	ldi	r31, 0x14	; 20
    2b7e:	4f 2e       	mov	r4, r31
    2b80:	f0 2d       	mov	r31, r0
    2b82:	0f 2e       	mov	r0, r31
    2b84:	f6 e1       	ldi	r31, 0x16	; 22
    2b86:	8f 2e       	mov	r8, r31
    2b88:	91 2c       	mov	r9, r1
    2b8a:	f0 2d       	mov	r31, r0
    2b8c:	5c 2c       	mov	r5, r12
    2b8e:	0d 2d       	mov	r16, r13
	 command(0x10);
	 command(0x0C); //Cursor and Blinking off
	 command(0x06);
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
    2b90:	68 ec       	ldi	r22, 0xC8	; 200
    2b92:	70 e0       	ldi	r23, 0x00	; 0
    2b94:	80 e0       	ldi	r24, 0x00	; 0
    2b96:	90 e0       	ldi	r25, 0x00	; 0
    2b98:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
    2b9c:	40 e0       	ldi	r20, 0x00	; 0
    2b9e:	50 e0       	ldi	r21, 0x00	; 0
    2ba0:	ba 01       	movw	r22, r20
    2ba2:	80 91 17 3f 	lds	r24, 0x3F17	; 0x803f17 <egDisplayTiming>
    2ba6:	90 91 18 3f 	lds	r25, 0x3F18	; 0x803f18 <egDisplayTiming+0x1>
    2baa:	0e 94 82 03 	call	0x704	; 0x704 <xEventGroupClearBits>
    2bae:	67 2b       	or	r22, r23
    2bb0:	68 2b       	or	r22, r24
    2bb2:	69 2b       	or	r22, r25
    2bb4:	09 f4       	brne	.+2      	; 0x2bb8 <vDisplayUpdateTask+0xee>
    2bb6:	49 c0       	rjmp	.+146    	; 0x2c4a <vDisplayUpdateTask+0x180>
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2bb8:	42 e0       	ldi	r20, 0x02	; 2
    2bba:	50 e0       	ldi	r21, 0x00	; 0
    2bbc:	60 e0       	ldi	r22, 0x00	; 0
    2bbe:	70 e0       	ldi	r23, 0x00	; 0
    2bc0:	80 91 17 3f 	lds	r24, 0x3F17	; 0x803f17 <egDisplayTiming>
    2bc4:	90 91 18 3f 	lds	r25, 0x3F18	; 0x803f18 <egDisplayTiming+0x1>
    2bc8:	0e 94 82 03 	call	0x704	; 0x704 <xEventGroupClearBits>
    2bcc:	fe 01       	movw	r30, r28
    2bce:	31 96       	adiw	r30, 0x01	; 1
    2bd0:	08 c0       	rjmp	.+16     	; 0x2be2 <vDisplayUpdateTask+0x118>
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    2bd2:	11 93       	st	Z+, r17
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
    2bd4:	e8 17       	cp	r30, r24
    2bd6:	f9 07       	cpc	r31, r25
    2bd8:	e1 f7       	brne	.-8      	; 0x2bd2 <vDisplayUpdateTask+0x108>
    2bda:	fc 01       	movw	r30, r24
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
    2bdc:	8a 15       	cp	r24, r10
    2bde:	9b 05       	cpc	r25, r11
    2be0:	a1 f1       	breq	.+104    	; 0x2c4a <vDisplayUpdateTask+0x180>
    2be2:	cf 01       	movw	r24, r30
    2be4:	44 96       	adiw	r24, 0x14	; 20
    2be6:	f5 cf       	rjmp	.-22     	; 0x2bd2 <vDisplayUpdateTask+0x108>
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    2be8:	2f ef       	ldi	r18, 0xFF	; 255
    2bea:	3f ef       	ldi	r19, 0xFF	; 255
    2bec:	a9 01       	movw	r20, r18
    2bee:	65 2d       	mov	r22, r5
    2bf0:	70 2f       	mov	r23, r16
    2bf2:	80 91 15 3f 	lds	r24, 0x3F15	; 0x803f15 <displayLineQueue>
    2bf6:	90 91 16 3f 	lds	r25, 0x3F16	; 0x803f16 <displayLineQueue+0x1>
    2bfa:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <xQueueReceive>
    2bfe:	88 23       	and	r24, r24
    2c00:	21 f1       	breq	.+72     	; 0x2c4a <vDisplayUpdateTask+0x180>
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2c02:	f6 01       	movw	r30, r12
    2c04:	21 81       	ldd	r18, Z+1	; 0x01
    2c06:	82 2f       	mov	r24, r18
    2c08:	90 e0       	ldi	r25, 0x00	; 0
    2c0a:	44 97       	sbiw	r24, 0x14	; 20
    2c0c:	f4 f4       	brge	.+60     	; 0x2c4a <vDisplayUpdateTask+0x180>
    2c0e:	82 81       	ldd	r24, Z+2	; 0x02
    2c10:	88 23       	and	r24, r24
    2c12:	d9 f0       	breq	.+54     	; 0x2c4a <vDisplayUpdateTask+0x180>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
    2c14:	90 81       	ld	r25, Z
    2c16:	30 e0       	ldi	r19, 0x00	; 0
    2c18:	d9 01       	movw	r26, r18
    2c1a:	49 9e       	mul	r4, r25
    2c1c:	a0 0d       	add	r26, r0
    2c1e:	b1 1d       	adc	r27, r1
    2c20:	11 24       	eor	r1, r1
    2c22:	41 e0       	ldi	r20, 0x01	; 1
    2c24:	50 e0       	ldi	r21, 0x00	; 0
    2c26:	4c 0f       	add	r20, r28
    2c28:	5d 1f       	adc	r21, r29
    2c2a:	a4 0f       	add	r26, r20
    2c2c:	b5 1f       	adc	r27, r21
    2c2e:	33 96       	adiw	r30, 0x03	; 3
    2c30:	a4 01       	movw	r20, r8
    2c32:	42 1b       	sub	r20, r18
    2c34:	53 0b       	sbc	r21, r19
    2c36:	9a 01       	movw	r18, r20
    2c38:	2c 0d       	add	r18, r12
    2c3a:	3d 1d       	adc	r19, r13
    2c3c:	8d 93       	st	X+, r24
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    2c3e:	e2 17       	cp	r30, r18
    2c40:	f3 07       	cpc	r31, r19
    2c42:	19 f0       	breq	.+6      	; 0x2c4a <vDisplayUpdateTask+0x180>
    2c44:	81 91       	ld	r24, Z+
    2c46:	81 11       	cpse	r24, r1
    2c48:	f9 cf       	rjmp	.-14     	; 0x2c3c <vDisplayUpdateTask+0x172>
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
    2c4a:	80 91 15 3f 	lds	r24, 0x3F15	; 0x803f15 <displayLineQueue>
    2c4e:	90 91 16 3f 	lds	r25, 0x3F16	; 0x803f16 <displayLineQueue+0x1>
    2c52:	0e 94 91 09 	call	0x1322	; 0x1322 <uxQueueMessagesWaiting>
    2c56:	81 11       	cpse	r24, r1
    2c58:	c7 cf       	rjmp	.-114    	; 0x2be8 <vDisplayUpdateTask+0x11e>
    2c5a:	ce 01       	movw	r24, r28
    2c5c:	01 96       	adiw	r24, 0x01	; 1
    2c5e:	7c 01       	movw	r14, r24
    2c60:	61 2c       	mov	r6, r1
    2c62:	71 2c       	mov	r7, r1
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
			 _displayWriteStringAtPos(i,0,&displayLines[i][0]);
    2c64:	a7 01       	movw	r20, r14
    2c66:	60 e0       	ldi	r22, 0x00	; 0
    2c68:	70 e0       	ldi	r23, 0x00	; 0
    2c6a:	c3 01       	movw	r24, r6
    2c6c:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <_displayWriteStringAtPos>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
    2c70:	9f ef       	ldi	r25, 0xFF	; 255
    2c72:	69 1a       	sub	r6, r25
    2c74:	79 0a       	sbc	r7, r25
    2c76:	e4 e1       	ldi	r30, 0x14	; 20
    2c78:	ee 0e       	add	r14, r30
    2c7a:	f1 1c       	adc	r15, r1
    2c7c:	f4 e0       	ldi	r31, 0x04	; 4
    2c7e:	6f 16       	cp	r6, r31
    2c80:	71 04       	cpc	r7, r1
    2c82:	81 f7       	brne	.-32     	; 0x2c64 <vDisplayUpdateTask+0x19a>
    2c84:	85 cf       	rjmp	.-246    	; 0x2b90 <vDisplayUpdateTask+0xc6>

00002c86 <vDisplayClear>:
	 }
 }
 

void vDisplayClear() {
	xEventGroupSetBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    2c86:	42 e0       	ldi	r20, 0x02	; 2
    2c88:	50 e0       	ldi	r21, 0x00	; 0
    2c8a:	60 e0       	ldi	r22, 0x00	; 0
    2c8c:	70 e0       	ldi	r23, 0x00	; 0
    2c8e:	80 91 17 3f 	lds	r24, 0x3F17	; 0x803f17 <egDisplayTiming>
    2c92:	90 91 18 3f 	lds	r25, 0x3F18	; 0x803f18 <egDisplayTiming+0x1>
    2c96:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
    2c9a:	08 95       	ret

00002c9c <vDisplayWriteStringAtPos>:
}

void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
    2c9c:	2f 92       	push	r2
    2c9e:	3f 92       	push	r3
    2ca0:	4f 92       	push	r4
    2ca2:	5f 92       	push	r5
    2ca4:	6f 92       	push	r6
    2ca6:	7f 92       	push	r7
    2ca8:	8f 92       	push	r8
    2caa:	9f 92       	push	r9
    2cac:	af 92       	push	r10
    2cae:	bf 92       	push	r11
    2cb0:	cf 92       	push	r12
    2cb2:	df 92       	push	r13
    2cb4:	ef 92       	push	r14
    2cb6:	ff 92       	push	r15
    2cb8:	0f 93       	push	r16
    2cba:	1f 93       	push	r17
    2cbc:	cf 93       	push	r28
    2cbe:	df 93       	push	r29
    2cc0:	cd b7       	in	r28, 0x3d	; 61
    2cc2:	de b7       	in	r29, 0x3e	; 62
    2cc4:	6d 97       	sbiw	r28, 0x1d	; 29
    2cc6:	cd bf       	out	0x3d, r28	; 61
    2cc8:	de bf       	out	0x3e, r29	; 62
    2cca:	2b a9       	ldd	r18, Y+51	; 0x33
    2ccc:	2b 8f       	std	Y+27, r18	; 0x1b
    2cce:	af a9       	ldd	r26, Y+55	; 0x37
    2cd0:	b8 ad       	ldd	r27, Y+56	; 0x38
	va_list arg;	
	va_start(arg, fmt);
    2cd2:	7e 01       	movw	r14, r28
    2cd4:	39 e3       	ldi	r19, 0x39	; 57
    2cd6:	e3 0e       	add	r14, r19
    2cd8:	f1 1c       	adc	r15, r1
    2cda:	26 e0       	ldi	r18, 0x06	; 6
    2cdc:	3d e2       	ldi	r19, 0x2D	; 45
	display_vprintf(line, pos, fmt, arg);
    2cde:	e2 ef       	ldi	r30, 0xF2	; 242
    2ce0:	fc e2       	ldi	r31, 0x2C	; 44
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
    2ce2:	11 92       	st	Z+, r1
	char ch;
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
    2ce4:	e2 17       	cp	r30, r18
    2ce6:	f3 07       	cpc	r31, r19
    2ce8:	e1 f7       	brne	.-8      	; 0x2ce2 <vDisplayWriteStringAtPos+0x46>
    2cea:	0f 2e       	mov	r0, r31
    2cec:	fe ed       	ldi	r31, 0xDE	; 222
    2cee:	af 2e       	mov	r10, r31
    2cf0:	fc e2       	ldi	r31, 0x2C	; 44
    2cf2:	bf 2e       	mov	r11, r31
    2cf4:	f0 2d       	mov	r31, r0
    2cf6:	22 ef       	ldi	r18, 0xF2	; 242
    2cf8:	3c e2       	ldi	r19, 0x2C	; 44
    2cfa:	f5 01       	movw	r30, r10
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
    2cfc:	11 92       	st	Z+, r1
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    2cfe:	e2 17       	cp	r30, r18
    2d00:	f3 07       	cpc	r31, r19
    2d02:	e1 f7       	brne	.-8      	; 0x2cfc <vDisplayWriteStringAtPos+0x60>
    2d04:	81 2c       	mov	r8, r1
    2d06:	91 2c       	mov	r9, r1
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    2d08:	0f 2e       	mov	r0, r31
    2d0a:	f2 ef       	ldi	r31, 0xF2	; 242
    2d0c:	cf 2e       	mov	r12, r31
    2d0e:	fc e2       	ldi	r31, 0x2C	; 44
    2d10:	df 2e       	mov	r13, r31
    2d12:	f0 2d       	mov	r31, r0
    2d14:	fc c2       	rjmp	.+1528   	; 0x330e <vDisplayWriteStringAtPos+0x672>
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
    2d16:	85 32       	cpi	r24, 0x25	; 37
    2d18:	09 f0       	breq	.+2      	; 0x2d1c <vDisplayWriteStringAtPos+0x80>
    2d1a:	e8 c2       	rjmp	.+1488   	; 0x32ec <vDisplayWriteStringAtPos+0x650>
			switch (ch = *fmt++) {
    2d1c:	2d 01       	movw	r4, r26
    2d1e:	82 e0       	ldi	r24, 0x02	; 2
    2d20:	48 0e       	add	r4, r24
    2d22:	51 1c       	adc	r5, r1
    2d24:	11 96       	adiw	r26, 0x01	; 1
    2d26:	8c 91       	ld	r24, X
    2d28:	85 36       	cpi	r24, 0x65	; 101
    2d2a:	09 f4       	brne	.+2      	; 0x2d2e <vDisplayWriteStringAtPos+0x92>
    2d2c:	db c1       	rjmp	.+950    	; 0x30e4 <vDisplayWriteStringAtPos+0x448>
    2d2e:	38 f4       	brcc	.+14     	; 0x2d3e <vDisplayWriteStringAtPos+0xa2>
    2d30:	83 36       	cpi	r24, 0x63	; 99
    2d32:	c1 f0       	breq	.+48     	; 0x2d64 <vDisplayWriteStringAtPos+0xc8>
    2d34:	08 f0       	brcs	.+2      	; 0x2d38 <vDisplayWriteStringAtPos+0x9c>
    2d36:	48 c0       	rjmp	.+144    	; 0x2dc8 <vDisplayWriteStringAtPos+0x12c>
    2d38:	85 32       	cpi	r24, 0x25	; 37
    2d3a:	51 f0       	breq	.+20     	; 0x2d50 <vDisplayWriteStringAtPos+0xb4>
    2d3c:	e7 c2       	rjmp	.+1486   	; 0x330c <vDisplayWriteStringAtPos+0x670>
    2d3e:	83 37       	cpi	r24, 0x73	; 115
    2d40:	f9 f0       	breq	.+62     	; 0x2d80 <vDisplayWriteStringAtPos+0xe4>
    2d42:	88 37       	cpi	r24, 0x78	; 120
    2d44:	09 f4       	brne	.+2      	; 0x2d48 <vDisplayWriteStringAtPos+0xac>
    2d46:	68 c0       	rjmp	.+208    	; 0x2e18 <vDisplayWriteStringAtPos+0x17c>
    2d48:	86 36       	cpi	r24, 0x66	; 102
    2d4a:	09 f0       	breq	.+2      	; 0x2d4e <vDisplayWriteStringAtPos+0xb2>
    2d4c:	df c2       	rjmp	.+1470   	; 0x330c <vDisplayWriteStringAtPos+0x670>
    2d4e:	8c c0       	rjmp	.+280    	; 0x2e68 <vDisplayWriteStringAtPos+0x1cc>
				/* %% - print out a single %    */
				case '%':
				str[length] = '%';
    2d50:	f4 01       	movw	r30, r8
    2d52:	e2 52       	subi	r30, 0x22	; 34
    2d54:	f3 4d       	sbci	r31, 0xD3	; 211
    2d56:	95 e2       	ldi	r25, 0x25	; 37
    2d58:	90 83       	st	Z, r25
				length++;
    2d5a:	af ef       	ldi	r26, 0xFF	; 255
    2d5c:	8a 1a       	sub	r8, r26
    2d5e:	9a 0a       	sbc	r9, r26
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2d60:	d2 01       	movw	r26, r4
    2d62:	d5 c2       	rjmp	.+1450   	; 0x330e <vDisplayWriteStringAtPos+0x672>
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
				str[length] = char_temp;
    2d64:	f4 01       	movw	r30, r8
    2d66:	e2 52       	subi	r30, 0x22	; 34
    2d68:	f3 4d       	sbci	r31, 0xD3	; 211
    2d6a:	d7 01       	movw	r26, r14
    2d6c:	8c 91       	ld	r24, X
    2d6e:	80 83       	st	Z, r24
				length++;
    2d70:	bf ef       	ldi	r27, 0xFF	; 255
    2d72:	8b 1a       	sub	r8, r27
    2d74:	9b 0a       	sbc	r9, r27
				length++;
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
    2d76:	f7 01       	movw	r30, r14
    2d78:	32 96       	adiw	r30, 0x02	; 2
    2d7a:	7f 01       	movw	r14, r30
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2d7c:	d2 01       	movw	r26, r4
    2d7e:	c7 c2       	rjmp	.+1422   	; 0x330e <vDisplayWriteStringAtPos+0x672>
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2d80:	a7 01       	movw	r20, r14
    2d82:	4e 5f       	subi	r20, 0xFE	; 254
    2d84:	5f 4f       	sbci	r21, 0xFF	; 255
    2d86:	d7 01       	movw	r26, r14
    2d88:	8d 91       	ld	r24, X+
    2d8a:	9c 91       	ld	r25, X
    2d8c:	9c 01       	movw	r18, r24
    2d8e:	b4 01       	movw	r22, r8
    2d90:	f4 01       	movw	r30, r8
    2d92:	e2 52       	subi	r30, 0x22	; 34
    2d94:	f3 4d       	sbci	r31, 0xD3	; 211
				for(int i = 0; i < strlen(string_temp);i++) {
    2d96:	00 e0       	ldi	r16, 0x00	; 0
    2d98:	10 e0       	ldi	r17, 0x00	; 0
    2d9a:	06 c0       	rjmp	.+12     	; 0x2da8 <vDisplayWriteStringAtPos+0x10c>
					str[length+i] = string_temp[i];
    2d9c:	d9 01       	movw	r26, r18
    2d9e:	fd 90       	ld	r15, X+
    2da0:	9d 01       	movw	r18, r26
    2da2:	f1 92       	st	Z+, r15
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
				for(int i = 0; i < strlen(string_temp);i++) {
    2da4:	0f 5f       	subi	r16, 0xFF	; 255
    2da6:	1f 4f       	sbci	r17, 0xFF	; 255
    2da8:	dc 01       	movw	r26, r24
    2daa:	0d 90       	ld	r0, X+
    2dac:	00 20       	and	r0, r0
    2dae:	e9 f7       	brne	.-6      	; 0x2daa <vDisplayWriteStringAtPos+0x10e>
    2db0:	11 97       	sbiw	r26, 0x01	; 1
    2db2:	a8 1b       	sub	r26, r24
    2db4:	b9 0b       	sbc	r27, r25
    2db6:	0a 17       	cp	r16, r26
    2db8:	1b 07       	cpc	r17, r27
    2dba:	80 f3       	brcs	.-32     	; 0x2d9c <vDisplayWriteStringAtPos+0x100>
					str[length+i] = string_temp[i];
				}
				length += strlen(string_temp);
    2dbc:	4d 01       	movw	r8, r26
    2dbe:	86 0e       	add	r8, r22
    2dc0:	97 1e       	adc	r9, r23
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    2dc2:	7a 01       	movw	r14, r20
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2dc4:	d2 01       	movw	r26, r4
    2dc6:	a3 c2       	rjmp	.+1350   	; 0x330e <vDisplayWriteStringAtPos+0x672>
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    2dc8:	87 01       	movw	r16, r14
    2dca:	0e 5f       	subi	r16, 0xFE	; 254
    2dcc:	1f 4f       	sbci	r17, 0xFF	; 255
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    2dce:	4a e0       	ldi	r20, 0x0A	; 10
    2dd0:	b6 01       	movw	r22, r12
    2dd2:	f7 01       	movw	r30, r14
    2dd4:	80 81       	ld	r24, Z
    2dd6:	91 81       	ldd	r25, Z+1	; 0x01
    2dd8:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <__itoa_ncheck>
    2ddc:	94 01       	movw	r18, r8
    2dde:	d4 01       	movw	r26, r8
    2de0:	a2 52       	subi	r26, 0x22	; 34
    2de2:	b3 4d       	sbci	r27, 0xD3	; 211
    2de4:	42 ef       	ldi	r20, 0xF2	; 242
    2de6:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    2de8:	80 e0       	ldi	r24, 0x00	; 0
    2dea:	90 e0       	ldi	r25, 0x00	; 0
    2dec:	05 c0       	rjmp	.+10     	; 0x2df8 <vDisplayWriteStringAtPos+0x15c>
					str[length+i] = buffer[i];
    2dee:	fa 01       	movw	r30, r20
    2df0:	61 91       	ld	r22, Z+
    2df2:	af 01       	movw	r20, r30
    2df4:	6d 93       	st	X+, r22

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    2df6:	01 96       	adiw	r24, 0x01	; 1
    2df8:	f6 01       	movw	r30, r12
    2dfa:	01 90       	ld	r0, Z+
    2dfc:	00 20       	and	r0, r0
    2dfe:	e9 f7       	brne	.-6      	; 0x2dfa <vDisplayWriteStringAtPos+0x15e>
    2e00:	31 97       	sbiw	r30, 0x01	; 1
    2e02:	e2 5f       	subi	r30, 0xF2	; 242
    2e04:	fc 42       	sbci	r31, 0x2C	; 44
    2e06:	8e 17       	cp	r24, r30
    2e08:	9f 07       	cpc	r25, r31
    2e0a:	88 f3       	brcs	.-30     	; 0x2dee <vDisplayWriteStringAtPos+0x152>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    2e0c:	4f 01       	movw	r8, r30
    2e0e:	82 0e       	add	r8, r18
    2e10:	93 1e       	adc	r9, r19
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    2e12:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2e14:	d2 01       	movw	r26, r4
    2e16:	7b c2       	rjmp	.+1270   	; 0x330e <vDisplayWriteStringAtPos+0x672>
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    2e18:	87 01       	movw	r16, r14
    2e1a:	0e 5f       	subi	r16, 0xFE	; 254
    2e1c:	1f 4f       	sbci	r17, 0xFF	; 255
    2e1e:	40 e1       	ldi	r20, 0x10	; 16
    2e20:	b6 01       	movw	r22, r12
    2e22:	d7 01       	movw	r26, r14
    2e24:	8d 91       	ld	r24, X+
    2e26:	9c 91       	ld	r25, X
    2e28:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <__itoa_ncheck>
    2e2c:	94 01       	movw	r18, r8
    2e2e:	f4 01       	movw	r30, r8
    2e30:	e2 52       	subi	r30, 0x22	; 34
    2e32:	f3 4d       	sbci	r31, 0xD3	; 211
    2e34:	42 ef       	ldi	r20, 0xF2	; 242
    2e36:	5c e2       	ldi	r21, 0x2C	; 44
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    2e38:	80 e0       	ldi	r24, 0x00	; 0
    2e3a:	90 e0       	ldi	r25, 0x00	; 0
    2e3c:	05 c0       	rjmp	.+10     	; 0x2e48 <vDisplayWriteStringAtPos+0x1ac>
					str[length+i] = buffer[i];
    2e3e:	da 01       	movw	r26, r20
    2e40:	6d 91       	ld	r22, X+
    2e42:	ad 01       	movw	r20, r26
    2e44:	61 93       	st	Z+, r22

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    2e46:	01 96       	adiw	r24, 0x01	; 1
    2e48:	d6 01       	movw	r26, r12
    2e4a:	0d 90       	ld	r0, X+
    2e4c:	00 20       	and	r0, r0
    2e4e:	e9 f7       	brne	.-6      	; 0x2e4a <vDisplayWriteStringAtPos+0x1ae>
    2e50:	11 97       	sbiw	r26, 0x01	; 1
    2e52:	a2 5f       	subi	r26, 0xF2	; 242
    2e54:	bc 42       	sbci	r27, 0x2C	; 44
    2e56:	8a 17       	cp	r24, r26
    2e58:	9b 07       	cpc	r25, r27
    2e5a:	88 f3       	brcs	.-30     	; 0x2e3e <vDisplayWriteStringAtPos+0x1a2>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    2e5c:	4d 01       	movw	r8, r26
    2e5e:	82 0e       	add	r8, r18
    2e60:	93 1e       	adc	r9, r19
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    2e62:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    2e64:	d2 01       	movw	r26, r4
    2e66:	53 c2       	rjmp	.+1190   	; 0x330e <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    2e68:	17 01       	movw	r2, r14
    2e6a:	b4 e0       	ldi	r27, 0x04	; 4
    2e6c:	2b 0e       	add	r2, r27
    2e6e:	31 1c       	adc	r3, r1
    2e70:	d7 01       	movw	r26, r14
    2e72:	8d 91       	ld	r24, X+
    2e74:	9d 91       	ld	r25, X+
    2e76:	0d 90       	ld	r0, X+
    2e78:	bc 91       	ld	r27, X
    2e7a:	a0 2d       	mov	r26, r0
    2e7c:	8f 8b       	std	Y+23, r24	; 0x17
    2e7e:	98 8f       	std	Y+24, r25	; 0x18
    2e80:	a9 8f       	std	Y+25, r26	; 0x19
    2e82:	ba 8f       	std	Y+26, r27	; 0x1a

    int exponent = 0;
    int places = 0;
    static const int width = 4;

    if (value == 0.0) {
    2e84:	20 e0       	ldi	r18, 0x00	; 0
    2e86:	30 e0       	ldi	r19, 0x00	; 0
    2e88:	a9 01       	movw	r20, r18
    2e8a:	bc 01       	movw	r22, r24
    2e8c:	cd 01       	movw	r24, r26
    2e8e:	0e 94 13 1b 	call	0x3626	; 0x3626 <__cmpsf2>
    2e92:	81 11       	cpse	r24, r1
    2e94:	05 c0       	rjmp	.+10     	; 0x2ea0 <vDisplayWriteStringAtPos+0x204>
        buffer[0] = '0';
    2e96:	20 e3       	ldi	r18, 0x30	; 48
    2e98:	f6 01       	movw	r30, r12
    2e9a:	20 83       	st	Z, r18
        buffer[1] = '\0';
    2e9c:	11 82       	std	Z+1, r1	; 0x01
    2e9e:	04 c1       	rjmp	.+520    	; 0x30a8 <vDisplayWriteStringAtPos+0x40c>
        return;
    }         

    if (value < 0.0) {
    2ea0:	20 e0       	ldi	r18, 0x00	; 0
    2ea2:	30 e0       	ldi	r19, 0x00	; 0
    2ea4:	a9 01       	movw	r20, r18
    2ea6:	6f 89       	ldd	r22, Y+23	; 0x17
    2ea8:	78 8d       	ldd	r23, Y+24	; 0x18
    2eaa:	89 8d       	ldd	r24, Y+25	; 0x19
    2eac:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2eae:	0e 94 13 1b 	call	0x3626	; 0x3626 <__cmpsf2>
    2eb2:	88 23       	and	r24, r24
    2eb4:	9c f4       	brge	.+38     	; 0x2edc <vDisplayWriteStringAtPos+0x240>
        *buffer++ = '-';
    2eb6:	ed e2       	ldi	r30, 0x2D	; 45
    2eb8:	d6 01       	movw	r26, r12
    2eba:	ec 93       	st	X, r30
        value = -value;
    2ebc:	8f 89       	ldd	r24, Y+23	; 0x17
    2ebe:	98 8d       	ldd	r25, Y+24	; 0x18
    2ec0:	a9 8d       	ldd	r26, Y+25	; 0x19
    2ec2:	ba 8d       	ldd	r27, Y+26	; 0x1a
    2ec4:	b0 58       	subi	r27, 0x80	; 128
    2ec6:	8f 8b       	std	Y+23, r24	; 0x17
    2ec8:	98 8f       	std	Y+24, r25	; 0x18
    2eca:	a9 8f       	std	Y+25, r26	; 0x19
    2ecc:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
        *buffer++ = '-';
    2ece:	0f 2e       	mov	r0, r31
    2ed0:	f3 ef       	ldi	r31, 0xF3	; 243
    2ed2:	6f 2e       	mov	r6, r31
    2ed4:	fc e2       	ldi	r31, 0x2C	; 44
    2ed6:	7f 2e       	mov	r7, r31
    2ed8:	f0 2d       	mov	r31, r0
    2eda:	01 c0       	rjmp	.+2      	; 0x2ede <vDisplayWriteStringAtPos+0x242>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
    2edc:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    2ede:	20 e0       	ldi	r18, 0x00	; 0
    2ee0:	30 e0       	ldi	r19, 0x00	; 0
    2ee2:	40 e8       	ldi	r20, 0x80	; 128
    2ee4:	5f e3       	ldi	r21, 0x3F	; 63
    2ee6:	6f 89       	ldd	r22, Y+23	; 0x17
    2ee8:	78 8d       	ldd	r23, Y+24	; 0x18
    2eea:	89 8d       	ldd	r24, Y+25	; 0x19
    2eec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2eee:	0e 94 72 1c 	call	0x38e4	; 0x38e4 <__gesf2>
    2ef2:	88 23       	and	r24, r24
    2ef4:	0c f4       	brge	.+2      	; 0x2ef8 <vDisplayWriteStringAtPos+0x25c>
    2ef6:	44 c2       	rjmp	.+1160   	; 0x3380 <vDisplayWriteStringAtPos+0x6e4>
    2ef8:	00 e0       	ldi	r16, 0x00	; 0
    2efa:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    2efc:	20 e0       	ldi	r18, 0x00	; 0
    2efe:	30 e0       	ldi	r19, 0x00	; 0
    2f00:	40 e2       	ldi	r20, 0x20	; 32
    2f02:	51 e4       	ldi	r21, 0x41	; 65
    2f04:	6f 89       	ldd	r22, Y+23	; 0x17
    2f06:	78 8d       	ldd	r23, Y+24	; 0x18
    2f08:	89 8d       	ldd	r24, Y+25	; 0x19
    2f0a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f0c:	0e 94 18 1b 	call	0x3630	; 0x3630 <__divsf3>
    2f10:	6f 8b       	std	Y+23, r22	; 0x17
    2f12:	78 8f       	std	Y+24, r23	; 0x18
    2f14:	89 8f       	std	Y+25, r24	; 0x19
    2f16:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    2f18:	0f 5f       	subi	r16, 0xFF	; 255
    2f1a:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    2f1c:	20 e0       	ldi	r18, 0x00	; 0
    2f1e:	30 e0       	ldi	r19, 0x00	; 0
    2f20:	40 e8       	ldi	r20, 0x80	; 128
    2f22:	5f e3       	ldi	r21, 0x3F	; 63
    2f24:	0e 94 72 1c 	call	0x38e4	; 0x38e4 <__gesf2>
    2f28:	88 23       	and	r24, r24
    2f2a:	44 f7       	brge	.-48     	; 0x2efc <vDisplayWriteStringAtPos+0x260>
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    2f2c:	2d ec       	ldi	r18, 0xCD	; 205
    2f2e:	3c ec       	ldi	r19, 0xCC	; 204
    2f30:	4c ec       	ldi	r20, 0xCC	; 204
    2f32:	5d e3       	ldi	r21, 0x3D	; 61
    2f34:	6f 89       	ldd	r22, Y+23	; 0x17
    2f36:	78 8d       	ldd	r23, Y+24	; 0x18
    2f38:	89 8d       	ldd	r24, Y+25	; 0x19
    2f3a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f3c:	0e 94 13 1b 	call	0x3626	; 0x3626 <__cmpsf2>
    2f40:	88 23       	and	r24, r24
    2f42:	1c f0       	brlt	.+6      	; 0x2f4a <vDisplayWriteStringAtPos+0x2ae>
    2f44:	1a c0       	rjmp	.+52     	; 0x2f7a <vDisplayWriteStringAtPos+0x2de>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    2f46:	00 e0       	ldi	r16, 0x00	; 0
    2f48:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
        value *= 10.0;
    2f4a:	20 e0       	ldi	r18, 0x00	; 0
    2f4c:	30 e0       	ldi	r19, 0x00	; 0
    2f4e:	40 e2       	ldi	r20, 0x20	; 32
    2f50:	51 e4       	ldi	r21, 0x41	; 65
    2f52:	6f 89       	ldd	r22, Y+23	; 0x17
    2f54:	78 8d       	ldd	r23, Y+24	; 0x18
    2f56:	89 8d       	ldd	r24, Y+25	; 0x19
    2f58:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f5a:	0e 94 77 1c 	call	0x38ee	; 0x38ee <__mulsf3>
    2f5e:	6f 8b       	std	Y+23, r22	; 0x17
    2f60:	78 8f       	std	Y+24, r23	; 0x18
    2f62:	89 8f       	std	Y+25, r24	; 0x19
    2f64:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    2f66:	01 50       	subi	r16, 0x01	; 1
    2f68:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    2f6a:	2d ec       	ldi	r18, 0xCD	; 205
    2f6c:	3c ec       	ldi	r19, 0xCC	; 204
    2f6e:	4c ec       	ldi	r20, 0xCC	; 204
    2f70:	5d e3       	ldi	r21, 0x3D	; 61
    2f72:	0e 94 13 1b 	call	0x3626	; 0x3626 <__cmpsf2>
    2f76:	88 23       	and	r24, r24
    2f78:	44 f3       	brlt	.-48     	; 0x2f4a <vDisplayWriteStringAtPos+0x2ae>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    2f7a:	10 16       	cp	r1, r16
    2f7c:	11 06       	cpc	r1, r17
    2f7e:	ac f5       	brge	.+106    	; 0x2fea <vDisplayWriteStringAtPos+0x34e>
    2f80:	73 01       	movw	r14, r6
    2f82:	d3 01       	movw	r26, r6
    2f84:	a0 0f       	add	r26, r16
    2f86:	b1 1f       	adc	r27, r17
    2f88:	ac 8f       	std	Y+28, r26	; 0x1c
    2f8a:	bd 8f       	std	Y+29, r27	; 0x1d
    2f8c:	3d 01       	movw	r6, r26
    2f8e:	6f 89       	ldd	r22, Y+23	; 0x17
    2f90:	78 8d       	ldd	r23, Y+24	; 0x18
    2f92:	89 8d       	ldd	r24, Y+25	; 0x19
    2f94:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10;
    2f96:	20 e0       	ldi	r18, 0x00	; 0
    2f98:	30 e0       	ldi	r19, 0x00	; 0
    2f9a:	40 e2       	ldi	r20, 0x20	; 32
    2f9c:	51 e4       	ldi	r21, 0x41	; 65
    2f9e:	0e 94 77 1c 	call	0x38ee	; 0x38ee <__mulsf3>
    2fa2:	6f 8b       	std	Y+23, r22	; 0x17
    2fa4:	78 8f       	std	Y+24, r23	; 0x18
    2fa6:	89 8f       	std	Y+25, r24	; 0x19
    2fa8:	9a 8f       	std	Y+26, r25	; 0x1a
    2faa:	0e 94 8a 1b 	call	0x3714	; 0x3714 <__fixsfsi>
        *buffer++ = digit + '0';
    2fae:	20 e3       	ldi	r18, 0x30	; 48
    2fb0:	26 0f       	add	r18, r22
    2fb2:	f7 01       	movw	r30, r14
    2fb4:	21 93       	st	Z+, r18
    2fb6:	7f 01       	movw	r14, r30
        value = value * 10 - digit;
    2fb8:	07 2e       	mov	r0, r23
    2fba:	00 0c       	add	r0, r0
    2fbc:	88 0b       	sbc	r24, r24
    2fbe:	99 0b       	sbc	r25, r25
    2fc0:	0e 94 c2 1b 	call	0x3784	; 0x3784 <__floatsisf>
    2fc4:	9b 01       	movw	r18, r22
    2fc6:	ac 01       	movw	r20, r24
    2fc8:	6f 89       	ldd	r22, Y+23	; 0x17
    2fca:	78 8d       	ldd	r23, Y+24	; 0x18
    2fcc:	89 8d       	ldd	r24, Y+25	; 0x19
    2fce:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2fd0:	0e 94 a6 1a 	call	0x354c	; 0x354c <__subsf3>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    2fd4:	e6 14       	cp	r14, r6
    2fd6:	f7 04       	cpc	r15, r7
    2fd8:	f1 f6       	brne	.-68     	; 0x2f96 <vDisplayWriteStringAtPos+0x2fa>
    2fda:	6f 8b       	std	Y+23, r22	; 0x17
    2fdc:	78 8f       	std	Y+24, r23	; 0x18
    2fde:	89 8f       	std	Y+25, r24	; 0x19
    2fe0:	9a 8f       	std	Y+26, r25	; 0x1a
        value = value * 10 - digit;
        ++places;
        --exponent;
    }

    if (places == 0)
    2fe2:	01 15       	cp	r16, r1
    2fe4:	11 05       	cpc	r17, r1
    2fe6:	89 f4       	brne	.+34     	; 0x300a <vDisplayWriteStringAtPos+0x36e>
    2fe8:	db c1       	rjmp	.+950    	; 0x33a0 <vDisplayWriteStringAtPos+0x704>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    2fea:	c8 01       	movw	r24, r16
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    2fec:	e0 e3       	ldi	r30, 0x30	; 48
    2fee:	d3 01       	movw	r26, r6
    2ff0:	ec 93       	st	X, r30

    *buffer++ = '.';
    2ff2:	73 01       	movw	r14, r6
    2ff4:	f2 e0       	ldi	r31, 0x02	; 2
    2ff6:	ef 0e       	add	r14, r31
    2ff8:	f1 1c       	adc	r15, r1
    2ffa:	2e e2       	ldi	r18, 0x2E	; 46
    2ffc:	11 96       	adiw	r26, 0x01	; 1
    2ffe:	2c 93       	st	X, r18

    while (exponent < 0 && places < width) {
    3000:	99 23       	and	r25, r25
    3002:	6c f0       	brlt	.+26     	; 0x301e <vDisplayWriteStringAtPos+0x382>
    3004:	00 e0       	ldi	r16, 0x00	; 0
    3006:	10 e0       	ldi	r17, 0x00	; 0
    3008:	1f c0       	rjmp	.+62     	; 0x3048 <vDisplayWriteStringAtPos+0x3ac>
    }

    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';
    300a:	ec 8c       	ldd	r14, Y+28	; 0x1c
    300c:	fd 8c       	ldd	r15, Y+29	; 0x1d
    300e:	3f ef       	ldi	r19, 0xFF	; 255
    3010:	e3 1a       	sub	r14, r19
    3012:	f3 0a       	sbc	r15, r19
    3014:	ee e2       	ldi	r30, 0x2E	; 46
    3016:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3018:	bd 8d       	ldd	r27, Y+29	; 0x1d
    301a:	ec 93       	st	X, r30
    301c:	12 c0       	rjmp	.+36     	; 0x3042 <vDisplayWriteStringAtPos+0x3a6>

    while (exponent < 0 && places < width) {
    301e:	00 e0       	ldi	r16, 0x00	; 0
    3020:	10 e0       	ldi	r17, 0x00	; 0
        *buffer++ = '0';
    3022:	ff ef       	ldi	r31, 0xFF	; 255
    3024:	ef 1a       	sub	r14, r31
    3026:	ff 0a       	sbc	r15, r31
    3028:	f7 01       	movw	r30, r14
    302a:	31 97       	sbiw	r30, 0x01	; 1
    302c:	20 e3       	ldi	r18, 0x30	; 48
    302e:	20 83       	st	Z, r18
        --exponent;
    3030:	01 97       	sbiw	r24, 0x01	; 1
        ++places;
    3032:	0f 5f       	subi	r16, 0xFF	; 255
    3034:	1f 4f       	sbci	r17, 0xFF	; 255
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    3036:	99 23       	and	r25, r25
    3038:	24 f4       	brge	.+8      	; 0x3042 <vDisplayWriteStringAtPos+0x3a6>
    303a:	04 30       	cpi	r16, 0x04	; 4
    303c:	11 05       	cpc	r17, r1
    303e:	8c f3       	brlt	.-30     	; 0x3022 <vDisplayWriteStringAtPos+0x386>
    3040:	31 c0       	rjmp	.+98     	; 0x30a4 <vDisplayWriteStringAtPos+0x408>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    3042:	04 30       	cpi	r16, 0x04	; 4
    3044:	11 05       	cpc	r17, r1
    3046:	74 f5       	brge	.+92     	; 0x30a4 <vDisplayWriteStringAtPos+0x408>
    3048:	37 01       	movw	r6, r14
    304a:	84 e0       	ldi	r24, 0x04	; 4
    304c:	90 e0       	ldi	r25, 0x00	; 0
    304e:	80 1b       	sub	r24, r16
    3050:	91 0b       	sbc	r25, r17
    3052:	e8 0e       	add	r14, r24
    3054:	f9 1e       	adc	r15, r25
    3056:	87 01       	movw	r16, r14
    3058:	6f 89       	ldd	r22, Y+23	; 0x17
    305a:	78 8d       	ldd	r23, Y+24	; 0x18
    305c:	89 8d       	ldd	r24, Y+25	; 0x19
    305e:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10.0;
    3060:	20 e0       	ldi	r18, 0x00	; 0
    3062:	30 e0       	ldi	r19, 0x00	; 0
    3064:	40 e2       	ldi	r20, 0x20	; 32
    3066:	51 e4       	ldi	r21, 0x41	; 65
    3068:	0e 94 77 1c 	call	0x38ee	; 0x38ee <__mulsf3>
    306c:	6f 8b       	std	Y+23, r22	; 0x17
    306e:	78 8f       	std	Y+24, r23	; 0x18
    3070:	89 8f       	std	Y+25, r24	; 0x19
    3072:	9a 8f       	std	Y+26, r25	; 0x1a
    3074:	0e 94 8a 1b 	call	0x3714	; 0x3714 <__fixsfsi>
        *buffer++ = digit + '0';
    3078:	20 e3       	ldi	r18, 0x30	; 48
    307a:	26 0f       	add	r18, r22
    307c:	d3 01       	movw	r26, r6
    307e:	2d 93       	st	X+, r18
    3080:	3d 01       	movw	r6, r26
        value = value * 10.0 - digit;
    3082:	07 2e       	mov	r0, r23
    3084:	00 0c       	add	r0, r0
    3086:	88 0b       	sbc	r24, r24
    3088:	99 0b       	sbc	r25, r25
    308a:	0e 94 c2 1b 	call	0x3784	; 0x3784 <__floatsisf>
    308e:	9b 01       	movw	r18, r22
    3090:	ac 01       	movw	r20, r24
    3092:	6f 89       	ldd	r22, Y+23	; 0x17
    3094:	78 8d       	ldd	r23, Y+24	; 0x18
    3096:	89 8d       	ldd	r24, Y+25	; 0x19
    3098:	9a 8d       	ldd	r25, Y+26	; 0x1a
    309a:	0e 94 a6 1a 	call	0x354c	; 0x354c <__subsf3>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    309e:	60 16       	cp	r6, r16
    30a0:	71 06       	cpc	r7, r17
    30a2:	f1 f6       	brne	.-68     	; 0x3060 <vDisplayWriteStringAtPos+0x3c4>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
        ++places;
    }
    *buffer = '\0';
    30a4:	f7 01       	movw	r30, r14
    30a6:	10 82       	st	Z, r1
    30a8:	94 01       	movw	r18, r8
    30aa:	f4 01       	movw	r30, r8
    30ac:	e2 52       	subi	r30, 0x22	; 34
    30ae:	f3 4d       	sbci	r31, 0xD3	; 211
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    30b0:	42 ef       	ldi	r20, 0xF2	; 242
    30b2:	5c e2       	ldi	r21, 0x2C	; 44
    30b4:	80 e0       	ldi	r24, 0x00	; 0
    30b6:	90 e0       	ldi	r25, 0x00	; 0
    30b8:	05 c0       	rjmp	.+10     	; 0x30c4 <vDisplayWriteStringAtPos+0x428>

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    30ba:	da 01       	movw	r26, r20
    30bc:	6d 91       	ld	r22, X+
    30be:	ad 01       	movw	r20, r26
    30c0:	61 93       	st	Z+, r22
				break;

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    30c2:	01 96       	adiw	r24, 0x01	; 1
    30c4:	d6 01       	movw	r26, r12
    30c6:	0d 90       	ld	r0, X+
    30c8:	00 20       	and	r0, r0
    30ca:	e9 f7       	brne	.-6      	; 0x30c6 <vDisplayWriteStringAtPos+0x42a>
    30cc:	11 97       	sbiw	r26, 0x01	; 1
    30ce:	a2 5f       	subi	r26, 0xF2	; 242
    30d0:	bc 42       	sbci	r27, 0x2C	; 44
    30d2:	8a 17       	cp	r24, r26
    30d4:	9b 07       	cpc	r25, r27
    30d6:	88 f3       	brcs	.-30     	; 0x30ba <vDisplayWriteStringAtPos+0x41e>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    30d8:	4d 01       	movw	r8, r26
    30da:	82 0e       	add	r8, r18
    30dc:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    30de:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    30e0:	d2 01       	movw	r26, r4
    30e2:	15 c1       	rjmp	.+554    	; 0x330e <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    30e4:	17 01       	movw	r2, r14
    30e6:	b4 e0       	ldi	r27, 0x04	; 4
    30e8:	2b 0e       	add	r2, r27
    30ea:	31 1c       	adc	r3, r1
    30ec:	d7 01       	movw	r26, r14
    30ee:	8d 91       	ld	r24, X+
    30f0:	9d 91       	ld	r25, X+
    30f2:	0d 90       	ld	r0, X+
    30f4:	bc 91       	ld	r27, X
    30f6:	a0 2d       	mov	r26, r0
    30f8:	8f 8b       	std	Y+23, r24	; 0x17
    30fa:	98 8f       	std	Y+24, r25	; 0x18
    30fc:	a9 8f       	std	Y+25, r26	; 0x19
    30fe:	ba 8f       	std	Y+26, r27	; 0x1a

void ftoa_sci(char *buffer, double value) {
    int exponent = 0;    
    static const int width = 4;

    if (value == 0.0) {
    3100:	20 e0       	ldi	r18, 0x00	; 0
    3102:	30 e0       	ldi	r19, 0x00	; 0
    3104:	a9 01       	movw	r20, r18
    3106:	bc 01       	movw	r22, r24
    3108:	cd 01       	movw	r24, r26
    310a:	0e 94 13 1b 	call	0x3626	; 0x3626 <__cmpsf2>
    310e:	81 11       	cpse	r24, r1
    3110:	05 c0       	rjmp	.+10     	; 0x311c <vDisplayWriteStringAtPos+0x480>
        buffer[0] = '0';
    3112:	20 e3       	ldi	r18, 0x30	; 48
    3114:	f6 01       	movw	r30, r12
    3116:	20 83       	st	Z, r18
        buffer[1] = '\0';
    3118:	11 82       	std	Z+1, r1	; 0x01
    311a:	ca c0       	rjmp	.+404    	; 0x32b0 <vDisplayWriteStringAtPos+0x614>
        return;
    }

    if (value < 0.0) {
    311c:	20 e0       	ldi	r18, 0x00	; 0
    311e:	30 e0       	ldi	r19, 0x00	; 0
    3120:	a9 01       	movw	r20, r18
    3122:	6f 89       	ldd	r22, Y+23	; 0x17
    3124:	78 8d       	ldd	r23, Y+24	; 0x18
    3126:	89 8d       	ldd	r24, Y+25	; 0x19
    3128:	9a 8d       	ldd	r25, Y+26	; 0x1a
    312a:	0e 94 13 1b 	call	0x3626	; 0x3626 <__cmpsf2>
    312e:	88 23       	and	r24, r24
    3130:	9c f4       	brge	.+38     	; 0x3158 <vDisplayWriteStringAtPos+0x4bc>
        *buffer++ = '-';
    3132:	ed e2       	ldi	r30, 0x2D	; 45
    3134:	d6 01       	movw	r26, r12
    3136:	ec 93       	st	X, r30
        value = -value;
    3138:	8f 89       	ldd	r24, Y+23	; 0x17
    313a:	98 8d       	ldd	r25, Y+24	; 0x18
    313c:	a9 8d       	ldd	r26, Y+25	; 0x19
    313e:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3140:	b0 58       	subi	r27, 0x80	; 128
    3142:	8f 8b       	std	Y+23, r24	; 0x17
    3144:	98 8f       	std	Y+24, r25	; 0x18
    3146:	a9 8f       	std	Y+25, r26	; 0x19
    3148:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
        *buffer++ = '-';
    314a:	0f 2e       	mov	r0, r31
    314c:	f3 ef       	ldi	r31, 0xF3	; 243
    314e:	6f 2e       	mov	r6, r31
    3150:	fc e2       	ldi	r31, 0x2C	; 44
    3152:	7f 2e       	mov	r7, r31
    3154:	f0 2d       	mov	r31, r0
    3156:	01 c0       	rjmp	.+2      	; 0x315a <vDisplayWriteStringAtPos+0x4be>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
    3158:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    315a:	20 e0       	ldi	r18, 0x00	; 0
    315c:	30 e0       	ldi	r19, 0x00	; 0
    315e:	40 e8       	ldi	r20, 0x80	; 128
    3160:	5f e3       	ldi	r21, 0x3F	; 63
    3162:	6f 89       	ldd	r22, Y+23	; 0x17
    3164:	78 8d       	ldd	r23, Y+24	; 0x18
    3166:	89 8d       	ldd	r24, Y+25	; 0x19
    3168:	9a 8d       	ldd	r25, Y+26	; 0x1a
    316a:	0e 94 72 1c 	call	0x38e4	; 0x38e4 <__gesf2>
    316e:	88 23       	and	r24, r24
    3170:	dc f0       	brlt	.+54     	; 0x31a8 <vDisplayWriteStringAtPos+0x50c>
    3172:	00 e0       	ldi	r16, 0x00	; 0
    3174:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    3176:	20 e0       	ldi	r18, 0x00	; 0
    3178:	30 e0       	ldi	r19, 0x00	; 0
    317a:	40 e2       	ldi	r20, 0x20	; 32
    317c:	51 e4       	ldi	r21, 0x41	; 65
    317e:	6f 89       	ldd	r22, Y+23	; 0x17
    3180:	78 8d       	ldd	r23, Y+24	; 0x18
    3182:	89 8d       	ldd	r24, Y+25	; 0x19
    3184:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3186:	0e 94 18 1b 	call	0x3630	; 0x3630 <__divsf3>
    318a:	6f 8b       	std	Y+23, r22	; 0x17
    318c:	78 8f       	std	Y+24, r23	; 0x18
    318e:	89 8f       	std	Y+25, r24	; 0x19
    3190:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    3192:	0f 5f       	subi	r16, 0xFF	; 255
    3194:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3196:	20 e0       	ldi	r18, 0x00	; 0
    3198:	30 e0       	ldi	r19, 0x00	; 0
    319a:	40 e8       	ldi	r20, 0x80	; 128
    319c:	5f e3       	ldi	r21, 0x3F	; 63
    319e:	0e 94 72 1c 	call	0x38e4	; 0x38e4 <__gesf2>
    31a2:	88 23       	and	r24, r24
    31a4:	44 f7       	brge	.-48     	; 0x3176 <vDisplayWriteStringAtPos+0x4da>
    31a6:	02 c0       	rjmp	.+4      	; 0x31ac <vDisplayWriteStringAtPos+0x510>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    31a8:	00 e0       	ldi	r16, 0x00	; 0
    31aa:	10 e0       	ldi	r17, 0x00	; 0
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    31ac:	2d ec       	ldi	r18, 0xCD	; 205
    31ae:	3c ec       	ldi	r19, 0xCC	; 204
    31b0:	4c ec       	ldi	r20, 0xCC	; 204
    31b2:	5d e3       	ldi	r21, 0x3D	; 61
    31b4:	6f 89       	ldd	r22, Y+23	; 0x17
    31b6:	78 8d       	ldd	r23, Y+24	; 0x18
    31b8:	89 8d       	ldd	r24, Y+25	; 0x19
    31ba:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31bc:	0e 94 13 1b 	call	0x3626	; 0x3626 <__cmpsf2>
    31c0:	88 23       	and	r24, r24
    31c2:	c4 f4       	brge	.+48     	; 0x31f4 <vDisplayWriteStringAtPos+0x558>
        value *= 10.0;
    31c4:	20 e0       	ldi	r18, 0x00	; 0
    31c6:	30 e0       	ldi	r19, 0x00	; 0
    31c8:	40 e2       	ldi	r20, 0x20	; 32
    31ca:	51 e4       	ldi	r21, 0x41	; 65
    31cc:	6f 89       	ldd	r22, Y+23	; 0x17
    31ce:	78 8d       	ldd	r23, Y+24	; 0x18
    31d0:	89 8d       	ldd	r24, Y+25	; 0x19
    31d2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31d4:	0e 94 77 1c 	call	0x38ee	; 0x38ee <__mulsf3>
    31d8:	6f 8b       	std	Y+23, r22	; 0x17
    31da:	78 8f       	std	Y+24, r23	; 0x18
    31dc:	89 8f       	std	Y+25, r24	; 0x19
    31de:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    31e0:	01 50       	subi	r16, 0x01	; 1
    31e2:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    31e4:	2d ec       	ldi	r18, 0xCD	; 205
    31e6:	3c ec       	ldi	r19, 0xCC	; 204
    31e8:	4c ec       	ldi	r20, 0xCC	; 204
    31ea:	5d e3       	ldi	r21, 0x3D	; 61
    31ec:	0e 94 13 1b 	call	0x3626	; 0x3626 <__cmpsf2>
    31f0:	88 23       	and	r24, r24
    31f2:	44 f3       	brlt	.-48     	; 0x31c4 <vDisplayWriteStringAtPos+0x528>
        value = -value;
    }

    exponent = normalize(&value);

    int digit = value * 10.0;
    31f4:	20 e0       	ldi	r18, 0x00	; 0
    31f6:	30 e0       	ldi	r19, 0x00	; 0
    31f8:	40 e2       	ldi	r20, 0x20	; 32
    31fa:	51 e4       	ldi	r21, 0x41	; 65
    31fc:	6f 89       	ldd	r22, Y+23	; 0x17
    31fe:	78 8d       	ldd	r23, Y+24	; 0x18
    3200:	89 8d       	ldd	r24, Y+25	; 0x19
    3202:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3204:	0e 94 77 1c 	call	0x38ee	; 0x38ee <__mulsf3>
    3208:	6f 8b       	std	Y+23, r22	; 0x17
    320a:	78 8f       	std	Y+24, r23	; 0x18
    320c:	89 8f       	std	Y+25, r24	; 0x19
    320e:	9a 8f       	std	Y+26, r25	; 0x1a
    3210:	0e 94 8a 1b 	call	0x3714	; 0x3714 <__fixsfsi>
    *buffer++ = digit + '0';
    3214:	20 e3       	ldi	r18, 0x30	; 48
    3216:	26 0f       	add	r18, r22
    3218:	d3 01       	movw	r26, r6
    321a:	2c 93       	st	X, r18
    value = value * 10.0 - digit;
    321c:	07 2e       	mov	r0, r23
    321e:	00 0c       	add	r0, r0
    3220:	88 0b       	sbc	r24, r24
    3222:	99 0b       	sbc	r25, r25
    3224:	0e 94 c2 1b 	call	0x3784	; 0x3784 <__floatsisf>
    3228:	9b 01       	movw	r18, r22
    322a:	ac 01       	movw	r20, r24
    322c:	6f 89       	ldd	r22, Y+23	; 0x17
    322e:	78 8d       	ldd	r23, Y+24	; 0x18
    3230:	89 8d       	ldd	r24, Y+25	; 0x19
    3232:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3234:	0e 94 a6 1a 	call	0x354c	; 0x354c <__subsf3>
    --exponent;
    3238:	f8 01       	movw	r30, r16
    323a:	31 97       	sbiw	r30, 0x01	; 1
    323c:	ec 8f       	std	Y+28, r30	; 0x1c
    323e:	fd 8f       	std	Y+29, r31	; 0x1d

    *buffer++ = '.';
    3240:	ee e2       	ldi	r30, 0x2E	; 46
    3242:	d3 01       	movw	r26, r6
    3244:	11 96       	adiw	r26, 0x01	; 1
    3246:	ec 93       	st	X, r30
    3248:	83 01       	movw	r16, r6
    324a:	0e 5f       	subi	r16, 0xFE	; 254
    324c:	1f 4f       	sbci	r17, 0xFF	; 255
    324e:	73 01       	movw	r14, r6
    3250:	f6 e0       	ldi	r31, 0x06	; 6
    3252:	ef 0e       	add	r14, r31
    3254:	f1 1c       	adc	r15, r1

    for (int i = 0; i < width; i++) {
        int digit = value * 10.0;
    3256:	20 e0       	ldi	r18, 0x00	; 0
    3258:	30 e0       	ldi	r19, 0x00	; 0
    325a:	40 e2       	ldi	r20, 0x20	; 32
    325c:	51 e4       	ldi	r21, 0x41	; 65
    325e:	0e 94 77 1c 	call	0x38ee	; 0x38ee <__mulsf3>
    3262:	6f 8b       	std	Y+23, r22	; 0x17
    3264:	78 8f       	std	Y+24, r23	; 0x18
    3266:	89 8f       	std	Y+25, r24	; 0x19
    3268:	9a 8f       	std	Y+26, r25	; 0x1a
    326a:	0e 94 8a 1b 	call	0x3714	; 0x3714 <__fixsfsi>
        *buffer++ = digit + '0';
    326e:	20 e3       	ldi	r18, 0x30	; 48
    3270:	26 0f       	add	r18, r22
    3272:	d8 01       	movw	r26, r16
    3274:	2d 93       	st	X+, r18
    3276:	8d 01       	movw	r16, r26
        value = value * 10.0 - digit;
    3278:	07 2e       	mov	r0, r23
    327a:	00 0c       	add	r0, r0
    327c:	88 0b       	sbc	r24, r24
    327e:	99 0b       	sbc	r25, r25
    3280:	0e 94 c2 1b 	call	0x3784	; 0x3784 <__floatsisf>
    3284:	9b 01       	movw	r18, r22
    3286:	ac 01       	movw	r20, r24
    3288:	6f 89       	ldd	r22, Y+23	; 0x17
    328a:	78 8d       	ldd	r23, Y+24	; 0x18
    328c:	89 8d       	ldd	r24, Y+25	; 0x19
    328e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3290:	0e 94 a6 1a 	call	0x354c	; 0x354c <__subsf3>
    value = value * 10.0 - digit;
    --exponent;

    *buffer++ = '.';

    for (int i = 0; i < width; i++) {
    3294:	0e 15       	cp	r16, r14
    3296:	1f 05       	cpc	r17, r15
    3298:	f1 f6       	brne	.-68     	; 0x3256 <vDisplayWriteStringAtPos+0x5ba>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
    }

    *buffer++ = 'e';
    329a:	25 e6       	ldi	r18, 0x65	; 101
    329c:	f3 01       	movw	r30, r6
    329e:	26 83       	std	Z+6, r18	; 0x06
    32a0:	b3 01       	movw	r22, r6
    32a2:	69 5f       	subi	r22, 0xF9	; 249
    32a4:	7f 4f       	sbci	r23, 0xFF	; 255
    32a6:	4a e0       	ldi	r20, 0x0A	; 10
    32a8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    32aa:	9d 8d       	ldd	r25, Y+29	; 0x1d
    32ac:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <__itoa_ncheck>
    32b0:	94 01       	movw	r18, r8
    32b2:	f4 01       	movw	r30, r8
    32b4:	e2 52       	subi	r30, 0x22	; 34
    32b6:	f3 4d       	sbci	r31, 0xD3	; 211
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    32b8:	42 ef       	ldi	r20, 0xF2	; 242
    32ba:	5c e2       	ldi	r21, 0x2C	; 44
    32bc:	80 e0       	ldi	r24, 0x00	; 0
    32be:	90 e0       	ldi	r25, 0x00	; 0
    32c0:	05 c0       	rjmp	.+10     	; 0x32cc <vDisplayWriteStringAtPos+0x630>

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    32c2:	da 01       	movw	r26, r20
    32c4:	6d 91       	ld	r22, X+
    32c6:	ad 01       	movw	r20, r26
    32c8:	61 93       	st	Z+, r22
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    32ca:	01 96       	adiw	r24, 0x01	; 1
    32cc:	d6 01       	movw	r26, r12
    32ce:	0d 90       	ld	r0, X+
    32d0:	00 20       	and	r0, r0
    32d2:	e9 f7       	brne	.-6      	; 0x32ce <vDisplayWriteStringAtPos+0x632>
    32d4:	11 97       	sbiw	r26, 0x01	; 1
    32d6:	a2 5f       	subi	r26, 0xF2	; 242
    32d8:	bc 42       	sbci	r27, 0x2C	; 44
    32da:	8a 17       	cp	r24, r26
    32dc:	9b 07       	cpc	r25, r27
    32de:	88 f3       	brcs	.-30     	; 0x32c2 <vDisplayWriteStringAtPos+0x626>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    32e0:	4d 01       	movw	r8, r26
    32e2:	82 0e       	add	r8, r18
    32e4:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    32e6:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    32e8:	d2 01       	movw	r26, r4
    32ea:	11 c0       	rjmp	.+34     	; 0x330e <vDisplayWriteStringAtPos+0x672>
				break;
			}
		}
		else {
			str[length] = ch;
			if(str[length] == '\n') {
    32ec:	8a 30       	cpi	r24, 0x0A	; 10
    32ee:	29 f0       	breq	.+10     	; 0x32fa <vDisplayWriteStringAtPos+0x65e>
				length += strlen(buffer);
				break;
			}
		}
		else {
			str[length] = ch;
    32f0:	f4 01       	movw	r30, r8
    32f2:	e2 52       	subi	r30, 0x22	; 34
    32f4:	f3 4d       	sbci	r31, 0xD3	; 211
    32f6:	80 83       	st	Z, r24
    32f8:	04 c0       	rjmp	.+8      	; 0x3302 <vDisplayWriteStringAtPos+0x666>
			if(str[length] == '\n') {
				str[length] = '\0';				
    32fa:	f4 01       	movw	r30, r8
    32fc:	e2 52       	subi	r30, 0x22	; 34
    32fe:	f3 4d       	sbci	r31, 0xD3	; 211
    3300:	10 82       	st	Z, r1
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    3302:	11 96       	adiw	r26, 0x01	; 1
		else {
			str[length] = ch;
			if(str[length] == '\n') {
				str[length] = '\0';				
			}
			length++;
    3304:	ef ef       	ldi	r30, 0xFF	; 255
    3306:	8e 1a       	sub	r8, r30
    3308:	9e 0a       	sbc	r9, r30
    330a:	01 c0       	rjmp	.+2      	; 0x330e <vDisplayWriteStringAtPos+0x672>
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    330c:	d2 01       	movw	r26, r4
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    330e:	8c 91       	ld	r24, X
    3310:	81 11       	cpse	r24, r1
    3312:	01 cd       	rjmp	.-1534   	; 0x2d16 <vDisplayWriteStringAtPos+0x7a>
				str[length] = '\0';				
			}
			length++;
		}
	}
	if(length + pos >= 20) {
    3314:	8d a9       	ldd	r24, Y+53	; 0x35
    3316:	9e a9       	ldd	r25, Y+54	; 0x36
    3318:	88 0d       	add	r24, r8
    331a:	99 1d       	adc	r25, r9
    331c:	44 97       	sbiw	r24, 0x14	; 20
    331e:	3c f0       	brlt	.+14     	; 0x332e <vDisplayWriteStringAtPos+0x692>
		length = 20-pos;
    3320:	84 e1       	ldi	r24, 0x14	; 20
    3322:	90 e0       	ldi	r25, 0x00	; 0
    3324:	4c 01       	movw	r8, r24
    3326:	2d a9       	ldd	r18, Y+53	; 0x35
    3328:	3e a9       	ldd	r19, Y+54	; 0x36
    332a:	82 1a       	sub	r8, r18
    332c:	93 0a       	sbc	r9, r19
    332e:	fe 01       	movw	r30, r28
    3330:	33 96       	adiw	r30, 0x03	; 3
    3332:	ce 01       	movw	r24, r28
    3334:	47 96       	adiw	r24, 0x17	; 23
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    3336:	df 01       	movw	r26, r30
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
    3338:	1d 92       	st	X+, r1
	}
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
    333a:	a8 17       	cp	r26, r24
    333c:	b9 07       	cpc	r27, r25
    333e:	e1 f7       	brne	.-8      	; 0x3338 <vDisplayWriteStringAtPos+0x69c>
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
    3340:	3b 8d       	ldd	r19, Y+27	; 0x1b
    3342:	39 83       	std	Y+1, r19	; 0x01
	newLine.displayPos = pos;
    3344:	8d a9       	ldd	r24, Y+53	; 0x35
    3346:	8a 83       	std	Y+2, r24	; 0x02
	for(int i = 0; i < length;i++) {
    3348:	18 14       	cp	r1, r8
    334a:	19 04       	cpc	r1, r9
    334c:	5c f4       	brge	.+22     	; 0x3364 <vDisplayWriteStringAtPos+0x6c8>
    334e:	ce 01       	movw	r24, r28
    3350:	88 0d       	add	r24, r8
    3352:	99 1d       	adc	r25, r9
    3354:	03 96       	adiw	r24, 0x03	; 3
		newLine.displayBuffer[i] = str[i];
    3356:	d5 01       	movw	r26, r10
    3358:	2d 91       	ld	r18, X+
    335a:	5d 01       	movw	r10, r26
    335c:	21 93       	st	Z+, r18
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
	newLine.displayPos = pos;
	for(int i = 0; i < length;i++) {
    335e:	8e 17       	cp	r24, r30
    3360:	9f 07       	cpc	r25, r31
    3362:	c9 f7       	brne	.-14     	; 0x3356 <vDisplayWriteStringAtPos+0x6ba>
		newLine.displayBuffer[i] = str[i];
	}	
	xQueueSend(displayLineQueue, (void *) &newLine, portMAX_DELAY);
    3364:	00 e0       	ldi	r16, 0x00	; 0
    3366:	2f ef       	ldi	r18, 0xFF	; 255
    3368:	3f ef       	ldi	r19, 0xFF	; 255
    336a:	a9 01       	movw	r20, r18
    336c:	be 01       	movw	r22, r28
    336e:	6f 5f       	subi	r22, 0xFF	; 255
    3370:	7f 4f       	sbci	r23, 0xFF	; 255
    3372:	80 91 15 3f 	lds	r24, 0x3F15	; 0x803f15 <displayLineQueue>
    3376:	90 91 16 3f 	lds	r25, 0x3F16	; 0x803f16 <displayLineQueue+0x1>
    337a:	0e 94 00 08 	call	0x1000	; 0x1000 <xQueueGenericSend>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    337e:	1b c0       	rjmp	.+54     	; 0x33b6 <vDisplayWriteStringAtPos+0x71a>
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3380:	2d ec       	ldi	r18, 0xCD	; 205
    3382:	3c ec       	ldi	r19, 0xCC	; 204
    3384:	4c ec       	ldi	r20, 0xCC	; 204
    3386:	5d e3       	ldi	r21, 0x3D	; 61
    3388:	6f 89       	ldd	r22, Y+23	; 0x17
    338a:	78 8d       	ldd	r23, Y+24	; 0x18
    338c:	89 8d       	ldd	r24, Y+25	; 0x19
    338e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3390:	0e 94 13 1b 	call	0x3626	; 0x3626 <__cmpsf2>
    3394:	88 23       	and	r24, r24
    3396:	0c f4       	brge	.+2      	; 0x339a <vDisplayWriteStringAtPos+0x6fe>
    3398:	d6 cd       	rjmp	.-1108   	; 0x2f46 <vDisplayWriteStringAtPos+0x2aa>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    339a:	80 e0       	ldi	r24, 0x00	; 0
    339c:	90 e0       	ldi	r25, 0x00	; 0
    339e:	26 ce       	rjmp	.-948    	; 0x2fec <vDisplayWriteStringAtPos+0x350>
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    33a0:	20 e3       	ldi	r18, 0x30	; 48
    33a2:	ec 8d       	ldd	r30, Y+28	; 0x1c
    33a4:	fd 8d       	ldd	r31, Y+29	; 0x1d
    33a6:	20 83       	st	Z, r18

    *buffer++ = '.';
    33a8:	7f 01       	movw	r14, r30
    33aa:	32 e0       	ldi	r19, 0x02	; 2
    33ac:	e3 0e       	add	r14, r19
    33ae:	f1 1c       	adc	r15, r1
    33b0:	8e e2       	ldi	r24, 0x2E	; 46
    33b2:	81 83       	std	Z+1, r24	; 0x01
    33b4:	46 ce       	rjmp	.-884    	; 0x3042 <vDisplayWriteStringAtPos+0x3a6>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    33b6:	6d 96       	adiw	r28, 0x1d	; 29
    33b8:	cd bf       	out	0x3d, r28	; 61
    33ba:	de bf       	out	0x3e, r29	; 62
    33bc:	df 91       	pop	r29
    33be:	cf 91       	pop	r28
    33c0:	1f 91       	pop	r17
    33c2:	0f 91       	pop	r16
    33c4:	ff 90       	pop	r15
    33c6:	ef 90       	pop	r14
    33c8:	df 90       	pop	r13
    33ca:	cf 90       	pop	r12
    33cc:	bf 90       	pop	r11
    33ce:	af 90       	pop	r10
    33d0:	9f 90       	pop	r9
    33d2:	8f 90       	pop	r8
    33d4:	7f 90       	pop	r7
    33d6:	6f 90       	pop	r6
    33d8:	5f 90       	pop	r5
    33da:	4f 90       	pop	r4
    33dc:	3f 90       	pop	r3
    33de:	2f 90       	pop	r2
    33e0:	08 95       	ret

000033e2 <vTask_DMAHandler>:
EventGroupHandle_t xSignalProcessEventGroup;

void vTask_DMAHandler(void *pvParameters) 
{
	//Do things and Stuff with DMA!
	xDMAProcessEventGroup = xEventGroupCreate();
    33e2:	0e 94 a8 02 	call	0x550	; 0x550 <xEventGroupCreate>
    33e6:	80 93 08 2d 	sts	0x2D08, r24	; 0x802d08 <xDMAProcessEventGroup>
    33ea:	90 93 09 2d 	sts	0x2D09, r25	; 0x802d09 <xDMAProcessEventGroup+0x1>
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,count_after_peak = 0;
	PORTF.DIRSET = PIN1_bm; /*LED1*/
    33ee:	e0 ea       	ldi	r30, 0xA0	; 160
    33f0:	f6 e0       	ldi	r31, 0x06	; 6
    33f2:	82 e0       	ldi	r24, 0x02	; 2
    33f4:	81 83       	std	Z+1, r24	; 0x01
	PORTF.DIRSET = PIN2_bm; /*LED2*/
    33f6:	94 e0       	ldi	r25, 0x04	; 4
    33f8:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN0_bm;
    33fa:	e0 e8       	ldi	r30, 0x80	; 128
    33fc:	f6 e0       	ldi	r31, 0x06	; 6
    33fe:	91 e0       	ldi	r25, 0x01	; 1
    3400:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN1_bm;
    3402:	81 83       	std	Z+1, r24	; 0x01
					//}
				//}
			}
			count_buffer_b++;
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x04));
    3404:	0f 2e       	mov	r0, r31
    3406:	f0 ea       	ldi	r31, 0xA0	; 160
    3408:	af 2e       	mov	r10, r31
    340a:	f6 e0       	ldi	r31, 0x06	; 6
    340c:	bf 2e       	mov	r11, r31
    340e:	f0 2d       	mov	r31, r0
	PORTE.DIRSET = PIN0_bm;
	PORTE.DIRSET = PIN1_bm;
	
	while(1)
	{
		uxBits = xEventGroupWaitBits(
    3410:	cc 24       	eor	r12, r12
    3412:	ca 94       	dec	r12
    3414:	dc 2c       	mov	r13, r12
    3416:	76 01       	movw	r14, r12
    3418:	00 e0       	ldi	r16, 0x00	; 0
    341a:	21 e0       	ldi	r18, 0x01	; 1
    341c:	43 e0       	ldi	r20, 0x03	; 3
    341e:	50 e0       	ldi	r21, 0x00	; 0
    3420:	60 e0       	ldi	r22, 0x00	; 0
    3422:	70 e0       	ldi	r23, 0x00	; 0
    3424:	80 91 08 2d 	lds	r24, 0x2D08	; 0x802d08 <xDMAProcessEventGroup>
    3428:	90 91 09 2d 	lds	r25, 0x2D09	; 0x802d09 <xDMAProcessEventGroup+0x1>
    342c:	0e 94 bd 02 	call	0x57a	; 0x57a <xEventGroupWaitBits>
		pdTRUE,        /* Bits should be cleared before returning. */
		pdFALSE,       /* Don't wait for both bits, either bit will do. */
		portMAX_DELAY );/* Wait a maximum for either bit to be set. */
			
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
    3430:	60 ff       	sbrs	r22, 0
    3432:	2f c0       	rjmp	.+94     	; 0x3492 <vTask_DMAHandler+0xb0>
    3434:	c0 e0       	ldi	r28, 0x00	; 0
    3436:	d0 e0       	ldi	r29, 0x00	; 0
		{
			//Do stuff with BufferA
			//buffer_a ....
			for (i=0;i<2047;i++)//Detect signal 
			{
				if (buffer_a[i] >= 20)
    3438:	fe 01       	movw	r30, r28
    343a:	ec 5f       	subi	r30, 0xFC	; 252
    343c:	f8 4c       	sbci	r31, 0xC8	; 200
    343e:	80 81       	ld	r24, Z
    3440:	84 31       	cpi	r24, 0x14	; 20
    3442:	a8 f0       	brcs	.+42     	; 0x346e <vTask_DMAHandler+0x8c>
				{
					xResult = xEventGroupSetBits(
    3444:	42 e0       	ldi	r20, 0x02	; 2
    3446:	50 e0       	ldi	r21, 0x00	; 0
    3448:	60 e0       	ldi	r22, 0x00	; 0
    344a:	70 e0       	ldi	r23, 0x00	; 0
    344c:	80 91 04 2e 	lds	r24, 0x2E04	; 0x802e04 <xSignalProcessEventGroup>
    3450:	90 91 05 2e 	lds	r25, 0x2E05	; 0x802e05 <xSignalProcessEventGroup+0x1>
    3454:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
								xSignalProcessEventGroup,   /* The event group being updated. */
								Process_Signal_BufferB /* The bits being set. */
								);
					if( xResult & Process_Signal_BufferB )
    3458:	61 ff       	sbrs	r22, 1
    345a:	09 c0       	rjmp	.+18     	; 0x346e <vTask_DMAHandler+0x8c>
					{
						count_array_a++;
    345c:	80 91 02 37 	lds	r24, 0x3702	; 0x803702 <count_array_a>
    3460:	90 91 03 37 	lds	r25, 0x3703	; 0x803703 <count_array_a+0x1>
    3464:	01 96       	adiw	r24, 0x01	; 1
    3466:	80 93 02 37 	sts	0x3702, r24	; 0x803702 <count_array_a>
    346a:	90 93 03 37 	sts	0x3703, r25	; 0x803703 <count_array_a+0x1>
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
		{
			//Do stuff with BufferA
			//buffer_a ....
			for (i=0;i<2047;i++)//Detect signal 
    346e:	21 96       	adiw	r28, 0x01	; 1
    3470:	cf 3f       	cpi	r28, 0xFF	; 255
    3472:	87 e0       	ldi	r24, 0x07	; 7
    3474:	d8 07       	cpc	r29, r24
    3476:	01 f7       	brne	.-64     	; 0x3438 <vTask_DMAHandler+0x56>
					//{
						//wenn pegel fr 20 werte kleiner als 10 ist -> kein signal mehr -> stop timer
					//}
				//}
			}
			count_buffer_a++;
    3478:	80 91 07 2d 	lds	r24, 0x2D07	; 0x802d07 <count_buffer_a>
    347c:	8f 5f       	subi	r24, 0xFF	; 255
    347e:	80 93 07 2d 	sts	0x2D07, r24	; 0x802d07 <count_buffer_a>
			
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x02));
    3482:	f5 01       	movw	r30, r10
    3484:	84 81       	ldd	r24, Z+4	; 0x04
    3486:	8d 7f       	andi	r24, 0xFD	; 253
    3488:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x04;
    348a:	84 81       	ldd	r24, Z+4	; 0x04
    348c:	84 60       	ori	r24, 0x04	; 4
    348e:	84 83       	std	Z+4, r24	; 0x04
    3490:	30 c0       	rjmp	.+96     	; 0x34f2 <vTask_DMAHandler+0x110>
    3492:	c0 e0       	ldi	r28, 0x00	; 0
    3494:	d0 e0       	ldi	r29, 0x00	; 0
			//Do stuff with BufferB
			//buffer_b ....
			i = i;
			for (i=0;i<2047;i++)
			{				
				if (buffer_b[i] >= 20)
    3496:	fe 01       	movw	r30, r28
    3498:	ee 5f       	subi	r30, 0xFE	; 254
    349a:	f0 4d       	sbci	r31, 0xD0	; 208
    349c:	80 81       	ld	r24, Z
    349e:	84 31       	cpi	r24, 0x14	; 20
    34a0:	b8 f0       	brcs	.+46     	; 0x34d0 <vTask_DMAHandler+0xee>
				{
				xResult = xEventGroupSetBits(
    34a2:	41 e0       	ldi	r20, 0x01	; 1
    34a4:	50 e0       	ldi	r21, 0x00	; 0
    34a6:	60 e0       	ldi	r22, 0x00	; 0
    34a8:	70 e0       	ldi	r23, 0x00	; 0
    34aa:	80 91 04 2e 	lds	r24, 0x2E04	; 0x802e04 <xSignalProcessEventGroup>
    34ae:	90 91 05 2e 	lds	r25, 0x2E05	; 0x802e05 <xSignalProcessEventGroup+0x1>
    34b2:	0e 94 a3 03 	call	0x746	; 0x746 <xEventGroupSetBits>
									xSignalProcessEventGroup,   /* The event group being updated. */
									Process_Signal_BufferA /* The bits being set. */
									);
				if( xResult & Process_Signal_BufferA )
    34b6:	60 ff       	sbrs	r22, 0
    34b8:	09 c0       	rjmp	.+18     	; 0x34cc <vTask_DMAHandler+0xea>
					{
						count_array_b++;
    34ba:	80 91 00 2f 	lds	r24, 0x2F00	; 0x802f00 <count_array_b>
    34be:	90 91 01 2f 	lds	r25, 0x2F01	; 0x802f01 <count_array_b+0x1>
    34c2:	01 96       	adiw	r24, 0x01	; 1
    34c4:	80 93 00 2f 	sts	0x2F00, r24	; 0x802f00 <count_array_b>
    34c8:	90 93 01 2f 	sts	0x2F01, r25	; 0x802f01 <count_array_b+0x1>
					}
					count_buffer_a = 0;
    34cc:	10 92 07 2d 	sts	0x2D07, r1	; 0x802d07 <count_buffer_a>
		{
								
			//Do stuff with BufferB
			//buffer_b ....
			i = i;
			for (i=0;i<2047;i++)
    34d0:	21 96       	adiw	r28, 0x01	; 1
    34d2:	cf 3f       	cpi	r28, 0xFF	; 255
    34d4:	f7 e0       	ldi	r31, 0x07	; 7
    34d6:	df 07       	cpc	r29, r31
    34d8:	f1 f6       	brne	.-68     	; 0x3496 <vTask_DMAHandler+0xb4>
					//for(n=0;n<20;n++){
						//wenn pegel fr 20 werte kleiner als 10 ist -> kein signal mehr -> stop timer
					//}
				//}
			}
			count_buffer_b++;
    34da:	80 91 06 2d 	lds	r24, 0x2D06	; 0x802d06 <count_buffer_b>
    34de:	8f 5f       	subi	r24, 0xFF	; 255
    34e0:	80 93 06 2d 	sts	0x2D06, r24	; 0x802d06 <count_buffer_b>
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x04));
    34e4:	f5 01       	movw	r30, r10
    34e6:	84 81       	ldd	r24, Z+4	; 0x04
    34e8:	8b 7f       	andi	r24, 0xFB	; 251
    34ea:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x02;
    34ec:	84 81       	ldd	r24, Z+4	; 0x04
    34ee:	82 60       	ori	r24, 0x02	; 2
    34f0:	84 83       	std	Z+4, r24	; 0x04
		}
	vTaskDelay(100 / portTICK_RATE_MS);
    34f2:	64 e6       	ldi	r22, 0x64	; 100
    34f4:	70 e0       	ldi	r23, 0x00	; 0
    34f6:	80 e0       	ldi	r24, 0x00	; 0
    34f8:	90 e0       	ldi	r25, 0x00	; 0
    34fa:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <vTaskDelay>
	}
    34fe:	88 cf       	rjmp	.-240    	; 0x3410 <vTask_DMAHandler+0x2e>

00003500 <getResetReason>:
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
	 // software reset ?
	 if( RST.STATUS & RST_SRF_bm )
    3500:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3504:	85 ff       	sbrs	r24, 5
    3506:	05 c0       	rjmp	.+10     	; 0x3512 <getResetReason+0x12>
	 {
		 // reset this bit
		 RST.STATUS = RST_SRF_bm;
    3508:	80 e2       	ldi	r24, 0x20	; 32
    350a:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_SOFTWARERESET;
    350e:	81 e0       	ldi	r24, 0x01	; 1
    3510:	08 95       	ret
	 }
	 // power on reset ?
	 else if( RST.STATUS & RST_PORF_bm)
    3512:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3516:	80 ff       	sbrs	r24, 0
    3518:	05 c0       	rjmp	.+10     	; 0x3524 <getResetReason+0x24>
	 {
		 // reset this bit
		 RST.STATUS = RST_PORF_bm;
    351a:	81 e0       	ldi	r24, 0x01	; 1
    351c:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_POWERONRESET;
    3520:	82 e0       	ldi	r24, 0x02	; 2
    3522:	08 95       	ret
	 }
	 // debugger reset ?
	 else if( RST.STATUS & RST_PDIRF_bm)
    3524:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3528:	84 ff       	sbrs	r24, 4
    352a:	05 c0       	rjmp	.+10     	; 0x3536 <getResetReason+0x36>
	 {
		 // reset this bit
		 RST.STATUS = RST_PDIRF_bm;
    352c:	80 e1       	ldi	r24, 0x10	; 16
    352e:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_DEBUGGERRESET;
    3532:	83 e0       	ldi	r24, 0x03	; 3
    3534:	08 95       	ret
	 }
	 // external reset ?
	 else if( RST.STATUS & RST_EXTRF_bm)
    3536:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    353a:	81 ff       	sbrs	r24, 1
    353c:	05 c0       	rjmp	.+10     	; 0x3548 <getResetReason+0x48>
	 {
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
    353e:	82 e0       	ldi	r24, 0x02	; 2
    3540:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_EXTERNALRESET;
    3544:	84 e0       	ldi	r24, 0x04	; 4
    3546:	08 95       	ret
 */ 
 #include "avr_compiler.h"
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
    3548:	82 e0       	ldi	r24, 0x02	; 2
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
		 returnValue = RESETREASON_EXTERNALRESET;
	 }
	 return returnValue;
    354a:	08 95       	ret

0000354c <__subsf3>:
    354c:	50 58       	subi	r21, 0x80	; 128

0000354e <__addsf3>:
    354e:	bb 27       	eor	r27, r27
    3550:	aa 27       	eor	r26, r26
    3552:	0e 94 be 1a 	call	0x357c	; 0x357c <__addsf3x>
    3556:	0c 94 38 1c 	jmp	0x3870	; 0x3870 <__fp_round>
    355a:	0e 94 2a 1c 	call	0x3854	; 0x3854 <__fp_pscA>
    355e:	38 f0       	brcs	.+14     	; 0x356e <__addsf3+0x20>
    3560:	0e 94 31 1c 	call	0x3862	; 0x3862 <__fp_pscB>
    3564:	20 f0       	brcs	.+8      	; 0x356e <__addsf3+0x20>
    3566:	39 f4       	brne	.+14     	; 0x3576 <__addsf3+0x28>
    3568:	9f 3f       	cpi	r25, 0xFF	; 255
    356a:	19 f4       	brne	.+6      	; 0x3572 <__addsf3+0x24>
    356c:	26 f4       	brtc	.+8      	; 0x3576 <__addsf3+0x28>
    356e:	0c 94 27 1c 	jmp	0x384e	; 0x384e <__fp_nan>
    3572:	0e f4       	brtc	.+2      	; 0x3576 <__addsf3+0x28>
    3574:	e0 95       	com	r30
    3576:	e7 fb       	bst	r30, 7
    3578:	0c 94 21 1c 	jmp	0x3842	; 0x3842 <__fp_inf>

0000357c <__addsf3x>:
    357c:	e9 2f       	mov	r30, r25
    357e:	0e 94 49 1c 	call	0x3892	; 0x3892 <__fp_split3>
    3582:	58 f3       	brcs	.-42     	; 0x355a <__addsf3+0xc>
    3584:	ba 17       	cp	r27, r26
    3586:	62 07       	cpc	r22, r18
    3588:	73 07       	cpc	r23, r19
    358a:	84 07       	cpc	r24, r20
    358c:	95 07       	cpc	r25, r21
    358e:	20 f0       	brcs	.+8      	; 0x3598 <__addsf3x+0x1c>
    3590:	79 f4       	brne	.+30     	; 0x35b0 <__addsf3x+0x34>
    3592:	a6 f5       	brtc	.+104    	; 0x35fc <__addsf3x+0x80>
    3594:	0c 94 6b 1c 	jmp	0x38d6	; 0x38d6 <__fp_zero>
    3598:	0e f4       	brtc	.+2      	; 0x359c <__addsf3x+0x20>
    359a:	e0 95       	com	r30
    359c:	0b 2e       	mov	r0, r27
    359e:	ba 2f       	mov	r27, r26
    35a0:	a0 2d       	mov	r26, r0
    35a2:	0b 01       	movw	r0, r22
    35a4:	b9 01       	movw	r22, r18
    35a6:	90 01       	movw	r18, r0
    35a8:	0c 01       	movw	r0, r24
    35aa:	ca 01       	movw	r24, r20
    35ac:	a0 01       	movw	r20, r0
    35ae:	11 24       	eor	r1, r1
    35b0:	ff 27       	eor	r31, r31
    35b2:	59 1b       	sub	r21, r25
    35b4:	99 f0       	breq	.+38     	; 0x35dc <__addsf3x+0x60>
    35b6:	59 3f       	cpi	r21, 0xF9	; 249
    35b8:	50 f4       	brcc	.+20     	; 0x35ce <__addsf3x+0x52>
    35ba:	50 3e       	cpi	r21, 0xE0	; 224
    35bc:	68 f1       	brcs	.+90     	; 0x3618 <__addsf3x+0x9c>
    35be:	1a 16       	cp	r1, r26
    35c0:	f0 40       	sbci	r31, 0x00	; 0
    35c2:	a2 2f       	mov	r26, r18
    35c4:	23 2f       	mov	r18, r19
    35c6:	34 2f       	mov	r19, r20
    35c8:	44 27       	eor	r20, r20
    35ca:	58 5f       	subi	r21, 0xF8	; 248
    35cc:	f3 cf       	rjmp	.-26     	; 0x35b4 <__addsf3x+0x38>
    35ce:	46 95       	lsr	r20
    35d0:	37 95       	ror	r19
    35d2:	27 95       	ror	r18
    35d4:	a7 95       	ror	r26
    35d6:	f0 40       	sbci	r31, 0x00	; 0
    35d8:	53 95       	inc	r21
    35da:	c9 f7       	brne	.-14     	; 0x35ce <__addsf3x+0x52>
    35dc:	7e f4       	brtc	.+30     	; 0x35fc <__addsf3x+0x80>
    35de:	1f 16       	cp	r1, r31
    35e0:	ba 0b       	sbc	r27, r26
    35e2:	62 0b       	sbc	r22, r18
    35e4:	73 0b       	sbc	r23, r19
    35e6:	84 0b       	sbc	r24, r20
    35e8:	ba f0       	brmi	.+46     	; 0x3618 <__addsf3x+0x9c>
    35ea:	91 50       	subi	r25, 0x01	; 1
    35ec:	a1 f0       	breq	.+40     	; 0x3616 <__addsf3x+0x9a>
    35ee:	ff 0f       	add	r31, r31
    35f0:	bb 1f       	adc	r27, r27
    35f2:	66 1f       	adc	r22, r22
    35f4:	77 1f       	adc	r23, r23
    35f6:	88 1f       	adc	r24, r24
    35f8:	c2 f7       	brpl	.-16     	; 0x35ea <__addsf3x+0x6e>
    35fa:	0e c0       	rjmp	.+28     	; 0x3618 <__addsf3x+0x9c>
    35fc:	ba 0f       	add	r27, r26
    35fe:	62 1f       	adc	r22, r18
    3600:	73 1f       	adc	r23, r19
    3602:	84 1f       	adc	r24, r20
    3604:	48 f4       	brcc	.+18     	; 0x3618 <__addsf3x+0x9c>
    3606:	87 95       	ror	r24
    3608:	77 95       	ror	r23
    360a:	67 95       	ror	r22
    360c:	b7 95       	ror	r27
    360e:	f7 95       	ror	r31
    3610:	9e 3f       	cpi	r25, 0xFE	; 254
    3612:	08 f0       	brcs	.+2      	; 0x3616 <__addsf3x+0x9a>
    3614:	b0 cf       	rjmp	.-160    	; 0x3576 <__addsf3+0x28>
    3616:	93 95       	inc	r25
    3618:	88 0f       	add	r24, r24
    361a:	08 f0       	brcs	.+2      	; 0x361e <__addsf3x+0xa2>
    361c:	99 27       	eor	r25, r25
    361e:	ee 0f       	add	r30, r30
    3620:	97 95       	ror	r25
    3622:	87 95       	ror	r24
    3624:	08 95       	ret

00003626 <__cmpsf2>:
    3626:	0e 94 fd 1b 	call	0x37fa	; 0x37fa <__fp_cmp>
    362a:	08 f4       	brcc	.+2      	; 0x362e <__cmpsf2+0x8>
    362c:	81 e0       	ldi	r24, 0x01	; 1
    362e:	08 95       	ret

00003630 <__divsf3>:
    3630:	0e 94 2c 1b 	call	0x3658	; 0x3658 <__divsf3x>
    3634:	0c 94 38 1c 	jmp	0x3870	; 0x3870 <__fp_round>
    3638:	0e 94 31 1c 	call	0x3862	; 0x3862 <__fp_pscB>
    363c:	58 f0       	brcs	.+22     	; 0x3654 <__divsf3+0x24>
    363e:	0e 94 2a 1c 	call	0x3854	; 0x3854 <__fp_pscA>
    3642:	40 f0       	brcs	.+16     	; 0x3654 <__divsf3+0x24>
    3644:	29 f4       	brne	.+10     	; 0x3650 <__divsf3+0x20>
    3646:	5f 3f       	cpi	r21, 0xFF	; 255
    3648:	29 f0       	breq	.+10     	; 0x3654 <__divsf3+0x24>
    364a:	0c 94 21 1c 	jmp	0x3842	; 0x3842 <__fp_inf>
    364e:	51 11       	cpse	r21, r1
    3650:	0c 94 6c 1c 	jmp	0x38d8	; 0x38d8 <__fp_szero>
    3654:	0c 94 27 1c 	jmp	0x384e	; 0x384e <__fp_nan>

00003658 <__divsf3x>:
    3658:	0e 94 49 1c 	call	0x3892	; 0x3892 <__fp_split3>
    365c:	68 f3       	brcs	.-38     	; 0x3638 <__divsf3+0x8>

0000365e <__divsf3_pse>:
    365e:	99 23       	and	r25, r25
    3660:	b1 f3       	breq	.-20     	; 0x364e <__divsf3+0x1e>
    3662:	55 23       	and	r21, r21
    3664:	91 f3       	breq	.-28     	; 0x364a <__divsf3+0x1a>
    3666:	95 1b       	sub	r25, r21
    3668:	55 0b       	sbc	r21, r21
    366a:	bb 27       	eor	r27, r27
    366c:	aa 27       	eor	r26, r26
    366e:	62 17       	cp	r22, r18
    3670:	73 07       	cpc	r23, r19
    3672:	84 07       	cpc	r24, r20
    3674:	38 f0       	brcs	.+14     	; 0x3684 <__divsf3_pse+0x26>
    3676:	9f 5f       	subi	r25, 0xFF	; 255
    3678:	5f 4f       	sbci	r21, 0xFF	; 255
    367a:	22 0f       	add	r18, r18
    367c:	33 1f       	adc	r19, r19
    367e:	44 1f       	adc	r20, r20
    3680:	aa 1f       	adc	r26, r26
    3682:	a9 f3       	breq	.-22     	; 0x366e <__divsf3_pse+0x10>
    3684:	35 d0       	rcall	.+106    	; 0x36f0 <__divsf3_pse+0x92>
    3686:	0e 2e       	mov	r0, r30
    3688:	3a f0       	brmi	.+14     	; 0x3698 <__divsf3_pse+0x3a>
    368a:	e0 e8       	ldi	r30, 0x80	; 128
    368c:	32 d0       	rcall	.+100    	; 0x36f2 <__divsf3_pse+0x94>
    368e:	91 50       	subi	r25, 0x01	; 1
    3690:	50 40       	sbci	r21, 0x00	; 0
    3692:	e6 95       	lsr	r30
    3694:	00 1c       	adc	r0, r0
    3696:	ca f7       	brpl	.-14     	; 0x368a <__divsf3_pse+0x2c>
    3698:	2b d0       	rcall	.+86     	; 0x36f0 <__divsf3_pse+0x92>
    369a:	fe 2f       	mov	r31, r30
    369c:	29 d0       	rcall	.+82     	; 0x36f0 <__divsf3_pse+0x92>
    369e:	66 0f       	add	r22, r22
    36a0:	77 1f       	adc	r23, r23
    36a2:	88 1f       	adc	r24, r24
    36a4:	bb 1f       	adc	r27, r27
    36a6:	26 17       	cp	r18, r22
    36a8:	37 07       	cpc	r19, r23
    36aa:	48 07       	cpc	r20, r24
    36ac:	ab 07       	cpc	r26, r27
    36ae:	b0 e8       	ldi	r27, 0x80	; 128
    36b0:	09 f0       	breq	.+2      	; 0x36b4 <__divsf3_pse+0x56>
    36b2:	bb 0b       	sbc	r27, r27
    36b4:	80 2d       	mov	r24, r0
    36b6:	bf 01       	movw	r22, r30
    36b8:	ff 27       	eor	r31, r31
    36ba:	93 58       	subi	r25, 0x83	; 131
    36bc:	5f 4f       	sbci	r21, 0xFF	; 255
    36be:	3a f0       	brmi	.+14     	; 0x36ce <__divsf3_pse+0x70>
    36c0:	9e 3f       	cpi	r25, 0xFE	; 254
    36c2:	51 05       	cpc	r21, r1
    36c4:	78 f0       	brcs	.+30     	; 0x36e4 <__divsf3_pse+0x86>
    36c6:	0c 94 21 1c 	jmp	0x3842	; 0x3842 <__fp_inf>
    36ca:	0c 94 6c 1c 	jmp	0x38d8	; 0x38d8 <__fp_szero>
    36ce:	5f 3f       	cpi	r21, 0xFF	; 255
    36d0:	e4 f3       	brlt	.-8      	; 0x36ca <__divsf3_pse+0x6c>
    36d2:	98 3e       	cpi	r25, 0xE8	; 232
    36d4:	d4 f3       	brlt	.-12     	; 0x36ca <__divsf3_pse+0x6c>
    36d6:	86 95       	lsr	r24
    36d8:	77 95       	ror	r23
    36da:	67 95       	ror	r22
    36dc:	b7 95       	ror	r27
    36de:	f7 95       	ror	r31
    36e0:	9f 5f       	subi	r25, 0xFF	; 255
    36e2:	c9 f7       	brne	.-14     	; 0x36d6 <__divsf3_pse+0x78>
    36e4:	88 0f       	add	r24, r24
    36e6:	91 1d       	adc	r25, r1
    36e8:	96 95       	lsr	r25
    36ea:	87 95       	ror	r24
    36ec:	97 f9       	bld	r25, 7
    36ee:	08 95       	ret
    36f0:	e1 e0       	ldi	r30, 0x01	; 1
    36f2:	66 0f       	add	r22, r22
    36f4:	77 1f       	adc	r23, r23
    36f6:	88 1f       	adc	r24, r24
    36f8:	bb 1f       	adc	r27, r27
    36fa:	62 17       	cp	r22, r18
    36fc:	73 07       	cpc	r23, r19
    36fe:	84 07       	cpc	r24, r20
    3700:	ba 07       	cpc	r27, r26
    3702:	20 f0       	brcs	.+8      	; 0x370c <__divsf3_pse+0xae>
    3704:	62 1b       	sub	r22, r18
    3706:	73 0b       	sbc	r23, r19
    3708:	84 0b       	sbc	r24, r20
    370a:	ba 0b       	sbc	r27, r26
    370c:	ee 1f       	adc	r30, r30
    370e:	88 f7       	brcc	.-30     	; 0x36f2 <__divsf3_pse+0x94>
    3710:	e0 95       	com	r30
    3712:	08 95       	ret

00003714 <__fixsfsi>:
    3714:	0e 94 91 1b 	call	0x3722	; 0x3722 <__fixunssfsi>
    3718:	68 94       	set
    371a:	b1 11       	cpse	r27, r1
    371c:	0c 94 6c 1c 	jmp	0x38d8	; 0x38d8 <__fp_szero>
    3720:	08 95       	ret

00003722 <__fixunssfsi>:
    3722:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <__fp_splitA>
    3726:	88 f0       	brcs	.+34     	; 0x374a <__fixunssfsi+0x28>
    3728:	9f 57       	subi	r25, 0x7F	; 127
    372a:	98 f0       	brcs	.+38     	; 0x3752 <__fixunssfsi+0x30>
    372c:	b9 2f       	mov	r27, r25
    372e:	99 27       	eor	r25, r25
    3730:	b7 51       	subi	r27, 0x17	; 23
    3732:	b0 f0       	brcs	.+44     	; 0x3760 <__fixunssfsi+0x3e>
    3734:	e1 f0       	breq	.+56     	; 0x376e <__fixunssfsi+0x4c>
    3736:	66 0f       	add	r22, r22
    3738:	77 1f       	adc	r23, r23
    373a:	88 1f       	adc	r24, r24
    373c:	99 1f       	adc	r25, r25
    373e:	1a f0       	brmi	.+6      	; 0x3746 <__fixunssfsi+0x24>
    3740:	ba 95       	dec	r27
    3742:	c9 f7       	brne	.-14     	; 0x3736 <__fixunssfsi+0x14>
    3744:	14 c0       	rjmp	.+40     	; 0x376e <__fixunssfsi+0x4c>
    3746:	b1 30       	cpi	r27, 0x01	; 1
    3748:	91 f0       	breq	.+36     	; 0x376e <__fixunssfsi+0x4c>
    374a:	0e 94 6b 1c 	call	0x38d6	; 0x38d6 <__fp_zero>
    374e:	b1 e0       	ldi	r27, 0x01	; 1
    3750:	08 95       	ret
    3752:	0c 94 6b 1c 	jmp	0x38d6	; 0x38d6 <__fp_zero>
    3756:	67 2f       	mov	r22, r23
    3758:	78 2f       	mov	r23, r24
    375a:	88 27       	eor	r24, r24
    375c:	b8 5f       	subi	r27, 0xF8	; 248
    375e:	39 f0       	breq	.+14     	; 0x376e <__fixunssfsi+0x4c>
    3760:	b9 3f       	cpi	r27, 0xF9	; 249
    3762:	cc f3       	brlt	.-14     	; 0x3756 <__fixunssfsi+0x34>
    3764:	86 95       	lsr	r24
    3766:	77 95       	ror	r23
    3768:	67 95       	ror	r22
    376a:	b3 95       	inc	r27
    376c:	d9 f7       	brne	.-10     	; 0x3764 <__fixunssfsi+0x42>
    376e:	3e f4       	brtc	.+14     	; 0x377e <__fixunssfsi+0x5c>
    3770:	90 95       	com	r25
    3772:	80 95       	com	r24
    3774:	70 95       	com	r23
    3776:	61 95       	neg	r22
    3778:	7f 4f       	sbci	r23, 0xFF	; 255
    377a:	8f 4f       	sbci	r24, 0xFF	; 255
    377c:	9f 4f       	sbci	r25, 0xFF	; 255
    377e:	08 95       	ret

00003780 <__floatunsisf>:
    3780:	e8 94       	clt
    3782:	09 c0       	rjmp	.+18     	; 0x3796 <__floatsisf+0x12>

00003784 <__floatsisf>:
    3784:	97 fb       	bst	r25, 7
    3786:	3e f4       	brtc	.+14     	; 0x3796 <__floatsisf+0x12>
    3788:	90 95       	com	r25
    378a:	80 95       	com	r24
    378c:	70 95       	com	r23
    378e:	61 95       	neg	r22
    3790:	7f 4f       	sbci	r23, 0xFF	; 255
    3792:	8f 4f       	sbci	r24, 0xFF	; 255
    3794:	9f 4f       	sbci	r25, 0xFF	; 255
    3796:	99 23       	and	r25, r25
    3798:	a9 f0       	breq	.+42     	; 0x37c4 <__floatsisf+0x40>
    379a:	f9 2f       	mov	r31, r25
    379c:	96 e9       	ldi	r25, 0x96	; 150
    379e:	bb 27       	eor	r27, r27
    37a0:	93 95       	inc	r25
    37a2:	f6 95       	lsr	r31
    37a4:	87 95       	ror	r24
    37a6:	77 95       	ror	r23
    37a8:	67 95       	ror	r22
    37aa:	b7 95       	ror	r27
    37ac:	f1 11       	cpse	r31, r1
    37ae:	f8 cf       	rjmp	.-16     	; 0x37a0 <__floatsisf+0x1c>
    37b0:	fa f4       	brpl	.+62     	; 0x37f0 <__floatsisf+0x6c>
    37b2:	bb 0f       	add	r27, r27
    37b4:	11 f4       	brne	.+4      	; 0x37ba <__floatsisf+0x36>
    37b6:	60 ff       	sbrs	r22, 0
    37b8:	1b c0       	rjmp	.+54     	; 0x37f0 <__floatsisf+0x6c>
    37ba:	6f 5f       	subi	r22, 0xFF	; 255
    37bc:	7f 4f       	sbci	r23, 0xFF	; 255
    37be:	8f 4f       	sbci	r24, 0xFF	; 255
    37c0:	9f 4f       	sbci	r25, 0xFF	; 255
    37c2:	16 c0       	rjmp	.+44     	; 0x37f0 <__floatsisf+0x6c>
    37c4:	88 23       	and	r24, r24
    37c6:	11 f0       	breq	.+4      	; 0x37cc <__floatsisf+0x48>
    37c8:	96 e9       	ldi	r25, 0x96	; 150
    37ca:	11 c0       	rjmp	.+34     	; 0x37ee <__floatsisf+0x6a>
    37cc:	77 23       	and	r23, r23
    37ce:	21 f0       	breq	.+8      	; 0x37d8 <__floatsisf+0x54>
    37d0:	9e e8       	ldi	r25, 0x8E	; 142
    37d2:	87 2f       	mov	r24, r23
    37d4:	76 2f       	mov	r23, r22
    37d6:	05 c0       	rjmp	.+10     	; 0x37e2 <__floatsisf+0x5e>
    37d8:	66 23       	and	r22, r22
    37da:	71 f0       	breq	.+28     	; 0x37f8 <__floatsisf+0x74>
    37dc:	96 e8       	ldi	r25, 0x86	; 134
    37de:	86 2f       	mov	r24, r22
    37e0:	70 e0       	ldi	r23, 0x00	; 0
    37e2:	60 e0       	ldi	r22, 0x00	; 0
    37e4:	2a f0       	brmi	.+10     	; 0x37f0 <__floatsisf+0x6c>
    37e6:	9a 95       	dec	r25
    37e8:	66 0f       	add	r22, r22
    37ea:	77 1f       	adc	r23, r23
    37ec:	88 1f       	adc	r24, r24
    37ee:	da f7       	brpl	.-10     	; 0x37e6 <__floatsisf+0x62>
    37f0:	88 0f       	add	r24, r24
    37f2:	96 95       	lsr	r25
    37f4:	87 95       	ror	r24
    37f6:	97 f9       	bld	r25, 7
    37f8:	08 95       	ret

000037fa <__fp_cmp>:
    37fa:	99 0f       	add	r25, r25
    37fc:	00 08       	sbc	r0, r0
    37fe:	55 0f       	add	r21, r21
    3800:	aa 0b       	sbc	r26, r26
    3802:	e0 e8       	ldi	r30, 0x80	; 128
    3804:	fe ef       	ldi	r31, 0xFE	; 254
    3806:	16 16       	cp	r1, r22
    3808:	17 06       	cpc	r1, r23
    380a:	e8 07       	cpc	r30, r24
    380c:	f9 07       	cpc	r31, r25
    380e:	c0 f0       	brcs	.+48     	; 0x3840 <__fp_cmp+0x46>
    3810:	12 16       	cp	r1, r18
    3812:	13 06       	cpc	r1, r19
    3814:	e4 07       	cpc	r30, r20
    3816:	f5 07       	cpc	r31, r21
    3818:	98 f0       	brcs	.+38     	; 0x3840 <__fp_cmp+0x46>
    381a:	62 1b       	sub	r22, r18
    381c:	73 0b       	sbc	r23, r19
    381e:	84 0b       	sbc	r24, r20
    3820:	95 0b       	sbc	r25, r21
    3822:	39 f4       	brne	.+14     	; 0x3832 <__fp_cmp+0x38>
    3824:	0a 26       	eor	r0, r26
    3826:	61 f0       	breq	.+24     	; 0x3840 <__fp_cmp+0x46>
    3828:	23 2b       	or	r18, r19
    382a:	24 2b       	or	r18, r20
    382c:	25 2b       	or	r18, r21
    382e:	21 f4       	brne	.+8      	; 0x3838 <__fp_cmp+0x3e>
    3830:	08 95       	ret
    3832:	0a 26       	eor	r0, r26
    3834:	09 f4       	brne	.+2      	; 0x3838 <__fp_cmp+0x3e>
    3836:	a1 40       	sbci	r26, 0x01	; 1
    3838:	a6 95       	lsr	r26
    383a:	8f ef       	ldi	r24, 0xFF	; 255
    383c:	81 1d       	adc	r24, r1
    383e:	81 1d       	adc	r24, r1
    3840:	08 95       	ret

00003842 <__fp_inf>:
    3842:	97 f9       	bld	r25, 7
    3844:	9f 67       	ori	r25, 0x7F	; 127
    3846:	80 e8       	ldi	r24, 0x80	; 128
    3848:	70 e0       	ldi	r23, 0x00	; 0
    384a:	60 e0       	ldi	r22, 0x00	; 0
    384c:	08 95       	ret

0000384e <__fp_nan>:
    384e:	9f ef       	ldi	r25, 0xFF	; 255
    3850:	80 ec       	ldi	r24, 0xC0	; 192
    3852:	08 95       	ret

00003854 <__fp_pscA>:
    3854:	00 24       	eor	r0, r0
    3856:	0a 94       	dec	r0
    3858:	16 16       	cp	r1, r22
    385a:	17 06       	cpc	r1, r23
    385c:	18 06       	cpc	r1, r24
    385e:	09 06       	cpc	r0, r25
    3860:	08 95       	ret

00003862 <__fp_pscB>:
    3862:	00 24       	eor	r0, r0
    3864:	0a 94       	dec	r0
    3866:	12 16       	cp	r1, r18
    3868:	13 06       	cpc	r1, r19
    386a:	14 06       	cpc	r1, r20
    386c:	05 06       	cpc	r0, r21
    386e:	08 95       	ret

00003870 <__fp_round>:
    3870:	09 2e       	mov	r0, r25
    3872:	03 94       	inc	r0
    3874:	00 0c       	add	r0, r0
    3876:	11 f4       	brne	.+4      	; 0x387c <__fp_round+0xc>
    3878:	88 23       	and	r24, r24
    387a:	52 f0       	brmi	.+20     	; 0x3890 <__fp_round+0x20>
    387c:	bb 0f       	add	r27, r27
    387e:	40 f4       	brcc	.+16     	; 0x3890 <__fp_round+0x20>
    3880:	bf 2b       	or	r27, r31
    3882:	11 f4       	brne	.+4      	; 0x3888 <__fp_round+0x18>
    3884:	60 ff       	sbrs	r22, 0
    3886:	04 c0       	rjmp	.+8      	; 0x3890 <__fp_round+0x20>
    3888:	6f 5f       	subi	r22, 0xFF	; 255
    388a:	7f 4f       	sbci	r23, 0xFF	; 255
    388c:	8f 4f       	sbci	r24, 0xFF	; 255
    388e:	9f 4f       	sbci	r25, 0xFF	; 255
    3890:	08 95       	ret

00003892 <__fp_split3>:
    3892:	57 fd       	sbrc	r21, 7
    3894:	90 58       	subi	r25, 0x80	; 128
    3896:	44 0f       	add	r20, r20
    3898:	55 1f       	adc	r21, r21
    389a:	59 f0       	breq	.+22     	; 0x38b2 <__fp_splitA+0x10>
    389c:	5f 3f       	cpi	r21, 0xFF	; 255
    389e:	71 f0       	breq	.+28     	; 0x38bc <__fp_splitA+0x1a>
    38a0:	47 95       	ror	r20

000038a2 <__fp_splitA>:
    38a2:	88 0f       	add	r24, r24
    38a4:	97 fb       	bst	r25, 7
    38a6:	99 1f       	adc	r25, r25
    38a8:	61 f0       	breq	.+24     	; 0x38c2 <__fp_splitA+0x20>
    38aa:	9f 3f       	cpi	r25, 0xFF	; 255
    38ac:	79 f0       	breq	.+30     	; 0x38cc <__fp_splitA+0x2a>
    38ae:	87 95       	ror	r24
    38b0:	08 95       	ret
    38b2:	12 16       	cp	r1, r18
    38b4:	13 06       	cpc	r1, r19
    38b6:	14 06       	cpc	r1, r20
    38b8:	55 1f       	adc	r21, r21
    38ba:	f2 cf       	rjmp	.-28     	; 0x38a0 <__fp_split3+0xe>
    38bc:	46 95       	lsr	r20
    38be:	f1 df       	rcall	.-30     	; 0x38a2 <__fp_splitA>
    38c0:	08 c0       	rjmp	.+16     	; 0x38d2 <__fp_splitA+0x30>
    38c2:	16 16       	cp	r1, r22
    38c4:	17 06       	cpc	r1, r23
    38c6:	18 06       	cpc	r1, r24
    38c8:	99 1f       	adc	r25, r25
    38ca:	f1 cf       	rjmp	.-30     	; 0x38ae <__fp_splitA+0xc>
    38cc:	86 95       	lsr	r24
    38ce:	71 05       	cpc	r23, r1
    38d0:	61 05       	cpc	r22, r1
    38d2:	08 94       	sec
    38d4:	08 95       	ret

000038d6 <__fp_zero>:
    38d6:	e8 94       	clt

000038d8 <__fp_szero>:
    38d8:	bb 27       	eor	r27, r27
    38da:	66 27       	eor	r22, r22
    38dc:	77 27       	eor	r23, r23
    38de:	cb 01       	movw	r24, r22
    38e0:	97 f9       	bld	r25, 7
    38e2:	08 95       	ret

000038e4 <__gesf2>:
    38e4:	0e 94 fd 1b 	call	0x37fa	; 0x37fa <__fp_cmp>
    38e8:	08 f4       	brcc	.+2      	; 0x38ec <__gesf2+0x8>
    38ea:	8f ef       	ldi	r24, 0xFF	; 255
    38ec:	08 95       	ret

000038ee <__mulsf3>:
    38ee:	0e 94 8a 1c 	call	0x3914	; 0x3914 <__mulsf3x>
    38f2:	0c 94 38 1c 	jmp	0x3870	; 0x3870 <__fp_round>
    38f6:	0e 94 2a 1c 	call	0x3854	; 0x3854 <__fp_pscA>
    38fa:	38 f0       	brcs	.+14     	; 0x390a <__mulsf3+0x1c>
    38fc:	0e 94 31 1c 	call	0x3862	; 0x3862 <__fp_pscB>
    3900:	20 f0       	brcs	.+8      	; 0x390a <__mulsf3+0x1c>
    3902:	95 23       	and	r25, r21
    3904:	11 f0       	breq	.+4      	; 0x390a <__mulsf3+0x1c>
    3906:	0c 94 21 1c 	jmp	0x3842	; 0x3842 <__fp_inf>
    390a:	0c 94 27 1c 	jmp	0x384e	; 0x384e <__fp_nan>
    390e:	11 24       	eor	r1, r1
    3910:	0c 94 6c 1c 	jmp	0x38d8	; 0x38d8 <__fp_szero>

00003914 <__mulsf3x>:
    3914:	0e 94 49 1c 	call	0x3892	; 0x3892 <__fp_split3>
    3918:	70 f3       	brcs	.-36     	; 0x38f6 <__mulsf3+0x8>

0000391a <__mulsf3_pse>:
    391a:	95 9f       	mul	r25, r21
    391c:	c1 f3       	breq	.-16     	; 0x390e <__mulsf3+0x20>
    391e:	95 0f       	add	r25, r21
    3920:	50 e0       	ldi	r21, 0x00	; 0
    3922:	55 1f       	adc	r21, r21
    3924:	62 9f       	mul	r22, r18
    3926:	f0 01       	movw	r30, r0
    3928:	72 9f       	mul	r23, r18
    392a:	bb 27       	eor	r27, r27
    392c:	f0 0d       	add	r31, r0
    392e:	b1 1d       	adc	r27, r1
    3930:	63 9f       	mul	r22, r19
    3932:	aa 27       	eor	r26, r26
    3934:	f0 0d       	add	r31, r0
    3936:	b1 1d       	adc	r27, r1
    3938:	aa 1f       	adc	r26, r26
    393a:	64 9f       	mul	r22, r20
    393c:	66 27       	eor	r22, r22
    393e:	b0 0d       	add	r27, r0
    3940:	a1 1d       	adc	r26, r1
    3942:	66 1f       	adc	r22, r22
    3944:	82 9f       	mul	r24, r18
    3946:	22 27       	eor	r18, r18
    3948:	b0 0d       	add	r27, r0
    394a:	a1 1d       	adc	r26, r1
    394c:	62 1f       	adc	r22, r18
    394e:	73 9f       	mul	r23, r19
    3950:	b0 0d       	add	r27, r0
    3952:	a1 1d       	adc	r26, r1
    3954:	62 1f       	adc	r22, r18
    3956:	83 9f       	mul	r24, r19
    3958:	a0 0d       	add	r26, r0
    395a:	61 1d       	adc	r22, r1
    395c:	22 1f       	adc	r18, r18
    395e:	74 9f       	mul	r23, r20
    3960:	33 27       	eor	r19, r19
    3962:	a0 0d       	add	r26, r0
    3964:	61 1d       	adc	r22, r1
    3966:	23 1f       	adc	r18, r19
    3968:	84 9f       	mul	r24, r20
    396a:	60 0d       	add	r22, r0
    396c:	21 1d       	adc	r18, r1
    396e:	82 2f       	mov	r24, r18
    3970:	76 2f       	mov	r23, r22
    3972:	6a 2f       	mov	r22, r26
    3974:	11 24       	eor	r1, r1
    3976:	9f 57       	subi	r25, 0x7F	; 127
    3978:	50 40       	sbci	r21, 0x00	; 0
    397a:	9a f0       	brmi	.+38     	; 0x39a2 <__mulsf3_pse+0x88>
    397c:	f1 f0       	breq	.+60     	; 0x39ba <__mulsf3_pse+0xa0>
    397e:	88 23       	and	r24, r24
    3980:	4a f0       	brmi	.+18     	; 0x3994 <__mulsf3_pse+0x7a>
    3982:	ee 0f       	add	r30, r30
    3984:	ff 1f       	adc	r31, r31
    3986:	bb 1f       	adc	r27, r27
    3988:	66 1f       	adc	r22, r22
    398a:	77 1f       	adc	r23, r23
    398c:	88 1f       	adc	r24, r24
    398e:	91 50       	subi	r25, 0x01	; 1
    3990:	50 40       	sbci	r21, 0x00	; 0
    3992:	a9 f7       	brne	.-22     	; 0x397e <__mulsf3_pse+0x64>
    3994:	9e 3f       	cpi	r25, 0xFE	; 254
    3996:	51 05       	cpc	r21, r1
    3998:	80 f0       	brcs	.+32     	; 0x39ba <__mulsf3_pse+0xa0>
    399a:	0c 94 21 1c 	jmp	0x3842	; 0x3842 <__fp_inf>
    399e:	0c 94 6c 1c 	jmp	0x38d8	; 0x38d8 <__fp_szero>
    39a2:	5f 3f       	cpi	r21, 0xFF	; 255
    39a4:	e4 f3       	brlt	.-8      	; 0x399e <__mulsf3_pse+0x84>
    39a6:	98 3e       	cpi	r25, 0xE8	; 232
    39a8:	d4 f3       	brlt	.-12     	; 0x399e <__mulsf3_pse+0x84>
    39aa:	86 95       	lsr	r24
    39ac:	77 95       	ror	r23
    39ae:	67 95       	ror	r22
    39b0:	b7 95       	ror	r27
    39b2:	f7 95       	ror	r31
    39b4:	e7 95       	ror	r30
    39b6:	9f 5f       	subi	r25, 0xFF	; 255
    39b8:	c1 f7       	brne	.-16     	; 0x39aa <__mulsf3_pse+0x90>
    39ba:	fe 2b       	or	r31, r30
    39bc:	88 0f       	add	r24, r24
    39be:	91 1d       	adc	r25, r1
    39c0:	96 95       	lsr	r25
    39c2:	87 95       	ror	r24
    39c4:	97 f9       	bld	r25, 7
    39c6:	08 95       	ret

000039c8 <__tablejump2__>:
    39c8:	ee 0f       	add	r30, r30
    39ca:	ff 1f       	adc	r31, r31
    39cc:	88 1f       	adc	r24, r24
    39ce:	8b bf       	out	0x3b, r24	; 59
    39d0:	07 90       	elpm	r0, Z+
    39d2:	f6 91       	elpm	r31, Z
    39d4:	e0 2d       	mov	r30, r0
    39d6:	19 94       	eijmp

000039d8 <memcpy>:
    39d8:	fb 01       	movw	r30, r22
    39da:	dc 01       	movw	r26, r24
    39dc:	02 c0       	rjmp	.+4      	; 0x39e2 <memcpy+0xa>
    39de:	01 90       	ld	r0, Z+
    39e0:	0d 92       	st	X+, r0
    39e2:	41 50       	subi	r20, 0x01	; 1
    39e4:	50 40       	sbci	r21, 0x00	; 0
    39e6:	d8 f7       	brcc	.-10     	; 0x39de <memcpy+0x6>
    39e8:	08 95       	ret

000039ea <memset>:
    39ea:	dc 01       	movw	r26, r24
    39ec:	01 c0       	rjmp	.+2      	; 0x39f0 <memset+0x6>
    39ee:	6d 93       	st	X+, r22
    39f0:	41 50       	subi	r20, 0x01	; 1
    39f2:	50 40       	sbci	r21, 0x00	; 0
    39f4:	e0 f7       	brcc	.-8      	; 0x39ee <memset+0x4>
    39f6:	08 95       	ret

000039f8 <__itoa_ncheck>:
    39f8:	bb 27       	eor	r27, r27
    39fa:	4a 30       	cpi	r20, 0x0A	; 10
    39fc:	31 f4       	brne	.+12     	; 0x3a0a <__itoa_ncheck+0x12>
    39fe:	99 23       	and	r25, r25
    3a00:	22 f4       	brpl	.+8      	; 0x3a0a <__itoa_ncheck+0x12>
    3a02:	bd e2       	ldi	r27, 0x2D	; 45
    3a04:	90 95       	com	r25
    3a06:	81 95       	neg	r24
    3a08:	9f 4f       	sbci	r25, 0xFF	; 255
    3a0a:	0c 94 08 1d 	jmp	0x3a10	; 0x3a10 <__utoa_common>

00003a0e <__utoa_ncheck>:
    3a0e:	bb 27       	eor	r27, r27

00003a10 <__utoa_common>:
    3a10:	fb 01       	movw	r30, r22
    3a12:	55 27       	eor	r21, r21
    3a14:	aa 27       	eor	r26, r26
    3a16:	88 0f       	add	r24, r24
    3a18:	99 1f       	adc	r25, r25
    3a1a:	aa 1f       	adc	r26, r26
    3a1c:	a4 17       	cp	r26, r20
    3a1e:	10 f0       	brcs	.+4      	; 0x3a24 <__utoa_common+0x14>
    3a20:	a4 1b       	sub	r26, r20
    3a22:	83 95       	inc	r24
    3a24:	50 51       	subi	r21, 0x10	; 16
    3a26:	b9 f7       	brne	.-18     	; 0x3a16 <__utoa_common+0x6>
    3a28:	a0 5d       	subi	r26, 0xD0	; 208
    3a2a:	aa 33       	cpi	r26, 0x3A	; 58
    3a2c:	08 f0       	brcs	.+2      	; 0x3a30 <__utoa_common+0x20>
    3a2e:	a9 5d       	subi	r26, 0xD9	; 217
    3a30:	a1 93       	st	Z+, r26
    3a32:	00 97       	sbiw	r24, 0x00	; 0
    3a34:	79 f7       	brne	.-34     	; 0x3a14 <__utoa_common+0x4>
    3a36:	b1 11       	cpse	r27, r1
    3a38:	b1 93       	st	Z+, r27
    3a3a:	11 92       	st	Z+, r1
    3a3c:	cb 01       	movw	r24, r22
    3a3e:	0c 94 21 1d 	jmp	0x3a42	; 0x3a42 <strrev>

00003a42 <strrev>:
    3a42:	dc 01       	movw	r26, r24
    3a44:	fc 01       	movw	r30, r24
    3a46:	67 2f       	mov	r22, r23
    3a48:	71 91       	ld	r23, Z+
    3a4a:	77 23       	and	r23, r23
    3a4c:	e1 f7       	brne	.-8      	; 0x3a46 <strrev+0x4>
    3a4e:	32 97       	sbiw	r30, 0x02	; 2
    3a50:	04 c0       	rjmp	.+8      	; 0x3a5a <strrev+0x18>
    3a52:	7c 91       	ld	r23, X
    3a54:	6d 93       	st	X+, r22
    3a56:	70 83       	st	Z, r23
    3a58:	62 91       	ld	r22, -Z
    3a5a:	ae 17       	cp	r26, r30
    3a5c:	bf 07       	cpc	r27, r31
    3a5e:	c8 f3       	brcs	.-14     	; 0x3a52 <strrev+0x10>
    3a60:	08 95       	ret

00003a62 <_exit>:
    3a62:	f8 94       	cli

00003a64 <__stop_program>:
    3a64:	ff cf       	rjmp	.-2      	; 0x3a64 <__stop_program>
