
QAMDecFS2019.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003fe6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000009e  00802000  00003fe6  0000407a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000110f  0080209e  0080209e  00004118  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004118  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004148  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000798  00000000  00000000  00004188  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001023f  00000000  00000000  00004920  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000520f  00000000  00000000  00014b5f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005333  00000000  00000000  00019d6e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000190c  00000000  00000000  0001f0a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00007652  00000000  00000000  000209b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009652  00000000  00000000  00028002  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000828  00000000  00000000  00031654  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 22 01 	jmp	0x244	; 0x244 <__ctors_end>
       4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
       c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      10:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      14:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      18:	0c 94 b9 01 	jmp	0x372	; 0x372 <__vector_6>
      1c:	0c 94 ff 01 	jmp	0x3fe	; 0x3fe <__vector_7>
      20:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      24:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      28:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      2c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      30:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      34:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      38:	0c 94 4c 06 	jmp	0xc98	; 0xc98 <__vector_14>
      3c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      40:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      44:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      48:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      4c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      50:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      54:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      58:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      5c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      60:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      64:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      68:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      6c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      70:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      74:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      78:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      7c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      80:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      84:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      88:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      8c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      90:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      94:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      98:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      9c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      a8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      ac:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      b8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      bc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      c8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      cc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      d8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      dc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      e8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      ec:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      f8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
      fc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     100:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     104:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     108:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     10c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     110:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     114:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     118:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     11c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     120:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     124:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     128:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     12c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     130:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     134:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     138:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     13c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     140:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     144:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     148:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     14c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     150:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     154:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     158:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     15c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     160:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     164:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     168:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     16c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     170:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     174:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     178:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     17c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     180:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     184:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     188:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     18c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     190:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     194:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     198:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     19c:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1a8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1ac:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1b0:	0c 94 39 16 	jmp	0x2c72	; 0x2c72 <__vector_108>
     1b4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1b8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1bc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1c8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1cc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1d8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1dc:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1e8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1ec:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f0:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f4:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1f8:	0c 94 4b 01 	jmp	0x296	; 0x296 <__bad_interrupt>
     1fc:	94 11       	cpse	r25, r4
     1fe:	94 11       	cpse	r25, r4
     200:	94 11       	cpse	r25, r4
     202:	e1 11       	cpse	r30, r1
     204:	c9 11       	cpse	r28, r9
     206:	de 11       	cpse	r29, r14
     208:	94 11       	cpse	r25, r4
     20a:	94 11       	cpse	r25, r4
     20c:	e1 11       	cpse	r30, r1
     20e:	c9 11       	cpse	r28, r9

00000210 <__trampolines_start>:
     210:	0c 94 68 13 	jmp	0x26d0	; 0x26d0 <vRead_DMA>
     214:	0c 94 d8 10 	jmp	0x21b0	; 0x21b0 <prvTimerTask>
     218:	0c 94 64 1c 	jmp	0x38c8	; 0x38c8 <vTask_DMAHandler>
     21c:	0c 94 71 12 	jmp	0x24e2	; 0x24e2 <vWrite_Display>
     220:	0c 94 65 12 	jmp	0x24ca	; 0x24ca <vLedBlink>
     224:	0c 94 d8 17 	jmp	0x2fb0	; 0x2fb0 <vDisplayUpdateTask>
     228:	0c 94 94 11 	jmp	0x2328	; 0x2328 <prvTimerTask+0x178>
     22c:	0c 94 61 0a 	jmp	0x14c2	; 0x14c2 <prvIdleTask>
     230:	0c 94 c9 11 	jmp	0x2392	; 0x2392 <prvTimerTask+0x1e2>
     234:	0c 94 37 04 	jmp	0x86e	; 0x86e <vEventGroupSetBitsCallback>
     238:	0c 94 e1 11 	jmp	0x23c2	; 0x23c2 <prvTimerTask+0x212>
     23c:	0c 94 c8 12 	jmp	0x2590	; 0x2590 <vPhase_Detection>
     240:	0c 94 de 11 	jmp	0x23bc	; 0x23bc <prvTimerTask+0x20c>

00000244 <__ctors_end>:
     244:	11 24       	eor	r1, r1
     246:	1f be       	out	0x3f, r1	; 63
     248:	cf ef       	ldi	r28, 0xFF	; 255
     24a:	cd bf       	out	0x3d, r28	; 61
     24c:	df e3       	ldi	r29, 0x3F	; 63
     24e:	de bf       	out	0x3e, r29	; 62
     250:	00 e0       	ldi	r16, 0x00	; 0
     252:	0c bf       	out	0x3c, r16	; 60

00000254 <init_mem>:
// !!! Never call this function, it is part of .init-Code
void __attribute__ ((naked, section(".init3"))) init_mem (void);
void init_mem (void)
{
   //  Use inline assembler so it works even with optimization turned off
   __asm volatile (
     254:	ed ea       	ldi	r30, 0xAD	; 173
     256:	f1 e3       	ldi	r31, 0x31	; 49
     258:	8a ea       	ldi	r24, 0xAA	; 170
     25a:	90 e4       	ldi	r25, 0x40	; 64
     25c:	81 93       	st	Z+, r24
     25e:	e0 30       	cpi	r30, 0x00	; 0
     260:	f9 07       	cpc	r31, r25
     262:	e0 f3       	brcs	.-8      	; 0x25c <init_mem+0x8>

00000264 <__do_copy_data>:
     264:	10 e2       	ldi	r17, 0x20	; 32
     266:	a0 e0       	ldi	r26, 0x00	; 0
     268:	b0 e2       	ldi	r27, 0x20	; 32
     26a:	e6 ee       	ldi	r30, 0xE6	; 230
     26c:	ff e3       	ldi	r31, 0x3F	; 63
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	0b bf       	out	0x3b, r16	; 59
     272:	02 c0       	rjmp	.+4      	; 0x278 <__do_copy_data+0x14>
     274:	07 90       	elpm	r0, Z+
     276:	0d 92       	st	X+, r0
     278:	ae 39       	cpi	r26, 0x9E	; 158
     27a:	b1 07       	cpc	r27, r17
     27c:	d9 f7       	brne	.-10     	; 0x274 <__do_copy_data+0x10>

0000027e <__do_clear_bss>:
     27e:	21 e3       	ldi	r18, 0x31	; 49
     280:	ae e9       	ldi	r26, 0x9E	; 158
     282:	b0 e2       	ldi	r27, 0x20	; 32
     284:	01 c0       	rjmp	.+2      	; 0x288 <.do_clear_bss_start>

00000286 <.do_clear_bss_loop>:
     286:	1d 92       	st	X+, r1

00000288 <.do_clear_bss_start>:
     288:	ad 3a       	cpi	r26, 0xAD	; 173
     28a:	b2 07       	cpc	r27, r18
     28c:	e1 f7       	brne	.-8      	; 0x286 <.do_clear_bss_loop>
     28e:	0e 94 92 15 	call	0x2b24	; 0x2b24 <main>
     292:	0c 94 f1 1f 	jmp	0x3fe2	; 0x3fe2 <_exit>

00000296 <__bad_interrupt>:
     296:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000029a <sys_InitADC>:
void sys_InitADC(void)
{
	
	// Free Running mode: On
	// Conversion mode: Unsigned, 8Bit
	ADCB.CTRLB=(ADCB.CTRLB & (~(ADC_CONMODE_bm | ADC_FREERUN_bm | ADC_RESOLUTION_gm))) | ADC_RESOLUTION_8BIT_gc | ADC_FREERUN_bm;
     29a:	e0 e4       	ldi	r30, 0x40	; 64
     29c:	f2 e0       	ldi	r31, 0x02	; 2
     29e:	81 81       	ldd	r24, Z+1	; 0x01
     2a0:	81 7e       	andi	r24, 0xE1	; 225
     2a2:	8c 60       	ori	r24, 0x0C	; 12
     2a4:	81 83       	std	Z+1, r24	; 0x01
	// Reference 1V and configuration of prescaler to 256
	ADCB.PRESCALER=(ADCB.PRESCALER & (~ADC_PRESCALER_gm)) | ADC_PRESCALER_DIV256_gc; //?????
     2a6:	84 81       	ldd	r24, Z+4	; 0x04
     2a8:	88 7f       	andi	r24, 0xF8	; 248
     2aa:	86 60       	ori	r24, 0x06	; 6
     2ac:	84 83       	std	Z+4, r24	; 0x04
	ADCB.REFCTRL = ADC_REFSEL_INT1V_gc | ADC_TEMPREF_bm;;			//internal 1V
     2ae:	81 e0       	ldi	r24, 0x01	; 1
     2b0:	82 83       	std	Z+2, r24	; 0x02

	// Read and save the ADC offset using channel 0
	ADCB.CH0.CTRL=(ADCB.CH0.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2b2:	80 a1       	ldd	r24, Z+32	; 0x20
     2b4:	80 76       	andi	r24, 0x60	; 96
     2b6:	81 60       	ori	r24, 0x01	; 1
     2b8:	80 a3       	std	Z+32, r24	; 0x20
	ADCB.CH0.MUXCTRL = ADC_CH_MUXPOS_PIN0_gc ;	// PORTB:0
     2ba:	11 a2       	std	Z+33, r1	; 0x21
	
	ADCB.CH1.CTRL=(ADCB.CH1.CTRL & (~(ADC_CH_START_bm | ADC_CH_GAIN_gm | ADC_CH_INPUTMODE_gm))) | ADC_CH_INPUTMODE_SINGLEENDED_gc;
     2bc:	80 a5       	ldd	r24, Z+40	; 0x28
     2be:	80 76       	andi	r24, 0x60	; 96
     2c0:	81 60       	ori	r24, 0x01	; 1
     2c2:	80 a7       	std	Z+40, r24	; 0x28
	ADCB.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc ;	// PORTB:1	
     2c4:	88 e0       	ldi	r24, 0x08	; 8
     2c6:	81 a7       	std	Z+41, r24	; 0x29
	
	ADCB.CH2.CTRL = ADC_CH_GAIN_1X_gc | ADC_CH_INPUTMODE_INTERNAL_gc;
     2c8:	10 aa       	std	Z+48, r1	; 0x30
	ADCB.CH2.MUXCTRL = ADC_CH_MUXINT_TEMP_gc;  //Temp Mux
     2ca:	11 aa       	std	Z+49, r1	; 0x31
	
	ADCB.EVCTRL = ADC_SWEEP_012_gc;
     2cc:	80 e8       	ldi	r24, 0x80	; 128
     2ce:	83 83       	std	Z+3, r24	; 0x03
	
	// Enable the ADC in order to read the offset
	ADCB.CTRLA|=ADC_ENABLE_bm;
     2d0:	80 81       	ld	r24, Z
     2d2:	81 60       	ori	r24, 0x01	; 1
     2d4:	80 83       	st	Z, r24
     2d6:	08 95       	ret

000002d8 <vInitDMA>:
void vInitDMA()
{
	uint8_t i = 0;
	
	//ADC8 PB0 Input
	PORTB.DIRCLR = PIN0_bm;
     2d8:	e0 e2       	ldi	r30, 0x20	; 32
     2da:	f6 e0       	ldi	r31, 0x06	; 6
     2dc:	81 e0       	ldi	r24, 0x01	; 1
     2de:	82 83       	std	Z+2, r24	; 0x02
	PORTB.DIRCLR = PIN1_bm;
     2e0:	82 e0       	ldi	r24, 0x02	; 2
     2e2:	82 83       	std	Z+2, r24	; 0x02
	
	sys_InitADC();
     2e4:	0e 94 4d 01 	call	0x29a	; 0x29a <sys_InitADC>

	// set TCC1 to 11024Hz overflow, actually 11019.2838Hz (-0.052% error)
	TCC1.CTRLA = 0; // stop if running
     2e8:	e0 e4       	ldi	r30, 0x40	; 64
     2ea:	f8 e0       	ldi	r31, 0x08	; 8
     2ec:	10 82       	st	Z, r1
	TCC1.CNT = 0;
     2ee:	10 a2       	std	Z+32, r1	; 0x20
     2f0:	11 a2       	std	Z+33, r1	; 0x21
	TCC1.PER = 0x0FFF;
     2f2:	8f ef       	ldi	r24, 0xFF	; 255
     2f4:	9f e0       	ldi	r25, 0x0F	; 15
     2f6:	86 a3       	std	Z+38, r24	; 0x26
     2f8:	97 a3       	std	Z+39, r25	; 0x27

	EVSYS.CH0MUX = EVSYS_CHMUX_TCC1_OVF_gc; // trigger on timer overflow
     2fa:	88 ec       	ldi	r24, 0xC8	; 200
     2fc:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <__TEXT_REGION_LENGTH__+0x700180>


	// reset DMA controller
	DMA.CTRL = 0;
     300:	e0 e0       	ldi	r30, 0x00	; 0
     302:	f1 e0       	ldi	r31, 0x01	; 1
     304:	10 82       	st	Z, r1
	DMA.CTRL = DMA_RESET_bm;
     306:	80 e4       	ldi	r24, 0x40	; 64
     308:	80 83       	st	Z, r24
	while ((DMA.CTRL & DMA_RESET_bm) != 0);
     30a:	80 81       	ld	r24, Z
     30c:	86 fd       	sbrc	r24, 6
     30e:	fd cf       	rjmp	.-6      	; 0x30a <vInitDMA+0x32>
	
	DMA.CTRL			= DMA_CH_ENABLE_bm | DMA_DBUFMODE_CH01_gc; // double buffered with channels 0 and 1
     310:	e0 e0       	ldi	r30, 0x00	; 0
     312:	f1 e0       	ldi	r31, 0x01	; 1
     314:	84 e8       	ldi	r24, 0x84	; 132
     316:	80 83       	st	Z, r24
	//Bei Double Buffering wird automatisch aus Channel 0 und 1 ein "Pair" gebildet. 
	//Siehe dazu AVR1304.P8
	
	// channel 0
	// **** TODO: reset dma channels
	DMA.CH0.REPCNT		= 0;
     318:	16 8a       	std	Z+22, r1	; 0x16
	DMA.CH0.CTRLA		=  DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 1 byte (8 bit word)
     31a:	74 e2       	ldi	r23, 0x24	; 36
     31c:	70 8b       	std	Z+16, r23	; 0x10
	DMA.CH0.CTRLB		= 0x1;
     31e:	61 e0       	ldi	r22, 0x01	; 1
     320:	61 8b       	std	Z+17, r22	; 0x11
	DMA.CH0.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     322:	5d e9       	ldi	r21, 0x9D	; 157
     324:	52 8b       	std	Z+18, r21	; 0x12
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH0.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc;	//DMA0 gets synched by TCC1
     326:	46 e4       	ldi	r20, 0x46	; 70
     328:	43 8b       	std	Z+19, r20	; 0x13
	DMA.CH0.TRFCNT		= 64; // always the number of bytes, even if burst length > 1
     32a:	20 e4       	ldi	r18, 0x40	; 64
     32c:	30 e0       	ldi	r19, 0x00	; 0
     32e:	24 8b       	std	Z+20, r18	; 0x14
     330:	35 8b       	std	Z+21, r19	; 0x15
	DMA.CH0.DESTADDR0	= (( (uint16_t) buffer_a) >> 0) & 0xFF;
     332:	80 e5       	ldi	r24, 0x50	; 80
     334:	9f e2       	ldi	r25, 0x2F	; 47
     336:	84 8f       	std	Z+28, r24	; 0x1c
	DMA.CH0.DESTADDR1	= (( (uint16_t) buffer_a) >> 8) & 0xFF;
     338:	95 8f       	std	Z+29, r25	; 0x1d
	DMA.CH0.DESTADDR2	= 0;
     33a:	16 8e       	std	Z+30, r1	; 0x1e
	DMA.CH0.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     33c:	9c e6       	ldi	r25, 0x6C	; 108
     33e:	90 8f       	std	Z+24, r25	; 0x18
	DMA.CH0.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     340:	82 e0       	ldi	r24, 0x02	; 2
     342:	81 8f       	std	Z+25, r24	; 0x19
	DMA.CH0.SRCADDR2	= 0;
     344:	12 8e       	std	Z+26, r1	; 0x1a

	// channel 1
	DMA.CH1.REPCNT		= 0;
     346:	16 a2       	std	Z+38, r1	; 0x26
	DMA.CH1.CTRLA		= DMA_CH_BURSTLEN_1BYTE_gc | DMA_CH_SINGLE_bm | DMA_CH_REPEAT_bm; // ADC result is 1 byte (8 bit word)
     348:	70 a3       	std	Z+32, r23	; 0x20
	DMA.CH1.CTRLB		= 0x1;
     34a:	61 a3       	std	Z+33, r22	; 0x21
	DMA.CH1.ADDRCTRL	= DMA_CH_SRCRELOAD_BURST_gc | DMA_CH_SRCDIR_INC_gc | // reload source after every burst
     34c:	52 a3       	std	Z+34, r21	; 0x22
	DMA_CH_DESTRELOAD_TRANSACTION_gc | DMA_CH_DESTDIR_INC_gc; // reload destination after every transaction
	DMA.CH1.TRIGSRC		= DMA_CH_TRIGSRC_TCC1_OVF_gc; //DMA1 gets synched by TCC1
     34e:	43 a3       	std	Z+35, r20	; 0x23
	DMA.CH1.TRFCNT		= 64; // always the number of bytes, even if burst length > 1
     350:	24 a3       	std	Z+36, r18	; 0x24
     352:	35 a3       	std	Z+37, r19	; 0x25
	DMA.CH1.DESTADDR0	= (( (uint16_t) buffer_b) >> 0) & 0xFF;
     354:	20 e1       	ldi	r18, 0x10	; 16
     356:	3f e2       	ldi	r19, 0x2F	; 47
     358:	24 a7       	std	Z+44, r18	; 0x2c
	DMA.CH1.DESTADDR1	= (( (uint16_t) buffer_b) >> 8) & 0xFF;
     35a:	35 a7       	std	Z+45, r19	; 0x2d
	DMA.CH1.DESTADDR2	= 0;
     35c:	16 a6       	std	Z+46, r1	; 0x2e
	DMA.CH1.SRCADDR0	= (( (uint16_t) &ADCB.CH1.RES) >> 0) & 0xFF;
     35e:	90 a7       	std	Z+40, r25	; 0x28
	DMA.CH1.SRCADDR1	= (( (uint16_t) &ADCB.CH1.RES) >> 8) & 0xFF;
     360:	81 a7       	std	Z+41, r24	; 0x29
	DMA.CH1.SRCADDR2	= 0;
     362:	12 a6       	std	Z+42, r1	; 0x2a

	DMA.CH0.CTRLA		|= DMA_CH_ENABLE_bm;
     364:	80 89       	ldd	r24, Z+16	; 0x10
     366:	80 68       	ori	r24, 0x80	; 128
     368:	80 8b       	std	Z+16, r24	; 0x10
	TCC1.CTRLA			= TC_CLKSEL_DIV1024_gc; // start timer, and in turn ADC
     36a:	87 e0       	ldi	r24, 0x07	; 7
     36c:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
     370:	08 95       	ret

00000372 <__vector_6>:
// 		DMA.INTFLAGS = DMA_CH0TRNIF_bm;

}

ISR(DMA_CH0_vect)
{
     372:	1f 92       	push	r1
     374:	0f 92       	push	r0
     376:	0f b6       	in	r0, 0x3f	; 63
     378:	0f 92       	push	r0
     37a:	11 24       	eor	r1, r1
     37c:	0b b6       	in	r0, 0x3b	; 59
     37e:	0f 92       	push	r0
     380:	2f 93       	push	r18
     382:	3f 93       	push	r19
     384:	4f 93       	push	r20
     386:	5f 93       	push	r21
     388:	6f 93       	push	r22
     38a:	7f 93       	push	r23
     38c:	8f 93       	push	r24
     38e:	9f 93       	push	r25
     390:	af 93       	push	r26
     392:	bf 93       	push	r27
     394:	ef 93       	push	r30
     396:	ff 93       	push	r31
     398:	cf 93       	push	r28
     39a:	df 93       	push	r29
     39c:	1f 92       	push	r1
     39e:	cd b7       	in	r28, 0x3d	; 61
     3a0:	de b7       	in	r29, 0x3e	; 62
	
	//Interrupt quittieren
	DMA.CH0.CTRLB |= 0x10;
     3a2:	e0 e0       	ldi	r30, 0x00	; 0
     3a4:	f1 e0       	ldi	r31, 0x01	; 1
     3a6:	81 89       	ldd	r24, Z+17	; 0x11
     3a8:	80 61       	ori	r24, 0x10	; 16
     3aa:	81 8b       	std	Z+17, r24	; 0x11
	TCC1.INTFLAGS |= 0x01;
     3ac:	e0 e4       	ldi	r30, 0x40	; 64
     3ae:	f8 e0       	ldi	r31, 0x08	; 8
     3b0:	84 85       	ldd	r24, Z+12	; 0x0c
     3b2:	81 60       	ori	r24, 0x01	; 1
     3b4:	84 87       	std	Z+12, r24	; 0x0c
	//PORTF.OUTTGL = 0x01;
		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     3b6:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     3b8:	9e 01       	movw	r18, r28
     3ba:	2f 5f       	subi	r18, 0xFF	; 255
     3bc:	3f 4f       	sbci	r19, 0xFF	; 255
     3be:	41 e0       	ldi	r20, 0x01	; 1
     3c0:	50 e0       	ldi	r21, 0x00	; 0
     3c2:	60 e0       	ldi	r22, 0x00	; 0
     3c4:	70 e0       	ldi	r23, 0x00	; 0
     3c6:	80 91 18 2d 	lds	r24, 0x2D18	; 0x802d18 <xDMAProcessEventGroup>
     3ca:	90 91 19 2d 	lds	r25, 0x2D19	; 0x802d19 <xDMAProcessEventGroup+0x1>
     3ce:	0e 94 3a 04 	call	0x874	; 0x874 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     3d2:	0f 90       	pop	r0
     3d4:	df 91       	pop	r29
     3d6:	cf 91       	pop	r28
     3d8:	ff 91       	pop	r31
     3da:	ef 91       	pop	r30
     3dc:	bf 91       	pop	r27
     3de:	af 91       	pop	r26
     3e0:	9f 91       	pop	r25
     3e2:	8f 91       	pop	r24
     3e4:	7f 91       	pop	r23
     3e6:	6f 91       	pop	r22
     3e8:	5f 91       	pop	r21
     3ea:	4f 91       	pop	r20
     3ec:	3f 91       	pop	r19
     3ee:	2f 91       	pop	r18
     3f0:	0f 90       	pop	r0
     3f2:	0b be       	out	0x3b, r0	; 59
     3f4:	0f 90       	pop	r0
     3f6:	0f be       	out	0x3f, r0	; 63
     3f8:	0f 90       	pop	r0
     3fa:	1f 90       	pop	r1
     3fc:	18 95       	reti

000003fe <__vector_7>:

ISR(DMA_CH1_vect)
{
     3fe:	1f 92       	push	r1
     400:	0f 92       	push	r0
     402:	0f b6       	in	r0, 0x3f	; 63
     404:	0f 92       	push	r0
     406:	11 24       	eor	r1, r1
     408:	0b b6       	in	r0, 0x3b	; 59
     40a:	0f 92       	push	r0
     40c:	2f 93       	push	r18
     40e:	3f 93       	push	r19
     410:	4f 93       	push	r20
     412:	5f 93       	push	r21
     414:	6f 93       	push	r22
     416:	7f 93       	push	r23
     418:	8f 93       	push	r24
     41a:	9f 93       	push	r25
     41c:	af 93       	push	r26
     41e:	bf 93       	push	r27
     420:	ef 93       	push	r30
     422:	ff 93       	push	r31
     424:	cf 93       	push	r28
     426:	df 93       	push	r29
     428:	1f 92       	push	r1
     42a:	cd b7       	in	r28, 0x3d	; 61
     42c:	de b7       	in	r29, 0x3e	; 62
	//Interrupt quittieren
	DMA.CH1.CTRLB |= 0x10;
     42e:	e0 e0       	ldi	r30, 0x00	; 0
     430:	f1 e0       	ldi	r31, 0x01	; 1
     432:	81 a1       	ldd	r24, Z+33	; 0x21
     434:	80 61       	ori	r24, 0x10	; 16
     436:	81 a3       	std	Z+33, r24	; 0x21
	TCC1.INTFLAGS |= 0x01;
     438:	e0 e4       	ldi	r30, 0x40	; 64
     43a:	f8 e0       	ldi	r31, 0x08	; 8
     43c:	84 85       	ldd	r24, Z+12	; 0x0c
     43e:	81 60       	ori	r24, 0x01	; 1
     440:	84 87       	std	Z+12, r24	; 0x0c

		
	BaseType_t xHigherPriorityTaskWoken, xResult;

	/* xHigherPriorityTaskWoken must be initialised to pdFALSE. */
	xHigherPriorityTaskWoken = pdFALSE;
     442:	19 82       	std	Y+1, r1	; 0x01

	/* Set bit 0 and bit 4 in xEventGroup. */
	xResult = xEventGroupSetBitsFromISR(
     444:	9e 01       	movw	r18, r28
     446:	2f 5f       	subi	r18, 0xFF	; 255
     448:	3f 4f       	sbci	r19, 0xFF	; 255
     44a:	42 e0       	ldi	r20, 0x02	; 2
     44c:	50 e0       	ldi	r21, 0x00	; 0
     44e:	60 e0       	ldi	r22, 0x00	; 0
     450:	70 e0       	ldi	r23, 0x00	; 0
     452:	80 91 18 2d 	lds	r24, 0x2D18	; 0x802d18 <xDMAProcessEventGroup>
     456:	90 91 19 2d 	lds	r25, 0x2D19	; 0x802d19 <xDMAProcessEventGroup+0x1>
     45a:	0e 94 3a 04 	call	0x874	; 0x874 <xEventGroupSetBitsFromISR>
		switch should be requested.  The macro used is port specific and will
		be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
		the documentation page for the port being used. */
		//portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}	
}
     45e:	0f 90       	pop	r0
     460:	df 91       	pop	r29
     462:	cf 91       	pop	r28
     464:	ff 91       	pop	r31
     466:	ef 91       	pop	r30
     468:	bf 91       	pop	r27
     46a:	af 91       	pop	r26
     46c:	9f 91       	pop	r25
     46e:	8f 91       	pop	r24
     470:	7f 91       	pop	r23
     472:	6f 91       	pop	r22
     474:	5f 91       	pop	r21
     476:	4f 91       	pop	r20
     478:	3f 91       	pop	r19
     47a:	2f 91       	pop	r18
     47c:	0f 90       	pop	r0
     47e:	0b be       	out	0x3b, r0	; 59
     480:	0f 90       	pop	r0
     482:	0f be       	out	0x3f, r0	; 63
     484:	0f 90       	pop	r0
     486:	1f 90       	pop	r1
     488:	18 95       	reti

0000048a <CCPWrite>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
     48a:	0f 93       	push	r16
     48c:	cf 93       	push	r28
     48e:	df 93       	push	r29
     490:	1f 92       	push	r1
     492:	cd b7       	in	r28, 0x3d	; 61
     494:	de b7       	in	r29, 0x3e	; 62

	// Restore global interrupt setting from scratch register.
        asm("out  0x3F, R1");

#elif defined __GNUC__
	AVR_ENTER_CRITICAL_REGION( );
     496:	2f b7       	in	r18, 0x3f	; 63
     498:	29 83       	std	Y+1, r18	; 0x01
     49a:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
#ifdef RAMPZ
	RAMPZ = 0;
     49c:	1b be       	out	0x3b, r1	; 59
#endif
	asm volatile(
     49e:	fc 01       	movw	r30, r24
     4a0:	08 ed       	ldi	r16, 0xD8	; 216
     4a2:	04 bf       	out	0x34, r16	; 52
     4a4:	60 83       	st	Z, r22
		:
		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
		: "r16", "r30", "r31"
		);

	AVR_LEAVE_CRITICAL_REGION( );
     4a6:	89 81       	ldd	r24, Y+1	; 0x01
     4a8:	8f bf       	out	0x3f, r24	; 63
#endif
}
     4aa:	0f 90       	pop	r0
     4ac:	df 91       	pop	r29
     4ae:	cf 91       	pop	r28
     4b0:	0f 91       	pop	r16
     4b2:	08 95       	ret

000004b4 <CLKSYS_XOSC_Config>:
 */
void CLKSYS_XOSC_Config( OSC_FRQRANGE_t freqRange,
                         bool lowPower32kHz,
                         OSC_XOSCSEL_t xoscModeSelection )
{
	OSC.XOSCCTRL = (uint8_t) freqRange |
     4b4:	61 11       	cpse	r22, r1
     4b6:	02 c0       	rjmp	.+4      	; 0x4bc <CLKSYS_XOSC_Config+0x8>
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	01 c0       	rjmp	.+2      	; 0x4be <CLKSYS_XOSC_Config+0xa>
     4bc:	90 e2       	ldi	r25, 0x20	; 32
     4be:	84 2b       	or	r24, r20
     4c0:	89 2b       	or	r24, r25
     4c2:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
     4c6:	08 95       	ret

000004c8 <CLKSYS_PLL_Config>:
 *                      from 1 to 31, inclusive.
 */
void CLKSYS_PLL_Config( OSC_PLLSRC_t clockSource, uint8_t factor )
{
	factor &= OSC_PLLFAC_gm;
	OSC.PLLCTRL = (uint8_t) clockSource | ( factor << OSC_PLLFAC_gp );
     4c8:	6f 71       	andi	r22, 0x1F	; 31
     4ca:	86 2b       	or	r24, r22
     4cc:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
     4d0:	08 95       	ret

000004d2 <CLKSYS_Disable>:
 *
 *  \return  Non-zero if oscillator was disabled successfully.
 */
uint8_t CLKSYS_Disable( uint8_t oscSel )
{
	OSC.CTRL &= ~oscSel;
     4d2:	e0 e5       	ldi	r30, 0x50	; 80
     4d4:	f0 e0       	ldi	r31, 0x00	; 0
     4d6:	90 81       	ld	r25, Z
     4d8:	28 2f       	mov	r18, r24
     4da:	20 95       	com	r18
     4dc:	92 23       	and	r25, r18
     4de:	90 83       	st	Z, r25
	uint8_t clkEnabled = OSC.CTRL & oscSel;
     4e0:	90 81       	ld	r25, Z
	return clkEnabled;
}
     4e2:	89 23       	and	r24, r25
     4e4:	08 95       	ret

000004e6 <CLKSYS_Prescalers_Config>:
 */
void CLKSYS_Prescalers_Config( CLK_PSADIV_t PSAfactor,
                               CLK_PSBCDIV_t PSBCfactor )
{
	uint8_t PSconfig = (uint8_t) PSAfactor | PSBCfactor;
	CCPWrite( &CLK.PSCTRL, PSconfig );
     4e6:	68 2b       	or	r22, r24
     4e8:	81 e4       	ldi	r24, 0x41	; 65
     4ea:	90 e0       	ldi	r25, 0x00	; 0
     4ec:	0e 94 45 02 	call	0x48a	; 0x48a <CCPWrite>
     4f0:	08 95       	ret

000004f2 <CLKSYS_Main_ClockSource_Select>:
 *                       prescaler block.
 *
 *  \return  Non-zero if change was successful.
 */
uint8_t CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_t clockSource )
{
     4f2:	0f 93       	push	r16
     4f4:	1f 93       	push	r17
     4f6:	cf 93       	push	r28
     4f8:	c8 2f       	mov	r28, r24
	uint8_t clkCtrl = ( CLK.CTRL & ~CLK_SCLKSEL_gm ) | clockSource;
     4fa:	00 e4       	ldi	r16, 0x40	; 64
     4fc:	10 e0       	ldi	r17, 0x00	; 0
     4fe:	f8 01       	movw	r30, r16
     500:	60 81       	ld	r22, Z
	CCPWrite( &CLK.CTRL, clkCtrl );
     502:	68 7f       	andi	r22, 0xF8	; 248
     504:	68 2b       	or	r22, r24
     506:	80 e4       	ldi	r24, 0x40	; 64
     508:	90 e0       	ldi	r25, 0x00	; 0
     50a:	0e 94 45 02 	call	0x48a	; 0x48a <CCPWrite>
	clkCtrl = ( CLK.CTRL & clockSource );
     50e:	f8 01       	movw	r30, r16
     510:	80 81       	ld	r24, Z
	return clkCtrl;
}
     512:	8c 23       	and	r24, r28
     514:	cf 91       	pop	r28
     516:	1f 91       	pop	r17
     518:	0f 91       	pop	r16
     51a:	08 95       	ret

0000051c <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
     51c:	fc 01       	movw	r30, r24
     51e:	90 81       	ld	r25, Z
     520:	90 7f       	andi	r25, 0xF0	; 240
     522:	69 2b       	or	r22, r25
     524:	60 83       	st	Z, r22
     526:	08 95       	ret

00000528 <TC0_ConfigWGM>:
     528:	fc 01       	movw	r30, r24
     52a:	91 81       	ldd	r25, Z+1	; 0x01
     52c:	98 7f       	andi	r25, 0xF8	; 248
     52e:	69 2b       	or	r22, r25
     530:	61 83       	std	Z+1, r22	; 0x01
     532:	08 95       	ret

00000534 <TC0_SetOverflowIntLevel>:
 *
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
     534:	fc 01       	movw	r30, r24
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
     536:	96 81       	ldd	r25, Z+6	; 0x06
     538:	9c 7f       	andi	r25, 0xFC	; 252
     53a:	69 2b       	or	r22, r25
     53c:	66 83       	std	Z+6, r22	; 0x06
     53e:	08 95       	ret

00000540 <software_reset>:
	 // TODO from here:
	 //
	 // - log the occurance of any error in flash mem (inc counter)
	 // - print a message

	 software_reset();
     540:	00 00       	nop
     542:	88 ed       	ldi	r24, 0xD8	; 216
     544:	84 bf       	out	0x34, r24	; 52
     546:	81 e0       	ldi	r24, 0x01	; 1
     548:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
     54c:	08 95       	ret

0000054e <vApplicationStackOverflowHook>:
     54e:	0e 94 a0 02 	call	0x540	; 0x540 <software_reset>
     552:	08 95       	ret

00000554 <xEventGroupCreate>:
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
}
     554:	cf 93       	push	r28
     556:	df 93       	push	r29
     558:	80 e1       	ldi	r24, 0x10	; 16
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	0e 94 47 04 	call	0x88e	; 0x88e <pvPortMalloc>
     560:	ec 01       	movw	r28, r24
     562:	00 97       	sbiw	r24, 0x00	; 0
     564:	41 f0       	breq	.+16     	; 0x576 <xEventGroupCreate+0x22>
     566:	fc 01       	movw	r30, r24
     568:	11 92       	st	Z+, r1
     56a:	11 92       	st	Z+, r1
     56c:	11 92       	st	Z+, r1
     56e:	11 92       	st	Z+, r1
     570:	cf 01       	movw	r24, r30
     572:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
     576:	ce 01       	movw	r24, r28
     578:	df 91       	pop	r29
     57a:	cf 91       	pop	r28
     57c:	08 95       	ret

0000057e <xEventGroupWaitBits>:
     57e:	2f 92       	push	r2
     580:	3f 92       	push	r3
     582:	4f 92       	push	r4
     584:	5f 92       	push	r5
     586:	6f 92       	push	r6
     588:	7f 92       	push	r7
     58a:	8f 92       	push	r8
     58c:	9f 92       	push	r9
     58e:	af 92       	push	r10
     590:	bf 92       	push	r11
     592:	cf 92       	push	r12
     594:	df 92       	push	r13
     596:	ef 92       	push	r14
     598:	ff 92       	push	r15
     59a:	0f 93       	push	r16
     59c:	1f 93       	push	r17
     59e:	cf 93       	push	r28
     5a0:	df 93       	push	r29
     5a2:	ec 01       	movw	r28, r24
     5a4:	4a 01       	movw	r8, r20
     5a6:	5b 01       	movw	r10, r22
     5a8:	62 2e       	mov	r6, r18
     5aa:	70 2e       	mov	r7, r16
     5ac:	0e 94 bb 0b 	call	0x1776	; 0x1776 <vTaskSuspendAll>
     5b0:	28 80       	ld	r2, Y
     5b2:	39 80       	ldd	r3, Y+1	; 0x01
     5b4:	4a 80       	ldd	r4, Y+2	; 0x02
     5b6:	5b 80       	ldd	r5, Y+3	; 0x03
     5b8:	01 11       	cpse	r16, r1
     5ba:	0d c0       	rjmp	.+26     	; 0x5d6 <xEventGroupWaitBits+0x58>
     5bc:	81 e0       	ldi	r24, 0x01	; 1
     5be:	b2 01       	movw	r22, r4
     5c0:	a1 01       	movw	r20, r2
     5c2:	48 21       	and	r20, r8
     5c4:	59 21       	and	r21, r9
     5c6:	6a 21       	and	r22, r10
     5c8:	7b 21       	and	r23, r11
     5ca:	45 2b       	or	r20, r21
     5cc:	46 2b       	or	r20, r22
     5ce:	47 2b       	or	r20, r23
     5d0:	79 f4       	brne	.+30     	; 0x5f0 <xEventGroupWaitBits+0x72>
     5d2:	80 e0       	ldi	r24, 0x00	; 0
     5d4:	0d c0       	rjmp	.+26     	; 0x5f0 <xEventGroupWaitBits+0x72>
     5d6:	81 e0       	ldi	r24, 0x01	; 1
     5d8:	b2 01       	movw	r22, r4
     5da:	a1 01       	movw	r20, r2
     5dc:	48 21       	and	r20, r8
     5de:	59 21       	and	r21, r9
     5e0:	6a 21       	and	r22, r10
     5e2:	7b 21       	and	r23, r11
     5e4:	48 15       	cp	r20, r8
     5e6:	59 05       	cpc	r21, r9
     5e8:	6a 05       	cpc	r22, r10
     5ea:	7b 05       	cpc	r23, r11
     5ec:	09 f0       	breq	.+2      	; 0x5f0 <xEventGroupWaitBits+0x72>
     5ee:	80 e0       	ldi	r24, 0x00	; 0
     5f0:	88 23       	and	r24, r24
     5f2:	81 f0       	breq	.+32     	; 0x614 <xEventGroupWaitBits+0x96>
     5f4:	66 20       	and	r6, r6
     5f6:	09 f4       	brne	.+2      	; 0x5fa <xEventGroupWaitBits+0x7c>
     5f8:	70 c0       	rjmp	.+224    	; 0x6da <xEventGroupWaitBits+0x15c>
     5fa:	80 94       	com	r8
     5fc:	90 94       	com	r9
     5fe:	a0 94       	com	r10
     600:	b0 94       	com	r11
     602:	82 20       	and	r8, r2
     604:	93 20       	and	r9, r3
     606:	a4 20       	and	r10, r4
     608:	b5 20       	and	r11, r5
     60a:	88 82       	st	Y, r8
     60c:	99 82       	std	Y+1, r9	; 0x01
     60e:	aa 82       	std	Y+2, r10	; 0x02
     610:	bb 82       	std	Y+3, r11	; 0x03
     612:	63 c0       	rjmp	.+198    	; 0x6da <xEventGroupWaitBits+0x15c>
     614:	c1 14       	cp	r12, r1
     616:	d1 04       	cpc	r13, r1
     618:	e1 04       	cpc	r14, r1
     61a:	f1 04       	cpc	r15, r1
     61c:	09 f4       	brne	.+2      	; 0x620 <xEventGroupWaitBits+0xa2>
     61e:	5d c0       	rjmp	.+186    	; 0x6da <xEventGroupWaitBits+0x15c>
     620:	66 20       	and	r6, r6
     622:	29 f0       	breq	.+10     	; 0x62e <xEventGroupWaitBits+0xb0>
     624:	40 e0       	ldi	r20, 0x00	; 0
     626:	50 e0       	ldi	r21, 0x00	; 0
     628:	60 e0       	ldi	r22, 0x00	; 0
     62a:	71 e0       	ldi	r23, 0x01	; 1
     62c:	03 c0       	rjmp	.+6      	; 0x634 <xEventGroupWaitBits+0xb6>
     62e:	40 e0       	ldi	r20, 0x00	; 0
     630:	50 e0       	ldi	r21, 0x00	; 0
     632:	ba 01       	movw	r22, r20
     634:	71 10       	cpse	r7, r1
     636:	74 60       	ori	r23, 0x04	; 4
     638:	48 29       	or	r20, r8
     63a:	59 29       	or	r21, r9
     63c:	6a 29       	or	r22, r10
     63e:	7b 29       	or	r23, r11
     640:	97 01       	movw	r18, r14
     642:	86 01       	movw	r16, r12
     644:	ce 01       	movw	r24, r28
     646:	04 96       	adiw	r24, 0x04	; 4
     648:	0e 94 ea 0d 	call	0x1bd4	; 0x1bd4 <vTaskPlaceOnUnorderedEventList>
     64c:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
     650:	81 11       	cpse	r24, r1
     652:	02 c0       	rjmp	.+4      	; 0x658 <xEventGroupWaitBits+0xda>
     654:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
     658:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <uxTaskResetEventItemValue>
     65c:	91 fd       	sbrc	r25, 1
     65e:	39 c0       	rjmp	.+114    	; 0x6d2 <xEventGroupWaitBits+0x154>
     660:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     664:	ff 93       	push	r31
     666:	f8 7f       	andi	r31, 0xF8	; 248
     668:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     66c:	68 81       	ld	r22, Y
     66e:	79 81       	ldd	r23, Y+1	; 0x01
     670:	8a 81       	ldd	r24, Y+2	; 0x02
     672:	9b 81       	ldd	r25, Y+3	; 0x03
     674:	71 10       	cpse	r7, r1
     676:	0d c0       	rjmp	.+26     	; 0x692 <xEventGroupWaitBits+0x114>
     678:	21 e0       	ldi	r18, 0x01	; 1
     67a:	75 01       	movw	r14, r10
     67c:	64 01       	movw	r12, r8
     67e:	c6 22       	and	r12, r22
     680:	d7 22       	and	r13, r23
     682:	e8 22       	and	r14, r24
     684:	f9 22       	and	r15, r25
     686:	cd 28       	or	r12, r13
     688:	ce 28       	or	r12, r14
     68a:	cf 28       	or	r12, r15
     68c:	79 f4       	brne	.+30     	; 0x6ac <xEventGroupWaitBits+0x12e>
     68e:	20 e0       	ldi	r18, 0x00	; 0
     690:	0d c0       	rjmp	.+26     	; 0x6ac <xEventGroupWaitBits+0x12e>
     692:	21 e0       	ldi	r18, 0x01	; 1
     694:	75 01       	movw	r14, r10
     696:	64 01       	movw	r12, r8
     698:	c6 22       	and	r12, r22
     69a:	d7 22       	and	r13, r23
     69c:	e8 22       	and	r14, r24
     69e:	f9 22       	and	r15, r25
     6a0:	c8 14       	cp	r12, r8
     6a2:	d9 04       	cpc	r13, r9
     6a4:	ea 04       	cpc	r14, r10
     6a6:	fb 04       	cpc	r15, r11
     6a8:	09 f0       	breq	.+2      	; 0x6ac <xEventGroupWaitBits+0x12e>
     6aa:	20 e0       	ldi	r18, 0x00	; 0
     6ac:	22 23       	and	r18, r18
     6ae:	71 f0       	breq	.+28     	; 0x6cc <xEventGroupWaitBits+0x14e>
     6b0:	66 20       	and	r6, r6
     6b2:	61 f0       	breq	.+24     	; 0x6cc <xEventGroupWaitBits+0x14e>
     6b4:	80 94       	com	r8
     6b6:	90 94       	com	r9
     6b8:	a0 94       	com	r10
     6ba:	b0 94       	com	r11
     6bc:	86 22       	and	r8, r22
     6be:	97 22       	and	r9, r23
     6c0:	a8 22       	and	r10, r24
     6c2:	b9 22       	and	r11, r25
     6c4:	88 82       	st	Y, r8
     6c6:	99 82       	std	Y+1, r9	; 0x01
     6c8:	aa 82       	std	Y+2, r10	; 0x02
     6ca:	bb 82       	std	Y+3, r11	; 0x03
     6cc:	ff 91       	pop	r31
     6ce:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     6d2:	1b 01       	movw	r2, r22
     6d4:	2c 01       	movw	r4, r24
     6d6:	55 24       	eor	r5, r5
     6d8:	02 c0       	rjmp	.+4      	; 0x6de <xEventGroupWaitBits+0x160>
     6da:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
     6de:	c2 01       	movw	r24, r4
     6e0:	b1 01       	movw	r22, r2
     6e2:	df 91       	pop	r29
     6e4:	cf 91       	pop	r28
     6e6:	1f 91       	pop	r17
     6e8:	0f 91       	pop	r16
     6ea:	ff 90       	pop	r15
     6ec:	ef 90       	pop	r14
     6ee:	df 90       	pop	r13
     6f0:	cf 90       	pop	r12
     6f2:	bf 90       	pop	r11
     6f4:	af 90       	pop	r10
     6f6:	9f 90       	pop	r9
     6f8:	8f 90       	pop	r8
     6fa:	7f 90       	pop	r7
     6fc:	6f 90       	pop	r6
     6fe:	5f 90       	pop	r5
     700:	4f 90       	pop	r4
     702:	3f 90       	pop	r3
     704:	2f 90       	pop	r2
     706:	08 95       	ret

00000708 <xEventGroupClearBits>:
     708:	0f 93       	push	r16
     70a:	1f 93       	push	r17
     70c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     710:	ff 93       	push	r31
     712:	f8 7f       	andi	r31, 0xF8	; 248
     714:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     718:	fc 01       	movw	r30, r24
     71a:	00 81       	ld	r16, Z
     71c:	11 81       	ldd	r17, Z+1	; 0x01
     71e:	22 81       	ldd	r18, Z+2	; 0x02
     720:	33 81       	ldd	r19, Z+3	; 0x03
     722:	40 95       	com	r20
     724:	50 95       	com	r21
     726:	60 95       	com	r22
     728:	70 95       	com	r23
     72a:	40 23       	and	r20, r16
     72c:	51 23       	and	r21, r17
     72e:	62 23       	and	r22, r18
     730:	73 23       	and	r23, r19
     732:	40 83       	st	Z, r20
     734:	51 83       	std	Z+1, r21	; 0x01
     736:	62 83       	std	Z+2, r22	; 0x02
     738:	73 83       	std	Z+3, r23	; 0x03
     73a:	ff 91       	pop	r31
     73c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     740:	c9 01       	movw	r24, r18
     742:	b8 01       	movw	r22, r16
     744:	1f 91       	pop	r17
     746:	0f 91       	pop	r16
     748:	08 95       	ret

0000074a <xEventGroupSetBits>:
     74a:	4f 92       	push	r4
     74c:	5f 92       	push	r5
     74e:	6f 92       	push	r6
     750:	7f 92       	push	r7
     752:	af 92       	push	r10
     754:	bf 92       	push	r11
     756:	cf 92       	push	r12
     758:	df 92       	push	r13
     75a:	ef 92       	push	r14
     75c:	ff 92       	push	r15
     75e:	0f 93       	push	r16
     760:	1f 93       	push	r17
     762:	cf 93       	push	r28
     764:	df 93       	push	r29
     766:	ec 01       	movw	r28, r24
     768:	6a 01       	movw	r12, r20
     76a:	7b 01       	movw	r14, r22
     76c:	8c 01       	movw	r16, r24
     76e:	09 5f       	subi	r16, 0xF9	; 249
     770:	1f 4f       	sbci	r17, 0xFF	; 255
     772:	0e 94 bb 0b 	call	0x1776	; 0x1776 <vTaskSuspendAll>
     776:	eb 85       	ldd	r30, Y+11	; 0x0b
     778:	fc 85       	ldd	r31, Y+12	; 0x0c
     77a:	88 81       	ld	r24, Y
     77c:	99 81       	ldd	r25, Y+1	; 0x01
     77e:	aa 81       	ldd	r26, Y+2	; 0x02
     780:	bb 81       	ldd	r27, Y+3	; 0x03
     782:	c8 2a       	or	r12, r24
     784:	d9 2a       	or	r13, r25
     786:	ea 2a       	or	r14, r26
     788:	fb 2a       	or	r15, r27
     78a:	c8 82       	st	Y, r12
     78c:	d9 82       	std	Y+1, r13	; 0x01
     78e:	ea 82       	std	Y+2, r14	; 0x02
     790:	fb 82       	std	Y+3, r15	; 0x03
     792:	0e 17       	cp	r16, r30
     794:	1f 07       	cpc	r17, r31
     796:	09 f4       	brne	.+2      	; 0x79a <xEventGroupSetBits+0x50>
     798:	42 c0       	rjmp	.+132    	; 0x81e <xEventGroupSetBits+0xd4>
     79a:	c1 2c       	mov	r12, r1
     79c:	d1 2c       	mov	r13, r1
     79e:	76 01       	movw	r14, r12
     7a0:	a4 80       	ldd	r10, Z+4	; 0x04
     7a2:	b5 80       	ldd	r11, Z+5	; 0x05
     7a4:	80 81       	ld	r24, Z
     7a6:	91 81       	ldd	r25, Z+1	; 0x01
     7a8:	a2 81       	ldd	r26, Z+2	; 0x02
     7aa:	b3 81       	ldd	r27, Z+3	; 0x03
     7ac:	ac 01       	movw	r20, r24
     7ae:	bd 01       	movw	r22, r26
     7b0:	77 27       	eor	r23, r23
     7b2:	b2 fd       	sbrc	r27, 2
     7b4:	0f c0       	rjmp	.+30     	; 0x7d4 <xEventGroupSetBits+0x8a>
     7b6:	48 80       	ld	r4, Y
     7b8:	59 80       	ldd	r5, Y+1	; 0x01
     7ba:	6a 80       	ldd	r6, Y+2	; 0x02
     7bc:	7b 80       	ldd	r7, Y+3	; 0x03
     7be:	44 22       	and	r4, r20
     7c0:	55 22       	and	r5, r21
     7c2:	66 22       	and	r6, r22
     7c4:	77 22       	and	r7, r23
     7c6:	21 e0       	ldi	r18, 0x01	; 1
     7c8:	45 28       	or	r4, r5
     7ca:	46 28       	or	r4, r6
     7cc:	47 28       	or	r4, r7
     7ce:	89 f4       	brne	.+34     	; 0x7f2 <xEventGroupSetBits+0xa8>
     7d0:	20 e0       	ldi	r18, 0x00	; 0
     7d2:	0f c0       	rjmp	.+30     	; 0x7f2 <xEventGroupSetBits+0xa8>
     7d4:	48 80       	ld	r4, Y
     7d6:	59 80       	ldd	r5, Y+1	; 0x01
     7d8:	6a 80       	ldd	r6, Y+2	; 0x02
     7da:	7b 80       	ldd	r7, Y+3	; 0x03
     7dc:	44 22       	and	r4, r20
     7de:	55 22       	and	r5, r21
     7e0:	66 22       	and	r6, r22
     7e2:	77 22       	and	r7, r23
     7e4:	21 e0       	ldi	r18, 0x01	; 1
     7e6:	44 16       	cp	r4, r20
     7e8:	55 06       	cpc	r5, r21
     7ea:	66 06       	cpc	r6, r22
     7ec:	77 06       	cpc	r7, r23
     7ee:	09 f0       	breq	.+2      	; 0x7f2 <xEventGroupSetBits+0xa8>
     7f0:	20 e0       	ldi	r18, 0x00	; 0
     7f2:	22 23       	and	r18, r18
     7f4:	71 f0       	breq	.+28     	; 0x812 <xEventGroupSetBits+0xc8>
     7f6:	b0 ff       	sbrs	r27, 0
     7f8:	04 c0       	rjmp	.+8      	; 0x802 <xEventGroupSetBits+0xb8>
     7fa:	c4 2a       	or	r12, r20
     7fc:	d5 2a       	or	r13, r21
     7fe:	e6 2a       	or	r14, r22
     800:	f7 2a       	or	r15, r23
     802:	48 81       	ld	r20, Y
     804:	59 81       	ldd	r21, Y+1	; 0x01
     806:	6a 81       	ldd	r22, Y+2	; 0x02
     808:	7b 81       	ldd	r23, Y+3	; 0x03
     80a:	72 60       	ori	r23, 0x02	; 2
     80c:	cf 01       	movw	r24, r30
     80e:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <vTaskRemoveFromUnorderedEventList>
     812:	ea 2d       	mov	r30, r10
     814:	fb 2d       	mov	r31, r11
     816:	0e 17       	cp	r16, r30
     818:	1f 07       	cpc	r17, r31
     81a:	11 f6       	brne	.-124    	; 0x7a0 <xEventGroupSetBits+0x56>
     81c:	03 c0       	rjmp	.+6      	; 0x824 <xEventGroupSetBits+0xda>
     81e:	c1 2c       	mov	r12, r1
     820:	d1 2c       	mov	r13, r1
     822:	76 01       	movw	r14, r12
     824:	c0 94       	com	r12
     826:	d0 94       	com	r13
     828:	e0 94       	com	r14
     82a:	f0 94       	com	r15
     82c:	88 81       	ld	r24, Y
     82e:	99 81       	ldd	r25, Y+1	; 0x01
     830:	aa 81       	ldd	r26, Y+2	; 0x02
     832:	bb 81       	ldd	r27, Y+3	; 0x03
     834:	c8 22       	and	r12, r24
     836:	d9 22       	and	r13, r25
     838:	ea 22       	and	r14, r26
     83a:	fb 22       	and	r15, r27
     83c:	c8 82       	st	Y, r12
     83e:	d9 82       	std	Y+1, r13	; 0x01
     840:	ea 82       	std	Y+2, r14	; 0x02
     842:	fb 82       	std	Y+3, r15	; 0x03
     844:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
     848:	68 81       	ld	r22, Y
     84a:	79 81       	ldd	r23, Y+1	; 0x01
     84c:	8a 81       	ldd	r24, Y+2	; 0x02
     84e:	9b 81       	ldd	r25, Y+3	; 0x03
     850:	df 91       	pop	r29
     852:	cf 91       	pop	r28
     854:	1f 91       	pop	r17
     856:	0f 91       	pop	r16
     858:	ff 90       	pop	r15
     85a:	ef 90       	pop	r14
     85c:	df 90       	pop	r13
     85e:	cf 90       	pop	r12
     860:	bf 90       	pop	r11
     862:	af 90       	pop	r10
     864:	7f 90       	pop	r7
     866:	6f 90       	pop	r6
     868:	5f 90       	pop	r5
     86a:	4f 90       	pop	r4
     86c:	08 95       	ret

0000086e <vEventGroupSetBitsCallback>:
     86e:	0e 94 a5 03 	call	0x74a	; 0x74a <xEventGroupSetBits>
     872:	08 95       	ret

00000874 <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
     874:	0f 93       	push	r16
     876:	1f 93       	push	r17
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
     878:	89 01       	movw	r16, r18
     87a:	9a 01       	movw	r18, r20
     87c:	ab 01       	movw	r20, r22
     87e:	bc 01       	movw	r22, r24
     880:	87 e3       	ldi	r24, 0x37	; 55
     882:	94 e0       	ldi	r25, 0x04	; 4
     884:	0e 94 07 12 	call	0x240e	; 0x240e <xTimerPendFunctionCallFromISR>

		return xReturn;
	}
     888:	1f 91       	pop	r17
     88a:	0f 91       	pop	r16
     88c:	08 95       	ret

0000088e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     88e:	cf 93       	push	r28
     890:	df 93       	push	r29
     892:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     894:	0e 94 bb 0b 	call	0x1776	; 0x1776 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     898:	20 91 9e 20 	lds	r18, 0x209E	; 0x80209e <__data_end>
     89c:	30 91 9f 20 	lds	r19, 0x209F	; 0x80209f <__data_end+0x1>
     8a0:	c9 01       	movw	r24, r18
     8a2:	8c 0f       	add	r24, r28
     8a4:	9d 1f       	adc	r25, r29
     8a6:	88 3b       	cpi	r24, 0xB8	; 184
     8a8:	4b e0       	ldi	r20, 0x0B	; 11
     8aa:	94 07       	cpc	r25, r20
     8ac:	58 f4       	brcc	.+22     	; 0x8c4 <pvPortMalloc+0x36>
     8ae:	28 17       	cp	r18, r24
     8b0:	39 07       	cpc	r19, r25
     8b2:	58 f4       	brcc	.+22     	; 0x8ca <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     8b4:	e9 01       	movw	r28, r18
     8b6:	c0 56       	subi	r28, 0x60	; 96
     8b8:	df 4d       	sbci	r29, 0xDF	; 223
			xNextFreeByte += xWantedSize;			
     8ba:	80 93 9e 20 	sts	0x209E, r24	; 0x80209e <__data_end>
     8be:	90 93 9f 20 	sts	0x209F, r25	; 0x80209f <__data_end+0x1>
     8c2:	05 c0       	rjmp	.+10     	; 0x8ce <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     8c4:	c0 e0       	ldi	r28, 0x00	; 0
     8c6:	d0 e0       	ldi	r29, 0x00	; 0
     8c8:	02 c0       	rjmp	.+4      	; 0x8ce <pvPortMalloc+0x40>
     8ca:	c0 e0       	ldi	r28, 0x00	; 0
     8cc:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     8ce:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     8d2:	ce 01       	movw	r24, r28
     8d4:	df 91       	pop	r29
     8d6:	cf 91       	pop	r28
     8d8:	08 95       	ret

000008da <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     8da:	08 95       	ret

000008dc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     8dc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8de:	03 96       	adiw	r24, 0x03	; 3
     8e0:	81 83       	std	Z+1, r24	; 0x01
     8e2:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8e4:	4f ef       	ldi	r20, 0xFF	; 255
     8e6:	5f ef       	ldi	r21, 0xFF	; 255
     8e8:	ba 01       	movw	r22, r20
     8ea:	43 83       	std	Z+3, r20	; 0x03
     8ec:	54 83       	std	Z+4, r21	; 0x04
     8ee:	65 83       	std	Z+5, r22	; 0x05
     8f0:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8f2:	87 83       	std	Z+7, r24	; 0x07
     8f4:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8f6:	81 87       	std	Z+9, r24	; 0x09
     8f8:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8fa:	10 82       	st	Z, r1
     8fc:	08 95       	ret

000008fe <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     8fe:	fc 01       	movw	r30, r24
     900:	12 86       	std	Z+10, r1	; 0x0a
     902:	13 86       	std	Z+11, r1	; 0x0b
     904:	08 95       	ret

00000906 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     906:	cf 93       	push	r28
     908:	df 93       	push	r29
     90a:	9c 01       	movw	r18, r24
     90c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     90e:	dc 01       	movw	r26, r24
     910:	11 96       	adiw	r26, 0x01	; 1
     912:	cd 91       	ld	r28, X+
     914:	dc 91       	ld	r29, X
     916:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     918:	c4 83       	std	Z+4, r28	; 0x04
     91a:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     91c:	8e 81       	ldd	r24, Y+6	; 0x06
     91e:	9f 81       	ldd	r25, Y+7	; 0x07
     920:	86 83       	std	Z+6, r24	; 0x06
     922:	97 83       	std	Z+7, r25	; 0x07

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     924:	8e 81       	ldd	r24, Y+6	; 0x06
     926:	9f 81       	ldd	r25, Y+7	; 0x07
     928:	dc 01       	movw	r26, r24
     92a:	14 96       	adiw	r26, 0x04	; 4
     92c:	6d 93       	st	X+, r22
     92e:	7c 93       	st	X, r23
     930:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxPrevious = pxNewListItem;
     932:	6e 83       	std	Y+6, r22	; 0x06
     934:	7f 83       	std	Y+7, r23	; 0x07

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     936:	22 87       	std	Z+10, r18	; 0x0a
     938:	33 87       	std	Z+11, r19	; 0x0b

	( pxList->uxNumberOfItems )++;
     93a:	f9 01       	movw	r30, r18
     93c:	80 81       	ld	r24, Z
     93e:	8f 5f       	subi	r24, 0xFF	; 255
     940:	80 83       	st	Z, r24
}
     942:	df 91       	pop	r29
     944:	cf 91       	pop	r28
     946:	08 95       	ret

00000948 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     952:	08 81       	ld	r16, Y
     954:	19 81       	ldd	r17, Y+1	; 0x01
     956:	2a 81       	ldd	r18, Y+2	; 0x02
     958:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     95a:	0f 3f       	cpi	r16, 0xFF	; 255
     95c:	4f ef       	ldi	r20, 0xFF	; 255
     95e:	14 07       	cpc	r17, r20
     960:	24 07       	cpc	r18, r20
     962:	34 07       	cpc	r19, r20
     964:	21 f4       	brne	.+8      	; 0x96e <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     966:	fc 01       	movw	r30, r24
     968:	a1 85       	ldd	r26, Z+9	; 0x09
     96a:	b2 85       	ldd	r27, Z+10	; 0x0a
     96c:	11 c0       	rjmp	.+34     	; 0x990 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     96e:	dc 01       	movw	r26, r24
     970:	13 96       	adiw	r26, 0x03	; 3
     972:	01 c0       	rjmp	.+2      	; 0x976 <vListInsert+0x2e>
     974:	df 01       	movw	r26, r30
     976:	14 96       	adiw	r26, 0x04	; 4
     978:	ed 91       	ld	r30, X+
     97a:	fc 91       	ld	r31, X
     97c:	15 97       	sbiw	r26, 0x05	; 5
     97e:	40 81       	ld	r20, Z
     980:	51 81       	ldd	r21, Z+1	; 0x01
     982:	62 81       	ldd	r22, Z+2	; 0x02
     984:	73 81       	ldd	r23, Z+3	; 0x03
     986:	04 17       	cp	r16, r20
     988:	15 07       	cpc	r17, r21
     98a:	26 07       	cpc	r18, r22
     98c:	37 07       	cpc	r19, r23
     98e:	90 f7       	brcc	.-28     	; 0x974 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     990:	14 96       	adiw	r26, 0x04	; 4
     992:	ed 91       	ld	r30, X+
     994:	fc 91       	ld	r31, X
     996:	15 97       	sbiw	r26, 0x05	; 5
     998:	ec 83       	std	Y+4, r30	; 0x04
     99a:	fd 83       	std	Y+5, r31	; 0x05
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     99c:	c6 83       	std	Z+6, r28	; 0x06
     99e:	d7 83       	std	Z+7, r29	; 0x07
	pxNewListItem->pxPrevious = pxIterator;
     9a0:	ae 83       	std	Y+6, r26	; 0x06
     9a2:	bf 83       	std	Y+7, r27	; 0x07
	pxIterator->pxNext = pxNewListItem;
     9a4:	14 96       	adiw	r26, 0x04	; 4
     9a6:	cd 93       	st	X+, r28
     9a8:	dc 93       	st	X, r29
     9aa:	15 97       	sbiw	r26, 0x05	; 5

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9ac:	8a 87       	std	Y+10, r24	; 0x0a
     9ae:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     9b0:	fc 01       	movw	r30, r24
     9b2:	20 81       	ld	r18, Z
     9b4:	2f 5f       	subi	r18, 0xFF	; 255
     9b6:	20 83       	st	Z, r18
}
     9b8:	df 91       	pop	r29
     9ba:	cf 91       	pop	r28
     9bc:	1f 91       	pop	r17
     9be:	0f 91       	pop	r16
     9c0:	08 95       	ret

000009c2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     9c2:	cf 93       	push	r28
     9c4:	df 93       	push	r29
     9c6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     9c8:	a2 85       	ldd	r26, Z+10	; 0x0a
     9ca:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9cc:	c4 81       	ldd	r28, Z+4	; 0x04
     9ce:	d5 81       	ldd	r29, Z+5	; 0x05
     9d0:	86 81       	ldd	r24, Z+6	; 0x06
     9d2:	97 81       	ldd	r25, Z+7	; 0x07
     9d4:	8e 83       	std	Y+6, r24	; 0x06
     9d6:	9f 83       	std	Y+7, r25	; 0x07
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     9d8:	c6 81       	ldd	r28, Z+6	; 0x06
     9da:	d7 81       	ldd	r29, Z+7	; 0x07
     9dc:	84 81       	ldd	r24, Z+4	; 0x04
     9de:	95 81       	ldd	r25, Z+5	; 0x05
     9e0:	8c 83       	std	Y+4, r24	; 0x04
     9e2:	9d 83       	std	Y+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9e4:	11 96       	adiw	r26, 0x01	; 1
     9e6:	8d 91       	ld	r24, X+
     9e8:	9c 91       	ld	r25, X
     9ea:	12 97       	sbiw	r26, 0x02	; 2
     9ec:	e8 17       	cp	r30, r24
     9ee:	f9 07       	cpc	r31, r25
     9f0:	31 f4       	brne	.+12     	; 0x9fe <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9f2:	86 81       	ldd	r24, Z+6	; 0x06
     9f4:	97 81       	ldd	r25, Z+7	; 0x07
     9f6:	11 96       	adiw	r26, 0x01	; 1
     9f8:	8d 93       	st	X+, r24
     9fa:	9c 93       	st	X, r25
     9fc:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9fe:	12 86       	std	Z+10, r1	; 0x0a
     a00:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     a02:	8c 91       	ld	r24, X
     a04:	81 50       	subi	r24, 0x01	; 1
     a06:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     a08:	8c 91       	ld	r24, X
}
     a0a:	df 91       	pop	r29
     a0c:	cf 91       	pop	r28
     a0e:	08 95       	ret

00000a10 <_portSetInterruptMaskFromIsr>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a10:	e0 ea       	ldi	r30, 0xA0	; 160
     a12:	f0 e0       	ldi	r31, 0x00	; 0
     a14:	82 81       	ldd	r24, Z+2	; 0x02
     a16:	92 81       	ldd	r25, Z+2	; 0x02
     a18:	98 7f       	andi	r25, 0xF8	; 248
     a1a:	92 83       	std	Z+2, r25	; 0x02
     a1c:	08 95       	ret

00000a1e <pxPortInitialiseStack>:
     a1e:	cf 92       	push	r12
     a20:	df 92       	push	r13
     a22:	ef 92       	push	r14
     a24:	ff 92       	push	r15
     a26:	31 e1       	ldi	r19, 0x11	; 17
     a28:	fc 01       	movw	r30, r24
     a2a:	30 83       	st	Z, r19
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	22 e2       	ldi	r18, 0x22	; 34
     a30:	20 83       	st	Z, r18
     a32:	31 97       	sbiw	r30, 0x01	; 1
     a34:	a3 e3       	ldi	r26, 0x33	; 51
     a36:	a0 83       	st	Z, r26
     a38:	6b 01       	movw	r12, r22
     a3a:	e1 2c       	mov	r14, r1
     a3c:	f1 2c       	mov	r15, r1
     a3e:	31 97       	sbiw	r30, 0x01	; 1
     a40:	60 83       	st	Z, r22
     a42:	31 97       	sbiw	r30, 0x01	; 1
     a44:	d0 82       	st	Z, r13
     a46:	31 97       	sbiw	r30, 0x01	; 1
     a48:	e0 82       	st	Z, r14
     a4a:	31 97       	sbiw	r30, 0x01	; 1
     a4c:	61 e3       	ldi	r22, 0x31	; 49
     a4e:	60 83       	st	Z, r22
     a50:	31 97       	sbiw	r30, 0x01	; 1
     a52:	60 e8       	ldi	r22, 0x80	; 128
     a54:	60 83       	st	Z, r22
     a56:	31 97       	sbiw	r30, 0x01	; 1
     a58:	67 e8       	ldi	r22, 0x87	; 135
     a5a:	60 83       	st	Z, r22
     a5c:	31 97       	sbiw	r30, 0x01	; 1
     a5e:	10 82       	st	Z, r1
     a60:	31 97       	sbiw	r30, 0x01	; 1
     a62:	10 82       	st	Z, r1
     a64:	31 97       	sbiw	r30, 0x01	; 1
     a66:	62 e0       	ldi	r22, 0x02	; 2
     a68:	60 83       	st	Z, r22
     a6a:	31 97       	sbiw	r30, 0x01	; 1
     a6c:	63 e0       	ldi	r22, 0x03	; 3
     a6e:	60 83       	st	Z, r22
     a70:	31 97       	sbiw	r30, 0x01	; 1
     a72:	64 e0       	ldi	r22, 0x04	; 4
     a74:	60 83       	st	Z, r22
     a76:	31 97       	sbiw	r30, 0x01	; 1
     a78:	65 e0       	ldi	r22, 0x05	; 5
     a7a:	60 83       	st	Z, r22
     a7c:	31 97       	sbiw	r30, 0x01	; 1
     a7e:	66 e0       	ldi	r22, 0x06	; 6
     a80:	60 83       	st	Z, r22
     a82:	31 97       	sbiw	r30, 0x01	; 1
     a84:	67 e0       	ldi	r22, 0x07	; 7
     a86:	60 83       	st	Z, r22
     a88:	31 97       	sbiw	r30, 0x01	; 1
     a8a:	68 e0       	ldi	r22, 0x08	; 8
     a8c:	60 83       	st	Z, r22
     a8e:	31 97       	sbiw	r30, 0x01	; 1
     a90:	69 e0       	ldi	r22, 0x09	; 9
     a92:	60 83       	st	Z, r22
     a94:	31 97       	sbiw	r30, 0x01	; 1
     a96:	60 e1       	ldi	r22, 0x10	; 16
     a98:	60 83       	st	Z, r22
     a9a:	31 97       	sbiw	r30, 0x01	; 1
     a9c:	30 83       	st	Z, r19
     a9e:	31 97       	sbiw	r30, 0x01	; 1
     aa0:	32 e1       	ldi	r19, 0x12	; 18
     aa2:	30 83       	st	Z, r19
     aa4:	31 97       	sbiw	r30, 0x01	; 1
     aa6:	33 e1       	ldi	r19, 0x13	; 19
     aa8:	30 83       	st	Z, r19
     aaa:	31 97       	sbiw	r30, 0x01	; 1
     aac:	34 e1       	ldi	r19, 0x14	; 20
     aae:	30 83       	st	Z, r19
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	35 e1       	ldi	r19, 0x15	; 21
     ab4:	30 83       	st	Z, r19
     ab6:	31 97       	sbiw	r30, 0x01	; 1
     ab8:	36 e1       	ldi	r19, 0x16	; 22
     aba:	30 83       	st	Z, r19
     abc:	31 97       	sbiw	r30, 0x01	; 1
     abe:	37 e1       	ldi	r19, 0x17	; 23
     ac0:	30 83       	st	Z, r19
     ac2:	31 97       	sbiw	r30, 0x01	; 1
     ac4:	38 e1       	ldi	r19, 0x18	; 24
     ac6:	30 83       	st	Z, r19
     ac8:	31 97       	sbiw	r30, 0x01	; 1
     aca:	39 e1       	ldi	r19, 0x19	; 25
     acc:	30 83       	st	Z, r19
     ace:	31 97       	sbiw	r30, 0x01	; 1
     ad0:	30 e2       	ldi	r19, 0x20	; 32
     ad2:	30 83       	st	Z, r19
     ad4:	31 97       	sbiw	r30, 0x01	; 1
     ad6:	31 e2       	ldi	r19, 0x21	; 33
     ad8:	30 83       	st	Z, r19
     ada:	31 97       	sbiw	r30, 0x01	; 1
     adc:	20 83       	st	Z, r18
     ade:	31 97       	sbiw	r30, 0x01	; 1
     ae0:	23 e2       	ldi	r18, 0x23	; 35
     ae2:	20 83       	st	Z, r18
     ae4:	6a 01       	movw	r12, r20
     ae6:	31 97       	sbiw	r30, 0x01	; 1
     ae8:	40 83       	st	Z, r20
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	d0 82       	st	Z, r13
     aee:	31 97       	sbiw	r30, 0x01	; 1
     af0:	26 e2       	ldi	r18, 0x26	; 38
     af2:	20 83       	st	Z, r18
     af4:	31 97       	sbiw	r30, 0x01	; 1
     af6:	27 e2       	ldi	r18, 0x27	; 39
     af8:	20 83       	st	Z, r18
     afa:	31 97       	sbiw	r30, 0x01	; 1
     afc:	28 e2       	ldi	r18, 0x28	; 40
     afe:	20 83       	st	Z, r18
     b00:	31 97       	sbiw	r30, 0x01	; 1
     b02:	29 e2       	ldi	r18, 0x29	; 41
     b04:	20 83       	st	Z, r18
     b06:	31 97       	sbiw	r30, 0x01	; 1
     b08:	20 e3       	ldi	r18, 0x30	; 48
     b0a:	20 83       	st	Z, r18
     b0c:	88 97       	sbiw	r24, 0x28	; 40
     b0e:	ff 90       	pop	r15
     b10:	ef 90       	pop	r14
     b12:	df 90       	pop	r13
     b14:	cf 90       	pop	r12
     b16:	08 95       	ret

00000b18 <xPortStartScheduler>:
     b18:	83 ef       	ldi	r24, 0xF3	; 243
     b1a:	91 e0       	ldi	r25, 0x01	; 1
     b1c:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
     b20:	90 93 27 08 	sts	0x0827, r25	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
     b24:	65 e0       	ldi	r22, 0x05	; 5
     b26:	80 e0       	ldi	r24, 0x00	; 0
     b28:	98 e0       	ldi	r25, 0x08	; 8
     b2a:	0e 94 8e 02 	call	0x51c	; 0x51c <TC0_ConfigClockSource>
     b2e:	61 e0       	ldi	r22, 0x01	; 1
     b30:	80 e0       	ldi	r24, 0x00	; 0
     b32:	98 e0       	ldi	r25, 0x08	; 8
     b34:	0e 94 9a 02 	call	0x534	; 0x534 <TC0_SetOverflowIntLevel>
     b38:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
     b3c:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
     b40:	0d 90       	ld	r0, X+
     b42:	0d be       	out	0x3d, r0	; 61
     b44:	0d 90       	ld	r0, X+
     b46:	0e be       	out	0x3e, r0	; 62
     b48:	ef 91       	pop	r30
     b4a:	df 91       	pop	r29
     b4c:	cf 91       	pop	r28
     b4e:	bf 91       	pop	r27
     b50:	af 91       	pop	r26
     b52:	9f 91       	pop	r25
     b54:	8f 91       	pop	r24
     b56:	7f 91       	pop	r23
     b58:	6f 91       	pop	r22
     b5a:	5f 91       	pop	r21
     b5c:	4f 91       	pop	r20
     b5e:	3f 91       	pop	r19
     b60:	2f 91       	pop	r18
     b62:	1f 91       	pop	r17
     b64:	0f 91       	pop	r16
     b66:	ff 90       	pop	r15
     b68:	ef 90       	pop	r14
     b6a:	df 90       	pop	r13
     b6c:	cf 90       	pop	r12
     b6e:	bf 90       	pop	r11
     b70:	af 90       	pop	r10
     b72:	9f 90       	pop	r9
     b74:	8f 90       	pop	r8
     b76:	7f 90       	pop	r7
     b78:	6f 90       	pop	r6
     b7a:	5f 90       	pop	r5
     b7c:	4f 90       	pop	r4
     b7e:	3f 90       	pop	r3
     b80:	2f 90       	pop	r2
     b82:	1f 90       	pop	r1
     b84:	0f 90       	pop	r0
     b86:	ff 91       	pop	r31
     b88:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b8c:	ff 91       	pop	r31
     b8e:	ff bf       	out	0x3f, r31	; 63
     b90:	ff 91       	pop	r31
     b92:	08 95       	ret
     b94:	81 e0       	ldi	r24, 0x01	; 1
     b96:	08 95       	ret

00000b98 <vPortYield>:
// 
//
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b98:	ff 93       	push	r31
     b9a:	ff b7       	in	r31, 0x3f	; 63
     b9c:	ff 93       	push	r31
     b9e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ba2:	ff 93       	push	r31
     ba4:	f8 7f       	andi	r31, 0xF8	; 248
     ba6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     baa:	0f 92       	push	r0
     bac:	1f 92       	push	r1
     bae:	11 24       	eor	r1, r1
     bb0:	2f 92       	push	r2
     bb2:	3f 92       	push	r3
     bb4:	4f 92       	push	r4
     bb6:	5f 92       	push	r5
     bb8:	6f 92       	push	r6
     bba:	7f 92       	push	r7
     bbc:	8f 92       	push	r8
     bbe:	9f 92       	push	r9
     bc0:	af 92       	push	r10
     bc2:	bf 92       	push	r11
     bc4:	cf 92       	push	r12
     bc6:	df 92       	push	r13
     bc8:	ef 92       	push	r14
     bca:	ff 92       	push	r15
     bcc:	0f 93       	push	r16
     bce:	1f 93       	push	r17
     bd0:	2f 93       	push	r18
     bd2:	3f 93       	push	r19
     bd4:	4f 93       	push	r20
     bd6:	5f 93       	push	r21
     bd8:	6f 93       	push	r22
     bda:	7f 93       	push	r23
     bdc:	8f 93       	push	r24
     bde:	9f 93       	push	r25
     be0:	af 93       	push	r26
     be2:	bf 93       	push	r27
     be4:	cf 93       	push	r28
     be6:	df 93       	push	r29
     be8:	ef 93       	push	r30
     bea:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
     bee:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
     bf2:	0d b6       	in	r0, 0x3d	; 61
     bf4:	0d 92       	st	X+, r0
     bf6:	0e b6       	in	r0, 0x3e	; 62
     bf8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     bfa:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bfe:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
     c02:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
     c06:	0d 90       	ld	r0, X+
     c08:	0d be       	out	0x3d, r0	; 61
     c0a:	0d 90       	ld	r0, X+
     c0c:	0e be       	out	0x3e, r0	; 62
     c0e:	ef 91       	pop	r30
     c10:	df 91       	pop	r29
     c12:	cf 91       	pop	r28
     c14:	bf 91       	pop	r27
     c16:	af 91       	pop	r26
     c18:	9f 91       	pop	r25
     c1a:	8f 91       	pop	r24
     c1c:	7f 91       	pop	r23
     c1e:	6f 91       	pop	r22
     c20:	5f 91       	pop	r21
     c22:	4f 91       	pop	r20
     c24:	3f 91       	pop	r19
     c26:	2f 91       	pop	r18
     c28:	1f 91       	pop	r17
     c2a:	0f 91       	pop	r16
     c2c:	ff 90       	pop	r15
     c2e:	ef 90       	pop	r14
     c30:	df 90       	pop	r13
     c32:	cf 90       	pop	r12
     c34:	bf 90       	pop	r11
     c36:	af 90       	pop	r10
     c38:	9f 90       	pop	r9
     c3a:	8f 90       	pop	r8
     c3c:	7f 90       	pop	r7
     c3e:	6f 90       	pop	r6
     c40:	5f 90       	pop	r5
     c42:	4f 90       	pop	r4
     c44:	3f 90       	pop	r3
     c46:	2f 90       	pop	r2
     c48:	1f 90       	pop	r1
     c4a:	0f 90       	pop	r0
     c4c:	ff 91       	pop	r31
     c4e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     c52:	ff 91       	pop	r31
     c54:	ff bf       	out	0x3f, r31	; 63
     c56:	ff 91       	pop	r31
	asm volatile ( "ret" );
     c58:	08 95       	ret

00000c5a <portTaskSwitchContext>:
	//-----------------------------------------------------------
	//
	// The task switch is deferred until there is no more nesting.
	//
	void portTaskSwitchContext(signed portBASE_TYPE xSwitchRequired)
	{
     c5a:	cf 93       	push	r28
		intTaskSwitchPending |= xSwitchRequired;					
     c5c:	90 91 90 2f 	lds	r25, 0x2F90	; 0x802f90 <intTaskSwitchPending>
     c60:	89 2b       	or	r24, r25
     c62:	80 93 90 2f 	sts	0x2F90, r24	; 0x802f90 <intTaskSwitchPending>
																
		if(NOT_NESTING() && intTaskSwitchPending)					
     c66:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c6a:	91 30       	cpi	r25, 0x01	; 1
     c6c:	41 f0       	breq	.+16     	; 0xc7e <portTaskSwitchContext+0x24>
     c6e:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c72:	92 30       	cpi	r25, 0x02	; 2
     c74:	21 f0       	breq	.+8      	; 0xc7e <portTaskSwitchContext+0x24>
     c76:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     c7a:	94 30       	cpi	r25, 0x04	; 4
     c7c:	59 f4       	brne	.+22     	; 0xc94 <portTaskSwitchContext+0x3a>
     c7e:	88 23       	and	r24, r24
     c80:	49 f0       	breq	.+18     	; 0xc94 <portTaskSwitchContext+0x3a>
		{															
			register unsigned portBASE_TYPE uxSavedPmicCtrlReg; 				
			extern void vTaskSwitchContext(void);   				
																
			// Critical section used, because vTaskSwitchContext handles FreeRTOS internal data structures.
 			uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR(); 
     c82:	0e 94 08 05 	call	0xa10	; 0xa10 <_portSetInterruptMaskFromIsr>
     c86:	c8 2f       	mov	r28, r24
			intTaskSwitchPending = 0;								
     c88:	10 92 90 2f 	sts	0x2F90, r1	; 0x802f90 <intTaskSwitchPending>
			vTaskSwitchContext();                   				
     c8c:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <vTaskSwitchContext>
			portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedPmicCtrlReg);
     c90:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		}                                          					
	}
     c94:	cf 91       	pop	r28
     c96:	08 95       	ret

00000c98 <__vector_14>:
	// the context is saved at the start of vPortYieldFromTick().  The tick
	// count is incremented after the context is saved.
	//
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
     c98:	ff 93       	push	r31
     c9a:	ff b7       	in	r31, 0x3f	; 63
     c9c:	ff 93       	push	r31
     c9e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ca2:	ff 93       	push	r31
     ca4:	f8 7f       	andi	r31, 0xF8	; 248
     ca6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     caa:	0f 92       	push	r0
     cac:	1f 92       	push	r1
     cae:	11 24       	eor	r1, r1
     cb0:	2f 92       	push	r2
     cb2:	3f 92       	push	r3
     cb4:	4f 92       	push	r4
     cb6:	5f 92       	push	r5
     cb8:	6f 92       	push	r6
     cba:	7f 92       	push	r7
     cbc:	8f 92       	push	r8
     cbe:	9f 92       	push	r9
     cc0:	af 92       	push	r10
     cc2:	bf 92       	push	r11
     cc4:	cf 92       	push	r12
     cc6:	df 92       	push	r13
     cc8:	ef 92       	push	r14
     cca:	ff 92       	push	r15
     ccc:	0f 93       	push	r16
     cce:	1f 93       	push	r17
     cd0:	2f 93       	push	r18
     cd2:	3f 93       	push	r19
     cd4:	4f 93       	push	r20
     cd6:	5f 93       	push	r21
     cd8:	6f 93       	push	r22
     cda:	7f 93       	push	r23
     cdc:	8f 93       	push	r24
     cde:	9f 93       	push	r25
     ce0:	af 93       	push	r26
     ce2:	bf 93       	push	r27
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
     ce8:	ef 93       	push	r30
     cea:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
     cee:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
     cf2:	0d b6       	in	r0, 0x3d	; 61
     cf4:	0d 92       	st	X+, r0
     cf6:	0e b6       	in	r0, 0x3e	; 62
     cf8:	0d 92       	st	X+, r0
	//
	static void portTaskIncrementTick( void )
	{
		register unsigned portBASE_TYPE uxSavedPmicCtrlReg;

 		uxSavedPmicCtrlReg = portSET_INTERRUPT_MASK_FROM_ISR();
     cfa:	0e 94 08 05 	call	0xa10	; 0xa10 <_portSetInterruptMaskFromIsr>
     cfe:	c8 2f       	mov	r28, r24
		xTaskIncrementTick();
     d00:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <xTaskIncrementTick>
 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedPmicCtrlReg );
     d04:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	ISR(TCC0_OVF_vect, ISR_NAKED)
	{
		portSTART_ISR();
		portTaskIncrementTick();
		//always try a task switch, but only if on kernel interrupt level
		portEND_SWITCHING_ISR(pdTRUE); 
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	0e 94 2d 06 	call	0xc5a	; 0xc5a <portTaskSwitchContext>
     d0e:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
     d12:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
     d16:	0d 90       	ld	r0, X+
     d18:	0d be       	out	0x3d, r0	; 61
     d1a:	0d 90       	ld	r0, X+
     d1c:	0e be       	out	0x3e, r0	; 62
     d1e:	ef 91       	pop	r30
     d20:	df 91       	pop	r29
     d22:	cf 91       	pop	r28
     d24:	bf 91       	pop	r27
     d26:	af 91       	pop	r26
     d28:	9f 91       	pop	r25
     d2a:	8f 91       	pop	r24
     d2c:	7f 91       	pop	r23
     d2e:	6f 91       	pop	r22
     d30:	5f 91       	pop	r21
     d32:	4f 91       	pop	r20
     d34:	3f 91       	pop	r19
     d36:	2f 91       	pop	r18
     d38:	1f 91       	pop	r17
     d3a:	0f 91       	pop	r16
     d3c:	ff 90       	pop	r15
     d3e:	ef 90       	pop	r14
     d40:	df 90       	pop	r13
     d42:	cf 90       	pop	r12
     d44:	bf 90       	pop	r11
     d46:	af 90       	pop	r10
     d48:	9f 90       	pop	r9
     d4a:	8f 90       	pop	r8
     d4c:	7f 90       	pop	r7
     d4e:	6f 90       	pop	r6
     d50:	5f 90       	pop	r5
     d52:	4f 90       	pop	r4
     d54:	3f 90       	pop	r3
     d56:	2f 90       	pop	r2
     d58:	1f 90       	pop	r1
     d5a:	0f 90       	pop	r0
     d5c:	ff 91       	pop	r31
     d5e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d62:	ff 91       	pop	r31
     d64:	ff bf       	out	0x3f, r31	; 63
     d66:	ff 91       	pop	r31
     d68:	18 95       	reti

00000d6a <prvIsQueueEmpty>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
     d6a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d6e:	ff 93       	push	r31
     d70:	f8 7f       	andi	r31, 0xF8	; 248
     d72:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d76:	fc 01       	movw	r30, r24
     d78:	96 8d       	ldd	r25, Z+30	; 0x1e
     d7a:	ff 91       	pop	r31
     d7c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d80:	81 e0       	ldi	r24, 0x01	; 1
     d82:	91 11       	cpse	r25, r1
     d84:	80 e0       	ldi	r24, 0x00	; 0
     d86:	08 95       	ret

00000d88 <prvIsQueueFull>:
     d88:	dc 01       	movw	r26, r24
     d8a:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d8e:	ff 93       	push	r31
     d90:	f8 7f       	andi	r31, 0xF8	; 248
     d92:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     d96:	5e 96       	adiw	r26, 0x1e	; 30
     d98:	9c 91       	ld	r25, X
     d9a:	5e 97       	sbiw	r26, 0x1e	; 30
     d9c:	ff 91       	pop	r31
     d9e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     da2:	81 e0       	ldi	r24, 0x01	; 1
     da4:	5f 96       	adiw	r26, 0x1f	; 31
     da6:	2c 91       	ld	r18, X
     da8:	29 13       	cpse	r18, r25
     daa:	80 e0       	ldi	r24, 0x00	; 0
     dac:	08 95       	ret

00000dae <prvCopyDataToQueue>:
     dae:	0f 93       	push	r16
     db0:	1f 93       	push	r17
     db2:	cf 93       	push	r28
     db4:	df 93       	push	r29
     db6:	ec 01       	movw	r28, r24
     db8:	04 2f       	mov	r16, r20
     dba:	1e 8d       	ldd	r17, Y+30	; 0x1e
     dbc:	48 a1       	ldd	r20, Y+32	; 0x20
     dbe:	44 23       	and	r20, r20
     dc0:	b9 f1       	breq	.+110    	; 0xe30 <prvCopyDataToQueue+0x82>
     dc2:	01 11       	cpse	r16, r1
     dc4:	16 c0       	rjmp	.+44     	; 0xdf2 <prvCopyDataToQueue+0x44>
     dc6:	50 e0       	ldi	r21, 0x00	; 0
     dc8:	8c 81       	ldd	r24, Y+4	; 0x04
     dca:	9d 81       	ldd	r25, Y+5	; 0x05
     dcc:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <memcpy>
     dd0:	28 a1       	ldd	r18, Y+32	; 0x20
     dd2:	8c 81       	ldd	r24, Y+4	; 0x04
     dd4:	9d 81       	ldd	r25, Y+5	; 0x05
     dd6:	82 0f       	add	r24, r18
     dd8:	91 1d       	adc	r25, r1
     dda:	8c 83       	std	Y+4, r24	; 0x04
     ddc:	9d 83       	std	Y+5, r25	; 0x05
     dde:	2a 81       	ldd	r18, Y+2	; 0x02
     de0:	3b 81       	ldd	r19, Y+3	; 0x03
     de2:	82 17       	cp	r24, r18
     de4:	93 07       	cpc	r25, r19
     de6:	20 f1       	brcs	.+72     	; 0xe30 <prvCopyDataToQueue+0x82>
     de8:	88 81       	ld	r24, Y
     dea:	99 81       	ldd	r25, Y+1	; 0x01
     dec:	8c 83       	std	Y+4, r24	; 0x04
     dee:	9d 83       	std	Y+5, r25	; 0x05
     df0:	1f c0       	rjmp	.+62     	; 0xe30 <prvCopyDataToQueue+0x82>
     df2:	50 e0       	ldi	r21, 0x00	; 0
     df4:	8e 81       	ldd	r24, Y+6	; 0x06
     df6:	9f 81       	ldd	r25, Y+7	; 0x07
     df8:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <memcpy>
     dfc:	88 a1       	ldd	r24, Y+32	; 0x20
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	91 95       	neg	r25
     e02:	81 95       	neg	r24
     e04:	91 09       	sbc	r25, r1
     e06:	2e 81       	ldd	r18, Y+6	; 0x06
     e08:	3f 81       	ldd	r19, Y+7	; 0x07
     e0a:	28 0f       	add	r18, r24
     e0c:	39 1f       	adc	r19, r25
     e0e:	2e 83       	std	Y+6, r18	; 0x06
     e10:	3f 83       	std	Y+7, r19	; 0x07
     e12:	48 81       	ld	r20, Y
     e14:	59 81       	ldd	r21, Y+1	; 0x01
     e16:	24 17       	cp	r18, r20
     e18:	35 07       	cpc	r19, r21
     e1a:	30 f4       	brcc	.+12     	; 0xe28 <prvCopyDataToQueue+0x7a>
     e1c:	2a 81       	ldd	r18, Y+2	; 0x02
     e1e:	3b 81       	ldd	r19, Y+3	; 0x03
     e20:	82 0f       	add	r24, r18
     e22:	93 1f       	adc	r25, r19
     e24:	8e 83       	std	Y+6, r24	; 0x06
     e26:	9f 83       	std	Y+7, r25	; 0x07
     e28:	02 30       	cpi	r16, 0x02	; 2
     e2a:	11 f4       	brne	.+4      	; 0xe30 <prvCopyDataToQueue+0x82>
     e2c:	11 11       	cpse	r17, r1
     e2e:	11 50       	subi	r17, 0x01	; 1
     e30:	1f 5f       	subi	r17, 0xFF	; 255
     e32:	1e 8f       	std	Y+30, r17	; 0x1e
     e34:	80 e0       	ldi	r24, 0x00	; 0
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	1f 91       	pop	r17
     e3c:	0f 91       	pop	r16
     e3e:	08 95       	ret

00000e40 <prvCopyDataFromQueue>:
     e40:	fc 01       	movw	r30, r24
     e42:	40 a1       	ldd	r20, Z+32	; 0x20
     e44:	44 23       	and	r20, r20
     e46:	a9 f0       	breq	.+42     	; 0xe72 <prvCopyDataFromQueue+0x32>
     e48:	50 e0       	ldi	r21, 0x00	; 0
     e4a:	26 81       	ldd	r18, Z+6	; 0x06
     e4c:	37 81       	ldd	r19, Z+7	; 0x07
     e4e:	24 0f       	add	r18, r20
     e50:	35 1f       	adc	r19, r21
     e52:	26 83       	std	Z+6, r18	; 0x06
     e54:	37 83       	std	Z+7, r19	; 0x07
     e56:	82 81       	ldd	r24, Z+2	; 0x02
     e58:	93 81       	ldd	r25, Z+3	; 0x03
     e5a:	28 17       	cp	r18, r24
     e5c:	39 07       	cpc	r19, r25
     e5e:	20 f0       	brcs	.+8      	; 0xe68 <prvCopyDataFromQueue+0x28>
     e60:	80 81       	ld	r24, Z
     e62:	91 81       	ldd	r25, Z+1	; 0x01
     e64:	86 83       	std	Z+6, r24	; 0x06
     e66:	97 83       	std	Z+7, r25	; 0x07
     e68:	cb 01       	movw	r24, r22
     e6a:	66 81       	ldd	r22, Z+6	; 0x06
     e6c:	77 81       	ldd	r23, Z+7	; 0x07
     e6e:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <memcpy>
     e72:	08 95       	ret

00000e74 <prvUnlockQueue>:
     e74:	ef 92       	push	r14
     e76:	ff 92       	push	r15
     e78:	0f 93       	push	r16
     e7a:	1f 93       	push	r17
     e7c:	cf 93       	push	r28
     e7e:	8c 01       	movw	r16, r24
     e80:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e84:	ff 93       	push	r31
     e86:	f8 7f       	andi	r31, 0xF8	; 248
     e88:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     e8c:	fc 01       	movw	r30, r24
     e8e:	c2 a1       	ldd	r28, Z+34	; 0x22
     e90:	1c 16       	cp	r1, r28
     e92:	ac f4       	brge	.+42     	; 0xebe <prvUnlockQueue+0x4a>
     e94:	83 89       	ldd	r24, Z+19	; 0x13
     e96:	81 11       	cpse	r24, r1
     e98:	06 c0       	rjmp	.+12     	; 0xea6 <prvUnlockQueue+0x32>
     e9a:	11 c0       	rjmp	.+34     	; 0xebe <prvUnlockQueue+0x4a>
     e9c:	f8 01       	movw	r30, r16
     e9e:	83 89       	ldd	r24, Z+19	; 0x13
     ea0:	81 11       	cpse	r24, r1
     ea2:	05 c0       	rjmp	.+10     	; 0xeae <prvUnlockQueue+0x3a>
     ea4:	0c c0       	rjmp	.+24     	; 0xebe <prvUnlockQueue+0x4a>
     ea6:	78 01       	movw	r14, r16
     ea8:	f3 e1       	ldi	r31, 0x13	; 19
     eaa:	ef 0e       	add	r14, r31
     eac:	f1 1c       	adc	r15, r1
     eae:	c7 01       	movw	r24, r14
     eb0:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <xTaskRemoveFromEventList>
     eb4:	81 11       	cpse	r24, r1
     eb6:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <vTaskMissedYield>
     eba:	c1 50       	subi	r28, 0x01	; 1
     ebc:	79 f7       	brne	.-34     	; 0xe9c <prvUnlockQueue+0x28>
     ebe:	8f ef       	ldi	r24, 0xFF	; 255
     ec0:	f8 01       	movw	r30, r16
     ec2:	82 a3       	std	Z+34, r24	; 0x22
     ec4:	ff 91       	pop	r31
     ec6:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     eca:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ece:	ff 93       	push	r31
     ed0:	f8 7f       	andi	r31, 0xF8	; 248
     ed2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     ed6:	f8 01       	movw	r30, r16
     ed8:	c1 a1       	ldd	r28, Z+33	; 0x21
     eda:	1c 16       	cp	r1, r28
     edc:	ac f4       	brge	.+42     	; 0xf08 <prvUnlockQueue+0x94>
     ede:	80 85       	ldd	r24, Z+8	; 0x08
     ee0:	81 11       	cpse	r24, r1
     ee2:	06 c0       	rjmp	.+12     	; 0xef0 <prvUnlockQueue+0x7c>
     ee4:	11 c0       	rjmp	.+34     	; 0xf08 <prvUnlockQueue+0x94>
     ee6:	f8 01       	movw	r30, r16
     ee8:	80 85       	ldd	r24, Z+8	; 0x08
     eea:	81 11       	cpse	r24, r1
     eec:	05 c0       	rjmp	.+10     	; 0xef8 <prvUnlockQueue+0x84>
     eee:	0c c0       	rjmp	.+24     	; 0xf08 <prvUnlockQueue+0x94>
     ef0:	78 01       	movw	r14, r16
     ef2:	f8 e0       	ldi	r31, 0x08	; 8
     ef4:	ef 0e       	add	r14, r31
     ef6:	f1 1c       	adc	r15, r1
     ef8:	c7 01       	movw	r24, r14
     efa:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <xTaskRemoveFromEventList>
     efe:	81 11       	cpse	r24, r1
     f00:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <vTaskMissedYield>
     f04:	c1 50       	subi	r28, 0x01	; 1
     f06:	79 f7       	brne	.-34     	; 0xee6 <prvUnlockQueue+0x72>
     f08:	8f ef       	ldi	r24, 0xFF	; 255
     f0a:	f8 01       	movw	r30, r16
     f0c:	81 a3       	std	Z+33, r24	; 0x21
     f0e:	ff 91       	pop	r31
     f10:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f14:	cf 91       	pop	r28
     f16:	1f 91       	pop	r17
     f18:	0f 91       	pop	r16
     f1a:	ff 90       	pop	r15
     f1c:	ef 90       	pop	r14
     f1e:	08 95       	ret

00000f20 <xQueueGenericReset>:
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
     f24:	ec 01       	movw	r28, r24
     f26:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f2a:	ff 93       	push	r31
     f2c:	f8 7f       	andi	r31, 0xF8	; 248
     f2e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f32:	48 81       	ld	r20, Y
     f34:	59 81       	ldd	r21, Y+1	; 0x01
     f36:	28 a1       	ldd	r18, Y+32	; 0x20
     f38:	30 e0       	ldi	r19, 0x00	; 0
     f3a:	7f 8d       	ldd	r23, Y+31	; 0x1f
     f3c:	72 9f       	mul	r23, r18
     f3e:	c0 01       	movw	r24, r0
     f40:	73 9f       	mul	r23, r19
     f42:	90 0d       	add	r25, r0
     f44:	11 24       	eor	r1, r1
     f46:	fa 01       	movw	r30, r20
     f48:	e8 0f       	add	r30, r24
     f4a:	f9 1f       	adc	r31, r25
     f4c:	ea 83       	std	Y+2, r30	; 0x02
     f4e:	fb 83       	std	Y+3, r31	; 0x03
     f50:	1e 8e       	std	Y+30, r1	; 0x1e
     f52:	4c 83       	std	Y+4, r20	; 0x04
     f54:	5d 83       	std	Y+5, r21	; 0x05
     f56:	82 1b       	sub	r24, r18
     f58:	93 0b       	sbc	r25, r19
     f5a:	84 0f       	add	r24, r20
     f5c:	95 1f       	adc	r25, r21
     f5e:	8e 83       	std	Y+6, r24	; 0x06
     f60:	9f 83       	std	Y+7, r25	; 0x07
     f62:	8f ef       	ldi	r24, 0xFF	; 255
     f64:	89 a3       	std	Y+33, r24	; 0x21
     f66:	8a a3       	std	Y+34, r24	; 0x22
     f68:	61 11       	cpse	r22, r1
     f6a:	0c c0       	rjmp	.+24     	; 0xf84 <xQueueGenericReset+0x64>
     f6c:	88 85       	ldd	r24, Y+8	; 0x08
     f6e:	88 23       	and	r24, r24
     f70:	89 f0       	breq	.+34     	; 0xf94 <xQueueGenericReset+0x74>
     f72:	ce 01       	movw	r24, r28
     f74:	08 96       	adiw	r24, 0x08	; 8
     f76:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <xTaskRemoveFromEventList>
     f7a:	88 23       	and	r24, r24
     f7c:	59 f0       	breq	.+22     	; 0xf94 <xQueueGenericReset+0x74>
     f7e:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
     f82:	08 c0       	rjmp	.+16     	; 0xf94 <xQueueGenericReset+0x74>
     f84:	ce 01       	movw	r24, r28
     f86:	08 96       	adiw	r24, 0x08	; 8
     f88:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
     f8c:	ce 01       	movw	r24, r28
     f8e:	43 96       	adiw	r24, 0x13	; 19
     f90:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
     f94:	ff 91       	pop	r31
     f96:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     f9a:	81 e0       	ldi	r24, 0x01	; 1
     f9c:	df 91       	pop	r29
     f9e:	cf 91       	pop	r28
     fa0:	08 95       	ret

00000fa2 <xQueueGenericCreate>:
     fa2:	ff 92       	push	r15
     fa4:	0f 93       	push	r16
     fa6:	1f 93       	push	r17
     fa8:	cf 93       	push	r28
     faa:	df 93       	push	r29
     fac:	08 2f       	mov	r16, r24
     fae:	16 2f       	mov	r17, r22
     fb0:	f4 2e       	mov	r15, r20
     fb2:	66 23       	and	r22, r22
     fb4:	c9 f0       	breq	.+50     	; 0xfe8 <xQueueGenericCreate+0x46>
     fb6:	86 9f       	mul	r24, r22
     fb8:	c0 01       	movw	r24, r0
     fba:	11 24       	eor	r1, r1
     fbc:	85 96       	adiw	r24, 0x25	; 37
     fbe:	0e 94 47 04 	call	0x88e	; 0x88e <pvPortMalloc>
     fc2:	ec 01       	movw	r28, r24
     fc4:	00 97       	sbiw	r24, 0x00	; 0
     fc6:	49 f4       	brne	.+18     	; 0xfda <xQueueGenericCreate+0x38>
     fc8:	16 c0       	rjmp	.+44     	; 0xff6 <xQueueGenericCreate+0x54>
     fca:	0f 8f       	std	Y+31, r16	; 0x1f
     fcc:	18 a3       	std	Y+32, r17	; 0x20
     fce:	61 e0       	ldi	r22, 0x01	; 1
     fd0:	ce 01       	movw	r24, r28
     fd2:	0e 94 90 07 	call	0xf20	; 0xf20 <xQueueGenericReset>
     fd6:	fc a2       	std	Y+36, r15	; 0x24
     fd8:	0e c0       	rjmp	.+28     	; 0xff6 <xQueueGenericCreate+0x54>
     fda:	85 96       	adiw	r24, 0x25	; 37
     fdc:	88 83       	st	Y, r24
     fde:	99 83       	std	Y+1, r25	; 0x01
     fe0:	f4 cf       	rjmp	.-24     	; 0xfca <xQueueGenericCreate+0x28>
     fe2:	c8 83       	st	Y, r28
     fe4:	d9 83       	std	Y+1, r29	; 0x01
     fe6:	f1 cf       	rjmp	.-30     	; 0xfca <xQueueGenericCreate+0x28>
     fe8:	85 e2       	ldi	r24, 0x25	; 37
     fea:	90 e0       	ldi	r25, 0x00	; 0
     fec:	0e 94 47 04 	call	0x88e	; 0x88e <pvPortMalloc>
     ff0:	ec 01       	movw	r28, r24
     ff2:	89 2b       	or	r24, r25
     ff4:	b1 f7       	brne	.-20     	; 0xfe2 <xQueueGenericCreate+0x40>
     ff6:	ce 01       	movw	r24, r28
     ff8:	df 91       	pop	r29
     ffa:	cf 91       	pop	r28
     ffc:	1f 91       	pop	r17
     ffe:	0f 91       	pop	r16
    1000:	ff 90       	pop	r15
    1002:	08 95       	ret

00001004 <xQueueGenericSend>:
    1004:	af 92       	push	r10
    1006:	bf 92       	push	r11
    1008:	cf 92       	push	r12
    100a:	df 92       	push	r13
    100c:	ef 92       	push	r14
    100e:	ff 92       	push	r15
    1010:	0f 93       	push	r16
    1012:	1f 93       	push	r17
    1014:	cf 93       	push	r28
    1016:	df 93       	push	r29
    1018:	cd b7       	in	r28, 0x3d	; 61
    101a:	de b7       	in	r29, 0x3e	; 62
    101c:	29 97       	sbiw	r28, 0x09	; 9
    101e:	cd bf       	out	0x3d, r28	; 61
    1020:	de bf       	out	0x3e, r29	; 62
    1022:	7c 01       	movw	r14, r24
    1024:	5b 01       	movw	r10, r22
    1026:	2e 83       	std	Y+6, r18	; 0x06
    1028:	3f 83       	std	Y+7, r19	; 0x07
    102a:	48 87       	std	Y+8, r20	; 0x08
    102c:	59 87       	std	Y+9, r21	; 0x09
    102e:	10 e0       	ldi	r17, 0x00	; 0
    1030:	6c 01       	movw	r12, r24
    1032:	88 e0       	ldi	r24, 0x08	; 8
    1034:	c8 0e       	add	r12, r24
    1036:	d1 1c       	adc	r13, r1
    1038:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    103c:	ff 93       	push	r31
    103e:	f8 7f       	andi	r31, 0xF8	; 248
    1040:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1044:	f7 01       	movw	r30, r14
    1046:	96 8d       	ldd	r25, Z+30	; 0x1e
    1048:	87 8d       	ldd	r24, Z+31	; 0x1f
    104a:	98 17       	cp	r25, r24
    104c:	10 f0       	brcs	.+4      	; 0x1052 <xQueueGenericSend+0x4e>
    104e:	02 30       	cpi	r16, 0x02	; 2
    1050:	d1 f4       	brne	.+52     	; 0x1086 <xQueueGenericSend+0x82>
    1052:	40 2f       	mov	r20, r16
    1054:	b5 01       	movw	r22, r10
    1056:	c7 01       	movw	r24, r14
    1058:	0e 94 d7 06 	call	0xdae	; 0xdae <prvCopyDataToQueue>
    105c:	f7 01       	movw	r30, r14
    105e:	93 89       	ldd	r25, Z+19	; 0x13
    1060:	99 23       	and	r25, r25
    1062:	49 f0       	breq	.+18     	; 0x1076 <xQueueGenericSend+0x72>
    1064:	c7 01       	movw	r24, r14
    1066:	43 96       	adiw	r24, 0x13	; 19
    1068:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <xTaskRemoveFromEventList>
    106c:	88 23       	and	r24, r24
    106e:	31 f0       	breq	.+12     	; 0x107c <xQueueGenericSend+0x78>
    1070:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
    1074:	03 c0       	rjmp	.+6      	; 0x107c <xQueueGenericSend+0x78>
    1076:	81 11       	cpse	r24, r1
    1078:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
    107c:	ff 91       	pop	r31
    107e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1082:	81 e0       	ldi	r24, 0x01	; 1
    1084:	57 c0       	rjmp	.+174    	; 0x1134 <xQueueGenericSend+0x130>
    1086:	8e 81       	ldd	r24, Y+6	; 0x06
    1088:	9f 81       	ldd	r25, Y+7	; 0x07
    108a:	a8 85       	ldd	r26, Y+8	; 0x08
    108c:	b9 85       	ldd	r27, Y+9	; 0x09
    108e:	89 2b       	or	r24, r25
    1090:	8a 2b       	or	r24, r26
    1092:	8b 2b       	or	r24, r27
    1094:	29 f4       	brne	.+10     	; 0x10a0 <xQueueGenericSend+0x9c>
    1096:	ff 91       	pop	r31
    1098:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    109c:	80 e0       	ldi	r24, 0x00	; 0
    109e:	4a c0       	rjmp	.+148    	; 0x1134 <xQueueGenericSend+0x130>
    10a0:	11 11       	cpse	r17, r1
    10a2:	05 c0       	rjmp	.+10     	; 0x10ae <xQueueGenericSend+0xaa>
    10a4:	ce 01       	movw	r24, r28
    10a6:	01 96       	adiw	r24, 0x01	; 1
    10a8:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <vTaskInternalSetTimeOutState>
    10ac:	11 e0       	ldi	r17, 0x01	; 1
    10ae:	ff 91       	pop	r31
    10b0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10b4:	0e 94 bb 0b 	call	0x1776	; 0x1776 <vTaskSuspendAll>
    10b8:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10bc:	ff 93       	push	r31
    10be:	f8 7f       	andi	r31, 0xF8	; 248
    10c0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10c4:	f7 01       	movw	r30, r14
    10c6:	81 a1       	ldd	r24, Z+33	; 0x21
    10c8:	8f 3f       	cpi	r24, 0xFF	; 255
    10ca:	09 f4       	brne	.+2      	; 0x10ce <xQueueGenericSend+0xca>
    10cc:	11 a2       	std	Z+33, r1	; 0x21
    10ce:	f7 01       	movw	r30, r14
    10d0:	82 a1       	ldd	r24, Z+34	; 0x22
    10d2:	8f 3f       	cpi	r24, 0xFF	; 255
    10d4:	09 f4       	brne	.+2      	; 0x10d8 <xQueueGenericSend+0xd4>
    10d6:	12 a2       	std	Z+34, r1	; 0x22
    10d8:	ff 91       	pop	r31
    10da:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    10de:	be 01       	movw	r22, r28
    10e0:	6a 5f       	subi	r22, 0xFA	; 250
    10e2:	7f 4f       	sbci	r23, 0xFF	; 255
    10e4:	ce 01       	movw	r24, r28
    10e6:	01 96       	adiw	r24, 0x01	; 1
    10e8:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xTaskCheckForTimeOut>
    10ec:	81 11       	cpse	r24, r1
    10ee:	1c c0       	rjmp	.+56     	; 0x1128 <xQueueGenericSend+0x124>
    10f0:	c7 01       	movw	r24, r14
    10f2:	0e 94 c4 06 	call	0xd88	; 0xd88 <prvIsQueueFull>
    10f6:	88 23       	and	r24, r24
    10f8:	89 f0       	breq	.+34     	; 0x111c <xQueueGenericSend+0x118>
    10fa:	4e 81       	ldd	r20, Y+6	; 0x06
    10fc:	5f 81       	ldd	r21, Y+7	; 0x07
    10fe:	68 85       	ldd	r22, Y+8	; 0x08
    1100:	79 85       	ldd	r23, Y+9	; 0x09
    1102:	c6 01       	movw	r24, r12
    1104:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vTaskPlaceOnEventList>
    1108:	c7 01       	movw	r24, r14
    110a:	0e 94 3a 07 	call	0xe74	; 0xe74 <prvUnlockQueue>
    110e:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
    1112:	81 11       	cpse	r24, r1
    1114:	91 cf       	rjmp	.-222    	; 0x1038 <xQueueGenericSend+0x34>
    1116:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
    111a:	8e cf       	rjmp	.-228    	; 0x1038 <xQueueGenericSend+0x34>
    111c:	c7 01       	movw	r24, r14
    111e:	0e 94 3a 07 	call	0xe74	; 0xe74 <prvUnlockQueue>
    1122:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
    1126:	88 cf       	rjmp	.-240    	; 0x1038 <xQueueGenericSend+0x34>
    1128:	c7 01       	movw	r24, r14
    112a:	0e 94 3a 07 	call	0xe74	; 0xe74 <prvUnlockQueue>
    112e:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
    1132:	80 e0       	ldi	r24, 0x00	; 0
    1134:	29 96       	adiw	r28, 0x09	; 9
    1136:	cd bf       	out	0x3d, r28	; 61
    1138:	de bf       	out	0x3e, r29	; 62
    113a:	df 91       	pop	r29
    113c:	cf 91       	pop	r28
    113e:	1f 91       	pop	r17
    1140:	0f 91       	pop	r16
    1142:	ff 90       	pop	r15
    1144:	ef 90       	pop	r14
    1146:	df 90       	pop	r13
    1148:	cf 90       	pop	r12
    114a:	bf 90       	pop	r11
    114c:	af 90       	pop	r10
    114e:	08 95       	ret

00001150 <xQueueGenericSendFromISR>:
    1150:	af 92       	push	r10
    1152:	bf 92       	push	r11
    1154:	cf 92       	push	r12
    1156:	df 92       	push	r13
    1158:	ff 92       	push	r15
    115a:	0f 93       	push	r16
    115c:	1f 93       	push	r17
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
    1162:	ec 01       	movw	r28, r24
    1164:	6b 01       	movw	r12, r22
    1166:	5a 01       	movw	r10, r20
    1168:	02 2f       	mov	r16, r18
    116a:	0e 94 08 05 	call	0xa10	; 0xa10 <_portSetInterruptMaskFromIsr>
    116e:	f8 2e       	mov	r15, r24
    1170:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1172:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1174:	98 17       	cp	r25, r24
    1176:	10 f0       	brcs	.+4      	; 0x117c <xQueueGenericSendFromISR+0x2c>
    1178:	02 30       	cpi	r16, 0x02	; 2
    117a:	e1 f4       	brne	.+56     	; 0x11b4 <xQueueGenericSendFromISR+0x64>
    117c:	1a a1       	ldd	r17, Y+34	; 0x22
    117e:	40 2f       	mov	r20, r16
    1180:	b6 01       	movw	r22, r12
    1182:	ce 01       	movw	r24, r28
    1184:	0e 94 d7 06 	call	0xdae	; 0xdae <prvCopyDataToQueue>
    1188:	1f 3f       	cpi	r17, 0xFF	; 255
    118a:	81 f4       	brne	.+32     	; 0x11ac <xQueueGenericSendFromISR+0x5c>
    118c:	8b 89       	ldd	r24, Y+19	; 0x13
    118e:	88 23       	and	r24, r24
    1190:	99 f0       	breq	.+38     	; 0x11b8 <xQueueGenericSendFromISR+0x68>
    1192:	ce 01       	movw	r24, r28
    1194:	43 96       	adiw	r24, 0x13	; 19
    1196:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <xTaskRemoveFromEventList>
    119a:	88 23       	and	r24, r24
    119c:	79 f0       	breq	.+30     	; 0x11bc <xQueueGenericSendFromISR+0x6c>
    119e:	a1 14       	cp	r10, r1
    11a0:	b1 04       	cpc	r11, r1
    11a2:	71 f0       	breq	.+28     	; 0x11c0 <xQueueGenericSendFromISR+0x70>
    11a4:	81 e0       	ldi	r24, 0x01	; 1
    11a6:	f5 01       	movw	r30, r10
    11a8:	80 83       	st	Z, r24
    11aa:	0b c0       	rjmp	.+22     	; 0x11c2 <xQueueGenericSendFromISR+0x72>
    11ac:	1f 5f       	subi	r17, 0xFF	; 255
    11ae:	1a a3       	std	Y+34, r17	; 0x22
    11b0:	81 e0       	ldi	r24, 0x01	; 1
    11b2:	07 c0       	rjmp	.+14     	; 0x11c2 <xQueueGenericSendFromISR+0x72>
    11b4:	80 e0       	ldi	r24, 0x00	; 0
    11b6:	05 c0       	rjmp	.+10     	; 0x11c2 <xQueueGenericSendFromISR+0x72>
    11b8:	81 e0       	ldi	r24, 0x01	; 1
    11ba:	03 c0       	rjmp	.+6      	; 0x11c2 <xQueueGenericSendFromISR+0x72>
    11bc:	81 e0       	ldi	r24, 0x01	; 1
    11be:	01 c0       	rjmp	.+2      	; 0x11c2 <xQueueGenericSendFromISR+0x72>
    11c0:	81 e0       	ldi	r24, 0x01	; 1
    11c2:	f0 92 a2 00 	sts	0x00A2, r15	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    11c6:	df 91       	pop	r29
    11c8:	cf 91       	pop	r28
    11ca:	1f 91       	pop	r17
    11cc:	0f 91       	pop	r16
    11ce:	ff 90       	pop	r15
    11d0:	df 90       	pop	r13
    11d2:	cf 90       	pop	r12
    11d4:	bf 90       	pop	r11
    11d6:	af 90       	pop	r10
    11d8:	08 95       	ret

000011da <xQueueReceive>:
    11da:	af 92       	push	r10
    11dc:	bf 92       	push	r11
    11de:	cf 92       	push	r12
    11e0:	df 92       	push	r13
    11e2:	ef 92       	push	r14
    11e4:	ff 92       	push	r15
    11e6:	0f 93       	push	r16
    11e8:	1f 93       	push	r17
    11ea:	cf 93       	push	r28
    11ec:	df 93       	push	r29
    11ee:	cd b7       	in	r28, 0x3d	; 61
    11f0:	de b7       	in	r29, 0x3e	; 62
    11f2:	29 97       	sbiw	r28, 0x09	; 9
    11f4:	cd bf       	out	0x3d, r28	; 61
    11f6:	de bf       	out	0x3e, r29	; 62
    11f8:	8c 01       	movw	r16, r24
    11fa:	5b 01       	movw	r10, r22
    11fc:	2e 83       	std	Y+6, r18	; 0x06
    11fe:	3f 83       	std	Y+7, r19	; 0x07
    1200:	48 87       	std	Y+8, r20	; 0x08
    1202:	59 87       	std	Y+9, r21	; 0x09
    1204:	e1 2c       	mov	r14, r1
    1206:	6c 01       	movw	r12, r24
    1208:	83 e1       	ldi	r24, 0x13	; 19
    120a:	c8 0e       	add	r12, r24
    120c:	d1 1c       	adc	r13, r1
    120e:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1212:	ff 93       	push	r31
    1214:	f8 7f       	andi	r31, 0xF8	; 248
    1216:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    121a:	f8 01       	movw	r30, r16
    121c:	f6 8c       	ldd	r15, Z+30	; 0x1e
    121e:	ff 20       	and	r15, r15
    1220:	b1 f0       	breq	.+44     	; 0x124e <xQueueReceive+0x74>
    1222:	b5 01       	movw	r22, r10
    1224:	c8 01       	movw	r24, r16
    1226:	0e 94 20 07 	call	0xe40	; 0xe40 <prvCopyDataFromQueue>
    122a:	fa 94       	dec	r15
    122c:	f8 01       	movw	r30, r16
    122e:	f6 8e       	std	Z+30, r15	; 0x1e
    1230:	80 85       	ldd	r24, Z+8	; 0x08
    1232:	88 23       	and	r24, r24
    1234:	39 f0       	breq	.+14     	; 0x1244 <xQueueReceive+0x6a>
    1236:	c8 01       	movw	r24, r16
    1238:	08 96       	adiw	r24, 0x08	; 8
    123a:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <xTaskRemoveFromEventList>
    123e:	81 11       	cpse	r24, r1
    1240:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
    1244:	ff 91       	pop	r31
    1246:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    124a:	81 e0       	ldi	r24, 0x01	; 1
    124c:	5e c0       	rjmp	.+188    	; 0x130a <xQueueReceive+0x130>
    124e:	8e 81       	ldd	r24, Y+6	; 0x06
    1250:	9f 81       	ldd	r25, Y+7	; 0x07
    1252:	a8 85       	ldd	r26, Y+8	; 0x08
    1254:	b9 85       	ldd	r27, Y+9	; 0x09
    1256:	89 2b       	or	r24, r25
    1258:	8a 2b       	or	r24, r26
    125a:	8b 2b       	or	r24, r27
    125c:	29 f4       	brne	.+10     	; 0x1268 <xQueueReceive+0x8e>
    125e:	ff 91       	pop	r31
    1260:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1264:	80 e0       	ldi	r24, 0x00	; 0
    1266:	51 c0       	rjmp	.+162    	; 0x130a <xQueueReceive+0x130>
    1268:	e1 10       	cpse	r14, r1
    126a:	06 c0       	rjmp	.+12     	; 0x1278 <xQueueReceive+0x9e>
    126c:	ce 01       	movw	r24, r28
    126e:	01 96       	adiw	r24, 0x01	; 1
    1270:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <vTaskInternalSetTimeOutState>
    1274:	ee 24       	eor	r14, r14
    1276:	e3 94       	inc	r14
    1278:	ff 91       	pop	r31
    127a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    127e:	0e 94 bb 0b 	call	0x1776	; 0x1776 <vTaskSuspendAll>
    1282:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1286:	ff 93       	push	r31
    1288:	f8 7f       	andi	r31, 0xF8	; 248
    128a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    128e:	f8 01       	movw	r30, r16
    1290:	81 a1       	ldd	r24, Z+33	; 0x21
    1292:	8f 3f       	cpi	r24, 0xFF	; 255
    1294:	09 f4       	brne	.+2      	; 0x1298 <xQueueReceive+0xbe>
    1296:	11 a2       	std	Z+33, r1	; 0x21
    1298:	f8 01       	movw	r30, r16
    129a:	82 a1       	ldd	r24, Z+34	; 0x22
    129c:	8f 3f       	cpi	r24, 0xFF	; 255
    129e:	09 f4       	brne	.+2      	; 0x12a2 <xQueueReceive+0xc8>
    12a0:	12 a2       	std	Z+34, r1	; 0x22
    12a2:	ff 91       	pop	r31
    12a4:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    12a8:	be 01       	movw	r22, r28
    12aa:	6a 5f       	subi	r22, 0xFA	; 250
    12ac:	7f 4f       	sbci	r23, 0xFF	; 255
    12ae:	ce 01       	movw	r24, r28
    12b0:	01 96       	adiw	r24, 0x01	; 1
    12b2:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xTaskCheckForTimeOut>
    12b6:	81 11       	cpse	r24, r1
    12b8:	1c c0       	rjmp	.+56     	; 0x12f2 <xQueueReceive+0x118>
    12ba:	c8 01       	movw	r24, r16
    12bc:	0e 94 b5 06 	call	0xd6a	; 0xd6a <prvIsQueueEmpty>
    12c0:	88 23       	and	r24, r24
    12c2:	89 f0       	breq	.+34     	; 0x12e6 <xQueueReceive+0x10c>
    12c4:	4e 81       	ldd	r20, Y+6	; 0x06
    12c6:	5f 81       	ldd	r21, Y+7	; 0x07
    12c8:	68 85       	ldd	r22, Y+8	; 0x08
    12ca:	79 85       	ldd	r23, Y+9	; 0x09
    12cc:	c6 01       	movw	r24, r12
    12ce:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vTaskPlaceOnEventList>
    12d2:	c8 01       	movw	r24, r16
    12d4:	0e 94 3a 07 	call	0xe74	; 0xe74 <prvUnlockQueue>
    12d8:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
    12dc:	81 11       	cpse	r24, r1
    12de:	97 cf       	rjmp	.-210    	; 0x120e <xQueueReceive+0x34>
    12e0:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
    12e4:	94 cf       	rjmp	.-216    	; 0x120e <xQueueReceive+0x34>
    12e6:	c8 01       	movw	r24, r16
    12e8:	0e 94 3a 07 	call	0xe74	; 0xe74 <prvUnlockQueue>
    12ec:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
    12f0:	8e cf       	rjmp	.-228    	; 0x120e <xQueueReceive+0x34>
    12f2:	c8 01       	movw	r24, r16
    12f4:	0e 94 3a 07 	call	0xe74	; 0xe74 <prvUnlockQueue>
    12f8:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
    12fc:	c8 01       	movw	r24, r16
    12fe:	0e 94 b5 06 	call	0xd6a	; 0xd6a <prvIsQueueEmpty>
    1302:	88 23       	and	r24, r24
    1304:	09 f4       	brne	.+2      	; 0x1308 <xQueueReceive+0x12e>
    1306:	83 cf       	rjmp	.-250    	; 0x120e <xQueueReceive+0x34>
    1308:	80 e0       	ldi	r24, 0x00	; 0
    130a:	29 96       	adiw	r28, 0x09	; 9
    130c:	cd bf       	out	0x3d, r28	; 61
    130e:	de bf       	out	0x3e, r29	; 62
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	1f 91       	pop	r17
    1316:	0f 91       	pop	r16
    1318:	ff 90       	pop	r15
    131a:	ef 90       	pop	r14
    131c:	df 90       	pop	r13
    131e:	cf 90       	pop	r12
    1320:	bf 90       	pop	r11
    1322:	af 90       	pop	r10
    1324:	08 95       	ret

00001326 <uxQueueMessagesWaiting>:
    1326:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    132a:	ff 93       	push	r31
    132c:	f8 7f       	andi	r31, 0xF8	; 248
    132e:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1332:	fc 01       	movw	r30, r24
    1334:	86 8d       	ldd	r24, Z+30	; 0x1e
    1336:	ff 91       	pop	r31
    1338:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    133c:	08 95       	ret

0000133e <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1344:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1348:	ff 93       	push	r31
    134a:	f8 7f       	andi	r31, 0xF8	; 248
    134c:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1350:	89 a1       	ldd	r24, Y+33	; 0x21
    1352:	8f 3f       	cpi	r24, 0xFF	; 255
    1354:	09 f4       	brne	.+2      	; 0x1358 <vQueueWaitForMessageRestricted+0x1a>
    1356:	19 a2       	std	Y+33, r1	; 0x21
    1358:	8a a1       	ldd	r24, Y+34	; 0x22
    135a:	8f 3f       	cpi	r24, 0xFF	; 255
    135c:	09 f4       	brne	.+2      	; 0x1360 <vQueueWaitForMessageRestricted+0x22>
    135e:	1a a2       	std	Y+34, r1	; 0x22
    1360:	ff 91       	pop	r31
    1362:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1366:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1368:	81 11       	cpse	r24, r1
    136a:	04 c0       	rjmp	.+8      	; 0x1374 <vQueueWaitForMessageRestricted+0x36>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    136c:	ce 01       	movw	r24, r28
    136e:	43 96       	adiw	r24, 0x13	; 19
    1370:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1374:	ce 01       	movw	r24, r28
    1376:	0e 94 3a 07 	call	0xe74	; 0xe74 <prvUnlockQueue>
	}
    137a:	df 91       	pop	r29
    137c:	cf 91       	pop	r28
    137e:	08 95       	ret

00001380 <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
    1380:	e0 91 82 2c 	lds	r30, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    1384:	f0 91 83 2c 	lds	r31, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    1388:	80 81       	ld	r24, Z
    138a:	81 11       	cpse	r24, r1
    138c:	0c c0       	rjmp	.+24     	; 0x13a6 <prvResetNextTaskUnblockTime+0x26>
    138e:	8f ef       	ldi	r24, 0xFF	; 255
    1390:	9f ef       	ldi	r25, 0xFF	; 255
    1392:	dc 01       	movw	r26, r24
    1394:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <xNextTaskUnblockTime>
    1398:	90 93 5c 2c 	sts	0x2C5C, r25	; 0x802c5c <xNextTaskUnblockTime+0x1>
    139c:	a0 93 5d 2c 	sts	0x2C5D, r26	; 0x802c5d <xNextTaskUnblockTime+0x2>
    13a0:	b0 93 5e 2c 	sts	0x2C5E, r27	; 0x802c5e <xNextTaskUnblockTime+0x3>
    13a4:	08 95       	ret
    13a6:	e0 91 82 2c 	lds	r30, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    13aa:	f0 91 83 2c 	lds	r31, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    13ae:	07 80       	ldd	r0, Z+7	; 0x07
    13b0:	f0 85       	ldd	r31, Z+8	; 0x08
    13b2:	e0 2d       	mov	r30, r0
    13b4:	00 84       	ldd	r0, Z+8	; 0x08
    13b6:	f1 85       	ldd	r31, Z+9	; 0x09
    13b8:	e0 2d       	mov	r30, r0
    13ba:	82 81       	ldd	r24, Z+2	; 0x02
    13bc:	93 81       	ldd	r25, Z+3	; 0x03
    13be:	a4 81       	ldd	r26, Z+4	; 0x04
    13c0:	b5 81       	ldd	r27, Z+5	; 0x05
    13c2:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <xNextTaskUnblockTime>
    13c6:	90 93 5c 2c 	sts	0x2C5C, r25	; 0x802c5c <xNextTaskUnblockTime+0x1>
    13ca:	a0 93 5d 2c 	sts	0x2C5D, r26	; 0x802c5d <xNextTaskUnblockTime+0x2>
    13ce:	b0 93 5e 2c 	sts	0x2C5E, r27	; 0x802c5e <xNextTaskUnblockTime+0x3>
    13d2:	08 95       	ret

000013d4 <prvAddCurrentTaskToDelayedList>:
    13d4:	8f 92       	push	r8
    13d6:	9f 92       	push	r9
    13d8:	af 92       	push	r10
    13da:	bf 92       	push	r11
    13dc:	cf 92       	push	r12
    13de:	df 92       	push	r13
    13e0:	ef 92       	push	r14
    13e2:	ff 92       	push	r15
    13e4:	cf 93       	push	r28
    13e6:	6b 01       	movw	r12, r22
    13e8:	7c 01       	movw	r14, r24
    13ea:	c4 2f       	mov	r28, r20
    13ec:	80 90 65 2c 	lds	r8, 0x2C65	; 0x802c65 <xTickCount>
    13f0:	90 90 66 2c 	lds	r9, 0x2C66	; 0x802c66 <xTickCount+0x1>
    13f4:	a0 90 67 2c 	lds	r10, 0x2C67	; 0x802c67 <xTickCount+0x2>
    13f8:	b0 90 68 2c 	lds	r11, 0x2C68	; 0x802c68 <xTickCount+0x3>
    13fc:	80 91 c6 2c 	lds	r24, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1400:	90 91 c7 2c 	lds	r25, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1404:	02 96       	adiw	r24, 0x02	; 2
    1406:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    140a:	8f ef       	ldi	r24, 0xFF	; 255
    140c:	c8 16       	cp	r12, r24
    140e:	d8 06       	cpc	r13, r24
    1410:	e8 06       	cpc	r14, r24
    1412:	f8 06       	cpc	r15, r24
    1414:	69 f4       	brne	.+26     	; 0x1430 <prvAddCurrentTaskToDelayedList+0x5c>
    1416:	cc 23       	and	r28, r28
    1418:	59 f0       	breq	.+22     	; 0x1430 <prvAddCurrentTaskToDelayedList+0x5c>
    141a:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    141e:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1422:	6e 5f       	subi	r22, 0xFE	; 254
    1424:	7f 4f       	sbci	r23, 0xFF	; 255
    1426:	8a e6       	ldi	r24, 0x6A	; 106
    1428:	9c e2       	ldi	r25, 0x2C	; 44
    142a:	0e 94 83 04 	call	0x906	; 0x906 <vListInsertEnd>
    142e:	3f c0       	rjmp	.+126    	; 0x14ae <prvAddCurrentTaskToDelayedList+0xda>
    1430:	c8 0c       	add	r12, r8
    1432:	d9 1c       	adc	r13, r9
    1434:	ea 1c       	adc	r14, r10
    1436:	fb 1c       	adc	r15, r11
    1438:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    143c:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1440:	c2 82       	std	Z+2, r12	; 0x02
    1442:	d3 82       	std	Z+3, r13	; 0x03
    1444:	e4 82       	std	Z+4, r14	; 0x04
    1446:	f5 82       	std	Z+5, r15	; 0x05
    1448:	c8 14       	cp	r12, r8
    144a:	d9 04       	cpc	r13, r9
    144c:	ea 04       	cpc	r14, r10
    144e:	fb 04       	cpc	r15, r11
    1450:	68 f4       	brcc	.+26     	; 0x146c <prvAddCurrentTaskToDelayedList+0x98>
    1452:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1456:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    145a:	80 91 80 2c 	lds	r24, 0x2C80	; 0x802c80 <pxOverflowDelayedTaskList>
    145e:	90 91 81 2c 	lds	r25, 0x2C81	; 0x802c81 <pxOverflowDelayedTaskList+0x1>
    1462:	6e 5f       	subi	r22, 0xFE	; 254
    1464:	7f 4f       	sbci	r23, 0xFF	; 255
    1466:	0e 94 a4 04 	call	0x948	; 0x948 <vListInsert>
    146a:	21 c0       	rjmp	.+66     	; 0x14ae <prvAddCurrentTaskToDelayedList+0xda>
    146c:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1470:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1474:	80 91 82 2c 	lds	r24, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    1478:	90 91 83 2c 	lds	r25, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    147c:	6e 5f       	subi	r22, 0xFE	; 254
    147e:	7f 4f       	sbci	r23, 0xFF	; 255
    1480:	0e 94 a4 04 	call	0x948	; 0x948 <vListInsert>
    1484:	80 91 5b 2c 	lds	r24, 0x2C5B	; 0x802c5b <xNextTaskUnblockTime>
    1488:	90 91 5c 2c 	lds	r25, 0x2C5C	; 0x802c5c <xNextTaskUnblockTime+0x1>
    148c:	a0 91 5d 2c 	lds	r26, 0x2C5D	; 0x802c5d <xNextTaskUnblockTime+0x2>
    1490:	b0 91 5e 2c 	lds	r27, 0x2C5E	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1494:	c8 16       	cp	r12, r24
    1496:	d9 06       	cpc	r13, r25
    1498:	ea 06       	cpc	r14, r26
    149a:	fb 06       	cpc	r15, r27
    149c:	40 f4       	brcc	.+16     	; 0x14ae <prvAddCurrentTaskToDelayedList+0xda>
    149e:	c0 92 5b 2c 	sts	0x2C5B, r12	; 0x802c5b <xNextTaskUnblockTime>
    14a2:	d0 92 5c 2c 	sts	0x2C5C, r13	; 0x802c5c <xNextTaskUnblockTime+0x1>
    14a6:	e0 92 5d 2c 	sts	0x2C5D, r14	; 0x802c5d <xNextTaskUnblockTime+0x2>
    14aa:	f0 92 5e 2c 	sts	0x2C5E, r15	; 0x802c5e <xNextTaskUnblockTime+0x3>
    14ae:	cf 91       	pop	r28
    14b0:	ff 90       	pop	r15
    14b2:	ef 90       	pop	r14
    14b4:	df 90       	pop	r13
    14b6:	cf 90       	pop	r12
    14b8:	bf 90       	pop	r11
    14ba:	af 90       	pop	r10
    14bc:	9f 90       	pop	r9
    14be:	8f 90       	pop	r8
    14c0:	08 95       	ret

000014c2 <prvIdleTask>:
    14c2:	ca e9       	ldi	r28, 0x9A	; 154
    14c4:	dc e2       	ldi	r29, 0x2C	; 44
    14c6:	88 81       	ld	r24, Y
    14c8:	82 30       	cpi	r24, 0x02	; 2
    14ca:	10 f0       	brcs	.+4      	; 0x14d0 <prvIdleTask+0xe>
    14cc:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
    14d0:	0e 94 91 15 	call	0x2b22	; 0x2b22 <vApplicationIdleHook>
    14d4:	f8 cf       	rjmp	.-16     	; 0x14c6 <prvIdleTask+0x4>

000014d6 <xTaskCreate>:
    14d6:	4f 92       	push	r4
    14d8:	5f 92       	push	r5
    14da:	6f 92       	push	r6
    14dc:	7f 92       	push	r7
    14de:	8f 92       	push	r8
    14e0:	9f 92       	push	r9
    14e2:	af 92       	push	r10
    14e4:	bf 92       	push	r11
    14e6:	cf 92       	push	r12
    14e8:	df 92       	push	r13
    14ea:	ef 92       	push	r14
    14ec:	ff 92       	push	r15
    14ee:	0f 93       	push	r16
    14f0:	cf 93       	push	r28
    14f2:	df 93       	push	r29
    14f4:	4c 01       	movw	r8, r24
    14f6:	6b 01       	movw	r12, r22
    14f8:	5a 01       	movw	r10, r20
    14fa:	29 01       	movw	r4, r18
    14fc:	ca 01       	movw	r24, r20
    14fe:	0e 94 47 04 	call	0x88e	; 0x88e <pvPortMalloc>
    1502:	3c 01       	movw	r6, r24
    1504:	89 2b       	or	r24, r25
    1506:	09 f4       	brne	.+2      	; 0x150a <xTaskCreate+0x34>
    1508:	ea c0       	rjmp	.+468    	; 0x16de <xTaskCreate+0x208>
    150a:	8c e2       	ldi	r24, 0x2C	; 44
    150c:	90 e0       	ldi	r25, 0x00	; 0
    150e:	0e 94 47 04 	call	0x88e	; 0x88e <pvPortMalloc>
    1512:	ec 01       	movw	r28, r24
    1514:	89 2b       	or	r24, r25
    1516:	b1 f0       	breq	.+44     	; 0x1544 <xTaskCreate+0x6e>
    1518:	6b 8e       	std	Y+27, r6	; 0x1b
    151a:	7c 8e       	std	Y+28, r7	; 0x1c
    151c:	a5 01       	movw	r20, r10
    151e:	65 ea       	ldi	r22, 0xA5	; 165
    1520:	70 e0       	ldi	r23, 0x00	; 0
    1522:	c3 01       	movw	r24, r6
    1524:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <memset>
    1528:	21 e0       	ldi	r18, 0x01	; 1
    152a:	a2 1a       	sub	r10, r18
    152c:	b1 08       	sbc	r11, r1
    152e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1530:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1532:	a8 0e       	add	r10, r24
    1534:	b9 1e       	adc	r11, r25
    1536:	d6 01       	movw	r26, r12
    1538:	8c 91       	ld	r24, X
    153a:	8d 8f       	std	Y+29, r24	; 0x1d
    153c:	8c 91       	ld	r24, X
    153e:	81 11       	cpse	r24, r1
    1540:	05 c0       	rjmp	.+10     	; 0x154c <xTaskCreate+0x76>
    1542:	18 c0       	rjmp	.+48     	; 0x1574 <xTaskCreate+0x9e>
    1544:	c3 01       	movw	r24, r6
    1546:	0e 94 6d 04 	call	0x8da	; 0x8da <vPortFree>
    154a:	c9 c0       	rjmp	.+402    	; 0x16de <xTaskCreate+0x208>
    154c:	ae 01       	movw	r20, r28
    154e:	42 5e       	subi	r20, 0xE2	; 226
    1550:	5f 4f       	sbci	r21, 0xFF	; 255
    1552:	f6 01       	movw	r30, r12
    1554:	31 96       	adiw	r30, 0x01	; 1
    1556:	b8 e0       	ldi	r27, 0x08	; 8
    1558:	cb 0e       	add	r12, r27
    155a:	d1 1c       	adc	r13, r1
    155c:	cf 01       	movw	r24, r30
    155e:	21 91       	ld	r18, Z+
    1560:	da 01       	movw	r26, r20
    1562:	2d 93       	st	X+, r18
    1564:	ad 01       	movw	r20, r26
    1566:	dc 01       	movw	r26, r24
    1568:	8c 91       	ld	r24, X
    156a:	88 23       	and	r24, r24
    156c:	19 f0       	breq	.+6      	; 0x1574 <xTaskCreate+0x9e>
    156e:	ec 15       	cp	r30, r12
    1570:	fd 05       	cpc	r31, r13
    1572:	a1 f7       	brne	.-24     	; 0x155c <xTaskCreate+0x86>
    1574:	1c a2       	std	Y+36, r1	; 0x24
    1576:	04 30       	cpi	r16, 0x04	; 4
    1578:	08 f0       	brcs	.+2      	; 0x157c <xTaskCreate+0xa6>
    157a:	03 e0       	ldi	r16, 0x03	; 3
    157c:	0a 8f       	std	Y+26, r16	; 0x1a
    157e:	6e 01       	movw	r12, r28
    1580:	b2 e0       	ldi	r27, 0x02	; 2
    1582:	cb 0e       	add	r12, r27
    1584:	d1 1c       	adc	r13, r1
    1586:	c6 01       	movw	r24, r12
    1588:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListInitialiseItem>
    158c:	ce 01       	movw	r24, r28
    158e:	0e 96       	adiw	r24, 0x0e	; 14
    1590:	0e 94 7f 04 	call	0x8fe	; 0x8fe <vListInitialiseItem>
    1594:	ca 87       	std	Y+10, r28	; 0x0a
    1596:	db 87       	std	Y+11, r29	; 0x0b
    1598:	84 e0       	ldi	r24, 0x04	; 4
    159a:	90 e0       	ldi	r25, 0x00	; 0
    159c:	a0 e0       	ldi	r26, 0x00	; 0
    159e:	b0 e0       	ldi	r27, 0x00	; 0
    15a0:	80 1b       	sub	r24, r16
    15a2:	91 09       	sbc	r25, r1
    15a4:	a1 09       	sbc	r26, r1
    15a6:	b1 09       	sbc	r27, r1
    15a8:	8e 87       	std	Y+14, r24	; 0x0e
    15aa:	9f 87       	std	Y+15, r25	; 0x0f
    15ac:	a8 8b       	std	Y+16, r26	; 0x10
    15ae:	b9 8b       	std	Y+17, r27	; 0x11
    15b0:	ce 8b       	std	Y+22, r28	; 0x16
    15b2:	df 8b       	std	Y+23, r29	; 0x17
    15b4:	1f a2       	std	Y+39, r1	; 0x27
    15b6:	18 a6       	std	Y+40, r1	; 0x28
    15b8:	19 a6       	std	Y+41, r1	; 0x29
    15ba:	1a a6       	std	Y+42, r1	; 0x2a
    15bc:	1b a6       	std	Y+43, r1	; 0x2b
    15be:	a2 01       	movw	r20, r4
    15c0:	b4 01       	movw	r22, r8
    15c2:	c5 01       	movw	r24, r10
    15c4:	0e 94 0f 05 	call	0xa1e	; 0xa1e <pxPortInitialiseStack>
    15c8:	88 83       	st	Y, r24
    15ca:	99 83       	std	Y+1, r25	; 0x01
    15cc:	e1 14       	cp	r14, r1
    15ce:	f1 04       	cpc	r15, r1
    15d0:	19 f0       	breq	.+6      	; 0x15d8 <xTaskCreate+0x102>
    15d2:	f7 01       	movw	r30, r14
    15d4:	c0 83       	st	Z, r28
    15d6:	d1 83       	std	Z+1, r29	; 0x01
    15d8:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15dc:	ff 93       	push	r31
    15de:	f8 7f       	andi	r31, 0xF8	; 248
    15e0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    15e4:	80 91 69 2c 	lds	r24, 0x2C69	; 0x802c69 <uxCurrentNumberOfTasks>
    15e8:	8f 5f       	subi	r24, 0xFF	; 255
    15ea:	80 93 69 2c 	sts	0x2C69, r24	; 0x802c69 <uxCurrentNumberOfTasks>
    15ee:	80 91 c6 2c 	lds	r24, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    15f2:	90 91 c7 2c 	lds	r25, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    15f6:	89 2b       	or	r24, r25
    15f8:	a9 f5       	brne	.+106    	; 0x1664 <xTaskCreate+0x18e>
    15fa:	c0 93 c6 2c 	sts	0x2CC6, r28	; 0x802cc6 <pxCurrentTCB>
    15fe:	d0 93 c7 2c 	sts	0x2CC7, r29	; 0x802cc7 <pxCurrentTCB+0x1>
    1602:	80 91 69 2c 	lds	r24, 0x2C69	; 0x802c69 <uxCurrentNumberOfTasks>
    1606:	81 30       	cpi	r24, 0x01	; 1
    1608:	e9 f5       	brne	.+122    	; 0x1684 <xTaskCreate+0x1ae>
    160a:	8a e9       	ldi	r24, 0x9A	; 154
    160c:	9c e2       	ldi	r25, 0x2C	; 44
    160e:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
    1612:	85 ea       	ldi	r24, 0xA5	; 165
    1614:	9c e2       	ldi	r25, 0x2C	; 44
    1616:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
    161a:	80 eb       	ldi	r24, 0xB0	; 176
    161c:	9c e2       	ldi	r25, 0x2C	; 44
    161e:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
    1622:	8b eb       	ldi	r24, 0xBB	; 187
    1624:	9c e2       	ldi	r25, 0x2C	; 44
    1626:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
    162a:	8f e8       	ldi	r24, 0x8F	; 143
    162c:	9c e2       	ldi	r25, 0x2C	; 44
    162e:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
    1632:	84 e8       	ldi	r24, 0x84	; 132
    1634:	9c e2       	ldi	r25, 0x2C	; 44
    1636:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
    163a:	85 e7       	ldi	r24, 0x75	; 117
    163c:	9c e2       	ldi	r25, 0x2C	; 44
    163e:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
    1642:	8a e6       	ldi	r24, 0x6A	; 106
    1644:	9c e2       	ldi	r25, 0x2C	; 44
    1646:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
    164a:	8f e8       	ldi	r24, 0x8F	; 143
    164c:	9c e2       	ldi	r25, 0x2C	; 44
    164e:	80 93 82 2c 	sts	0x2C82, r24	; 0x802c82 <pxDelayedTaskList>
    1652:	90 93 83 2c 	sts	0x2C83, r25	; 0x802c83 <pxDelayedTaskList+0x1>
    1656:	84 e8       	ldi	r24, 0x84	; 132
    1658:	9c e2       	ldi	r25, 0x2C	; 44
    165a:	80 93 80 2c 	sts	0x2C80, r24	; 0x802c80 <pxOverflowDelayedTaskList>
    165e:	90 93 81 2c 	sts	0x2C81, r25	; 0x802c81 <pxOverflowDelayedTaskList+0x1>
    1662:	10 c0       	rjmp	.+32     	; 0x1684 <xTaskCreate+0x1ae>
    1664:	80 91 63 2c 	lds	r24, 0x2C63	; 0x802c63 <xSchedulerRunning>
    1668:	81 11       	cpse	r24, r1
    166a:	0c c0       	rjmp	.+24     	; 0x1684 <xTaskCreate+0x1ae>
    166c:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1670:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1674:	92 8d       	ldd	r25, Z+26	; 0x1a
    1676:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1678:	89 17       	cp	r24, r25
    167a:	20 f0       	brcs	.+8      	; 0x1684 <xTaskCreate+0x1ae>
    167c:	c0 93 c6 2c 	sts	0x2CC6, r28	; 0x802cc6 <pxCurrentTCB>
    1680:	d0 93 c7 2c 	sts	0x2CC7, r29	; 0x802cc7 <pxCurrentTCB+0x1>
    1684:	80 91 5f 2c 	lds	r24, 0x2C5F	; 0x802c5f <uxTaskNumber>
    1688:	8f 5f       	subi	r24, 0xFF	; 255
    168a:	80 93 5f 2c 	sts	0x2C5F, r24	; 0x802c5f <uxTaskNumber>
    168e:	8d a3       	std	Y+37, r24	; 0x25
    1690:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1692:	90 91 64 2c 	lds	r25, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    1696:	98 17       	cp	r25, r24
    1698:	10 f4       	brcc	.+4      	; 0x169e <xTaskCreate+0x1c8>
    169a:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    169e:	fb e0       	ldi	r31, 0x0B	; 11
    16a0:	8f 9f       	mul	r24, r31
    16a2:	c0 01       	movw	r24, r0
    16a4:	11 24       	eor	r1, r1
    16a6:	b6 01       	movw	r22, r12
    16a8:	86 56       	subi	r24, 0x66	; 102
    16aa:	93 4d       	sbci	r25, 0xD3	; 211
    16ac:	0e 94 83 04 	call	0x906	; 0x906 <vListInsertEnd>
    16b0:	ff 91       	pop	r31
    16b2:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    16b6:	80 91 63 2c 	lds	r24, 0x2C63	; 0x802c63 <xSchedulerRunning>
    16ba:	88 23       	and	r24, r24
    16bc:	61 f0       	breq	.+24     	; 0x16d6 <xTaskCreate+0x200>
    16be:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    16c2:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    16c6:	92 8d       	ldd	r25, Z+26	; 0x1a
    16c8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16ca:	98 17       	cp	r25, r24
    16cc:	30 f4       	brcc	.+12     	; 0x16da <xTaskCreate+0x204>
    16ce:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	05 c0       	rjmp	.+10     	; 0x16e0 <xTaskCreate+0x20a>
    16d6:	81 e0       	ldi	r24, 0x01	; 1
    16d8:	03 c0       	rjmp	.+6      	; 0x16e0 <xTaskCreate+0x20a>
    16da:	81 e0       	ldi	r24, 0x01	; 1
    16dc:	01 c0       	rjmp	.+2      	; 0x16e0 <xTaskCreate+0x20a>
    16de:	8f ef       	ldi	r24, 0xFF	; 255
    16e0:	df 91       	pop	r29
    16e2:	cf 91       	pop	r28
    16e4:	0f 91       	pop	r16
    16e6:	ff 90       	pop	r15
    16e8:	ef 90       	pop	r14
    16ea:	df 90       	pop	r13
    16ec:	cf 90       	pop	r12
    16ee:	bf 90       	pop	r11
    16f0:	af 90       	pop	r10
    16f2:	9f 90       	pop	r9
    16f4:	8f 90       	pop	r8
    16f6:	7f 90       	pop	r7
    16f8:	6f 90       	pop	r6
    16fa:	5f 90       	pop	r5
    16fc:	4f 90       	pop	r4
    16fe:	08 95       	ret

00001700 <vTaskStartScheduler>:
    1700:	ef 92       	push	r14
    1702:	ff 92       	push	r15
    1704:	0f 93       	push	r16
    1706:	0f 2e       	mov	r0, r31
    1708:	f9 e5       	ldi	r31, 0x59	; 89
    170a:	ef 2e       	mov	r14, r31
    170c:	fc e2       	ldi	r31, 0x2C	; 44
    170e:	ff 2e       	mov	r15, r31
    1710:	f0 2d       	mov	r31, r0
    1712:	00 e0       	ldi	r16, 0x00	; 0
    1714:	20 e0       	ldi	r18, 0x00	; 0
    1716:	30 e0       	ldi	r19, 0x00	; 0
    1718:	48 ec       	ldi	r20, 0xC8	; 200
    171a:	50 e0       	ldi	r21, 0x00	; 0
    171c:	65 e0       	ldi	r22, 0x05	; 5
    171e:	70 e2       	ldi	r23, 0x20	; 32
    1720:	81 e6       	ldi	r24, 0x61	; 97
    1722:	9a e0       	ldi	r25, 0x0A	; 10
    1724:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <xTaskCreate>
    1728:	81 30       	cpi	r24, 0x01	; 1
    172a:	09 f5       	brne	.+66     	; 0x176e <vTaskStartScheduler+0x6e>
    172c:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <xTimerCreateTimerTask>
    1730:	81 30       	cpi	r24, 0x01	; 1
    1732:	e9 f4       	brne	.+58     	; 0x176e <vTaskStartScheduler+0x6e>
    1734:	e0 ea       	ldi	r30, 0xA0	; 160
    1736:	f0 e0       	ldi	r31, 0x00	; 0
    1738:	82 81       	ldd	r24, Z+2	; 0x02
    173a:	88 7f       	andi	r24, 0xF8	; 248
    173c:	82 83       	std	Z+2, r24	; 0x02
    173e:	8f ef       	ldi	r24, 0xFF	; 255
    1740:	9f ef       	ldi	r25, 0xFF	; 255
    1742:	dc 01       	movw	r26, r24
    1744:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <xNextTaskUnblockTime>
    1748:	90 93 5c 2c 	sts	0x2C5C, r25	; 0x802c5c <xNextTaskUnblockTime+0x1>
    174c:	a0 93 5d 2c 	sts	0x2C5D, r26	; 0x802c5d <xNextTaskUnblockTime+0x2>
    1750:	b0 93 5e 2c 	sts	0x2C5E, r27	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1754:	81 e0       	ldi	r24, 0x01	; 1
    1756:	80 93 63 2c 	sts	0x2C63, r24	; 0x802c63 <xSchedulerRunning>
    175a:	10 92 65 2c 	sts	0x2C65, r1	; 0x802c65 <xTickCount>
    175e:	10 92 66 2c 	sts	0x2C66, r1	; 0x802c66 <xTickCount+0x1>
    1762:	10 92 67 2c 	sts	0x2C67, r1	; 0x802c67 <xTickCount+0x2>
    1766:	10 92 68 2c 	sts	0x2C68, r1	; 0x802c68 <xTickCount+0x3>
    176a:	0e 94 8c 05 	call	0xb18	; 0xb18 <xPortStartScheduler>
    176e:	0f 91       	pop	r16
    1770:	ff 90       	pop	r15
    1772:	ef 90       	pop	r14
    1774:	08 95       	ret

00001776 <vTaskSuspendAll>:
    1776:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    177a:	8f 5f       	subi	r24, 0xFF	; 255
    177c:	80 93 58 2c 	sts	0x2C58, r24	; 0x802c58 <uxSchedulerSuspended>
    1780:	08 95       	ret

00001782 <xTaskGetTickCount>:
    1782:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1786:	ff 93       	push	r31
    1788:	f8 7f       	andi	r31, 0xF8	; 248
    178a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    178e:	60 91 65 2c 	lds	r22, 0x2C65	; 0x802c65 <xTickCount>
    1792:	70 91 66 2c 	lds	r23, 0x2C66	; 0x802c66 <xTickCount+0x1>
    1796:	80 91 67 2c 	lds	r24, 0x2C67	; 0x802c67 <xTickCount+0x2>
    179a:	90 91 68 2c 	lds	r25, 0x2C68	; 0x802c68 <xTickCount+0x3>
    179e:	ff 91       	pop	r31
    17a0:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    17a4:	08 95       	ret

000017a6 <xTaskIncrementTick>:
    17a6:	af 92       	push	r10
    17a8:	bf 92       	push	r11
    17aa:	cf 92       	push	r12
    17ac:	df 92       	push	r13
    17ae:	ef 92       	push	r14
    17b0:	ff 92       	push	r15
    17b2:	0f 93       	push	r16
    17b4:	1f 93       	push	r17
    17b6:	cf 93       	push	r28
    17b8:	df 93       	push	r29
    17ba:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    17be:	81 11       	cpse	r24, r1
    17c0:	ad c0       	rjmp	.+346    	; 0x191c <xTaskIncrementTick+0x176>
    17c2:	c0 90 65 2c 	lds	r12, 0x2C65	; 0x802c65 <xTickCount>
    17c6:	d0 90 66 2c 	lds	r13, 0x2C66	; 0x802c66 <xTickCount+0x1>
    17ca:	e0 90 67 2c 	lds	r14, 0x2C67	; 0x802c67 <xTickCount+0x2>
    17ce:	f0 90 68 2c 	lds	r15, 0x2C68	; 0x802c68 <xTickCount+0x3>
    17d2:	8f ef       	ldi	r24, 0xFF	; 255
    17d4:	c8 1a       	sub	r12, r24
    17d6:	d8 0a       	sbc	r13, r24
    17d8:	e8 0a       	sbc	r14, r24
    17da:	f8 0a       	sbc	r15, r24
    17dc:	c0 92 65 2c 	sts	0x2C65, r12	; 0x802c65 <xTickCount>
    17e0:	d0 92 66 2c 	sts	0x2C66, r13	; 0x802c66 <xTickCount+0x1>
    17e4:	e0 92 67 2c 	sts	0x2C67, r14	; 0x802c67 <xTickCount+0x2>
    17e8:	f0 92 68 2c 	sts	0x2C68, r15	; 0x802c68 <xTickCount+0x3>
    17ec:	c1 14       	cp	r12, r1
    17ee:	d1 04       	cpc	r13, r1
    17f0:	e1 04       	cpc	r14, r1
    17f2:	f1 04       	cpc	r15, r1
    17f4:	b9 f4       	brne	.+46     	; 0x1824 <xTaskIncrementTick+0x7e>
    17f6:	80 91 82 2c 	lds	r24, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    17fa:	90 91 83 2c 	lds	r25, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    17fe:	20 91 80 2c 	lds	r18, 0x2C80	; 0x802c80 <pxOverflowDelayedTaskList>
    1802:	30 91 81 2c 	lds	r19, 0x2C81	; 0x802c81 <pxOverflowDelayedTaskList+0x1>
    1806:	20 93 82 2c 	sts	0x2C82, r18	; 0x802c82 <pxDelayedTaskList>
    180a:	30 93 83 2c 	sts	0x2C83, r19	; 0x802c83 <pxDelayedTaskList+0x1>
    180e:	80 93 80 2c 	sts	0x2C80, r24	; 0x802c80 <pxOverflowDelayedTaskList>
    1812:	90 93 81 2c 	sts	0x2C81, r25	; 0x802c81 <pxOverflowDelayedTaskList+0x1>
    1816:	80 91 60 2c 	lds	r24, 0x2C60	; 0x802c60 <xNumOfOverflows>
    181a:	8f 5f       	subi	r24, 0xFF	; 255
    181c:	80 93 60 2c 	sts	0x2C60, r24	; 0x802c60 <xNumOfOverflows>
    1820:	0e 94 c0 09 	call	0x1380	; 0x1380 <prvResetNextTaskUnblockTime>
    1824:	80 91 5b 2c 	lds	r24, 0x2C5B	; 0x802c5b <xNextTaskUnblockTime>
    1828:	90 91 5c 2c 	lds	r25, 0x2C5C	; 0x802c5c <xNextTaskUnblockTime+0x1>
    182c:	a0 91 5d 2c 	lds	r26, 0x2C5D	; 0x802c5d <xNextTaskUnblockTime+0x2>
    1830:	b0 91 5e 2c 	lds	r27, 0x2C5E	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1834:	c8 16       	cp	r12, r24
    1836:	d9 06       	cpc	r13, r25
    1838:	ea 06       	cpc	r14, r26
    183a:	fb 06       	cpc	r15, r27
    183c:	10 f4       	brcc	.+4      	; 0x1842 <xTaskIncrementTick+0x9c>
    183e:	b1 2c       	mov	r11, r1
    1840:	5c c0       	rjmp	.+184    	; 0x18fa <xTaskIncrementTick+0x154>
    1842:	b1 2c       	mov	r11, r1
    1844:	0f 2e       	mov	r0, r31
    1846:	fb e0       	ldi	r31, 0x0B	; 11
    1848:	af 2e       	mov	r10, r31
    184a:	f0 2d       	mov	r31, r0
    184c:	e0 91 82 2c 	lds	r30, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    1850:	f0 91 83 2c 	lds	r31, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    1854:	80 81       	ld	r24, Z
    1856:	81 11       	cpse	r24, r1
    1858:	0c c0       	rjmp	.+24     	; 0x1872 <xTaskIncrementTick+0xcc>
    185a:	8f ef       	ldi	r24, 0xFF	; 255
    185c:	9f ef       	ldi	r25, 0xFF	; 255
    185e:	dc 01       	movw	r26, r24
    1860:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <xNextTaskUnblockTime>
    1864:	90 93 5c 2c 	sts	0x2C5C, r25	; 0x802c5c <xNextTaskUnblockTime+0x1>
    1868:	a0 93 5d 2c 	sts	0x2C5D, r26	; 0x802c5d <xNextTaskUnblockTime+0x2>
    186c:	b0 93 5e 2c 	sts	0x2C5E, r27	; 0x802c5e <xNextTaskUnblockTime+0x3>
    1870:	44 c0       	rjmp	.+136    	; 0x18fa <xTaskIncrementTick+0x154>
    1872:	e0 91 82 2c 	lds	r30, 0x2C82	; 0x802c82 <pxDelayedTaskList>
    1876:	f0 91 83 2c 	lds	r31, 0x2C83	; 0x802c83 <pxDelayedTaskList+0x1>
    187a:	07 80       	ldd	r0, Z+7	; 0x07
    187c:	f0 85       	ldd	r31, Z+8	; 0x08
    187e:	e0 2d       	mov	r30, r0
    1880:	c0 85       	ldd	r28, Z+8	; 0x08
    1882:	d1 85       	ldd	r29, Z+9	; 0x09
    1884:	8a 81       	ldd	r24, Y+2	; 0x02
    1886:	9b 81       	ldd	r25, Y+3	; 0x03
    1888:	ac 81       	ldd	r26, Y+4	; 0x04
    188a:	bd 81       	ldd	r27, Y+5	; 0x05
    188c:	c8 16       	cp	r12, r24
    188e:	d9 06       	cpc	r13, r25
    1890:	ea 06       	cpc	r14, r26
    1892:	fb 06       	cpc	r15, r27
    1894:	48 f4       	brcc	.+18     	; 0x18a8 <xTaskIncrementTick+0x102>
    1896:	80 93 5b 2c 	sts	0x2C5B, r24	; 0x802c5b <xNextTaskUnblockTime>
    189a:	90 93 5c 2c 	sts	0x2C5C, r25	; 0x802c5c <xNextTaskUnblockTime+0x1>
    189e:	a0 93 5d 2c 	sts	0x2C5D, r26	; 0x802c5d <xNextTaskUnblockTime+0x2>
    18a2:	b0 93 5e 2c 	sts	0x2C5E, r27	; 0x802c5e <xNextTaskUnblockTime+0x3>
    18a6:	29 c0       	rjmp	.+82     	; 0x18fa <xTaskIncrementTick+0x154>
    18a8:	8e 01       	movw	r16, r28
    18aa:	0e 5f       	subi	r16, 0xFE	; 254
    18ac:	1f 4f       	sbci	r17, 0xFF	; 255
    18ae:	c8 01       	movw	r24, r16
    18b0:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    18b4:	88 8d       	ldd	r24, Y+24	; 0x18
    18b6:	99 8d       	ldd	r25, Y+25	; 0x19
    18b8:	89 2b       	or	r24, r25
    18ba:	21 f0       	breq	.+8      	; 0x18c4 <xTaskIncrementTick+0x11e>
    18bc:	ce 01       	movw	r24, r28
    18be:	0e 96       	adiw	r24, 0x0e	; 14
    18c0:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    18c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    18c6:	90 91 64 2c 	lds	r25, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    18ca:	98 17       	cp	r25, r24
    18cc:	10 f4       	brcc	.+4      	; 0x18d2 <xTaskIncrementTick+0x12c>
    18ce:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    18d2:	a8 9e       	mul	r10, r24
    18d4:	c0 01       	movw	r24, r0
    18d6:	11 24       	eor	r1, r1
    18d8:	b8 01       	movw	r22, r16
    18da:	86 56       	subi	r24, 0x66	; 102
    18dc:	93 4d       	sbci	r25, 0xD3	; 211
    18de:	0e 94 83 04 	call	0x906	; 0x906 <vListInsertEnd>
    18e2:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    18e6:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    18ea:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    18ee:	98 17       	cp	r25, r24
    18f0:	08 f4       	brcc	.+2      	; 0x18f4 <xTaskIncrementTick+0x14e>
    18f2:	ac cf       	rjmp	.-168    	; 0x184c <xTaskIncrementTick+0xa6>
    18f4:	bb 24       	eor	r11, r11
    18f6:	b3 94       	inc	r11
    18f8:	a9 cf       	rjmp	.-174    	; 0x184c <xTaskIncrementTick+0xa6>
    18fa:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    18fe:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1902:	e2 8d       	ldd	r30, Z+26	; 0x1a
    1904:	8b e0       	ldi	r24, 0x0B	; 11
    1906:	e8 9f       	mul	r30, r24
    1908:	f0 01       	movw	r30, r0
    190a:	11 24       	eor	r1, r1
    190c:	e6 56       	subi	r30, 0x66	; 102
    190e:	f3 4d       	sbci	r31, 0xD3	; 211
    1910:	80 81       	ld	r24, Z
    1912:	82 30       	cpi	r24, 0x02	; 2
    1914:	48 f0       	brcs	.+18     	; 0x1928 <xTaskIncrementTick+0x182>
    1916:	bb 24       	eor	r11, r11
    1918:	b3 94       	inc	r11
    191a:	06 c0       	rjmp	.+12     	; 0x1928 <xTaskIncrementTick+0x182>
    191c:	80 91 62 2c 	lds	r24, 0x2C62	; 0x802c62 <uxPendedTicks>
    1920:	8f 5f       	subi	r24, 0xFF	; 255
    1922:	80 93 62 2c 	sts	0x2C62, r24	; 0x802c62 <uxPendedTicks>
    1926:	b1 2c       	mov	r11, r1
    1928:	80 91 61 2c 	lds	r24, 0x2C61	; 0x802c61 <xYieldPending>
    192c:	88 23       	and	r24, r24
    192e:	11 f0       	breq	.+4      	; 0x1934 <xTaskIncrementTick+0x18e>
    1930:	bb 24       	eor	r11, r11
    1932:	b3 94       	inc	r11
    1934:	8b 2d       	mov	r24, r11
    1936:	df 91       	pop	r29
    1938:	cf 91       	pop	r28
    193a:	1f 91       	pop	r17
    193c:	0f 91       	pop	r16
    193e:	ff 90       	pop	r15
    1940:	ef 90       	pop	r14
    1942:	df 90       	pop	r13
    1944:	cf 90       	pop	r12
    1946:	bf 90       	pop	r11
    1948:	af 90       	pop	r10
    194a:	08 95       	ret

0000194c <xTaskResumeAll>:
    194c:	cf 92       	push	r12
    194e:	df 92       	push	r13
    1950:	ef 92       	push	r14
    1952:	ff 92       	push	r15
    1954:	0f 93       	push	r16
    1956:	1f 93       	push	r17
    1958:	cf 93       	push	r28
    195a:	df 93       	push	r29
    195c:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1960:	ff 93       	push	r31
    1962:	f8 7f       	andi	r31, 0xF8	; 248
    1964:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1968:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    196c:	81 50       	subi	r24, 0x01	; 1
    196e:	80 93 58 2c 	sts	0x2C58, r24	; 0x802c58 <uxSchedulerSuspended>
    1972:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    1976:	81 11       	cpse	r24, r1
    1978:	5c c0       	rjmp	.+184    	; 0x1a32 <xTaskResumeAll+0xe6>
    197a:	80 91 69 2c 	lds	r24, 0x2C69	; 0x802c69 <uxCurrentNumberOfTasks>
    197e:	81 11       	cpse	r24, r1
    1980:	2c c0       	rjmp	.+88     	; 0x19da <xTaskResumeAll+0x8e>
    1982:	5a c0       	rjmp	.+180    	; 0x1a38 <xTaskResumeAll+0xec>
    1984:	d7 01       	movw	r26, r14
    1986:	17 96       	adiw	r26, 0x07	; 7
    1988:	ed 91       	ld	r30, X+
    198a:	fc 91       	ld	r31, X
    198c:	18 97       	sbiw	r26, 0x08	; 8
    198e:	c0 85       	ldd	r28, Z+8	; 0x08
    1990:	d1 85       	ldd	r29, Z+9	; 0x09
    1992:	ce 01       	movw	r24, r28
    1994:	0e 96       	adiw	r24, 0x0e	; 14
    1996:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    199a:	8e 01       	movw	r16, r28
    199c:	0e 5f       	subi	r16, 0xFE	; 254
    199e:	1f 4f       	sbci	r17, 0xFF	; 255
    19a0:	c8 01       	movw	r24, r16
    19a2:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    19a6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19a8:	90 91 64 2c 	lds	r25, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    19ac:	98 17       	cp	r25, r24
    19ae:	10 f4       	brcc	.+4      	; 0x19b4 <xTaskResumeAll+0x68>
    19b0:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    19b4:	d8 9e       	mul	r13, r24
    19b6:	c0 01       	movw	r24, r0
    19b8:	11 24       	eor	r1, r1
    19ba:	b8 01       	movw	r22, r16
    19bc:	86 56       	subi	r24, 0x66	; 102
    19be:	93 4d       	sbci	r25, 0xD3	; 211
    19c0:	0e 94 83 04 	call	0x906	; 0x906 <vListInsertEnd>
    19c4:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    19c8:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    19cc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    19d0:	98 17       	cp	r25, r24
    19d2:	88 f0       	brcs	.+34     	; 0x19f6 <xTaskResumeAll+0xaa>
    19d4:	c0 92 61 2c 	sts	0x2C61, r12	; 0x802c61 <xYieldPending>
    19d8:	0e c0       	rjmp	.+28     	; 0x19f6 <xTaskResumeAll+0xaa>
    19da:	c0 e0       	ldi	r28, 0x00	; 0
    19dc:	d0 e0       	ldi	r29, 0x00	; 0
    19de:	0f 2e       	mov	r0, r31
    19e0:	f5 e7       	ldi	r31, 0x75	; 117
    19e2:	ef 2e       	mov	r14, r31
    19e4:	fc e2       	ldi	r31, 0x2C	; 44
    19e6:	ff 2e       	mov	r15, r31
    19e8:	f0 2d       	mov	r31, r0
    19ea:	0f 2e       	mov	r0, r31
    19ec:	fb e0       	ldi	r31, 0x0B	; 11
    19ee:	df 2e       	mov	r13, r31
    19f0:	f0 2d       	mov	r31, r0
    19f2:	cc 24       	eor	r12, r12
    19f4:	c3 94       	inc	r12
    19f6:	f7 01       	movw	r30, r14
    19f8:	80 81       	ld	r24, Z
    19fa:	81 11       	cpse	r24, r1
    19fc:	c3 cf       	rjmp	.-122    	; 0x1984 <xTaskResumeAll+0x38>
    19fe:	cd 2b       	or	r28, r29
    1a00:	11 f0       	breq	.+4      	; 0x1a06 <xTaskResumeAll+0xba>
    1a02:	0e 94 c0 09 	call	0x1380	; 0x1380 <prvResetNextTaskUnblockTime>
    1a06:	c0 91 62 2c 	lds	r28, 0x2C62	; 0x802c62 <uxPendedTicks>
    1a0a:	cc 23       	and	r28, r28
    1a0c:	51 f0       	breq	.+20     	; 0x1a22 <xTaskResumeAll+0xd6>
    1a0e:	d1 e0       	ldi	r29, 0x01	; 1
    1a10:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <xTaskIncrementTick>
    1a14:	81 11       	cpse	r24, r1
    1a16:	d0 93 61 2c 	sts	0x2C61, r29	; 0x802c61 <xYieldPending>
    1a1a:	c1 50       	subi	r28, 0x01	; 1
    1a1c:	c9 f7       	brne	.-14     	; 0x1a10 <xTaskResumeAll+0xc4>
    1a1e:	10 92 62 2c 	sts	0x2C62, r1	; 0x802c62 <uxPendedTicks>
    1a22:	80 91 61 2c 	lds	r24, 0x2C61	; 0x802c61 <xYieldPending>
    1a26:	88 23       	and	r24, r24
    1a28:	31 f0       	breq	.+12     	; 0x1a36 <xTaskResumeAll+0xea>
    1a2a:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
    1a2e:	81 e0       	ldi	r24, 0x01	; 1
    1a30:	03 c0       	rjmp	.+6      	; 0x1a38 <xTaskResumeAll+0xec>
    1a32:	80 e0       	ldi	r24, 0x00	; 0
    1a34:	01 c0       	rjmp	.+2      	; 0x1a38 <xTaskResumeAll+0xec>
    1a36:	80 e0       	ldi	r24, 0x00	; 0
    1a38:	ff 91       	pop	r31
    1a3a:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1a3e:	df 91       	pop	r29
    1a40:	cf 91       	pop	r28
    1a42:	1f 91       	pop	r17
    1a44:	0f 91       	pop	r16
    1a46:	ff 90       	pop	r15
    1a48:	ef 90       	pop	r14
    1a4a:	df 90       	pop	r13
    1a4c:	cf 90       	pop	r12
    1a4e:	08 95       	ret

00001a50 <vTaskDelay>:
    1a50:	cf 92       	push	r12
    1a52:	df 92       	push	r13
    1a54:	ef 92       	push	r14
    1a56:	ff 92       	push	r15
    1a58:	6b 01       	movw	r12, r22
    1a5a:	7c 01       	movw	r14, r24
    1a5c:	67 2b       	or	r22, r23
    1a5e:	68 2b       	or	r22, r24
    1a60:	69 2b       	or	r22, r25
    1a62:	59 f0       	breq	.+22     	; 0x1a7a <vTaskDelay+0x2a>
    1a64:	0e 94 bb 0b 	call	0x1776	; 0x1776 <vTaskSuspendAll>
    1a68:	40 e0       	ldi	r20, 0x00	; 0
    1a6a:	c7 01       	movw	r24, r14
    1a6c:	b6 01       	movw	r22, r12
    1a6e:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <prvAddCurrentTaskToDelayedList>
    1a72:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
    1a76:	81 11       	cpse	r24, r1
    1a78:	02 c0       	rjmp	.+4      	; 0x1a7e <vTaskDelay+0x2e>
    1a7a:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
    1a7e:	ff 90       	pop	r15
    1a80:	ef 90       	pop	r14
    1a82:	df 90       	pop	r13
    1a84:	cf 90       	pop	r12
    1a86:	08 95       	ret

00001a88 <vTaskSwitchContext>:
    1a88:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    1a8c:	88 23       	and	r24, r24
    1a8e:	21 f0       	breq	.+8      	; 0x1a98 <vTaskSwitchContext+0x10>
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	80 93 61 2c 	sts	0x2C61, r24	; 0x802c61 <xYieldPending>
    1a96:	08 95       	ret
    1a98:	10 92 61 2c 	sts	0x2C61, r1	; 0x802c61 <xYieldPending>
    1a9c:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1aa0:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1aa4:	03 8c       	ldd	r0, Z+27	; 0x1b
    1aa6:	f4 8d       	ldd	r31, Z+28	; 0x1c
    1aa8:	e0 2d       	mov	r30, r0
    1aaa:	80 81       	ld	r24, Z
    1aac:	91 81       	ldd	r25, Z+1	; 0x01
    1aae:	a2 81       	ldd	r26, Z+2	; 0x02
    1ab0:	b3 81       	ldd	r27, Z+3	; 0x03
    1ab2:	85 3a       	cpi	r24, 0xA5	; 165
    1ab4:	95 4a       	sbci	r25, 0xA5	; 165
    1ab6:	a5 4a       	sbci	r26, 0xA5	; 165
    1ab8:	b5 4a       	sbci	r27, 0xA5	; 165
    1aba:	d9 f4       	brne	.+54     	; 0x1af2 <vTaskSwitchContext+0x6a>
    1abc:	84 81       	ldd	r24, Z+4	; 0x04
    1abe:	95 81       	ldd	r25, Z+5	; 0x05
    1ac0:	a6 81       	ldd	r26, Z+6	; 0x06
    1ac2:	b7 81       	ldd	r27, Z+7	; 0x07
    1ac4:	85 3a       	cpi	r24, 0xA5	; 165
    1ac6:	95 4a       	sbci	r25, 0xA5	; 165
    1ac8:	a5 4a       	sbci	r26, 0xA5	; 165
    1aca:	b5 4a       	sbci	r27, 0xA5	; 165
    1acc:	91 f4       	brne	.+36     	; 0x1af2 <vTaskSwitchContext+0x6a>
    1ace:	80 85       	ldd	r24, Z+8	; 0x08
    1ad0:	91 85       	ldd	r25, Z+9	; 0x09
    1ad2:	a2 85       	ldd	r26, Z+10	; 0x0a
    1ad4:	b3 85       	ldd	r27, Z+11	; 0x0b
    1ad6:	85 3a       	cpi	r24, 0xA5	; 165
    1ad8:	95 4a       	sbci	r25, 0xA5	; 165
    1ada:	a5 4a       	sbci	r26, 0xA5	; 165
    1adc:	b5 4a       	sbci	r27, 0xA5	; 165
    1ade:	49 f4       	brne	.+18     	; 0x1af2 <vTaskSwitchContext+0x6a>
    1ae0:	84 85       	ldd	r24, Z+12	; 0x0c
    1ae2:	95 85       	ldd	r25, Z+13	; 0x0d
    1ae4:	a6 85       	ldd	r26, Z+14	; 0x0e
    1ae6:	b7 85       	ldd	r27, Z+15	; 0x0f
    1ae8:	85 3a       	cpi	r24, 0xA5	; 165
    1aea:	95 4a       	sbci	r25, 0xA5	; 165
    1aec:	a5 4a       	sbci	r26, 0xA5	; 165
    1aee:	b5 4a       	sbci	r27, 0xA5	; 165
    1af0:	61 f0       	breq	.+24     	; 0x1b0a <vTaskSwitchContext+0x82>
    1af2:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1af6:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1afa:	80 91 c6 2c 	lds	r24, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1afe:	90 91 c7 2c 	lds	r25, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1b02:	63 5e       	subi	r22, 0xE3	; 227
    1b04:	7f 4f       	sbci	r23, 0xFF	; 255
    1b06:	0e 94 a7 02 	call	0x54e	; 0x54e <vApplicationStackOverflowHook>
    1b0a:	80 91 64 2c 	lds	r24, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    1b0e:	28 2f       	mov	r18, r24
    1b10:	30 e0       	ldi	r19, 0x00	; 0
    1b12:	9b e0       	ldi	r25, 0x0B	; 11
    1b14:	89 9f       	mul	r24, r25
    1b16:	f0 01       	movw	r30, r0
    1b18:	11 24       	eor	r1, r1
    1b1a:	e6 56       	subi	r30, 0x66	; 102
    1b1c:	f3 4d       	sbci	r31, 0xD3	; 211
    1b1e:	90 81       	ld	r25, Z
    1b20:	91 11       	cpse	r25, r1
    1b22:	0e c0       	rjmp	.+28     	; 0x1b40 <vTaskSwitchContext+0xb8>
    1b24:	4b e0       	ldi	r20, 0x0B	; 11
    1b26:	81 50       	subi	r24, 0x01	; 1
    1b28:	28 2f       	mov	r18, r24
    1b2a:	30 e0       	ldi	r19, 0x00	; 0
    1b2c:	42 9f       	mul	r20, r18
    1b2e:	f0 01       	movw	r30, r0
    1b30:	43 9f       	mul	r20, r19
    1b32:	f0 0d       	add	r31, r0
    1b34:	11 24       	eor	r1, r1
    1b36:	e6 56       	subi	r30, 0x66	; 102
    1b38:	f3 4d       	sbci	r31, 0xD3	; 211
    1b3a:	90 81       	ld	r25, Z
    1b3c:	99 23       	and	r25, r25
    1b3e:	99 f3       	breq	.-26     	; 0x1b26 <vTaskSwitchContext+0x9e>
    1b40:	9b e0       	ldi	r25, 0x0B	; 11
    1b42:	92 9f       	mul	r25, r18
    1b44:	a0 01       	movw	r20, r0
    1b46:	93 9f       	mul	r25, r19
    1b48:	50 0d       	add	r21, r0
    1b4a:	11 24       	eor	r1, r1
    1b4c:	da 01       	movw	r26, r20
    1b4e:	a6 56       	subi	r26, 0x66	; 102
    1b50:	b3 4d       	sbci	r27, 0xD3	; 211
    1b52:	11 96       	adiw	r26, 0x01	; 1
    1b54:	ed 91       	ld	r30, X+
    1b56:	fc 91       	ld	r31, X
    1b58:	12 97       	sbiw	r26, 0x02	; 2
    1b5a:	04 80       	ldd	r0, Z+4	; 0x04
    1b5c:	f5 81       	ldd	r31, Z+5	; 0x05
    1b5e:	e0 2d       	mov	r30, r0
    1b60:	11 96       	adiw	r26, 0x01	; 1
    1b62:	ed 93       	st	X+, r30
    1b64:	fc 93       	st	X, r31
    1b66:	12 97       	sbiw	r26, 0x02	; 2
    1b68:	43 56       	subi	r20, 0x63	; 99
    1b6a:	53 4d       	sbci	r21, 0xD3	; 211
    1b6c:	e4 17       	cp	r30, r20
    1b6e:	f5 07       	cpc	r31, r21
    1b70:	29 f4       	brne	.+10     	; 0x1b7c <vTaskSwitchContext+0xf4>
    1b72:	44 81       	ldd	r20, Z+4	; 0x04
    1b74:	55 81       	ldd	r21, Z+5	; 0x05
    1b76:	fd 01       	movw	r30, r26
    1b78:	41 83       	std	Z+1, r20	; 0x01
    1b7a:	52 83       	std	Z+2, r21	; 0x02
    1b7c:	9b e0       	ldi	r25, 0x0B	; 11
    1b7e:	92 9f       	mul	r25, r18
    1b80:	f0 01       	movw	r30, r0
    1b82:	93 9f       	mul	r25, r19
    1b84:	f0 0d       	add	r31, r0
    1b86:	11 24       	eor	r1, r1
    1b88:	e6 56       	subi	r30, 0x66	; 102
    1b8a:	f3 4d       	sbci	r31, 0xD3	; 211
    1b8c:	01 80       	ldd	r0, Z+1	; 0x01
    1b8e:	f2 81       	ldd	r31, Z+2	; 0x02
    1b90:	e0 2d       	mov	r30, r0
    1b92:	20 85       	ldd	r18, Z+8	; 0x08
    1b94:	31 85       	ldd	r19, Z+9	; 0x09
    1b96:	20 93 c6 2c 	sts	0x2CC6, r18	; 0x802cc6 <pxCurrentTCB>
    1b9a:	30 93 c7 2c 	sts	0x2CC7, r19	; 0x802cc7 <pxCurrentTCB+0x1>
    1b9e:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    1ba2:	08 95       	ret

00001ba4 <vTaskPlaceOnEventList>:
    1ba4:	cf 92       	push	r12
    1ba6:	df 92       	push	r13
    1ba8:	ef 92       	push	r14
    1baa:	ff 92       	push	r15
    1bac:	6a 01       	movw	r12, r20
    1bae:	7b 01       	movw	r14, r22
    1bb0:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1bb4:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1bb8:	62 5f       	subi	r22, 0xF2	; 242
    1bba:	7f 4f       	sbci	r23, 0xFF	; 255
    1bbc:	0e 94 a4 04 	call	0x948	; 0x948 <vListInsert>
    1bc0:	41 e0       	ldi	r20, 0x01	; 1
    1bc2:	c7 01       	movw	r24, r14
    1bc4:	b6 01       	movw	r22, r12
    1bc6:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <prvAddCurrentTaskToDelayedList>
    1bca:	ff 90       	pop	r15
    1bcc:	ef 90       	pop	r14
    1bce:	df 90       	pop	r13
    1bd0:	cf 90       	pop	r12
    1bd2:	08 95       	ret

00001bd4 <vTaskPlaceOnUnorderedEventList>:
    1bd4:	cf 92       	push	r12
    1bd6:	df 92       	push	r13
    1bd8:	ef 92       	push	r14
    1bda:	ff 92       	push	r15
    1bdc:	0f 93       	push	r16
    1bde:	1f 93       	push	r17
    1be0:	68 01       	movw	r12, r16
    1be2:	79 01       	movw	r14, r18
    1be4:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1be8:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1bec:	70 68       	ori	r23, 0x80	; 128
    1bee:	46 87       	std	Z+14, r20	; 0x0e
    1bf0:	57 87       	std	Z+15, r21	; 0x0f
    1bf2:	60 8b       	std	Z+16, r22	; 0x10
    1bf4:	71 8b       	std	Z+17, r23	; 0x11
    1bf6:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1bfa:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1bfe:	62 5f       	subi	r22, 0xF2	; 242
    1c00:	7f 4f       	sbci	r23, 0xFF	; 255
    1c02:	0e 94 83 04 	call	0x906	; 0x906 <vListInsertEnd>
    1c06:	41 e0       	ldi	r20, 0x01	; 1
    1c08:	c7 01       	movw	r24, r14
    1c0a:	b6 01       	movw	r22, r12
    1c0c:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <prvAddCurrentTaskToDelayedList>
    1c10:	1f 91       	pop	r17
    1c12:	0f 91       	pop	r16
    1c14:	ff 90       	pop	r15
    1c16:	ef 90       	pop	r14
    1c18:	df 90       	pop	r13
    1c1a:	cf 90       	pop	r12
    1c1c:	08 95       	ret

00001c1e <vTaskPlaceOnEventListRestricted>:
    1c1e:	cf 92       	push	r12
    1c20:	df 92       	push	r13
    1c22:	ef 92       	push	r14
    1c24:	ff 92       	push	r15
    1c26:	cf 93       	push	r28
    1c28:	6a 01       	movw	r12, r20
    1c2a:	7b 01       	movw	r14, r22
    1c2c:	c2 2f       	mov	r28, r18
    1c2e:	60 91 c6 2c 	lds	r22, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1c32:	70 91 c7 2c 	lds	r23, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1c36:	62 5f       	subi	r22, 0xF2	; 242
    1c38:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3a:	0e 94 83 04 	call	0x906	; 0x906 <vListInsertEnd>
    1c3e:	cc 23       	and	r28, r28
    1c40:	21 f0       	breq	.+8      	; 0x1c4a <vTaskPlaceOnEventListRestricted+0x2c>
    1c42:	cc 24       	eor	r12, r12
    1c44:	ca 94       	dec	r12
    1c46:	dc 2c       	mov	r13, r12
    1c48:	76 01       	movw	r14, r12
    1c4a:	4c 2f       	mov	r20, r28
    1c4c:	c7 01       	movw	r24, r14
    1c4e:	b6 01       	movw	r22, r12
    1c50:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <prvAddCurrentTaskToDelayedList>
    1c54:	cf 91       	pop	r28
    1c56:	ff 90       	pop	r15
    1c58:	ef 90       	pop	r14
    1c5a:	df 90       	pop	r13
    1c5c:	cf 90       	pop	r12
    1c5e:	08 95       	ret

00001c60 <xTaskRemoveFromEventList>:
    1c60:	0f 93       	push	r16
    1c62:	1f 93       	push	r17
    1c64:	cf 93       	push	r28
    1c66:	df 93       	push	r29
    1c68:	dc 01       	movw	r26, r24
    1c6a:	17 96       	adiw	r26, 0x07	; 7
    1c6c:	ed 91       	ld	r30, X+
    1c6e:	fc 91       	ld	r31, X
    1c70:	18 97       	sbiw	r26, 0x08	; 8
    1c72:	c0 85       	ldd	r28, Z+8	; 0x08
    1c74:	d1 85       	ldd	r29, Z+9	; 0x09
    1c76:	8e 01       	movw	r16, r28
    1c78:	02 5f       	subi	r16, 0xF2	; 242
    1c7a:	1f 4f       	sbci	r17, 0xFF	; 255
    1c7c:	c8 01       	movw	r24, r16
    1c7e:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    1c82:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    1c86:	81 11       	cpse	r24, r1
    1c88:	16 c0       	rjmp	.+44     	; 0x1cb6 <xTaskRemoveFromEventList+0x56>
    1c8a:	0c 50       	subi	r16, 0x0C	; 12
    1c8c:	11 09       	sbc	r17, r1
    1c8e:	c8 01       	movw	r24, r16
    1c90:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    1c94:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c96:	90 91 64 2c 	lds	r25, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    1c9a:	98 17       	cp	r25, r24
    1c9c:	10 f4       	brcc	.+4      	; 0x1ca2 <xTaskRemoveFromEventList+0x42>
    1c9e:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    1ca2:	bb e0       	ldi	r27, 0x0B	; 11
    1ca4:	8b 9f       	mul	r24, r27
    1ca6:	c0 01       	movw	r24, r0
    1ca8:	11 24       	eor	r1, r1
    1caa:	b8 01       	movw	r22, r16
    1cac:	86 56       	subi	r24, 0x66	; 102
    1cae:	93 4d       	sbci	r25, 0xD3	; 211
    1cb0:	0e 94 83 04 	call	0x906	; 0x906 <vListInsertEnd>
    1cb4:	05 c0       	rjmp	.+10     	; 0x1cc0 <xTaskRemoveFromEventList+0x60>
    1cb6:	b8 01       	movw	r22, r16
    1cb8:	85 e7       	ldi	r24, 0x75	; 117
    1cba:	9c e2       	ldi	r25, 0x2C	; 44
    1cbc:	0e 94 83 04 	call	0x906	; 0x906 <vListInsertEnd>
    1cc0:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1cc4:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1cc8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1cca:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ccc:	89 17       	cp	r24, r25
    1cce:	20 f4       	brcc	.+8      	; 0x1cd8 <xTaskRemoveFromEventList+0x78>
    1cd0:	81 e0       	ldi	r24, 0x01	; 1
    1cd2:	80 93 61 2c 	sts	0x2C61, r24	; 0x802c61 <xYieldPending>
    1cd6:	01 c0       	rjmp	.+2      	; 0x1cda <xTaskRemoveFromEventList+0x7a>
    1cd8:	80 e0       	ldi	r24, 0x00	; 0
    1cda:	df 91       	pop	r29
    1cdc:	cf 91       	pop	r28
    1cde:	1f 91       	pop	r17
    1ce0:	0f 91       	pop	r16
    1ce2:	08 95       	ret

00001ce4 <vTaskRemoveFromUnorderedEventList>:
    1ce4:	0f 93       	push	r16
    1ce6:	1f 93       	push	r17
    1ce8:	cf 93       	push	r28
    1cea:	df 93       	push	r29
    1cec:	70 68       	ori	r23, 0x80	; 128
    1cee:	fc 01       	movw	r30, r24
    1cf0:	40 83       	st	Z, r20
    1cf2:	51 83       	std	Z+1, r21	; 0x01
    1cf4:	62 83       	std	Z+2, r22	; 0x02
    1cf6:	73 83       	std	Z+3, r23	; 0x03
    1cf8:	c0 85       	ldd	r28, Z+8	; 0x08
    1cfa:	d1 85       	ldd	r29, Z+9	; 0x09
    1cfc:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    1d00:	8e 01       	movw	r16, r28
    1d02:	0e 5f       	subi	r16, 0xFE	; 254
    1d04:	1f 4f       	sbci	r17, 0xFF	; 255
    1d06:	c8 01       	movw	r24, r16
    1d08:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    1d0c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d0e:	90 91 64 2c 	lds	r25, 0x2C64	; 0x802c64 <uxTopReadyPriority>
    1d12:	98 17       	cp	r25, r24
    1d14:	10 f4       	brcc	.+4      	; 0x1d1a <vTaskRemoveFromUnorderedEventList+0x36>
    1d16:	80 93 64 2c 	sts	0x2C64, r24	; 0x802c64 <uxTopReadyPriority>
    1d1a:	fb e0       	ldi	r31, 0x0B	; 11
    1d1c:	8f 9f       	mul	r24, r31
    1d1e:	c0 01       	movw	r24, r0
    1d20:	11 24       	eor	r1, r1
    1d22:	b8 01       	movw	r22, r16
    1d24:	86 56       	subi	r24, 0x66	; 102
    1d26:	93 4d       	sbci	r25, 0xD3	; 211
    1d28:	0e 94 83 04 	call	0x906	; 0x906 <vListInsertEnd>
    1d2c:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1d30:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1d34:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d36:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d38:	89 17       	cp	r24, r25
    1d3a:	18 f4       	brcc	.+6      	; 0x1d42 <vTaskRemoveFromUnorderedEventList+0x5e>
    1d3c:	81 e0       	ldi	r24, 0x01	; 1
    1d3e:	80 93 61 2c 	sts	0x2C61, r24	; 0x802c61 <xYieldPending>
    1d42:	df 91       	pop	r29
    1d44:	cf 91       	pop	r28
    1d46:	1f 91       	pop	r17
    1d48:	0f 91       	pop	r16
    1d4a:	08 95       	ret

00001d4c <vTaskInternalSetTimeOutState>:
    1d4c:	20 91 60 2c 	lds	r18, 0x2C60	; 0x802c60 <xNumOfOverflows>
    1d50:	fc 01       	movw	r30, r24
    1d52:	20 83       	st	Z, r18
    1d54:	40 91 65 2c 	lds	r20, 0x2C65	; 0x802c65 <xTickCount>
    1d58:	50 91 66 2c 	lds	r21, 0x2C66	; 0x802c66 <xTickCount+0x1>
    1d5c:	60 91 67 2c 	lds	r22, 0x2C67	; 0x802c67 <xTickCount+0x2>
    1d60:	70 91 68 2c 	lds	r23, 0x2C68	; 0x802c68 <xTickCount+0x3>
    1d64:	41 83       	std	Z+1, r20	; 0x01
    1d66:	52 83       	std	Z+2, r21	; 0x02
    1d68:	63 83       	std	Z+3, r22	; 0x03
    1d6a:	74 83       	std	Z+4, r23	; 0x04
    1d6c:	08 95       	ret

00001d6e <xTaskCheckForTimeOut>:
    1d6e:	cf 92       	push	r12
    1d70:	df 92       	push	r13
    1d72:	ef 92       	push	r14
    1d74:	ff 92       	push	r15
    1d76:	0f 93       	push	r16
    1d78:	1f 93       	push	r17
    1d7a:	cf 93       	push	r28
    1d7c:	df 93       	push	r29
    1d7e:	db 01       	movw	r26, r22
    1d80:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d84:	ff 93       	push	r31
    1d86:	f8 7f       	andi	r31, 0xF8	; 248
    1d88:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1d8c:	40 91 65 2c 	lds	r20, 0x2C65	; 0x802c65 <xTickCount>
    1d90:	50 91 66 2c 	lds	r21, 0x2C66	; 0x802c66 <xTickCount+0x1>
    1d94:	60 91 67 2c 	lds	r22, 0x2C67	; 0x802c67 <xTickCount+0x2>
    1d98:	70 91 68 2c 	lds	r23, 0x2C68	; 0x802c68 <xTickCount+0x3>
    1d9c:	0d 91       	ld	r16, X+
    1d9e:	1d 91       	ld	r17, X+
    1da0:	2d 91       	ld	r18, X+
    1da2:	3c 91       	ld	r19, X
    1da4:	13 97       	sbiw	r26, 0x03	; 3
    1da6:	0f 3f       	cpi	r16, 0xFF	; 255
    1da8:	cf ef       	ldi	r28, 0xFF	; 255
    1daa:	1c 07       	cpc	r17, r28
    1dac:	2c 07       	cpc	r18, r28
    1dae:	3c 07       	cpc	r19, r28
    1db0:	69 f1       	breq	.+90     	; 0x1e0c <xTaskCheckForTimeOut+0x9e>
    1db2:	fc 01       	movw	r30, r24
    1db4:	c1 80       	ldd	r12, Z+1	; 0x01
    1db6:	d2 80       	ldd	r13, Z+2	; 0x02
    1db8:	e3 80       	ldd	r14, Z+3	; 0x03
    1dba:	f4 80       	ldd	r15, Z+4	; 0x04
    1dbc:	e0 91 60 2c 	lds	r30, 0x2C60	; 0x802c60 <xNumOfOverflows>
    1dc0:	ec 01       	movw	r28, r24
    1dc2:	f8 81       	ld	r31, Y
    1dc4:	fe 17       	cp	r31, r30
    1dc6:	29 f0       	breq	.+10     	; 0x1dd2 <xTaskCheckForTimeOut+0x64>
    1dc8:	4c 15       	cp	r20, r12
    1dca:	5d 05       	cpc	r21, r13
    1dcc:	6e 05       	cpc	r22, r14
    1dce:	7f 05       	cpc	r23, r15
    1dd0:	f8 f4       	brcc	.+62     	; 0x1e10 <xTaskCheckForTimeOut+0xa2>
    1dd2:	4c 19       	sub	r20, r12
    1dd4:	5d 09       	sbc	r21, r13
    1dd6:	6e 09       	sbc	r22, r14
    1dd8:	7f 09       	sbc	r23, r15
    1dda:	40 17       	cp	r20, r16
    1ddc:	51 07       	cpc	r21, r17
    1dde:	62 07       	cpc	r22, r18
    1de0:	73 07       	cpc	r23, r19
    1de2:	68 f4       	brcc	.+26     	; 0x1dfe <xTaskCheckForTimeOut+0x90>
    1de4:	fd 01       	movw	r30, r26
    1de6:	04 1b       	sub	r16, r20
    1de8:	15 0b       	sbc	r17, r21
    1dea:	26 0b       	sbc	r18, r22
    1dec:	37 0b       	sbc	r19, r23
    1dee:	00 83       	st	Z, r16
    1df0:	11 83       	std	Z+1, r17	; 0x01
    1df2:	22 83       	std	Z+2, r18	; 0x02
    1df4:	33 83       	std	Z+3, r19	; 0x03
    1df6:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <vTaskInternalSetTimeOutState>
    1dfa:	80 e0       	ldi	r24, 0x00	; 0
    1dfc:	0a c0       	rjmp	.+20     	; 0x1e12 <xTaskCheckForTimeOut+0xa4>
    1dfe:	1d 92       	st	X+, r1
    1e00:	1d 92       	st	X+, r1
    1e02:	1d 92       	st	X+, r1
    1e04:	1c 92       	st	X, r1
    1e06:	13 97       	sbiw	r26, 0x03	; 3
    1e08:	81 e0       	ldi	r24, 0x01	; 1
    1e0a:	03 c0       	rjmp	.+6      	; 0x1e12 <xTaskCheckForTimeOut+0xa4>
    1e0c:	80 e0       	ldi	r24, 0x00	; 0
    1e0e:	01 c0       	rjmp	.+2      	; 0x1e12 <xTaskCheckForTimeOut+0xa4>
    1e10:	81 e0       	ldi	r24, 0x01	; 1
    1e12:	ff 91       	pop	r31
    1e14:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1e18:	df 91       	pop	r29
    1e1a:	cf 91       	pop	r28
    1e1c:	1f 91       	pop	r17
    1e1e:	0f 91       	pop	r16
    1e20:	ff 90       	pop	r15
    1e22:	ef 90       	pop	r14
    1e24:	df 90       	pop	r13
    1e26:	cf 90       	pop	r12
    1e28:	08 95       	ret

00001e2a <vTaskMissedYield>:
    1e2a:	81 e0       	ldi	r24, 0x01	; 1
    1e2c:	80 93 61 2c 	sts	0x2C61, r24	; 0x802c61 <xYieldPending>
    1e30:	08 95       	ret

00001e32 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    1e32:	80 91 63 2c 	lds	r24, 0x2C63	; 0x802c63 <xSchedulerRunning>
    1e36:	88 23       	and	r24, r24
    1e38:	31 f0       	breq	.+12     	; 0x1e46 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1e3a:	80 91 58 2c 	lds	r24, 0x2C58	; 0x802c58 <uxSchedulerSuspended>
    1e3e:	88 23       	and	r24, r24
    1e40:	21 f0       	breq	.+8      	; 0x1e4a <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1e42:	80 e0       	ldi	r24, 0x00	; 0
    1e44:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1e46:	81 e0       	ldi	r24, 0x01	; 1
    1e48:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    1e4a:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    1e4c:	08 95       	ret

00001e4e <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    1e4e:	cf 92       	push	r12
    1e50:	df 92       	push	r13
    1e52:	ef 92       	push	r14
    1e54:	ff 92       	push	r15
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1e56:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1e5a:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1e5e:	66 85       	ldd	r22, Z+14	; 0x0e
    1e60:	77 85       	ldd	r23, Z+15	; 0x0f
    1e62:	80 89       	ldd	r24, Z+16	; 0x10
    1e64:	91 89       	ldd	r25, Z+17	; 0x11

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e66:	e0 91 c6 2c 	lds	r30, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1e6a:	f0 91 c7 2c 	lds	r31, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1e6e:	a0 91 c6 2c 	lds	r26, 0x2CC6	; 0x802cc6 <pxCurrentTCB>
    1e72:	b0 91 c7 2c 	lds	r27, 0x2CC7	; 0x802cc7 <pxCurrentTCB+0x1>
    1e76:	5a 96       	adiw	r26, 0x1a	; 26
    1e78:	2c 91       	ld	r18, X
    1e7a:	c1 2c       	mov	r12, r1
    1e7c:	d1 2c       	mov	r13, r1
    1e7e:	76 01       	movw	r14, r12
    1e80:	68 94       	set
    1e82:	c2 f8       	bld	r12, 2
    1e84:	c2 1a       	sub	r12, r18
    1e86:	d1 08       	sbc	r13, r1
    1e88:	e1 08       	sbc	r14, r1
    1e8a:	f1 08       	sbc	r15, r1
    1e8c:	c6 86       	std	Z+14, r12	; 0x0e
    1e8e:	d7 86       	std	Z+15, r13	; 0x0f
    1e90:	e0 8a       	std	Z+16, r14	; 0x10
    1e92:	f1 8a       	std	Z+17, r15	; 0x11

	return uxReturn;
}
    1e94:	ff 90       	pop	r15
    1e96:	ef 90       	pop	r14
    1e98:	df 90       	pop	r13
    1e9a:	cf 90       	pop	r12
    1e9c:	08 95       	ret

00001e9e <prvInsertTimerInActiveList>:

	taskENTER_CRITICAL();
	{
		pxTimer->pvTimerID = pvNewID;
	}
	taskEXIT_CRITICAL();
    1e9e:	cf 92       	push	r12
    1ea0:	df 92       	push	r13
    1ea2:	ef 92       	push	r14
    1ea4:	ff 92       	push	r15
    1ea6:	0f 93       	push	r16
    1ea8:	1f 93       	push	r17
    1eaa:	fc 01       	movw	r30, r24
    1eac:	42 83       	std	Z+2, r20	; 0x02
    1eae:	53 83       	std	Z+3, r21	; 0x03
    1eb0:	64 83       	std	Z+4, r22	; 0x04
    1eb2:	75 83       	std	Z+5, r23	; 0x05
    1eb4:	82 87       	std	Z+10, r24	; 0x0a
    1eb6:	93 87       	std	Z+11, r25	; 0x0b
    1eb8:	04 17       	cp	r16, r20
    1eba:	15 07       	cpc	r17, r21
    1ebc:	26 07       	cpc	r18, r22
    1ebe:	37 07       	cpc	r19, r23
    1ec0:	c0 f0       	brcs	.+48     	; 0x1ef2 <prvInsertTimerInActiveList+0x54>
    1ec2:	0c 19       	sub	r16, r12
    1ec4:	1d 09       	sbc	r17, r13
    1ec6:	2e 09       	sbc	r18, r14
    1ec8:	3f 09       	sbc	r19, r15
    1eca:	86 85       	ldd	r24, Z+14	; 0x0e
    1ecc:	97 85       	ldd	r25, Z+15	; 0x0f
    1ece:	a0 89       	ldd	r26, Z+16	; 0x10
    1ed0:	b1 89       	ldd	r27, Z+17	; 0x11
    1ed2:	08 17       	cp	r16, r24
    1ed4:	19 07       	cpc	r17, r25
    1ed6:	2a 07       	cpc	r18, r26
    1ed8:	3b 07       	cpc	r19, r27
    1eda:	00 f5       	brcc	.+64     	; 0x1f1c <prvInsertTimerInActiveList+0x7e>
    1edc:	bf 01       	movw	r22, r30
    1ede:	6e 5f       	subi	r22, 0xFE	; 254
    1ee0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ee2:	80 91 d0 2c 	lds	r24, 0x2CD0	; 0x802cd0 <pxOverflowTimerList>
    1ee6:	90 91 d1 2c 	lds	r25, 0x2CD1	; 0x802cd1 <pxOverflowTimerList+0x1>
    1eea:	0e 94 a4 04 	call	0x948	; 0x948 <vListInsert>
    1eee:	80 e0       	ldi	r24, 0x00	; 0
    1ef0:	18 c0       	rjmp	.+48     	; 0x1f22 <prvInsertTimerInActiveList+0x84>
    1ef2:	0c 15       	cp	r16, r12
    1ef4:	1d 05       	cpc	r17, r13
    1ef6:	2e 05       	cpc	r18, r14
    1ef8:	3f 05       	cpc	r19, r15
    1efa:	28 f4       	brcc	.+10     	; 0x1f06 <prvInsertTimerInActiveList+0x68>
    1efc:	4c 15       	cp	r20, r12
    1efe:	5d 05       	cpc	r21, r13
    1f00:	6e 05       	cpc	r22, r14
    1f02:	7f 05       	cpc	r23, r15
    1f04:	68 f4       	brcc	.+26     	; 0x1f20 <prvInsertTimerInActiveList+0x82>
    1f06:	bf 01       	movw	r22, r30
    1f08:	6e 5f       	subi	r22, 0xFE	; 254
    1f0a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f0c:	80 91 d2 2c 	lds	r24, 0x2CD2	; 0x802cd2 <pxCurrentTimerList>
    1f10:	90 91 d3 2c 	lds	r25, 0x2CD3	; 0x802cd3 <pxCurrentTimerList+0x1>
    1f14:	0e 94 a4 04 	call	0x948	; 0x948 <vListInsert>
    1f18:	80 e0       	ldi	r24, 0x00	; 0
    1f1a:	03 c0       	rjmp	.+6      	; 0x1f22 <prvInsertTimerInActiveList+0x84>
    1f1c:	81 e0       	ldi	r24, 0x01	; 1
    1f1e:	01 c0       	rjmp	.+2      	; 0x1f22 <prvInsertTimerInActiveList+0x84>
    1f20:	81 e0       	ldi	r24, 0x01	; 1
    1f22:	1f 91       	pop	r17
    1f24:	0f 91       	pop	r16
    1f26:	ff 90       	pop	r15
    1f28:	ef 90       	pop	r14
    1f2a:	df 90       	pop	r13
    1f2c:	cf 90       	pop	r12
    1f2e:	08 95       	ret

00001f30 <prvCheckForValidListAndQueue>:
    1f30:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f34:	ff 93       	push	r31
    1f36:	f8 7f       	andi	r31, 0xF8	; 248
    1f38:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f3c:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    1f40:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    1f44:	89 2b       	or	r24, r25
    1f46:	e9 f4       	brne	.+58     	; 0x1f82 <prvCheckForValidListAndQueue+0x52>
    1f48:	8f ed       	ldi	r24, 0xDF	; 223
    1f4a:	9c e2       	ldi	r25, 0x2C	; 44
    1f4c:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
    1f50:	84 ed       	ldi	r24, 0xD4	; 212
    1f52:	9c e2       	ldi	r25, 0x2C	; 44
    1f54:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vListInitialise>
    1f58:	8f ed       	ldi	r24, 0xDF	; 223
    1f5a:	9c e2       	ldi	r25, 0x2C	; 44
    1f5c:	80 93 d2 2c 	sts	0x2CD2, r24	; 0x802cd2 <pxCurrentTimerList>
    1f60:	90 93 d3 2c 	sts	0x2CD3, r25	; 0x802cd3 <pxCurrentTimerList+0x1>
    1f64:	84 ed       	ldi	r24, 0xD4	; 212
    1f66:	9c e2       	ldi	r25, 0x2C	; 44
    1f68:	80 93 d0 2c 	sts	0x2CD0, r24	; 0x802cd0 <pxOverflowTimerList>
    1f6c:	90 93 d1 2c 	sts	0x2CD1, r25	; 0x802cd1 <pxOverflowTimerList+0x1>
    1f70:	40 e0       	ldi	r20, 0x00	; 0
    1f72:	69 e0       	ldi	r22, 0x09	; 9
    1f74:	85 e0       	ldi	r24, 0x05	; 5
    1f76:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <xQueueGenericCreate>
    1f7a:	80 93 ce 2c 	sts	0x2CCE, r24	; 0x802cce <xTimerQueue>
    1f7e:	90 93 cf 2c 	sts	0x2CCF, r25	; 0x802ccf <xTimerQueue+0x1>
    1f82:	ff 91       	pop	r31
    1f84:	f0 93 a2 00 	sts	0x00A2, r31	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
    1f88:	08 95       	ret

00001f8a <xTimerCreateTimerTask>:
    1f8a:	ef 92       	push	r14
    1f8c:	ff 92       	push	r15
    1f8e:	0f 93       	push	r16
    1f90:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <prvCheckForValidListAndQueue>
    1f94:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    1f98:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    1f9c:	89 2b       	or	r24, r25
    1f9e:	91 f0       	breq	.+36     	; 0x1fc4 <xTimerCreateTimerTask+0x3a>
    1fa0:	0f 2e       	mov	r0, r31
    1fa2:	fc ec       	ldi	r31, 0xCC	; 204
    1fa4:	ef 2e       	mov	r14, r31
    1fa6:	fc e2       	ldi	r31, 0x2C	; 44
    1fa8:	ff 2e       	mov	r15, r31
    1faa:	f0 2d       	mov	r31, r0
    1fac:	03 e0       	ldi	r16, 0x03	; 3
    1fae:	20 e0       	ldi	r18, 0x00	; 0
    1fb0:	30 e0       	ldi	r19, 0x00	; 0
    1fb2:	48 ec       	ldi	r20, 0xC8	; 200
    1fb4:	50 e0       	ldi	r21, 0x00	; 0
    1fb6:	6a e0       	ldi	r22, 0x0A	; 10
    1fb8:	70 e2       	ldi	r23, 0x20	; 32
    1fba:	88 ed       	ldi	r24, 0xD8	; 216
    1fbc:	90 e1       	ldi	r25, 0x10	; 16
    1fbe:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <xTaskCreate>
    1fc2:	01 c0       	rjmp	.+2      	; 0x1fc6 <xTimerCreateTimerTask+0x3c>
    1fc4:	80 e0       	ldi	r24, 0x00	; 0
    1fc6:	0f 91       	pop	r16
    1fc8:	ff 90       	pop	r15
    1fca:	ef 90       	pop	r14
    1fcc:	08 95       	ret

00001fce <xTimerGenericCommand>:
    1fce:	8f 92       	push	r8
    1fd0:	9f 92       	push	r9
    1fd2:	af 92       	push	r10
    1fd4:	bf 92       	push	r11
    1fd6:	cf 92       	push	r12
    1fd8:	df 92       	push	r13
    1fda:	ef 92       	push	r14
    1fdc:	ff 92       	push	r15
    1fde:	0f 93       	push	r16
    1fe0:	1f 93       	push	r17
    1fe2:	cf 93       	push	r28
    1fe4:	df 93       	push	r29
    1fe6:	cd b7       	in	r28, 0x3d	; 61
    1fe8:	de b7       	in	r29, 0x3e	; 62
    1fea:	29 97       	sbiw	r28, 0x09	; 9
    1fec:	cd bf       	out	0x3d, r28	; 61
    1fee:	de bf       	out	0x3e, r29	; 62
    1ff0:	e0 91 ce 2c 	lds	r30, 0x2CCE	; 0x802cce <xTimerQueue>
    1ff4:	f0 91 cf 2c 	lds	r31, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    1ff8:	30 97       	sbiw	r30, 0x00	; 0
    1ffa:	89 f1       	breq	.+98     	; 0x205e <xTimerGenericCommand+0x90>
    1ffc:	69 83       	std	Y+1, r22	; 0x01
    1ffe:	2a 83       	std	Y+2, r18	; 0x02
    2000:	3b 83       	std	Y+3, r19	; 0x03
    2002:	4c 83       	std	Y+4, r20	; 0x04
    2004:	5d 83       	std	Y+5, r21	; 0x05
    2006:	8e 83       	std	Y+6, r24	; 0x06
    2008:	9f 83       	std	Y+7, r25	; 0x07
    200a:	66 30       	cpi	r22, 0x06	; 6
    200c:	fc f4       	brge	.+62     	; 0x204c <xTimerGenericCommand+0x7e>
    200e:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <xTaskGetSchedulerState>
    2012:	82 30       	cpi	r24, 0x02	; 2
    2014:	69 f4       	brne	.+26     	; 0x2030 <xTimerGenericCommand+0x62>
    2016:	00 e0       	ldi	r16, 0x00	; 0
    2018:	a7 01       	movw	r20, r14
    201a:	96 01       	movw	r18, r12
    201c:	be 01       	movw	r22, r28
    201e:	6f 5f       	subi	r22, 0xFF	; 255
    2020:	7f 4f       	sbci	r23, 0xFF	; 255
    2022:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    2026:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    202a:	0e 94 02 08 	call	0x1004	; 0x1004 <xQueueGenericSend>
    202e:	18 c0       	rjmp	.+48     	; 0x2060 <xTimerGenericCommand+0x92>
    2030:	00 e0       	ldi	r16, 0x00	; 0
    2032:	20 e0       	ldi	r18, 0x00	; 0
    2034:	30 e0       	ldi	r19, 0x00	; 0
    2036:	a9 01       	movw	r20, r18
    2038:	be 01       	movw	r22, r28
    203a:	6f 5f       	subi	r22, 0xFF	; 255
    203c:	7f 4f       	sbci	r23, 0xFF	; 255
    203e:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    2042:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    2046:	0e 94 02 08 	call	0x1004	; 0x1004 <xQueueGenericSend>
    204a:	0a c0       	rjmp	.+20     	; 0x2060 <xTimerGenericCommand+0x92>
    204c:	20 e0       	ldi	r18, 0x00	; 0
    204e:	a8 01       	movw	r20, r16
    2050:	be 01       	movw	r22, r28
    2052:	6f 5f       	subi	r22, 0xFF	; 255
    2054:	7f 4f       	sbci	r23, 0xFF	; 255
    2056:	cf 01       	movw	r24, r30
    2058:	0e 94 a8 08 	call	0x1150	; 0x1150 <xQueueGenericSendFromISR>
    205c:	01 c0       	rjmp	.+2      	; 0x2060 <xTimerGenericCommand+0x92>
    205e:	80 e0       	ldi	r24, 0x00	; 0
    2060:	29 96       	adiw	r28, 0x09	; 9
    2062:	cd bf       	out	0x3d, r28	; 61
    2064:	de bf       	out	0x3e, r29	; 62
    2066:	df 91       	pop	r29
    2068:	cf 91       	pop	r28
    206a:	1f 91       	pop	r17
    206c:	0f 91       	pop	r16
    206e:	ff 90       	pop	r15
    2070:	ef 90       	pop	r14
    2072:	df 90       	pop	r13
    2074:	cf 90       	pop	r12
    2076:	bf 90       	pop	r11
    2078:	af 90       	pop	r10
    207a:	9f 90       	pop	r9
    207c:	8f 90       	pop	r8
    207e:	08 95       	ret

00002080 <prvSampleTimeNow>:
    2080:	2f 92       	push	r2
    2082:	3f 92       	push	r3
    2084:	4f 92       	push	r4
    2086:	5f 92       	push	r5
    2088:	6f 92       	push	r6
    208a:	7f 92       	push	r7
    208c:	8f 92       	push	r8
    208e:	9f 92       	push	r9
    2090:	af 92       	push	r10
    2092:	bf 92       	push	r11
    2094:	cf 92       	push	r12
    2096:	df 92       	push	r13
    2098:	ef 92       	push	r14
    209a:	ff 92       	push	r15
    209c:	0f 93       	push	r16
    209e:	1f 93       	push	r17
    20a0:	cf 93       	push	r28
    20a2:	df 93       	push	r29
    20a4:	1c 01       	movw	r2, r24
    20a6:	0e 94 c1 0b 	call	0x1782	; 0x1782 <xTaskGetTickCount>
    20aa:	2b 01       	movw	r4, r22
    20ac:	3c 01       	movw	r6, r24
    20ae:	80 91 c8 2c 	lds	r24, 0x2CC8	; 0x802cc8 <xLastTime.4745>
    20b2:	90 91 c9 2c 	lds	r25, 0x2CC9	; 0x802cc9 <xLastTime.4745+0x1>
    20b6:	a0 91 ca 2c 	lds	r26, 0x2CCA	; 0x802cca <xLastTime.4745+0x2>
    20ba:	b0 91 cb 2c 	lds	r27, 0x2CCB	; 0x802ccb <xLastTime.4745+0x3>
    20be:	48 16       	cp	r4, r24
    20c0:	59 06       	cpc	r5, r25
    20c2:	6a 06       	cpc	r6, r26
    20c4:	7b 06       	cpc	r7, r27
    20c6:	08 f0       	brcs	.+2      	; 0x20ca <prvSampleTimeNow+0x4a>
    20c8:	54 c0       	rjmp	.+168    	; 0x2172 <prvSampleTimeNow+0xf2>
    20ca:	3c c0       	rjmp	.+120    	; 0x2144 <prvSampleTimeNow+0xc4>
    20cc:	07 80       	ldd	r0, Z+7	; 0x07
    20ce:	f0 85       	ldd	r31, Z+8	; 0x08
    20d0:	e0 2d       	mov	r30, r0
    20d2:	80 80       	ld	r8, Z
    20d4:	91 80       	ldd	r9, Z+1	; 0x01
    20d6:	a2 80       	ldd	r10, Z+2	; 0x02
    20d8:	b3 80       	ldd	r11, Z+3	; 0x03
    20da:	c0 85       	ldd	r28, Z+8	; 0x08
    20dc:	d1 85       	ldd	r29, Z+9	; 0x09
    20de:	8e 01       	movw	r16, r28
    20e0:	0e 5f       	subi	r16, 0xFE	; 254
    20e2:	1f 4f       	sbci	r17, 0xFF	; 255
    20e4:	c8 01       	movw	r24, r16
    20e6:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    20ea:	ed 89       	ldd	r30, Y+21	; 0x15
    20ec:	fe 89       	ldd	r31, Y+22	; 0x16
    20ee:	ce 01       	movw	r24, r28
    20f0:	19 95       	eicall
    20f2:	8a 89       	ldd	r24, Y+18	; 0x12
    20f4:	81 30       	cpi	r24, 0x01	; 1
    20f6:	31 f5       	brne	.+76     	; 0x2144 <prvSampleTimeNow+0xc4>
    20f8:	8e 85       	ldd	r24, Y+14	; 0x0e
    20fa:	9f 85       	ldd	r25, Y+15	; 0x0f
    20fc:	a8 89       	ldd	r26, Y+16	; 0x10
    20fe:	b9 89       	ldd	r27, Y+17	; 0x11
    2100:	88 0d       	add	r24, r8
    2102:	99 1d       	adc	r25, r9
    2104:	aa 1d       	adc	r26, r10
    2106:	bb 1d       	adc	r27, r11
    2108:	88 16       	cp	r8, r24
    210a:	99 06       	cpc	r9, r25
    210c:	aa 06       	cpc	r10, r26
    210e:	bb 06       	cpc	r11, r27
    2110:	70 f4       	brcc	.+28     	; 0x212e <prvSampleTimeNow+0xae>
    2112:	8a 83       	std	Y+2, r24	; 0x02
    2114:	9b 83       	std	Y+3, r25	; 0x03
    2116:	ac 83       	std	Y+4, r26	; 0x04
    2118:	bd 83       	std	Y+5, r27	; 0x05
    211a:	ca 87       	std	Y+10, r28	; 0x0a
    211c:	db 87       	std	Y+11, r29	; 0x0b
    211e:	b8 01       	movw	r22, r16
    2120:	80 91 d2 2c 	lds	r24, 0x2CD2	; 0x802cd2 <pxCurrentTimerList>
    2124:	90 91 d3 2c 	lds	r25, 0x2CD3	; 0x802cd3 <pxCurrentTimerList+0x1>
    2128:	0e 94 a4 04 	call	0x948	; 0x948 <vListInsert>
    212c:	0b c0       	rjmp	.+22     	; 0x2144 <prvSampleTimeNow+0xc4>
    212e:	c1 2c       	mov	r12, r1
    2130:	d1 2c       	mov	r13, r1
    2132:	76 01       	movw	r14, r12
    2134:	00 e0       	ldi	r16, 0x00	; 0
    2136:	10 e0       	ldi	r17, 0x00	; 0
    2138:	a5 01       	movw	r20, r10
    213a:	94 01       	movw	r18, r8
    213c:	60 e0       	ldi	r22, 0x00	; 0
    213e:	ce 01       	movw	r24, r28
    2140:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <xTimerGenericCommand>
    2144:	e0 91 d2 2c 	lds	r30, 0x2CD2	; 0x802cd2 <pxCurrentTimerList>
    2148:	f0 91 d3 2c 	lds	r31, 0x2CD3	; 0x802cd3 <pxCurrentTimerList+0x1>
    214c:	80 81       	ld	r24, Z
    214e:	81 11       	cpse	r24, r1
    2150:	bd cf       	rjmp	.-134    	; 0x20cc <prvSampleTimeNow+0x4c>
    2152:	80 91 d0 2c 	lds	r24, 0x2CD0	; 0x802cd0 <pxOverflowTimerList>
    2156:	90 91 d1 2c 	lds	r25, 0x2CD1	; 0x802cd1 <pxOverflowTimerList+0x1>
    215a:	80 93 d2 2c 	sts	0x2CD2, r24	; 0x802cd2 <pxCurrentTimerList>
    215e:	90 93 d3 2c 	sts	0x2CD3, r25	; 0x802cd3 <pxCurrentTimerList+0x1>
    2162:	e0 93 d0 2c 	sts	0x2CD0, r30	; 0x802cd0 <pxOverflowTimerList>
    2166:	f0 93 d1 2c 	sts	0x2CD1, r31	; 0x802cd1 <pxOverflowTimerList+0x1>
    216a:	81 e0       	ldi	r24, 0x01	; 1
    216c:	f1 01       	movw	r30, r2
    216e:	80 83       	st	Z, r24
    2170:	02 c0       	rjmp	.+4      	; 0x2176 <prvSampleTimeNow+0xf6>
    2172:	f1 01       	movw	r30, r2
    2174:	10 82       	st	Z, r1
    2176:	40 92 c8 2c 	sts	0x2CC8, r4	; 0x802cc8 <xLastTime.4745>
    217a:	50 92 c9 2c 	sts	0x2CC9, r5	; 0x802cc9 <xLastTime.4745+0x1>
    217e:	60 92 ca 2c 	sts	0x2CCA, r6	; 0x802cca <xLastTime.4745+0x2>
    2182:	70 92 cb 2c 	sts	0x2CCB, r7	; 0x802ccb <xLastTime.4745+0x3>
    2186:	c3 01       	movw	r24, r6
    2188:	b2 01       	movw	r22, r4
    218a:	df 91       	pop	r29
    218c:	cf 91       	pop	r28
    218e:	1f 91       	pop	r17
    2190:	0f 91       	pop	r16
    2192:	ff 90       	pop	r15
    2194:	ef 90       	pop	r14
    2196:	df 90       	pop	r13
    2198:	cf 90       	pop	r12
    219a:	bf 90       	pop	r11
    219c:	af 90       	pop	r10
    219e:	9f 90       	pop	r9
    21a0:	8f 90       	pop	r8
    21a2:	7f 90       	pop	r7
    21a4:	6f 90       	pop	r6
    21a6:	5f 90       	pop	r5
    21a8:	4f 90       	pop	r4
    21aa:	3f 90       	pop	r3
    21ac:	2f 90       	pop	r2
    21ae:	08 95       	ret

000021b0 <prvTimerTask>:
    21b0:	cf 93       	push	r28
    21b2:	df 93       	push	r29
    21b4:	cd b7       	in	r28, 0x3d	; 61
    21b6:	de b7       	in	r29, 0x3e	; 62
    21b8:	2e 97       	sbiw	r28, 0x0e	; 14
    21ba:	cd bf       	out	0x3d, r28	; 61
    21bc:	de bf       	out	0x3e, r29	; 62
    21be:	ce 01       	movw	r24, r28
    21c0:	01 96       	adiw	r24, 0x01	; 1
    21c2:	1c 01       	movw	r2, r24
    21c4:	a8 2e       	mov	r10, r24
    21c6:	b3 2c       	mov	r11, r3
    21c8:	e0 91 d2 2c 	lds	r30, 0x2CD2	; 0x802cd2 <pxCurrentTimerList>
    21cc:	f0 91 d3 2c 	lds	r31, 0x2CD3	; 0x802cd3 <pxCurrentTimerList+0x1>
    21d0:	80 81       	ld	r24, Z
    21d2:	88 23       	and	r24, r24
    21d4:	09 f4       	brne	.+2      	; 0x21d8 <prvTimerTask+0x28>
    21d6:	03 c1       	rjmp	.+518    	; 0x23de <prvTimerTask+0x22e>
    21d8:	07 80       	ldd	r0, Z+7	; 0x07
    21da:	f0 85       	ldd	r31, Z+8	; 0x08
    21dc:	e0 2d       	mov	r30, r0
    21de:	40 80       	ld	r4, Z
    21e0:	51 80       	ldd	r5, Z+1	; 0x01
    21e2:	62 80       	ldd	r6, Z+2	; 0x02
    21e4:	73 80       	ldd	r7, Z+3	; 0x03
    21e6:	0e 94 bb 0b 	call	0x1776	; 0x1776 <vTaskSuspendAll>
    21ea:	c1 01       	movw	r24, r2
    21ec:	0e 94 40 10 	call	0x2080	; 0x2080 <prvSampleTimeNow>
    21f0:	6b 87       	std	Y+11, r22	; 0x0b
    21f2:	7c 87       	std	Y+12, r23	; 0x0c
    21f4:	8d 87       	std	Y+13, r24	; 0x0d
    21f6:	9e 87       	std	Y+14, r25	; 0x0e
    21f8:	89 81       	ldd	r24, Y+1	; 0x01
    21fa:	81 11       	cpse	r24, r1
    21fc:	5e c0       	rjmp	.+188    	; 0x22ba <prvTimerTask+0x10a>
    21fe:	8b 85       	ldd	r24, Y+11	; 0x0b
    2200:	9c 85       	ldd	r25, Y+12	; 0x0c
    2202:	ad 85       	ldd	r26, Y+13	; 0x0d
    2204:	be 85       	ldd	r27, Y+14	; 0x0e
    2206:	84 15       	cp	r24, r4
    2208:	95 05       	cpc	r25, r5
    220a:	a6 05       	cpc	r26, r6
    220c:	b7 05       	cpc	r27, r7
    220e:	e8 f1       	brcs	.+122    	; 0x228a <prvTimerTask+0xda>
    2210:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
    2214:	e0 91 d2 2c 	lds	r30, 0x2CD2	; 0x802cd2 <pxCurrentTimerList>
    2218:	f0 91 d3 2c 	lds	r31, 0x2CD3	; 0x802cd3 <pxCurrentTimerList+0x1>
    221c:	07 80       	ldd	r0, Z+7	; 0x07
    221e:	f0 85       	ldd	r31, Z+8	; 0x08
    2220:	e0 2d       	mov	r30, r0
    2222:	80 84       	ldd	r8, Z+8	; 0x08
    2224:	91 84       	ldd	r9, Z+9	; 0x09
    2226:	c4 01       	movw	r24, r8
    2228:	02 96       	adiw	r24, 0x02	; 2
    222a:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    222e:	d4 01       	movw	r26, r8
    2230:	52 96       	adiw	r26, 0x12	; 18
    2232:	8c 91       	ld	r24, X
    2234:	52 97       	sbiw	r26, 0x12	; 18
    2236:	81 30       	cpi	r24, 0x01	; 1
    2238:	01 f5       	brne	.+64     	; 0x227a <prvTimerTask+0xca>
    223a:	1e 96       	adiw	r26, 0x0e	; 14
    223c:	4d 91       	ld	r20, X+
    223e:	5d 91       	ld	r21, X+
    2240:	6d 91       	ld	r22, X+
    2242:	7c 91       	ld	r23, X
    2244:	51 97       	sbiw	r26, 0x11	; 17
    2246:	44 0d       	add	r20, r4
    2248:	55 1d       	adc	r21, r5
    224a:	66 1d       	adc	r22, r6
    224c:	77 1d       	adc	r23, r7
    224e:	73 01       	movw	r14, r6
    2250:	62 01       	movw	r12, r4
    2252:	0b 85       	ldd	r16, Y+11	; 0x0b
    2254:	1c 85       	ldd	r17, Y+12	; 0x0c
    2256:	2d 85       	ldd	r18, Y+13	; 0x0d
    2258:	3e 85       	ldd	r19, Y+14	; 0x0e
    225a:	c4 01       	movw	r24, r8
    225c:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <prvInsertTimerInActiveList>
    2260:	88 23       	and	r24, r24
    2262:	59 f0       	breq	.+22     	; 0x227a <prvTimerTask+0xca>
    2264:	c1 2c       	mov	r12, r1
    2266:	d1 2c       	mov	r13, r1
    2268:	76 01       	movw	r14, r12
    226a:	00 e0       	ldi	r16, 0x00	; 0
    226c:	10 e0       	ldi	r17, 0x00	; 0
    226e:	a3 01       	movw	r20, r6
    2270:	92 01       	movw	r18, r4
    2272:	60 e0       	ldi	r22, 0x00	; 0
    2274:	c4 01       	movw	r24, r8
    2276:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <xTimerGenericCommand>
    227a:	d4 01       	movw	r26, r8
    227c:	55 96       	adiw	r26, 0x15	; 21
    227e:	ed 91       	ld	r30, X+
    2280:	fc 91       	ld	r31, X
    2282:	56 97       	sbiw	r26, 0x16	; 22
    2284:	c4 01       	movw	r24, r8
    2286:	19 95       	eicall
    2288:	9c c0       	rjmp	.+312    	; 0x23c2 <prvTimerTask+0x212>
    228a:	20 e0       	ldi	r18, 0x00	; 0
    228c:	b3 01       	movw	r22, r6
    228e:	a2 01       	movw	r20, r4
    2290:	8b 85       	ldd	r24, Y+11	; 0x0b
    2292:	9c 85       	ldd	r25, Y+12	; 0x0c
    2294:	ad 85       	ldd	r26, Y+13	; 0x0d
    2296:	be 85       	ldd	r27, Y+14	; 0x0e
    2298:	48 1b       	sub	r20, r24
    229a:	59 0b       	sbc	r21, r25
    229c:	6a 0b       	sbc	r22, r26
    229e:	7b 0b       	sbc	r23, r27
    22a0:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    22a4:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    22a8:	0e 94 9f 09 	call	0x133e	; 0x133e <vQueueWaitForMessageRestricted>
    22ac:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
    22b0:	81 11       	cpse	r24, r1
    22b2:	87 c0       	rjmp	.+270    	; 0x23c2 <prvTimerTask+0x212>
    22b4:	0e 94 cc 05 	call	0xb98	; 0xb98 <vPortYield>
    22b8:	84 c0       	rjmp	.+264    	; 0x23c2 <prvTimerTask+0x212>
    22ba:	0e 94 a6 0c 	call	0x194c	; 0x194c <xTaskResumeAll>
    22be:	81 c0       	rjmp	.+258    	; 0x23c2 <prvTimerTask+0x212>
    22c0:	89 81       	ldd	r24, Y+1	; 0x01
    22c2:	88 23       	and	r24, r24
    22c4:	6c f4       	brge	.+26     	; 0x22e0 <prvTimerTask+0x130>
    22c6:	4e 81       	ldd	r20, Y+6	; 0x06
    22c8:	5f 81       	ldd	r21, Y+7	; 0x07
    22ca:	68 85       	ldd	r22, Y+8	; 0x08
    22cc:	79 85       	ldd	r23, Y+9	; 0x09
    22ce:	ea 81       	ldd	r30, Y+2	; 0x02
    22d0:	fb 81       	ldd	r31, Y+3	; 0x03
    22d2:	8c 81       	ldd	r24, Y+4	; 0x04
    22d4:	9d 81       	ldd	r25, Y+5	; 0x05
    22d6:	19 95       	eicall
    22d8:	89 81       	ldd	r24, Y+1	; 0x01
    22da:	88 23       	and	r24, r24
    22dc:	0c f4       	brge	.+2      	; 0x22e0 <prvTimerTask+0x130>
    22de:	71 c0       	rjmp	.+226    	; 0x23c2 <prvTimerTask+0x212>
    22e0:	8e 80       	ldd	r8, Y+6	; 0x06
    22e2:	9f 80       	ldd	r9, Y+7	; 0x07
    22e4:	d4 01       	movw	r26, r8
    22e6:	1c 96       	adiw	r26, 0x0c	; 12
    22e8:	8d 91       	ld	r24, X+
    22ea:	9c 91       	ld	r25, X
    22ec:	1d 97       	sbiw	r26, 0x0d	; 13
    22ee:	89 2b       	or	r24, r25
    22f0:	21 f0       	breq	.+8      	; 0x22fa <prvTimerTask+0x14a>
    22f2:	c4 01       	movw	r24, r8
    22f4:	02 96       	adiw	r24, 0x02	; 2
    22f6:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <uxListRemove>
    22fa:	ce 01       	movw	r24, r28
    22fc:	0a 96       	adiw	r24, 0x0a	; 10
    22fe:	0e 94 40 10 	call	0x2080	; 0x2080 <prvSampleTimeNow>
    2302:	8b 01       	movw	r16, r22
    2304:	9c 01       	movw	r18, r24
    2306:	89 81       	ldd	r24, Y+1	; 0x01
    2308:	08 2e       	mov	r0, r24
    230a:	00 0c       	add	r0, r0
    230c:	99 0b       	sbc	r25, r25
    230e:	aa 0b       	sbc	r26, r26
    2310:	bb 0b       	sbc	r27, r27
    2312:	8a 30       	cpi	r24, 0x0A	; 10
    2314:	91 05       	cpc	r25, r1
    2316:	08 f0       	brcs	.+2      	; 0x231a <prvTimerTask+0x16a>
    2318:	54 c0       	rjmp	.+168    	; 0x23c2 <prvTimerTask+0x212>
    231a:	fc 01       	movw	r30, r24
    231c:	88 27       	eor	r24, r24
    231e:	e2 50       	subi	r30, 0x02	; 2
    2320:	ff 4f       	sbci	r31, 0xFF	; 255
    2322:	8f 4f       	sbci	r24, 0xFF	; 255
    2324:	0c 94 90 1f 	jmp	0x3f20	; 0x3f20 <__tablejump2__>
    2328:	ca 80       	ldd	r12, Y+2	; 0x02
    232a:	db 80       	ldd	r13, Y+3	; 0x03
    232c:	ec 80       	ldd	r14, Y+4	; 0x04
    232e:	fd 80       	ldd	r15, Y+5	; 0x05
    2330:	f4 01       	movw	r30, r8
    2332:	46 85       	ldd	r20, Z+14	; 0x0e
    2334:	57 85       	ldd	r21, Z+15	; 0x0f
    2336:	60 89       	ldd	r22, Z+16	; 0x10
    2338:	71 89       	ldd	r23, Z+17	; 0x11
    233a:	4c 0d       	add	r20, r12
    233c:	5d 1d       	adc	r21, r13
    233e:	6e 1d       	adc	r22, r14
    2340:	7f 1d       	adc	r23, r15
    2342:	c4 01       	movw	r24, r8
    2344:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <prvInsertTimerInActiveList>
    2348:	88 23       	and	r24, r24
    234a:	d9 f1       	breq	.+118    	; 0x23c2 <prvTimerTask+0x212>
    234c:	d4 01       	movw	r26, r8
    234e:	55 96       	adiw	r26, 0x15	; 21
    2350:	ed 91       	ld	r30, X+
    2352:	fc 91       	ld	r31, X
    2354:	56 97       	sbiw	r26, 0x16	; 22
    2356:	c4 01       	movw	r24, r8
    2358:	19 95       	eicall
    235a:	f4 01       	movw	r30, r8
    235c:	82 89       	ldd	r24, Z+18	; 0x12
    235e:	81 30       	cpi	r24, 0x01	; 1
    2360:	81 f5       	brne	.+96     	; 0x23c2 <prvTimerTask+0x212>
    2362:	4a 81       	ldd	r20, Y+2	; 0x02
    2364:	5b 81       	ldd	r21, Y+3	; 0x03
    2366:	6c 81       	ldd	r22, Y+4	; 0x04
    2368:	7d 81       	ldd	r23, Y+5	; 0x05
    236a:	86 85       	ldd	r24, Z+14	; 0x0e
    236c:	97 85       	ldd	r25, Z+15	; 0x0f
    236e:	a0 89       	ldd	r26, Z+16	; 0x10
    2370:	b1 89       	ldd	r27, Z+17	; 0x11
    2372:	9a 01       	movw	r18, r20
    2374:	ab 01       	movw	r20, r22
    2376:	28 0f       	add	r18, r24
    2378:	39 1f       	adc	r19, r25
    237a:	4a 1f       	adc	r20, r26
    237c:	5b 1f       	adc	r21, r27
    237e:	c1 2c       	mov	r12, r1
    2380:	d1 2c       	mov	r13, r1
    2382:	76 01       	movw	r14, r12
    2384:	00 e0       	ldi	r16, 0x00	; 0
    2386:	10 e0       	ldi	r17, 0x00	; 0
    2388:	60 e0       	ldi	r22, 0x00	; 0
    238a:	c4 01       	movw	r24, r8
    238c:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <xTimerGenericCommand>
    2390:	18 c0       	rjmp	.+48     	; 0x23c2 <prvTimerTask+0x212>
    2392:	4a 81       	ldd	r20, Y+2	; 0x02
    2394:	5b 81       	ldd	r21, Y+3	; 0x03
    2396:	6c 81       	ldd	r22, Y+4	; 0x04
    2398:	7d 81       	ldd	r23, Y+5	; 0x05
    239a:	d4 01       	movw	r26, r8
    239c:	1e 96       	adiw	r26, 0x0e	; 14
    239e:	4d 93       	st	X+, r20
    23a0:	5d 93       	st	X+, r21
    23a2:	6d 93       	st	X+, r22
    23a4:	7c 93       	st	X, r23
    23a6:	51 97       	sbiw	r26, 0x11	; 17
    23a8:	40 0f       	add	r20, r16
    23aa:	51 1f       	adc	r21, r17
    23ac:	62 1f       	adc	r22, r18
    23ae:	73 1f       	adc	r23, r19
    23b0:	68 01       	movw	r12, r16
    23b2:	79 01       	movw	r14, r18
    23b4:	c4 01       	movw	r24, r8
    23b6:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <prvInsertTimerInActiveList>
    23ba:	03 c0       	rjmp	.+6      	; 0x23c2 <prvTimerTask+0x212>
    23bc:	c4 01       	movw	r24, r8
    23be:	0e 94 6d 04 	call	0x8da	; 0x8da <vPortFree>
    23c2:	20 e0       	ldi	r18, 0x00	; 0
    23c4:	30 e0       	ldi	r19, 0x00	; 0
    23c6:	a9 01       	movw	r20, r18
    23c8:	6a 2d       	mov	r22, r10
    23ca:	7b 2d       	mov	r23, r11
    23cc:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    23d0:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    23d4:	0e 94 ed 08 	call	0x11da	; 0x11da <xQueueReceive>
    23d8:	81 11       	cpse	r24, r1
    23da:	72 cf       	rjmp	.-284    	; 0x22c0 <prvTimerTask+0x110>
    23dc:	f5 ce       	rjmp	.-534    	; 0x21c8 <prvTimerTask+0x18>
    23de:	0e 94 bb 0b 	call	0x1776	; 0x1776 <vTaskSuspendAll>
    23e2:	c1 01       	movw	r24, r2
    23e4:	0e 94 40 10 	call	0x2080	; 0x2080 <prvSampleTimeNow>
    23e8:	6b 87       	std	Y+11, r22	; 0x0b
    23ea:	7c 87       	std	Y+12, r23	; 0x0c
    23ec:	8d 87       	std	Y+13, r24	; 0x0d
    23ee:	9e 87       	std	Y+14, r25	; 0x0e
    23f0:	89 81       	ldd	r24, Y+1	; 0x01
    23f2:	81 11       	cpse	r24, r1
    23f4:	62 cf       	rjmp	.-316    	; 0x22ba <prvTimerTask+0x10a>
    23f6:	e0 91 d0 2c 	lds	r30, 0x2CD0	; 0x802cd0 <pxOverflowTimerList>
    23fa:	f0 91 d1 2c 	lds	r31, 0x2CD1	; 0x802cd1 <pxOverflowTimerList+0x1>
    23fe:	80 81       	ld	r24, Z
    2400:	21 e0       	ldi	r18, 0x01	; 1
    2402:	81 11       	cpse	r24, r1
    2404:	20 e0       	ldi	r18, 0x00	; 0
    2406:	41 2c       	mov	r4, r1
    2408:	51 2c       	mov	r5, r1
    240a:	32 01       	movw	r6, r4
    240c:	3f cf       	rjmp	.-386    	; 0x228c <prvTimerTask+0xdc>

0000240e <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
    240e:	0f 93       	push	r16
    2410:	1f 93       	push	r17
    2412:	cf 93       	push	r28
    2414:	df 93       	push	r29
    2416:	cd b7       	in	r28, 0x3d	; 61
    2418:	de b7       	in	r29, 0x3e	; 62
    241a:	29 97       	sbiw	r28, 0x09	; 9
    241c:	cd bf       	out	0x3d, r28	; 61
    241e:	de bf       	out	0x3e, r29	; 62
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
    2420:	ee ef       	ldi	r30, 0xFE	; 254
    2422:	e9 83       	std	Y+1, r30	; 0x01
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
    2424:	8a 83       	std	Y+2, r24	; 0x02
    2426:	9b 83       	std	Y+3, r25	; 0x03
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
    2428:	6c 83       	std	Y+4, r22	; 0x04
    242a:	7d 83       	std	Y+5, r23	; 0x05
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
    242c:	2e 83       	std	Y+6, r18	; 0x06
    242e:	3f 83       	std	Y+7, r19	; 0x07
    2430:	48 87       	std	Y+8, r20	; 0x08
    2432:	59 87       	std	Y+9, r21	; 0x09

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2434:	20 e0       	ldi	r18, 0x00	; 0
    2436:	a8 01       	movw	r20, r16
    2438:	be 01       	movw	r22, r28
    243a:	6f 5f       	subi	r22, 0xFF	; 255
    243c:	7f 4f       	sbci	r23, 0xFF	; 255
    243e:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <xTimerQueue>
    2442:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <xTimerQueue+0x1>
    2446:	0e 94 a8 08 	call	0x1150	; 0x1150 <xQueueGenericSendFromISR>

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
	}
    244a:	29 96       	adiw	r28, 0x09	; 9
    244c:	cd bf       	out	0x3d, r28	; 61
    244e:	de bf       	out	0x3e, r29	; 62
    2450:	df 91       	pop	r29
    2452:	cf 91       	pop	r28
    2454:	1f 91       	pop	r17
    2456:	0f 91       	pop	r16
    2458:	08 95       	ret

0000245a <vInitClock>:
#include "clksys_driver.h"


void vInitClock(void)
{
	CLKSYS_Enable( OSC_RC2MEN_bm );
    245a:	e0 e5       	ldi	r30, 0x50	; 80
    245c:	f0 e0       	ldi	r31, 0x00	; 0
    245e:	80 81       	ld	r24, Z
    2460:	81 60       	ori	r24, 0x01	; 1
    2462:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_RC2MRDY_bm ) == 0 );
    2464:	81 81       	ldd	r24, Z+1	; 0x01
    2466:	80 ff       	sbrs	r24, 0
    2468:	fd cf       	rjmp	.-6      	; 0x2464 <vInitClock+0xa>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_RC2M_gc );
    246a:	80 e0       	ldi	r24, 0x00	; 0
    246c:	0e 94 79 02 	call	0x4f2	; 0x4f2 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_XOSCEN_bm | OSC_PLLEN_bm);
    2470:	8e e1       	ldi	r24, 0x1E	; 30
    2472:	0e 94 69 02 	call	0x4d2	; 0x4d2 <CLKSYS_Disable>
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    2476:	60 e0       	ldi	r22, 0x00	; 0
    2478:	80 e0       	ldi	r24, 0x00	; 0
    247a:	0e 94 73 02 	call	0x4e6	; 0x4e6 <CLKSYS_Prescalers_Config>
	CLKSYS_XOSC_Config( OSC_FRQRANGE_2TO9_gc,false,OSC_XOSCSEL_XTAL_256CLK_gc );
    247e:	43 e0       	ldi	r20, 0x03	; 3
    2480:	60 e0       	ldi	r22, 0x00	; 0
    2482:	80 e4       	ldi	r24, 0x40	; 64
    2484:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <CLKSYS_XOSC_Config>
	CLKSYS_Enable( OSC_XOSCEN_bm );
    2488:	e0 e5       	ldi	r30, 0x50	; 80
    248a:	f0 e0       	ldi	r31, 0x00	; 0
    248c:	80 81       	ld	r24, Z
    248e:	88 60       	ori	r24, 0x08	; 8
    2490:	80 83       	st	Z, r24
	do {} while ( CLKSYS_IsReady( OSC_XOSCRDY_bm ) == 0 );
    2492:	81 81       	ldd	r24, Z+1	; 0x01
    2494:	83 ff       	sbrs	r24, 3
    2496:	fd cf       	rjmp	.-6      	; 0x2492 <vInitClock+0x38>
	CLKSYS_PLL_Config( OSC_PLLSRC_XOSC_gc, 4 );
    2498:	64 e0       	ldi	r22, 0x04	; 4
    249a:	80 ec       	ldi	r24, 0xC0	; 192
    249c:	0e 94 64 02 	call	0x4c8	; 0x4c8 <CLKSYS_PLL_Config>
	CLKSYS_Enable( OSC_PLLEN_bm );
    24a0:	e0 e5       	ldi	r30, 0x50	; 80
    24a2:	f0 e0       	ldi	r31, 0x00	; 0
    24a4:	80 81       	ld	r24, Z
    24a6:	80 61       	ori	r24, 0x10	; 16
    24a8:	80 83       	st	Z, r24
	CLKSYS_Prescalers_Config( CLK_PSADIV_1_gc, CLK_PSBCDIV_1_1_gc );
    24aa:	60 e0       	ldi	r22, 0x00	; 0
    24ac:	80 e0       	ldi	r24, 0x00	; 0
    24ae:	0e 94 73 02 	call	0x4e6	; 0x4e6 <CLKSYS_Prescalers_Config>
	do {} while ( CLKSYS_IsReady( OSC_PLLRDY_bm ) == 0 );
    24b2:	e0 e5       	ldi	r30, 0x50	; 80
    24b4:	f0 e0       	ldi	r31, 0x00	; 0
    24b6:	81 81       	ldd	r24, Z+1	; 0x01
    24b8:	84 ff       	sbrs	r24, 4
    24ba:	fd cf       	rjmp	.-6      	; 0x24b6 <vInitClock+0x5c>
	CLKSYS_Main_ClockSource_Select( CLK_SCLKSEL_PLL_gc );
    24bc:	84 e0       	ldi	r24, 0x04	; 4
    24be:	0e 94 79 02 	call	0x4f2	; 0x4f2 <CLKSYS_Main_ClockSource_Select>
	CLKSYS_Disable( OSC_RC32MEN_bm | OSC_RC2MEN_bm | OSC_RC32KEN_bm);
    24c2:	87 e0       	ldi	r24, 0x07	; 7
    24c4:	0e 94 69 02 	call	0x4d2	; 0x4d2 <CLKSYS_Disable>
    24c8:	08 95       	ret

000024ca <vLedBlink>:
	return 0;
}

void vLedBlink(void *pvParameters) {
	(void) pvParameters;
	PORTF.DIRSET = PIN0_bm; /*LED1*/
    24ca:	e0 ea       	ldi	r30, 0xA0	; 160
    24cc:	f6 e0       	ldi	r31, 0x06	; 6
    24ce:	81 e0       	ldi	r24, 0x01	; 1
    24d0:	81 83       	std	Z+1, r24	; 0x01
	PORTF.OUT = 0x01;
    24d2:	84 83       	std	Z+4, r24	; 0x04
	for(;;) {
		//PORTF.OUTTGL = 0x01;				
		vTaskDelay(100 / portTICK_RATE_MS);
    24d4:	64 e6       	ldi	r22, 0x64	; 100
    24d6:	70 e0       	ldi	r23, 0x00	; 0
    24d8:	80 e0       	ldi	r24, 0x00	; 0
    24da:	90 e0       	ldi	r25, 0x00	; 0
    24dc:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vTaskDelay>
    24e0:	f9 cf       	rjmp	.-14     	; 0x24d4 <vLedBlink+0xa>

000024e2 <vWrite_Display>:
void vWrite_Display(void *pvParameters){
	EventBits_t uxBits;
	for (;;)
	{
			vDisplayClear();
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    24e2:	0f 2e       	mov	r0, r31
    24e4:	f2 e1       	ldi	r31, 0x12	; 18
    24e6:	ef 2e       	mov	r14, r31
    24e8:	f0 e2       	ldi	r31, 0x20	; 32
    24ea:	ff 2e       	mov	r15, r31
    24ec:	f0 2d       	mov	r31, r0
			vDisplayWriteStringAtPos(1,0,"a: %d b: %d",buffer_a[1],buffer_b[1]);
    24ee:	0f 2e       	mov	r0, r31
    24f0:	f0 e1       	ldi	r31, 0x10	; 16
    24f2:	af 2e       	mov	r10, r31
    24f4:	ff e2       	ldi	r31, 0x2F	; 47
    24f6:	bf 2e       	mov	r11, r31
    24f8:	f0 2d       	mov	r31, r0
    24fa:	0f 2e       	mov	r0, r31
    24fc:	f0 e5       	ldi	r31, 0x50	; 80
    24fe:	cf 2e       	mov	r12, r31
    2500:	ff e2       	ldi	r31, 0x2F	; 47
    2502:	df 2e       	mov	r13, r31
    2504:	f0 2d       	mov	r31, r0
    2506:	02 e2       	ldi	r16, 0x22	; 34
    2508:	10 e2       	ldi	r17, 0x20	; 32
    250a:	88 24       	eor	r8, r8
    250c:	83 94       	inc	r8
			vDisplayWriteStringAtPos(2,0,"H: %d L: %d ",high_peak, low_peak);
    250e:	ce e2       	ldi	r28, 0x2E	; 46
    2510:	d0 e2       	ldi	r29, 0x20	; 32
    2512:	68 94       	set
    2514:	99 24       	eor	r9, r9
    2516:	91 f8       	bld	r9, 1
}
void vWrite_Display(void *pvParameters){
	EventBits_t uxBits;
	for (;;)
	{
			vDisplayClear();
    2518:	0e 94 b6 18 	call	0x316c	; 0x316c <vDisplayClear>
			vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    251c:	ff 92       	push	r15
    251e:	ef 92       	push	r14
    2520:	1f 92       	push	r1
    2522:	1f 92       	push	r1
    2524:	1f 92       	push	r1
    2526:	1f 92       	push	r1
    2528:	0e 94 c1 18 	call	0x3182	; 0x3182 <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(1,0,"a: %d b: %d",buffer_a[1],buffer_b[1]);
    252c:	f5 01       	movw	r30, r10
    252e:	91 81       	ldd	r25, Z+1	; 0x01
    2530:	f6 01       	movw	r30, r12
    2532:	81 81       	ldd	r24, Z+1	; 0x01
    2534:	1f 92       	push	r1
    2536:	9f 93       	push	r25
    2538:	1f 92       	push	r1
    253a:	8f 93       	push	r24
    253c:	1f 93       	push	r17
    253e:	0f 93       	push	r16
    2540:	1f 92       	push	r1
    2542:	1f 92       	push	r1
    2544:	1f 92       	push	r1
    2546:	8f 92       	push	r8
    2548:	0e 94 c1 18 	call	0x3182	; 0x3182 <vDisplayWriteStringAtPos>
			vDisplayWriteStringAtPos(2,0,"H: %d L: %d ",high_peak, low_peak);
    254c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <low_peak+0x1>
    2550:	8f 93       	push	r24
    2552:	80 91 01 20 	lds	r24, 0x2001	; 0x802001 <low_peak>
    2556:	8f 93       	push	r24
    2558:	80 91 04 20 	lds	r24, 0x2004	; 0x802004 <high_peak+0x1>
    255c:	8f 93       	push	r24
    255e:	80 91 03 20 	lds	r24, 0x2003	; 0x802003 <high_peak>
    2562:	8f 93       	push	r24
    2564:	df 93       	push	r29
    2566:	cf 93       	push	r28
    2568:	1f 92       	push	r1
    256a:	1f 92       	push	r1
    256c:	1f 92       	push	r1
    256e:	9f 92       	push	r9
    2570:	0e 94 c1 18 	call	0x3182	; 0x3182 <vDisplayWriteStringAtPos>
			//vDisplayWriteStringAtPos(3,0,"Hoi");
			vTaskStartScheduler();
    2574:	0e 94 80 0b 	call	0x1700	; 0x1700 <vTaskStartScheduler>
			vTaskDelay(100 / portTICK_RATE_MS);
    2578:	64 e6       	ldi	r22, 0x64	; 100
    257a:	70 e0       	ldi	r23, 0x00	; 0
    257c:	80 e0       	ldi	r24, 0x00	; 0
    257e:	90 e0       	ldi	r25, 0x00	; 0
    2580:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vTaskDelay>
    2584:	ed b7       	in	r30, 0x3d	; 61
    2586:	fe b7       	in	r31, 0x3e	; 62
    2588:	7a 96       	adiw	r30, 0x1a	; 26
    258a:	ed bf       	out	0x3d, r30	; 61
    258c:	fe bf       	out	0x3e, r31	; 62
    258e:	c4 cf       	rjmp	.-120    	; 0x2518 <vWrite_Display+0x36>

00002590 <vPhase_Detection>:
						 pruef_variable = phase_H;
					 }
					 else
					 {
						//phase ist 0 grad
						 pruef_variable = phase_H/3*4;
    2590:	0f 2e       	mov	r0, r31
    2592:	f3 e0       	ldi	r31, 0x03	; 3
    2594:	6f 2e       	mov	r6, r31
    2596:	71 2c       	mov	r7, r1
    2598:	f0 2d       	mov	r31, r0
								portMAX_DELAY );/* Wait a maximum for either bit to be set. */								

		/*Phase Detection Buffer A*/ 
		if (uxBits & Process_Phase_detectionA) // if Bit phase detection is set -> read out peak array
		{
			periode_H = position_array_H[0]*4;
    259a:	0f 2e       	mov	r0, r31
    259c:	f1 e2       	ldi	r31, 0x21	; 33
    259e:	8f 2e       	mov	r8, r31
    25a0:	f1 e3       	ldi	r31, 0x31	; 49
    25a2:	9f 2e       	mov	r9, r31
    25a4:	f0 2d       	mov	r31, r0
			periode_L = position_array_L[0]/3*4;
    25a6:	0f 2e       	mov	r0, r31
    25a8:	f1 e9       	ldi	r31, 0x91	; 145
    25aa:	af 2e       	mov	r10, r31
    25ac:	ff e2       	ldi	r31, 0x2F	; 47
    25ae:	bf 2e       	mov	r11, r31
    25b0:	f0 2d       	mov	r31, r0
	int phase_detect_results;
	int pruef_variable;
	int i=1;
	for (;;)
	{
		uxBits = xEventGroupWaitBits(
    25b2:	cc 24       	eor	r12, r12
    25b4:	ca 94       	dec	r12
    25b6:	dc 2c       	mov	r13, r12
    25b8:	76 01       	movw	r14, r12
    25ba:	00 e0       	ldi	r16, 0x00	; 0
    25bc:	21 e0       	ldi	r18, 0x01	; 1
    25be:	43 e0       	ldi	r20, 0x03	; 3
    25c0:	50 e0       	ldi	r21, 0x00	; 0
    25c2:	60 e0       	ldi	r22, 0x00	; 0
    25c4:	70 e0       	ldi	r23, 0x00	; 0
    25c6:	80 91 1f 31 	lds	r24, 0x311F	; 0x80311f <xPhaseDetectionEventGroup>
    25ca:	90 91 20 31 	lds	r25, 0x3120	; 0x803120 <xPhaseDetectionEventGroup+0x1>
    25ce:	0e 94 bf 02 	call	0x57e	; 0x57e <xEventGroupWaitBits>
								pdTRUE,        /* Bits should be cleared before returning. */
								pdFALSE,       /* Don't wait for both bits, either bit will do. */
								portMAX_DELAY );/* Wait a maximum for either bit to be set. */								

		/*Phase Detection Buffer A*/ 
		if (uxBits & Process_Phase_detectionA) // if Bit phase detection is set -> read out peak array
    25d2:	9b 01       	movw	r18, r22
    25d4:	21 70       	andi	r18, 0x01	; 1
    25d6:	33 27       	eor	r19, r19
    25d8:	23 2b       	or	r18, r19
    25da:	e1 f1       	breq	.+120    	; 0x2654 <vPhase_Detection+0xc4>
		{
			periode_H = position_array_H[0]*4;
			periode_L = position_array_L[0]/3*4;
			periode_mittelwert = position_array_H[0] + position_array_L[0]; //(periode_H + periode_L)/2;
    25dc:	f4 01       	movw	r30, r8
    25de:	c0 81       	ld	r28, Z
    25e0:	d1 81       	ldd	r29, Z+1	; 0x01
    25e2:	f5 01       	movw	r30, r10
    25e4:	80 81       	ld	r24, Z
    25e6:	91 81       	ldd	r25, Z+1	; 0x01
    25e8:	c8 0f       	add	r28, r24
    25ea:	d9 1f       	adc	r29, r25
    25ec:	e3 e2       	ldi	r30, 0x23	; 35
    25ee:	f1 e3       	ldi	r31, 0x31	; 49
			for (i=1;i<peak_array_length;i++)
    25f0:	21 e0       	ldi	r18, 0x01	; 1
    25f2:	30 e0       	ldi	r19, 0x00	; 0
			{
				phase_H = (periode_mittelwert*(i+1) - position_array_H[i]);
    25f4:	2f 5f       	subi	r18, 0xFF	; 255
    25f6:	3f 4f       	sbci	r19, 0xFF	; 255
    25f8:	41 91       	ld	r20, Z+
    25fa:	51 91       	ld	r21, Z+
    25fc:	2c 9f       	mul	r18, r28
    25fe:	c0 01       	movw	r24, r0
    2600:	2d 9f       	mul	r18, r29
    2602:	90 0d       	add	r25, r0
    2604:	3c 9f       	mul	r19, r28
    2606:	90 0d       	add	r25, r0
    2608:	11 24       	eor	r1, r1
    260a:	84 1b       	sub	r24, r20
    260c:	95 0b       	sbc	r25, r21
				phase_L = (periode_mittelwert*(i+1) - position_array_L[i]);
				// Phase High detect
				if(phase_H > 13)
    260e:	8e 30       	cpi	r24, 0x0E	; 14
    2610:	91 05       	cpc	r25, r1
    2612:	64 f0       	brlt	.+24     	; 0x262c <vPhase_Detection+0x9c>
				{
					 if (phase_H >= 18)
    2614:	82 31       	cpi	r24, 0x12	; 18
    2616:	91 05       	cpc	r25, r1
    2618:	84 f4       	brge	.+32     	; 0x263a <vPhase_Detection+0xaa>
						 pruef_variable = phase_H;
					 }
					 else
					 {
						//phase ist 0 grad
						 pruef_variable = phase_H/3*4;
    261a:	b3 01       	movw	r22, r6
    261c:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <__divmodhi4>
    2620:	cb 01       	movw	r24, r22
    2622:	88 0f       	add	r24, r24
    2624:	99 1f       	adc	r25, r25
    2626:	88 0f       	add	r24, r24
    2628:	99 1f       	adc	r25, r25
    262a:	07 c0       	rjmp	.+14     	; 0x263a <vPhase_Detection+0xaa>
					 }
				}
				else
				{
					if (phase_H <= 8)
    262c:	89 30       	cpi	r24, 0x09	; 9
    262e:	91 05       	cpc	r25, r1
    2630:	24 f4       	brge	.+8      	; 0x263a <vPhase_Detection+0xaa>
					{
						//phase ist 180 grad
						 pruef_variable = phase_H * 4;
    2632:	88 0f       	add	r24, r24
    2634:	99 1f       	adc	r25, r25
    2636:	88 0f       	add	r24, r24
    2638:	99 1f       	adc	r25, r25
					{
						 //phase ist -90 grad
						 //pruef_variable = phase_L;
					}
				}
				if(pruef_variable > periode_mittelwert)
    263a:	c8 17       	cp	r28, r24
    263c:	d9 07       	cpc	r29, r25
    263e:	14 f4       	brge	.+4      	; 0x2644 <vPhase_Detection+0xb4>
				{
					periode_mittelwert = periode_mittelwert-1; //if prf variable bigger than periode, then decrease periode 
    2640:	21 97       	sbiw	r28, 0x01	; 1
    2642:	04 c0       	rjmp	.+8      	; 0x264c <vPhase_Detection+0xbc>
				}
				else if (pruef_variable < periode_mittelwert)
    2644:	8c 17       	cp	r24, r28
    2646:	9d 07       	cpc	r25, r29
    2648:	0c f4       	brge	.+2      	; 0x264c <vPhase_Detection+0xbc>
				{
					periode_mittelwert = periode_mittelwert + 1; //if prf variable bigger than periode, then increase periode 
    264a:	21 96       	adiw	r28, 0x01	; 1
		if (uxBits & Process_Phase_detectionA) // if Bit phase detection is set -> read out peak array
		{
			periode_H = position_array_H[0]*4;
			periode_L = position_array_L[0]/3*4;
			periode_mittelwert = position_array_H[0] + position_array_L[0]; //(periode_H + periode_L)/2;
			for (i=1;i<peak_array_length;i++)
    264c:	23 30       	cpi	r18, 0x03	; 3
    264e:	31 05       	cpc	r19, r1
    2650:	89 f6       	brne	.-94     	; 0x25f4 <vPhase_Detection+0x64>
    2652:	37 c0       	rjmp	.+110    	; 0x26c2 <vPhase_Detection+0x132>
			}

		}
		
		/*Phase Detection Buffer B*/ 	
		else if (uxBits & Process_Phase_detectionB)// if Bit phase detection is set -> read out peak array
    2654:	62 70       	andi	r22, 0x02	; 2
    2656:	77 27       	eor	r23, r23
    2658:	67 2b       	or	r22, r23
    265a:	99 f1       	breq	.+102    	; 0x26c2 <vPhase_Detection+0x132>
    265c:	e3 e2       	ldi	r30, 0x23	; 35
    265e:	f1 e3       	ldi	r31, 0x31	; 49
    2660:	21 e0       	ldi	r18, 0x01	; 1
    2662:	30 e0       	ldi	r19, 0x00	; 0
		{
			for (i=1;i<peak_array_length;i++)
			{
				phase_H = (periode_mittelwert*(i+1) - position_array_H[i]);
    2664:	2f 5f       	subi	r18, 0xFF	; 255
    2666:	3f 4f       	sbci	r19, 0xFF	; 255
    2668:	41 91       	ld	r20, Z+
    266a:	51 91       	ld	r21, Z+
    266c:	2c 9f       	mul	r18, r28
    266e:	c0 01       	movw	r24, r0
    2670:	2d 9f       	mul	r18, r29
    2672:	90 0d       	add	r25, r0
    2674:	3c 9f       	mul	r19, r28
    2676:	90 0d       	add	r25, r0
    2678:	11 24       	eor	r1, r1
    267a:	84 1b       	sub	r24, r20
    267c:	95 0b       	sbc	r25, r21
				phase_L = (periode_mittelwert*(i+1) - position_array_L[i]);
				// Phase High detect
				if(phase_H > 13)
    267e:	8e 30       	cpi	r24, 0x0E	; 14
    2680:	91 05       	cpc	r25, r1
    2682:	64 f0       	brlt	.+24     	; 0x269c <vPhase_Detection+0x10c>
				{
					 if (phase_H >= 18)
    2684:	82 31       	cpi	r24, 0x12	; 18
    2686:	91 05       	cpc	r25, r1
    2688:	84 f4       	brge	.+32     	; 0x26aa <vPhase_Detection+0x11a>
						 pruef_variable = phase_H;
					 }
					 else
					 {
						//phase ist 0 grad
						 pruef_variable = phase_H/3*4;
    268a:	b3 01       	movw	r22, r6
    268c:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <__divmodhi4>
    2690:	cb 01       	movw	r24, r22
    2692:	88 0f       	add	r24, r24
    2694:	99 1f       	adc	r25, r25
    2696:	88 0f       	add	r24, r24
    2698:	99 1f       	adc	r25, r25
    269a:	07 c0       	rjmp	.+14     	; 0x26aa <vPhase_Detection+0x11a>
					 }
				}
				else
				{
					if (phase_H <= 8)
    269c:	89 30       	cpi	r24, 0x09	; 9
    269e:	91 05       	cpc	r25, r1
    26a0:	24 f4       	brge	.+8      	; 0x26aa <vPhase_Detection+0x11a>
					{
						//phase ist 180 grad
						 pruef_variable = phase_H * 4;
    26a2:	88 0f       	add	r24, r24
    26a4:	99 1f       	adc	r25, r25
    26a6:	88 0f       	add	r24, r24
    26a8:	99 1f       	adc	r25, r25
					{
						 //phase ist -90 grad
						 //pruef_variable = phase_L;
					}
				}
				if(pruef_variable > periode_mittelwert)
    26aa:	c8 17       	cp	r28, r24
    26ac:	d9 07       	cpc	r29, r25
    26ae:	14 f4       	brge	.+4      	; 0x26b4 <vPhase_Detection+0x124>
				{
					periode_mittelwert = periode_mittelwert-1; //if prf variable bigger than periode, then decrease periode 
    26b0:	21 97       	sbiw	r28, 0x01	; 1
    26b2:	04 c0       	rjmp	.+8      	; 0x26bc <vPhase_Detection+0x12c>
				}
				else if (pruef_variable < periode_mittelwert)
    26b4:	8c 17       	cp	r24, r28
    26b6:	9d 07       	cpc	r25, r29
    26b8:	0c f4       	brge	.+2      	; 0x26bc <vPhase_Detection+0x12c>
				{
					periode_mittelwert = periode_mittelwert + 1; //if prf variable bigger than periode, then increase periode 
    26ba:	21 96       	adiw	r28, 0x01	; 1
		}
		
		/*Phase Detection Buffer B*/ 	
		else if (uxBits & Process_Phase_detectionB)// if Bit phase detection is set -> read out peak array
		{
			for (i=1;i<peak_array_length;i++)
    26bc:	23 30       	cpi	r18, 0x03	; 3
    26be:	31 05       	cpc	r19, r1
    26c0:	89 f6       	brne	.-94     	; 0x2664 <vPhase_Detection+0xd4>
					periode_mittelwert = periode_mittelwert + 1; //if prf variable bigger than periode, then increase periode 
				}
			}
		}
		
		vTaskDelay(100 / portTICK_RATE_MS);
    26c2:	64 e6       	ldi	r22, 0x64	; 100
    26c4:	70 e0       	ldi	r23, 0x00	; 0
    26c6:	80 e0       	ldi	r24, 0x00	; 0
    26c8:	90 e0       	ldi	r25, 0x00	; 0
    26ca:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vTaskDelay>
	}
    26ce:	71 cf       	rjmp	.-286    	; 0x25b2 <vPhase_Detection+0x22>

000026d0 <vRead_DMA>:
}

void vRead_DMA(void *pvParameters)
{
	int count_array_position_H, count_array_position_L = 0;
    26d0:	81 2c       	mov	r8, r1
    26d2:	91 2c       	mov	r9, r1
									{
										peak_array_L[count_array_position_L] = low_peak;
										position_array_L[count_array_position_L] = position_low_peak_a;
										count_array_position_L++;
										count_array_b++; // Count up to activate event bit when 16 peaks got collected
										low_peak = 127;
    26d4:	0f 2e       	mov	r0, r31
    26d6:	ff e7       	ldi	r31, 0x7F	; 127
    26d8:	6f 2e       	mov	r6, r31
    26da:	71 2c       	mov	r7, r1
    26dc:	f0 2d       	mov	r31, r0
	//int count_array_a = 0;
	EventBits_t uxBits;
	BaseType_t xResult;
	for (;;)
	{			
		uxBits = xEventGroupWaitBits(
    26de:	cc 24       	eor	r12, r12
    26e0:	ca 94       	dec	r12
    26e2:	dc 2c       	mov	r13, r12
    26e4:	76 01       	movw	r14, r12
    26e6:	00 e0       	ldi	r16, 0x00	; 0
    26e8:	21 e0       	ldi	r18, 0x01	; 1
    26ea:	43 e0       	ldi	r20, 0x03	; 3
    26ec:	50 e0       	ldi	r21, 0x00	; 0
    26ee:	60 e0       	ldi	r22, 0x00	; 0
    26f0:	70 e0       	ldi	r23, 0x00	; 0
    26f2:	80 91 14 2e 	lds	r24, 0x2E14	; 0x802e14 <xSignalProcessEventGroup>
    26f6:	90 91 15 2e 	lds	r25, 0x2E15	; 0x802e15 <xSignalProcessEventGroup+0x1>
    26fa:	0e 94 bf 02 	call	0x57e	; 0x57e <xEventGroupWaitBits>
								Process_Signal_BufferA | Process_Signal_BufferB, /* The bits within the event group to wait for. */
								pdTRUE,        /* Bits should be cleared before returning. */
								pdFALSE,       /* Don't wait for both bits, either bit will do. */
								portMAX_DELAY );/* Wait a maximum for either bit to be set. */								
		//process signal values
		if (uxBits & Process_Signal_BufferA) // if "BufferA" bit is set, read out bufferA
    26fe:	60 ff       	sbrs	r22, 0
    2700:	04 c1       	rjmp	.+520    	; 0x290a <vRead_DMA+0x23a>
		{
			i = 0;
			for(i=0;i<buffer_length;i++)
    2702:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    2706:	88 23       	and	r24, r24
    2708:	09 f4       	brne	.+2      	; 0x270c <vRead_DMA+0x3c>
    270a:	04 c2       	rjmp	.+1032   	; 0x2b14 <vRead_DMA+0x444>
    270c:	00 e0       	ldi	r16, 0x00	; 0
    270e:	10 e0       	ldi	r17, 0x00	; 0
			{
				// HIGH PEAK A
				if(count_array_a >= peak_array_length) // check array a
    2710:	20 91 ec 2c 	lds	r18, 0x2CEC	; 0x802cec <count_array_a>
    2714:	30 91 ed 2c 	lds	r19, 0x2CED	; 0x802ced <count_array_a+0x1>
    2718:	23 30       	cpi	r18, 0x03	; 3
    271a:	31 05       	cpc	r19, r1
    271c:	7c f0       	brlt	.+30     	; 0x273c <vRead_DMA+0x6c>
				{
					count_array_a = 0;
    271e:	10 92 ec 2c 	sts	0x2CEC, r1	; 0x802cec <count_array_a>
    2722:	10 92 ed 2c 	sts	0x2CED, r1	; 0x802ced <count_array_a+0x1>
					/* Set bit 0 and bit 4 in xEventGroup. */
					xResult = xEventGroupSetBits(
    2726:	42 e0       	ldi	r20, 0x02	; 2
    2728:	50 e0       	ldi	r21, 0x00	; 0
    272a:	60 e0       	ldi	r22, 0x00	; 0
    272c:	70 e0       	ldi	r23, 0x00	; 0
    272e:	80 91 1f 31 	lds	r24, 0x311F	; 0x80311f <xPhaseDetectionEventGroup>
    2732:	90 91 20 31 	lds	r25, 0x3120	; 0x803120 <xPhaseDetectionEventGroup+0x1>
    2736:	0e 94 a5 03 	call	0x74a	; 0x74a <xEventGroupSetBits>
    273a:	dd c0       	rjmp	.+442    	; 0x28f6 <vRead_DMA+0x226>
					Process_Phase_detectionB			/* The bits being set. */
					);
				}
				else
				{	
					if (buffer_a[i] > 127)
    273c:	f8 01       	movw	r30, r16
    273e:	e0 5b       	subi	r30, 0xB0	; 176
    2740:	f0 4d       	sbci	r31, 0xD0	; 208
    2742:	80 81       	ld	r24, Z
    2744:	88 23       	and	r24, r24
    2746:	0c f0       	brlt	.+2      	; 0x274a <vRead_DMA+0x7a>
    2748:	6e c0       	rjmp	.+220    	; 0x2826 <vRead_DMA+0x156>
					{
						if (buffer_a[i] > high_peak)	//if buffer bigger than current high_peak
    274a:	f8 01       	movw	r30, r16
    274c:	e0 5b       	subi	r30, 0xB0	; 176
    274e:	f0 4d       	sbci	r31, 0xD0	; 208
    2750:	80 81       	ld	r24, Z
    2752:	40 91 03 20 	lds	r20, 0x2003	; 0x802003 <high_peak>
    2756:	50 91 04 20 	lds	r21, 0x2004	; 0x802004 <high_peak+0x1>
    275a:	90 e0       	ldi	r25, 0x00	; 0
    275c:	48 17       	cp	r20, r24
    275e:	59 07       	cpc	r21, r25
    2760:	d4 f4       	brge	.+52     	; 0x2796 <vRead_DMA+0xc6>
						{
							if (buffer_a[i] > 220)
    2762:	f8 01       	movw	r30, r16
    2764:	e0 5b       	subi	r30, 0xB0	; 176
    2766:	f0 4d       	sbci	r31, 0xD0	; 208
    2768:	80 81       	ld	r24, Z
    276a:	8d 3d       	cpi	r24, 0xDD	; 221
    276c:	08 f4       	brcc	.+2      	; 0x2770 <vRead_DMA+0xa0>
    276e:	c3 c0       	rjmp	.+390    	; 0x28f6 <vRead_DMA+0x226>
							{
								high_peak = buffer_a[i];	// store new peak
    2770:	f8 01       	movw	r30, r16
    2772:	e0 5b       	subi	r30, 0xB0	; 176
    2774:	f0 4d       	sbci	r31, 0xD0	; 208
    2776:	80 81       	ld	r24, Z
    2778:	90 e0       	ldi	r25, 0x00	; 0
    277a:	80 93 03 20 	sts	0x2003, r24	; 0x802003 <high_peak>
    277e:	90 93 04 20 	sts	0x2004, r25	; 0x802004 <high_peak+0x1>
								position_high_peak_a = i;	// store array position of new peak
    2782:	00 93 11 30 	sts	0x3011, r16	; 0x803011 <position_high_peak_a>
    2786:	10 93 12 30 	sts	0x3012, r17	; 0x803012 <position_high_peak_a+0x1>
								flag_H = 1;
								flag_L = 0;
    278a:	c0 e0       	ldi	r28, 0x00	; 0
    278c:	d0 e0       	ldi	r29, 0x00	; 0
						{
							if (buffer_a[i] > 220)
							{
								high_peak = buffer_a[i];	// store new peak
								position_high_peak_a = i;	// store array position of new peak
								flag_H = 1;
    278e:	aa 24       	eor	r10, r10
    2790:	a3 94       	inc	r10
    2792:	b1 2c       	mov	r11, r1
    2794:	b0 c0       	rjmp	.+352    	; 0x28f6 <vRead_DMA+0x226>
								flag_L = 0;
							}
						}	
						else 
						{
							if (buffer_a[i] > 160 )
    2796:	f8 01       	movw	r30, r16
    2798:	e0 5b       	subi	r30, 0xB0	; 176
    279a:	f0 4d       	sbci	r31, 0xD0	; 208
    279c:	80 81       	ld	r24, Z
    279e:	81 3a       	cpi	r24, 0xA1	; 161
    27a0:	50 f0       	brcs	.+20     	; 0x27b6 <vRead_DMA+0xe6>
							{
								count_after_peak++;
    27a2:	80 91 97 30 	lds	r24, 0x3097	; 0x803097 <count_after_peak>
    27a6:	90 91 98 30 	lds	r25, 0x3098	; 0x803098 <count_after_peak+0x1>
    27aa:	01 96       	adiw	r24, 0x01	; 1
    27ac:	80 93 97 30 	sts	0x3097, r24	; 0x803097 <count_after_peak>
    27b0:	90 93 98 30 	sts	0x3098, r25	; 0x803098 <count_after_peak+0x1>
    27b4:	a0 c0       	rjmp	.+320    	; 0x28f6 <vRead_DMA+0x226>
							}
							else if(buffer_a[i] < 160)
    27b6:	f8 01       	movw	r30, r16
    27b8:	e0 5b       	subi	r30, 0xB0	; 176
    27ba:	f0 4d       	sbci	r31, 0xD0	; 208
    27bc:	80 81       	ld	r24, Z
    27be:	80 3a       	cpi	r24, 0xA0	; 160
    27c0:	08 f0       	brcs	.+2      	; 0x27c4 <vRead_DMA+0xf4>
    27c2:	99 c0       	rjmp	.+306    	; 0x28f6 <vRead_DMA+0x226>
							{
								if(flag_H == 1)
    27c4:	81 e0       	ldi	r24, 0x01	; 1
    27c6:	a8 16       	cp	r10, r24
    27c8:	b1 04       	cpc	r11, r1
    27ca:	09 f0       	breq	.+2      	; 0x27ce <vRead_DMA+0xfe>
    27cc:	94 c0       	rjmp	.+296    	; 0x28f6 <vRead_DMA+0x226>
								{
									if (count_after_peak > 3)
    27ce:	80 91 97 30 	lds	r24, 0x3097	; 0x803097 <count_after_peak>
    27d2:	90 91 98 30 	lds	r25, 0x3098	; 0x803098 <count_after_peak+0x1>
    27d6:	04 97       	sbiw	r24, 0x04	; 4
    27d8:	0c f4       	brge	.+2      	; 0x27dc <vRead_DMA+0x10c>
    27da:	8d c0       	rjmp	.+282    	; 0x28f6 <vRead_DMA+0x226>
									{
										peak_array_H[count_array_position_H] = high_peak;	//
    27dc:	c2 01       	movw	r24, r4
    27de:	88 0f       	add	r24, r24
    27e0:	99 1f       	adc	r25, r25
    27e2:	fc 01       	movw	r30, r24
    27e4:	e9 5e       	subi	r30, 0xE9	; 233
    27e6:	ff 4c       	sbci	r31, 0xCF	; 207
    27e8:	40 83       	st	Z, r20
    27ea:	51 83       	std	Z+1, r21	; 0x01
										position_array_H[count_array_position_H] = position_high_peak_a;
    27ec:	fc 01       	movw	r30, r24
    27ee:	ef 5d       	subi	r30, 0xDF	; 223
    27f0:	fe 4c       	sbci	r31, 0xCE	; 206
    27f2:	40 91 11 30 	lds	r20, 0x3011	; 0x803011 <position_high_peak_a>
    27f6:	50 91 12 30 	lds	r21, 0x3012	; 0x803012 <position_high_peak_a+0x1>
    27fa:	40 83       	st	Z, r20
    27fc:	51 83       	std	Z+1, r21	; 0x01
										count_array_position_H++;
    27fe:	8f ef       	ldi	r24, 0xFF	; 255
    2800:	48 1a       	sub	r4, r24
    2802:	58 0a       	sbc	r5, r24
										count_array_a++; // Count up to activate event bit when 16 peaks got collected
    2804:	2f 5f       	subi	r18, 0xFF	; 255
    2806:	3f 4f       	sbci	r19, 0xFF	; 255
    2808:	20 93 ec 2c 	sts	0x2CEC, r18	; 0x802cec <count_array_a>
    280c:	30 93 ed 2c 	sts	0x2CED, r19	; 0x802ced <count_array_a+0x1>
										high_peak = 127;
    2810:	60 92 03 20 	sts	0x2003, r6	; 0x802003 <high_peak>
    2814:	70 92 04 20 	sts	0x2004, r7	; 0x802004 <high_peak+0x1>
										flag_H = 0;
										count_after_peak = 0;
    2818:	10 92 97 30 	sts	0x3097, r1	; 0x803097 <count_after_peak>
    281c:	10 92 98 30 	sts	0x3098, r1	; 0x803098 <count_after_peak+0x1>
										peak_array_H[count_array_position_H] = high_peak;	//
										position_array_H[count_array_position_H] = position_high_peak_a;
										count_array_position_H++;
										count_array_a++; // Count up to activate event bit when 16 peaks got collected
										high_peak = 127;
										flag_H = 0;
    2820:	a1 2c       	mov	r10, r1
    2822:	b1 2c       	mov	r11, r1
    2824:	68 c0       	rjmp	.+208    	; 0x28f6 <vRead_DMA+0x226>
						}
					}
					// LOW PEAK	A
					else 
					{
						if (buffer_a[i] < low_peak)		//if buffer bigger than current high_peak
    2826:	f8 01       	movw	r30, r16
    2828:	e0 5b       	subi	r30, 0xB0	; 176
    282a:	f0 4d       	sbci	r31, 0xD0	; 208
    282c:	80 81       	ld	r24, Z
    282e:	40 91 01 20 	lds	r20, 0x2001	; 0x802001 <low_peak>
    2832:	50 91 02 20 	lds	r21, 0x2002	; 0x802002 <low_peak+0x1>
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	84 17       	cp	r24, r20
    283a:	95 07       	cpc	r25, r21
    283c:	cc f4       	brge	.+50     	; 0x2870 <vRead_DMA+0x1a0>
						{
							if (buffer_a[i] < 40)
    283e:	f8 01       	movw	r30, r16
    2840:	e0 5b       	subi	r30, 0xB0	; 176
    2842:	f0 4d       	sbci	r31, 0xD0	; 208
    2844:	80 81       	ld	r24, Z
    2846:	88 32       	cpi	r24, 0x28	; 40
    2848:	08 f0       	brcs	.+2      	; 0x284c <vRead_DMA+0x17c>
    284a:	55 c0       	rjmp	.+170    	; 0x28f6 <vRead_DMA+0x226>
							{
								low_peak = buffer_a[i];	// store new peak
    284c:	f8 01       	movw	r30, r16
    284e:	e0 5b       	subi	r30, 0xB0	; 176
    2850:	f0 4d       	sbci	r31, 0xD0	; 208
    2852:	80 81       	ld	r24, Z
    2854:	90 e0       	ldi	r25, 0x00	; 0
    2856:	80 93 01 20 	sts	0x2001, r24	; 0x802001 <low_peak>
    285a:	90 93 02 20 	sts	0x2002, r25	; 0x802002 <low_peak+0x1>
								position_low_peak_a = i;	// store array position of new peak
    285e:	00 93 9b 30 	sts	0x309B, r16	; 0x80309b <position_low_peak_a>
    2862:	10 93 9c 30 	sts	0x309C, r17	; 0x80309c <position_low_peak_a+0x1>
								flag_L = 1;
    2866:	c1 e0       	ldi	r28, 0x01	; 1
    2868:	d0 e0       	ldi	r29, 0x00	; 0
								flag_H = 0;
    286a:	a1 2c       	mov	r10, r1
    286c:	b1 2c       	mov	r11, r1
    286e:	43 c0       	rjmp	.+134    	; 0x28f6 <vRead_DMA+0x226>
							}
						}
						else
						{
							if (buffer_a[i] < 100)
    2870:	f8 01       	movw	r30, r16
    2872:	e0 5b       	subi	r30, 0xB0	; 176
    2874:	f0 4d       	sbci	r31, 0xD0	; 208
    2876:	80 81       	ld	r24, Z
    2878:	84 36       	cpi	r24, 0x64	; 100
    287a:	50 f4       	brcc	.+20     	; 0x2890 <vRead_DMA+0x1c0>
							{
								count_after_peak++;
    287c:	80 91 97 30 	lds	r24, 0x3097	; 0x803097 <count_after_peak>
    2880:	90 91 98 30 	lds	r25, 0x3098	; 0x803098 <count_after_peak+0x1>
    2884:	01 96       	adiw	r24, 0x01	; 1
    2886:	80 93 97 30 	sts	0x3097, r24	; 0x803097 <count_after_peak>
    288a:	90 93 98 30 	sts	0x3098, r25	; 0x803098 <count_after_peak+0x1>
    288e:	33 c0       	rjmp	.+102    	; 0x28f6 <vRead_DMA+0x226>
							}
							else if (buffer_a[i] > 100)
    2890:	f8 01       	movw	r30, r16
    2892:	e0 5b       	subi	r30, 0xB0	; 176
    2894:	f0 4d       	sbci	r31, 0xD0	; 208
    2896:	80 81       	ld	r24, Z
    2898:	85 36       	cpi	r24, 0x65	; 101
    289a:	68 f1       	brcs	.+90     	; 0x28f6 <vRead_DMA+0x226>
							{
								if (flag_L == 1)
    289c:	c1 30       	cpi	r28, 0x01	; 1
    289e:	d1 05       	cpc	r29, r1
    28a0:	51 f5       	brne	.+84     	; 0x28f6 <vRead_DMA+0x226>
								{
									if (count_after_peak > 4)
    28a2:	80 91 97 30 	lds	r24, 0x3097	; 0x803097 <count_after_peak>
    28a6:	90 91 98 30 	lds	r25, 0x3098	; 0x803098 <count_after_peak+0x1>
    28aa:	05 97       	sbiw	r24, 0x05	; 5
    28ac:	24 f1       	brlt	.+72     	; 0x28f6 <vRead_DMA+0x226>
									{
										peak_array_L[count_array_position_L] = low_peak;
    28ae:	c4 01       	movw	r24, r8
    28b0:	88 0f       	add	r24, r24
    28b2:	99 1f       	adc	r25, r25
    28b4:	fc 01       	movw	r30, r24
    28b6:	e3 56       	subi	r30, 0x63	; 99
    28b8:	ff 4c       	sbci	r31, 0xCF	; 207
    28ba:	40 83       	st	Z, r20
    28bc:	51 83       	std	Z+1, r21	; 0x01
										position_array_L[count_array_position_L] = position_low_peak_a;
    28be:	fc 01       	movw	r30, r24
    28c0:	ef 56       	subi	r30, 0x6F	; 111
    28c2:	f0 4d       	sbci	r31, 0xD0	; 208
    28c4:	40 91 9b 30 	lds	r20, 0x309B	; 0x80309b <position_low_peak_a>
    28c8:	50 91 9c 30 	lds	r21, 0x309C	; 0x80309c <position_low_peak_a+0x1>
    28cc:	40 83       	st	Z, r20
    28ce:	51 83       	std	Z+1, r21	; 0x01
										count_array_position_L++;
    28d0:	8f ef       	ldi	r24, 0xFF	; 255
    28d2:	88 1a       	sub	r8, r24
    28d4:	98 0a       	sbc	r9, r24
										count_array_a++; // Count up to activate event bit when 16 peaks got collected
    28d6:	2f 5f       	subi	r18, 0xFF	; 255
    28d8:	3f 4f       	sbci	r19, 0xFF	; 255
    28da:	20 93 ec 2c 	sts	0x2CEC, r18	; 0x802cec <count_array_a>
    28de:	30 93 ed 2c 	sts	0x2CED, r19	; 0x802ced <count_array_a+0x1>
										low_peak = 127;
    28e2:	60 92 01 20 	sts	0x2001, r6	; 0x802001 <low_peak>
    28e6:	70 92 02 20 	sts	0x2002, r7	; 0x802002 <low_peak+0x1>
										flag_L = 0;
										count_after_peak = 0;
    28ea:	10 92 97 30 	sts	0x3097, r1	; 0x803097 <count_after_peak>
    28ee:	10 92 98 30 	sts	0x3098, r1	; 0x803098 <count_after_peak+0x1>
										peak_array_L[count_array_position_L] = low_peak;
										position_array_L[count_array_position_L] = position_low_peak_a;
										count_array_position_L++;
										count_array_a++; // Count up to activate event bit when 16 peaks got collected
										low_peak = 127;
										flag_L = 0;
    28f2:	c0 e0       	ldi	r28, 0x00	; 0
    28f4:	d0 e0       	ldi	r29, 0x00	; 0
								portMAX_DELAY );/* Wait a maximum for either bit to be set. */								
		//process signal values
		if (uxBits & Process_Signal_BufferA) // if "BufferA" bit is set, read out bufferA
		{
			i = 0;
			for(i=0;i<buffer_length;i++)
    28f6:	0f 5f       	subi	r16, 0xFF	; 255
    28f8:	1f 4f       	sbci	r17, 0xFF	; 255
    28fa:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    28fe:	90 e0       	ldi	r25, 0x00	; 0
    2900:	08 17       	cp	r16, r24
    2902:	19 07       	cpc	r17, r25
    2904:	0c f4       	brge	.+2      	; 0x2908 <vRead_DMA+0x238>
    2906:	04 cf       	rjmp	.-504    	; 0x2710 <vRead_DMA+0x40>
    2908:	05 c1       	rjmp	.+522    	; 0x2b14 <vRead_DMA+0x444>
						}	
					}	
				}
			}
		}
		else if (uxBits & Process_Signal_BufferB)
    290a:	61 ff       	sbrs	r22, 1
    290c:	03 c1       	rjmp	.+518    	; 0x2b14 <vRead_DMA+0x444>
		{
			for (i=0;i<buffer_length;i++)
    290e:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    2912:	88 23       	and	r24, r24
    2914:	09 f4       	brne	.+2      	; 0x2918 <vRead_DMA+0x248>
    2916:	fe c0       	rjmp	.+508    	; 0x2b14 <vRead_DMA+0x444>
    2918:	00 e0       	ldi	r16, 0x00	; 0
    291a:	10 e0       	ldi	r17, 0x00	; 0
			{
				if(count_array_b >= peak_array_length) // check array b
    291c:	20 91 ea 2c 	lds	r18, 0x2CEA	; 0x802cea <count_array_b>
    2920:	30 91 eb 2c 	lds	r19, 0x2CEB	; 0x802ceb <count_array_b+0x1>
    2924:	23 30       	cpi	r18, 0x03	; 3
    2926:	31 05       	cpc	r19, r1
    2928:	7c f0       	brlt	.+30     	; 0x2948 <vRead_DMA+0x278>
				{
					count_array_b = 0;
    292a:	10 92 ea 2c 	sts	0x2CEA, r1	; 0x802cea <count_array_b>
    292e:	10 92 eb 2c 	sts	0x2CEB, r1	; 0x802ceb <count_array_b+0x1>
					/* Set bit 0 and bit 4 in xEventGroup. */
					xResult = xEventGroupSetBits(
    2932:	41 e0       	ldi	r20, 0x01	; 1
    2934:	50 e0       	ldi	r21, 0x00	; 0
    2936:	60 e0       	ldi	r22, 0x00	; 0
    2938:	70 e0       	ldi	r23, 0x00	; 0
    293a:	80 91 1f 31 	lds	r24, 0x311F	; 0x80311f <xPhaseDetectionEventGroup>
    293e:	90 91 20 31 	lds	r25, 0x3120	; 0x803120 <xPhaseDetectionEventGroup+0x1>
    2942:	0e 94 a5 03 	call	0x74a	; 0x74a <xEventGroupSetBits>
    2946:	dd c0       	rjmp	.+442    	; 0x2b02 <vRead_DMA+0x432>
					);
				}
				else
				{
					// HIGH PEAK B
					if (buffer_a[i] > 127)
    2948:	f8 01       	movw	r30, r16
    294a:	e0 5b       	subi	r30, 0xB0	; 176
    294c:	f0 4d       	sbci	r31, 0xD0	; 208
    294e:	80 81       	ld	r24, Z
    2950:	88 23       	and	r24, r24
    2952:	0c f0       	brlt	.+2      	; 0x2956 <vRead_DMA+0x286>
    2954:	6e c0       	rjmp	.+220    	; 0x2a32 <vRead_DMA+0x362>
					{
						if (buffer_a[i] > high_peak)	//if buffer bigger than current high_peak
    2956:	f8 01       	movw	r30, r16
    2958:	e0 5b       	subi	r30, 0xB0	; 176
    295a:	f0 4d       	sbci	r31, 0xD0	; 208
    295c:	80 81       	ld	r24, Z
    295e:	40 91 03 20 	lds	r20, 0x2003	; 0x802003 <high_peak>
    2962:	50 91 04 20 	lds	r21, 0x2004	; 0x802004 <high_peak+0x1>
    2966:	90 e0       	ldi	r25, 0x00	; 0
    2968:	48 17       	cp	r20, r24
    296a:	59 07       	cpc	r21, r25
    296c:	d4 f4       	brge	.+52     	; 0x29a2 <vRead_DMA+0x2d2>
						{
							if (buffer_a[i] > 220)
    296e:	f8 01       	movw	r30, r16
    2970:	e0 5b       	subi	r30, 0xB0	; 176
    2972:	f0 4d       	sbci	r31, 0xD0	; 208
    2974:	80 81       	ld	r24, Z
    2976:	8d 3d       	cpi	r24, 0xDD	; 221
    2978:	08 f4       	brcc	.+2      	; 0x297c <vRead_DMA+0x2ac>
    297a:	c3 c0       	rjmp	.+390    	; 0x2b02 <vRead_DMA+0x432>
							{
								high_peak = buffer_a[i];	// store new peak
    297c:	f8 01       	movw	r30, r16
    297e:	e0 5b       	subi	r30, 0xB0	; 176
    2980:	f0 4d       	sbci	r31, 0xD0	; 208
    2982:	80 81       	ld	r24, Z
    2984:	90 e0       	ldi	r25, 0x00	; 0
    2986:	80 93 03 20 	sts	0x2003, r24	; 0x802003 <high_peak>
    298a:	90 93 04 20 	sts	0x2004, r25	; 0x802004 <high_peak+0x1>
								position_high_peak_a = i;	// store array position of new peak
    298e:	00 93 11 30 	sts	0x3011, r16	; 0x803011 <position_high_peak_a>
    2992:	10 93 12 30 	sts	0x3012, r17	; 0x803012 <position_high_peak_a+0x1>
								flag_H = 1;
								flag_L = 0;
    2996:	c0 e0       	ldi	r28, 0x00	; 0
    2998:	d0 e0       	ldi	r29, 0x00	; 0
						{
							if (buffer_a[i] > 220)
							{
								high_peak = buffer_a[i];	// store new peak
								position_high_peak_a = i;	// store array position of new peak
								flag_H = 1;
    299a:	aa 24       	eor	r10, r10
    299c:	a3 94       	inc	r10
    299e:	b1 2c       	mov	r11, r1
    29a0:	b0 c0       	rjmp	.+352    	; 0x2b02 <vRead_DMA+0x432>
								flag_L = 0;
							}
						}
						else
						{
							if (buffer_a[i] > 160 )
    29a2:	f8 01       	movw	r30, r16
    29a4:	e0 5b       	subi	r30, 0xB0	; 176
    29a6:	f0 4d       	sbci	r31, 0xD0	; 208
    29a8:	80 81       	ld	r24, Z
    29aa:	81 3a       	cpi	r24, 0xA1	; 161
    29ac:	50 f0       	brcs	.+20     	; 0x29c2 <vRead_DMA+0x2f2>
							{
								count_after_peak++;
    29ae:	80 91 97 30 	lds	r24, 0x3097	; 0x803097 <count_after_peak>
    29b2:	90 91 98 30 	lds	r25, 0x3098	; 0x803098 <count_after_peak+0x1>
    29b6:	01 96       	adiw	r24, 0x01	; 1
    29b8:	80 93 97 30 	sts	0x3097, r24	; 0x803097 <count_after_peak>
    29bc:	90 93 98 30 	sts	0x3098, r25	; 0x803098 <count_after_peak+0x1>
    29c0:	a0 c0       	rjmp	.+320    	; 0x2b02 <vRead_DMA+0x432>
							}
							else if(buffer_a[i] < 160)
    29c2:	f8 01       	movw	r30, r16
    29c4:	e0 5b       	subi	r30, 0xB0	; 176
    29c6:	f0 4d       	sbci	r31, 0xD0	; 208
    29c8:	80 81       	ld	r24, Z
    29ca:	80 3a       	cpi	r24, 0xA0	; 160
    29cc:	08 f0       	brcs	.+2      	; 0x29d0 <vRead_DMA+0x300>
    29ce:	99 c0       	rjmp	.+306    	; 0x2b02 <vRead_DMA+0x432>
							{
								if(flag_H == 1)
    29d0:	81 e0       	ldi	r24, 0x01	; 1
    29d2:	a8 16       	cp	r10, r24
    29d4:	b1 04       	cpc	r11, r1
    29d6:	09 f0       	breq	.+2      	; 0x29da <vRead_DMA+0x30a>
    29d8:	94 c0       	rjmp	.+296    	; 0x2b02 <vRead_DMA+0x432>
								{
									if (count_after_peak > 3)
    29da:	80 91 97 30 	lds	r24, 0x3097	; 0x803097 <count_after_peak>
    29de:	90 91 98 30 	lds	r25, 0x3098	; 0x803098 <count_after_peak+0x1>
    29e2:	04 97       	sbiw	r24, 0x04	; 4
    29e4:	0c f4       	brge	.+2      	; 0x29e8 <vRead_DMA+0x318>
    29e6:	8d c0       	rjmp	.+282    	; 0x2b02 <vRead_DMA+0x432>
									{
										peak_array_H[count_array_position_H] = high_peak;	//
    29e8:	c2 01       	movw	r24, r4
    29ea:	88 0f       	add	r24, r24
    29ec:	99 1f       	adc	r25, r25
    29ee:	fc 01       	movw	r30, r24
    29f0:	e9 5e       	subi	r30, 0xE9	; 233
    29f2:	ff 4c       	sbci	r31, 0xCF	; 207
    29f4:	40 83       	st	Z, r20
    29f6:	51 83       	std	Z+1, r21	; 0x01
										position_array_H[count_array_position_H] = position_high_peak_a;
    29f8:	fc 01       	movw	r30, r24
    29fa:	ef 5d       	subi	r30, 0xDF	; 223
    29fc:	fe 4c       	sbci	r31, 0xCE	; 206
    29fe:	40 91 11 30 	lds	r20, 0x3011	; 0x803011 <position_high_peak_a>
    2a02:	50 91 12 30 	lds	r21, 0x3012	; 0x803012 <position_high_peak_a+0x1>
    2a06:	40 83       	st	Z, r20
    2a08:	51 83       	std	Z+1, r21	; 0x01
										count_array_position_H++;
    2a0a:	8f ef       	ldi	r24, 0xFF	; 255
    2a0c:	48 1a       	sub	r4, r24
    2a0e:	58 0a       	sbc	r5, r24
										count_array_b++; // Count up to activate event bit when 16 peaks got collected
    2a10:	2f 5f       	subi	r18, 0xFF	; 255
    2a12:	3f 4f       	sbci	r19, 0xFF	; 255
    2a14:	20 93 ea 2c 	sts	0x2CEA, r18	; 0x802cea <count_array_b>
    2a18:	30 93 eb 2c 	sts	0x2CEB, r19	; 0x802ceb <count_array_b+0x1>
										high_peak = 127;
    2a1c:	60 92 03 20 	sts	0x2003, r6	; 0x802003 <high_peak>
    2a20:	70 92 04 20 	sts	0x2004, r7	; 0x802004 <high_peak+0x1>
										flag_H = 0;
										count_after_peak = 0;
    2a24:	10 92 97 30 	sts	0x3097, r1	; 0x803097 <count_after_peak>
    2a28:	10 92 98 30 	sts	0x3098, r1	; 0x803098 <count_after_peak+0x1>
										peak_array_H[count_array_position_H] = high_peak;	//
										position_array_H[count_array_position_H] = position_high_peak_a;
										count_array_position_H++;
										count_array_b++; // Count up to activate event bit when 16 peaks got collected
										high_peak = 127;
										flag_H = 0;
    2a2c:	a1 2c       	mov	r10, r1
    2a2e:	b1 2c       	mov	r11, r1
    2a30:	68 c0       	rjmp	.+208    	; 0x2b02 <vRead_DMA+0x432>
						}
					}
					// LOW PEAK	B				
					else
					{
						if (buffer_a[i] < low_peak)		//if buffer bigger than current high_peak
    2a32:	f8 01       	movw	r30, r16
    2a34:	e0 5b       	subi	r30, 0xB0	; 176
    2a36:	f0 4d       	sbci	r31, 0xD0	; 208
    2a38:	80 81       	ld	r24, Z
    2a3a:	40 91 01 20 	lds	r20, 0x2001	; 0x802001 <low_peak>
    2a3e:	50 91 02 20 	lds	r21, 0x2002	; 0x802002 <low_peak+0x1>
    2a42:	90 e0       	ldi	r25, 0x00	; 0
    2a44:	84 17       	cp	r24, r20
    2a46:	95 07       	cpc	r25, r21
    2a48:	cc f4       	brge	.+50     	; 0x2a7c <vRead_DMA+0x3ac>
						{
							if (buffer_a[i] < 40)
    2a4a:	f8 01       	movw	r30, r16
    2a4c:	e0 5b       	subi	r30, 0xB0	; 176
    2a4e:	f0 4d       	sbci	r31, 0xD0	; 208
    2a50:	80 81       	ld	r24, Z
    2a52:	88 32       	cpi	r24, 0x28	; 40
    2a54:	08 f0       	brcs	.+2      	; 0x2a58 <vRead_DMA+0x388>
    2a56:	55 c0       	rjmp	.+170    	; 0x2b02 <vRead_DMA+0x432>
							{
								low_peak = buffer_a[i];	// store new peak
    2a58:	f8 01       	movw	r30, r16
    2a5a:	e0 5b       	subi	r30, 0xB0	; 176
    2a5c:	f0 4d       	sbci	r31, 0xD0	; 208
    2a5e:	80 81       	ld	r24, Z
    2a60:	90 e0       	ldi	r25, 0x00	; 0
    2a62:	80 93 01 20 	sts	0x2001, r24	; 0x802001 <low_peak>
    2a66:	90 93 02 20 	sts	0x2002, r25	; 0x802002 <low_peak+0x1>
								position_low_peak_a = i;	// store array position of new peak
    2a6a:	00 93 9b 30 	sts	0x309B, r16	; 0x80309b <position_low_peak_a>
    2a6e:	10 93 9c 30 	sts	0x309C, r17	; 0x80309c <position_low_peak_a+0x1>
								flag_L = 1;
    2a72:	c1 e0       	ldi	r28, 0x01	; 1
    2a74:	d0 e0       	ldi	r29, 0x00	; 0
								flag_H = 0;
    2a76:	a1 2c       	mov	r10, r1
    2a78:	b1 2c       	mov	r11, r1
    2a7a:	43 c0       	rjmp	.+134    	; 0x2b02 <vRead_DMA+0x432>
							}
						}
						else
						{
							if (buffer_a[i] < 100)
    2a7c:	f8 01       	movw	r30, r16
    2a7e:	e0 5b       	subi	r30, 0xB0	; 176
    2a80:	f0 4d       	sbci	r31, 0xD0	; 208
    2a82:	80 81       	ld	r24, Z
    2a84:	84 36       	cpi	r24, 0x64	; 100
    2a86:	50 f4       	brcc	.+20     	; 0x2a9c <vRead_DMA+0x3cc>
							{
								count_after_peak++;
    2a88:	80 91 97 30 	lds	r24, 0x3097	; 0x803097 <count_after_peak>
    2a8c:	90 91 98 30 	lds	r25, 0x3098	; 0x803098 <count_after_peak+0x1>
    2a90:	01 96       	adiw	r24, 0x01	; 1
    2a92:	80 93 97 30 	sts	0x3097, r24	; 0x803097 <count_after_peak>
    2a96:	90 93 98 30 	sts	0x3098, r25	; 0x803098 <count_after_peak+0x1>
    2a9a:	33 c0       	rjmp	.+102    	; 0x2b02 <vRead_DMA+0x432>
							}
							else if (buffer_a[i] > 100)
    2a9c:	f8 01       	movw	r30, r16
    2a9e:	e0 5b       	subi	r30, 0xB0	; 176
    2aa0:	f0 4d       	sbci	r31, 0xD0	; 208
    2aa2:	80 81       	ld	r24, Z
    2aa4:	85 36       	cpi	r24, 0x65	; 101
    2aa6:	68 f1       	brcs	.+90     	; 0x2b02 <vRead_DMA+0x432>
							{
								if (flag_L == 1)
    2aa8:	c1 30       	cpi	r28, 0x01	; 1
    2aaa:	d1 05       	cpc	r29, r1
    2aac:	51 f5       	brne	.+84     	; 0x2b02 <vRead_DMA+0x432>
								{
									if (count_after_peak > 4)
    2aae:	80 91 97 30 	lds	r24, 0x3097	; 0x803097 <count_after_peak>
    2ab2:	90 91 98 30 	lds	r25, 0x3098	; 0x803098 <count_after_peak+0x1>
    2ab6:	05 97       	sbiw	r24, 0x05	; 5
    2ab8:	24 f1       	brlt	.+72     	; 0x2b02 <vRead_DMA+0x432>
									{
										peak_array_L[count_array_position_L] = low_peak;
    2aba:	c4 01       	movw	r24, r8
    2abc:	88 0f       	add	r24, r24
    2abe:	99 1f       	adc	r25, r25
    2ac0:	fc 01       	movw	r30, r24
    2ac2:	e3 56       	subi	r30, 0x63	; 99
    2ac4:	ff 4c       	sbci	r31, 0xCF	; 207
    2ac6:	40 83       	st	Z, r20
    2ac8:	51 83       	std	Z+1, r21	; 0x01
										position_array_L[count_array_position_L] = position_low_peak_a;
    2aca:	fc 01       	movw	r30, r24
    2acc:	ef 56       	subi	r30, 0x6F	; 111
    2ace:	f0 4d       	sbci	r31, 0xD0	; 208
    2ad0:	40 91 9b 30 	lds	r20, 0x309B	; 0x80309b <position_low_peak_a>
    2ad4:	50 91 9c 30 	lds	r21, 0x309C	; 0x80309c <position_low_peak_a+0x1>
    2ad8:	40 83       	st	Z, r20
    2ada:	51 83       	std	Z+1, r21	; 0x01
										count_array_position_L++;
    2adc:	8f ef       	ldi	r24, 0xFF	; 255
    2ade:	88 1a       	sub	r8, r24
    2ae0:	98 0a       	sbc	r9, r24
										count_array_b++; // Count up to activate event bit when 16 peaks got collected
    2ae2:	2f 5f       	subi	r18, 0xFF	; 255
    2ae4:	3f 4f       	sbci	r19, 0xFF	; 255
    2ae6:	20 93 ea 2c 	sts	0x2CEA, r18	; 0x802cea <count_array_b>
    2aea:	30 93 eb 2c 	sts	0x2CEB, r19	; 0x802ceb <count_array_b+0x1>
										low_peak = 127;
    2aee:	60 92 01 20 	sts	0x2001, r6	; 0x802001 <low_peak>
    2af2:	70 92 02 20 	sts	0x2002, r7	; 0x802002 <low_peak+0x1>
										flag_L = 0;
										count_after_peak = 0;
    2af6:	10 92 97 30 	sts	0x3097, r1	; 0x803097 <count_after_peak>
    2afa:	10 92 98 30 	sts	0x3098, r1	; 0x803098 <count_after_peak+0x1>
										peak_array_L[count_array_position_L] = low_peak;
										position_array_L[count_array_position_L] = position_low_peak_a;
										count_array_position_L++;
										count_array_b++; // Count up to activate event bit when 16 peaks got collected
										low_peak = 127;
										flag_L = 0;
    2afe:	c0 e0       	ldi	r28, 0x00	; 0
    2b00:	d0 e0       	ldi	r29, 0x00	; 0
				}
			}
		}
		else if (uxBits & Process_Signal_BufferB)
		{
			for (i=0;i<buffer_length;i++)
    2b02:	0f 5f       	subi	r16, 0xFF	; 255
    2b04:	1f 4f       	sbci	r17, 0xFF	; 255
    2b06:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    2b0a:	90 e0       	ldi	r25, 0x00	; 0
    2b0c:	08 17       	cp	r16, r24
    2b0e:	19 07       	cpc	r17, r25
    2b10:	0c f4       	brge	.+2      	; 0x2b14 <vRead_DMA+0x444>
    2b12:	04 cf       	rjmp	.-504    	; 0x291c <vRead_DMA+0x24c>
						}
					}
				}
			}
		}
		vTaskDelay(100 / portTICK_RATE_MS);
    2b14:	64 e6       	ldi	r22, 0x64	; 100
    2b16:	70 e0       	ldi	r23, 0x00	; 0
    2b18:	80 e0       	ldi	r24, 0x00	; 0
    2b1a:	90 e0       	ldi	r25, 0x00	; 0
    2b1c:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vTaskDelay>
	}
    2b20:	de cd       	rjmp	.-1092   	; 0x26de <vRead_DMA+0xe>

00002b22 <vApplicationIdleHook>:




void vApplicationIdleHook( void )
{	
    2b22:	08 95       	ret

00002b24 <main>:
	
}

int main(void)
{
    2b24:	ef 92       	push	r14
    2b26:	ff 92       	push	r15
    2b28:	0f 93       	push	r16
    2b2a:	cf 93       	push	r28
    resetReason_t reason = getResetReason();
    2b2c:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <getResetReason>
    2b30:	c8 2f       	mov	r28, r24

	vInitClock();
    2b32:	0e 94 2d 12 	call	0x245a	; 0x245a <vInitClock>
	vInitDisplay();
    2b36:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vInitDisplay>
	
	xTaskCreate( vLedBlink, (const char *) "ledBlink", configMINIMAL_STACK_SIZE+10, NULL, 1, &ledTask);
    2b3a:	0f 2e       	mov	r0, r31
    2b3c:	f3 e1       	ldi	r31, 0x13	; 19
    2b3e:	ef 2e       	mov	r14, r31
    2b40:	f0 e3       	ldi	r31, 0x30	; 48
    2b42:	ff 2e       	mov	r15, r31
    2b44:	f0 2d       	mov	r31, r0
    2b46:	01 e0       	ldi	r16, 0x01	; 1
    2b48:	20 e0       	ldi	r18, 0x00	; 0
    2b4a:	30 e0       	ldi	r19, 0x00	; 0
    2b4c:	42 ed       	ldi	r20, 0xD2	; 210
    2b4e:	50 e0       	ldi	r21, 0x00	; 0
    2b50:	6b e3       	ldi	r22, 0x3B	; 59
    2b52:	70 e2       	ldi	r23, 0x20	; 32
    2b54:	85 e6       	ldi	r24, 0x65	; 101
    2b56:	92 e1       	ldi	r25, 0x12	; 18
    2b58:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <xTaskCreate>
	xTaskCreate( vRead_DMA, (const char *) "read_DMA", configMINIMAL_STACK_SIZE+100, NULL, 1, &my_read_DMA);
    2b5c:	0f 2e       	mov	r0, r31
    2b5e:	f9 e9       	ldi	r31, 0x99	; 153
    2b60:	ef 2e       	mov	r14, r31
    2b62:	f0 e3       	ldi	r31, 0x30	; 48
    2b64:	ff 2e       	mov	r15, r31
    2b66:	f0 2d       	mov	r31, r0
    2b68:	20 e0       	ldi	r18, 0x00	; 0
    2b6a:	30 e0       	ldi	r19, 0x00	; 0
    2b6c:	4c e2       	ldi	r20, 0x2C	; 44
    2b6e:	51 e0       	ldi	r21, 0x01	; 1
    2b70:	64 e4       	ldi	r22, 0x44	; 68
    2b72:	70 e2       	ldi	r23, 0x20	; 32
    2b74:	88 e6       	ldi	r24, 0x68	; 104
    2b76:	93 e1       	ldi	r25, 0x13	; 19
    2b78:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <xTaskCreate>
	xTaskCreate( vPhase_Detection, (const char *) "phase_detect", configMINIMAL_STACK_SIZE+10, NULL, 1, &my_phase_detection);
    2b7c:	0f 2e       	mov	r0, r31
    2b7e:	fd e1       	ldi	r31, 0x1D	; 29
    2b80:	ef 2e       	mov	r14, r31
    2b82:	f1 e3       	ldi	r31, 0x31	; 49
    2b84:	ff 2e       	mov	r15, r31
    2b86:	f0 2d       	mov	r31, r0
    2b88:	20 e0       	ldi	r18, 0x00	; 0
    2b8a:	30 e0       	ldi	r19, 0x00	; 0
    2b8c:	42 ed       	ldi	r20, 0xD2	; 210
    2b8e:	50 e0       	ldi	r21, 0x00	; 0
    2b90:	6d e4       	ldi	r22, 0x4D	; 77
    2b92:	70 e2       	ldi	r23, 0x20	; 32
    2b94:	88 ec       	ldi	r24, 0xC8	; 200
    2b96:	92 e1       	ldi	r25, 0x12	; 18
    2b98:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <xTaskCreate>
	xTaskCreate( vWrite_Display, (const char *) "display", configMINIMAL_STACK_SIZE+10, NULL, 1, &my_Display);
    2b9c:	0f 2e       	mov	r0, r31
    2b9e:	f5 ea       	ldi	r31, 0xA5	; 165
    2ba0:	ef 2e       	mov	r14, r31
    2ba2:	f1 e3       	ldi	r31, 0x31	; 49
    2ba4:	ff 2e       	mov	r15, r31
    2ba6:	f0 2d       	mov	r31, r0
    2ba8:	20 e0       	ldi	r18, 0x00	; 0
    2baa:	30 e0       	ldi	r19, 0x00	; 0
    2bac:	42 ed       	ldi	r20, 0xD2	; 210
    2bae:	50 e0       	ldi	r21, 0x00	; 0
    2bb0:	6a e5       	ldi	r22, 0x5A	; 90
    2bb2:	70 e2       	ldi	r23, 0x20	; 32
    2bb4:	81 e7       	ldi	r24, 0x71	; 113
    2bb6:	92 e1       	ldi	r25, 0x12	; 18
    2bb8:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <xTaskCreate>
	xTaskCreate( vTask_DMAHandler, (const char *) "dmaHandler", configMINIMAL_STACK_SIZE + 100, NULL, 1, &TaskDMAHandler);		
    2bbc:	0f 2e       	mov	r0, r31
    2bbe:	f7 ea       	ldi	r31, 0xA7	; 167
    2bc0:	ef 2e       	mov	r14, r31
    2bc2:	f1 e3       	ldi	r31, 0x31	; 49
    2bc4:	ff 2e       	mov	r15, r31
    2bc6:	f0 2d       	mov	r31, r0
    2bc8:	20 e0       	ldi	r18, 0x00	; 0
    2bca:	30 e0       	ldi	r19, 0x00	; 0
    2bcc:	4c e2       	ldi	r20, 0x2C	; 44
    2bce:	51 e0       	ldi	r21, 0x01	; 1
    2bd0:	62 e6       	ldi	r22, 0x62	; 98
    2bd2:	70 e2       	ldi	r23, 0x20	; 32
    2bd4:	84 e6       	ldi	r24, 0x64	; 100
    2bd6:	9c e1       	ldi	r25, 0x1C	; 28
    2bd8:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <xTaskCreate>
	xSignalProcessEventGroup = xEventGroupCreate();
    2bdc:	0e 94 aa 02 	call	0x554	; 0x554 <xEventGroupCreate>
    2be0:	80 93 14 2e 	sts	0x2E14, r24	; 0x802e14 <xSignalProcessEventGroup>
    2be4:	90 93 15 2e 	sts	0x2E15, r25	; 0x802e15 <xSignalProcessEventGroup+0x1>
	xPhaseDetectionEventGroup = xEventGroupCreate();
    2be8:	0e 94 aa 02 	call	0x554	; 0x554 <xEventGroupCreate>
    2bec:	80 93 1f 31 	sts	0x311F, r24	; 0x80311f <xPhaseDetectionEventGroup>
    2bf0:	90 93 20 31 	sts	0x3120, r25	; 0x803120 <xPhaseDetectionEventGroup+0x1>
	vInitDMA();			
    2bf4:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <vInitDMA>

	vDisplayClear();
    2bf8:	0e 94 b6 18 	call	0x316c	; 0x316c <vDisplayClear>
	vDisplayWriteStringAtPos(0,0,"FreeRTOS 10.0.1");
    2bfc:	82 e1       	ldi	r24, 0x12	; 18
    2bfe:	90 e2       	ldi	r25, 0x20	; 32
    2c00:	9f 93       	push	r25
    2c02:	8f 93       	push	r24
    2c04:	1f 92       	push	r1
    2c06:	1f 92       	push	r1
    2c08:	1f 92       	push	r1
    2c0a:	1f 92       	push	r1
    2c0c:	0e 94 c1 18 	call	0x3182	; 0x3182 <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(1,0,"EDUBoard 1.0");
    2c10:	8d e6       	ldi	r24, 0x6D	; 109
    2c12:	90 e2       	ldi	r25, 0x20	; 32
    2c14:	9f 93       	push	r25
    2c16:	8f 93       	push	r24
    2c18:	1f 92       	push	r1
    2c1a:	1f 92       	push	r1
    2c1c:	1f 92       	push	r1
    2c1e:	81 e0       	ldi	r24, 0x01	; 1
    2c20:	8f 93       	push	r24
    2c22:	0e 94 c1 18 	call	0x3182	; 0x3182 <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(2,0,"Template");
    2c26:	8a e7       	ldi	r24, 0x7A	; 122
    2c28:	90 e2       	ldi	r25, 0x20	; 32
    2c2a:	9f 93       	push	r25
    2c2c:	8f 93       	push	r24
    2c2e:	1f 92       	push	r1
    2c30:	1f 92       	push	r1
    2c32:	1f 92       	push	r1
    2c34:	82 e0       	ldi	r24, 0x02	; 2
    2c36:	8f 93       	push	r24
    2c38:	0e 94 c1 18 	call	0x3182	; 0x3182 <vDisplayWriteStringAtPos>
	vDisplayWriteStringAtPos(3,0,"ResetReason: %d", reason);
    2c3c:	1f 92       	push	r1
    2c3e:	cf 93       	push	r28
    2c40:	83 e8       	ldi	r24, 0x83	; 131
    2c42:	90 e2       	ldi	r25, 0x20	; 32
    2c44:	9f 93       	push	r25
    2c46:	8f 93       	push	r24
    2c48:	1f 92       	push	r1
    2c4a:	1f 92       	push	r1
    2c4c:	1f 92       	push	r1
    2c4e:	83 e0       	ldi	r24, 0x03	; 3
    2c50:	8f 93       	push	r24
    2c52:	0e 94 c1 18 	call	0x3182	; 0x3182 <vDisplayWriteStringAtPos>
	vTaskStartScheduler();
    2c56:	0e 94 80 0b 	call	0x1700	; 0x1700 <vTaskStartScheduler>
    2c5a:	8d b7       	in	r24, 0x3d	; 61
    2c5c:	9e b7       	in	r25, 0x3e	; 62
    2c5e:	4a 96       	adiw	r24, 0x1a	; 26
    2c60:	8d bf       	out	0x3d, r24	; 61
    2c62:	9e bf       	out	0x3e, r25	; 62
	return 0;
}
    2c64:	80 e0       	ldi	r24, 0x00	; 0
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	cf 91       	pop	r28
    2c6a:	0f 91       	pop	r16
    2c6c:	ff 90       	pop	r15
    2c6e:	ef 90       	pop	r14
    2c70:	08 95       	ret

00002c72 <__vector_108>:
 void displayHome() {
	 command(0x02);
 }
 void _displayClear() {
	 command(0x01);
	 delayUS(2000);
    2c72:	1f 92       	push	r1
    2c74:	0f 92       	push	r0
    2c76:	0f b6       	in	r0, 0x3f	; 63
    2c78:	0f 92       	push	r0
    2c7a:	11 24       	eor	r1, r1
    2c7c:	0b b6       	in	r0, 0x3b	; 59
    2c7e:	0f 92       	push	r0
    2c80:	2f 93       	push	r18
    2c82:	3f 93       	push	r19
    2c84:	4f 93       	push	r20
    2c86:	5f 93       	push	r21
    2c88:	6f 93       	push	r22
    2c8a:	7f 93       	push	r23
    2c8c:	8f 93       	push	r24
    2c8e:	9f 93       	push	r25
    2c90:	af 93       	push	r26
    2c92:	bf 93       	push	r27
    2c94:	ef 93       	push	r30
    2c96:	ff 93       	push	r31
    2c98:	cf 93       	push	r28
    2c9a:	df 93       	push	r29
    2c9c:	1f 92       	push	r1
    2c9e:	cd b7       	in	r28, 0x3d	; 61
    2ca0:	de b7       	in	r29, 0x3e	; 62
    2ca2:	19 82       	std	Y+1, r1	; 0x01
    2ca4:	9e 01       	movw	r18, r28
    2ca6:	2f 5f       	subi	r18, 0xFF	; 255
    2ca8:	3f 4f       	sbci	r19, 0xFF	; 255
    2caa:	41 e0       	ldi	r20, 0x01	; 1
    2cac:	50 e0       	ldi	r21, 0x00	; 0
    2cae:	60 e0       	ldi	r22, 0x00	; 0
    2cb0:	70 e0       	ldi	r23, 0x00	; 0
    2cb2:	80 91 ab 31 	lds	r24, 0x31AB	; 0x8031ab <egDisplayTiming>
    2cb6:	90 91 ac 31 	lds	r25, 0x31AC	; 0x8031ac <egDisplayTiming+0x1>
    2cba:	0e 94 3a 04 	call	0x874	; 0x874 <xEventGroupSetBitsFromISR>
    2cbe:	60 e0       	ldi	r22, 0x00	; 0
    2cc0:	80 e0       	ldi	r24, 0x00	; 0
    2cc2:	9b e0       	ldi	r25, 0x0B	; 11
    2cc4:	0e 94 8e 02 	call	0x51c	; 0x51c <TC0_ConfigClockSource>
    2cc8:	10 92 06 0b 	sts	0x0B06, r1	; 0x800b06 <__TEXT_REGION_LENGTH__+0x700b06>
    2ccc:	0f 90       	pop	r0
    2cce:	df 91       	pop	r29
    2cd0:	cf 91       	pop	r28
    2cd2:	ff 91       	pop	r31
    2cd4:	ef 91       	pop	r30
    2cd6:	bf 91       	pop	r27
    2cd8:	af 91       	pop	r26
    2cda:	9f 91       	pop	r25
    2cdc:	8f 91       	pop	r24
    2cde:	7f 91       	pop	r23
    2ce0:	6f 91       	pop	r22
    2ce2:	5f 91       	pop	r21
    2ce4:	4f 91       	pop	r20
    2ce6:	3f 91       	pop	r19
    2ce8:	2f 91       	pop	r18
    2cea:	0f 90       	pop	r0
    2cec:	0b be       	out	0x3b, r0	; 59
    2cee:	0f 90       	pop	r0
    2cf0:	0f be       	out	0x3f, r0	; 63
    2cf2:	0f 90       	pop	r0
    2cf4:	1f 90       	pop	r1
    2cf6:	18 95       	reti

00002cf8 <delayUS>:
    2cf8:	cf 92       	push	r12
    2cfa:	df 92       	push	r13
    2cfc:	ef 92       	push	r14
    2cfe:	ff 92       	push	r15
    2d00:	0f 93       	push	r16
    2d02:	6b 01       	movw	r12, r22
    2d04:	7c 01       	movw	r14, r24
    2d06:	82 e0       	ldi	r24, 0x02	; 2
    2d08:	c8 16       	cp	r12, r24
    2d0a:	d1 04       	cpc	r13, r1
    2d0c:	e1 04       	cpc	r14, r1
    2d0e:	f1 04       	cpc	r15, r1
    2d10:	08 f4       	brcc	.+2      	; 0x2d14 <delayUS+0x1c>
    2d12:	4e c0       	rjmp	.+156    	; 0x2db0 <delayUS+0xb8>
    2d14:	e0 e0       	ldi	r30, 0x00	; 0
    2d16:	fb e0       	ldi	r31, 0x0B	; 11
    2d18:	81 e0       	ldi	r24, 0x01	; 1
    2d1a:	86 83       	std	Z+6, r24	; 0x06
    2d1c:	10 a2       	std	Z+32, r1	; 0x20
    2d1e:	11 a2       	std	Z+33, r1	; 0x21
    2d20:	60 e0       	ldi	r22, 0x00	; 0
    2d22:	80 e0       	ldi	r24, 0x00	; 0
    2d24:	9b e0       	ldi	r25, 0x0B	; 11
    2d26:	0e 94 94 02 	call	0x528	; 0x528 <TC0_ConfigWGM>
    2d2a:	8e ef       	ldi	r24, 0xFE	; 254
    2d2c:	c8 16       	cp	r12, r24
    2d2e:	8f ef       	ldi	r24, 0xFF	; 255
    2d30:	d8 06       	cpc	r13, r24
    2d32:	e1 04       	cpc	r14, r1
    2d34:	f1 04       	cpc	r15, r1
    2d36:	70 f4       	brcc	.+28     	; 0x2d54 <delayUS+0x5c>
    2d38:	f6 94       	lsr	r15
    2d3a:	e7 94       	ror	r14
    2d3c:	d7 94       	ror	r13
    2d3e:	c7 94       	ror	r12
    2d40:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2d44:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2d48:	65 e0       	ldi	r22, 0x05	; 5
    2d4a:	80 e0       	ldi	r24, 0x00	; 0
    2d4c:	9b e0       	ldi	r25, 0x0B	; 11
    2d4e:	0e 94 8e 02 	call	0x51c	; 0x51c <TC0_ConfigClockSource>
    2d52:	19 c0       	rjmp	.+50     	; 0x2d86 <delayUS+0x8e>
    2d54:	80 e4       	ldi	r24, 0x40	; 64
    2d56:	c8 16       	cp	r12, r24
    2d58:	82 e4       	ldi	r24, 0x42	; 66
    2d5a:	d8 06       	cpc	r13, r24
    2d5c:	8f e0       	ldi	r24, 0x0F	; 15
    2d5e:	e8 06       	cpc	r14, r24
    2d60:	f1 04       	cpc	r15, r1
    2d62:	88 f4       	brcc	.+34     	; 0x2d86 <delayUS+0x8e>
    2d64:	68 94       	set
    2d66:	14 f8       	bld	r1, 4
    2d68:	f6 94       	lsr	r15
    2d6a:	e7 94       	ror	r14
    2d6c:	d7 94       	ror	r13
    2d6e:	c7 94       	ror	r12
    2d70:	16 94       	lsr	r1
    2d72:	d1 f7       	brne	.-12     	; 0x2d68 <delayUS+0x70>
    2d74:	c0 92 26 0b 	sts	0x0B26, r12	; 0x800b26 <__TEXT_REGION_LENGTH__+0x700b26>
    2d78:	d0 92 27 0b 	sts	0x0B27, r13	; 0x800b27 <__TEXT_REGION_LENGTH__+0x700b27>
    2d7c:	67 e0       	ldi	r22, 0x07	; 7
    2d7e:	80 e0       	ldi	r24, 0x00	; 0
    2d80:	9b e0       	ldi	r25, 0x0B	; 11
    2d82:	0e 94 8e 02 	call	0x51c	; 0x51c <TC0_ConfigClockSource>
    2d86:	0f 2e       	mov	r0, r31
    2d88:	f4 ef       	ldi	r31, 0xF4	; 244
    2d8a:	cf 2e       	mov	r12, r31
    2d8c:	dd 24       	eor	r13, r13
    2d8e:	d3 94       	inc	r13
    2d90:	e1 2c       	mov	r14, r1
    2d92:	f1 2c       	mov	r15, r1
    2d94:	f0 2d       	mov	r31, r0
    2d96:	00 e0       	ldi	r16, 0x00	; 0
    2d98:	21 e0       	ldi	r18, 0x01	; 1
    2d9a:	41 e0       	ldi	r20, 0x01	; 1
    2d9c:	50 e0       	ldi	r21, 0x00	; 0
    2d9e:	60 e0       	ldi	r22, 0x00	; 0
    2da0:	70 e0       	ldi	r23, 0x00	; 0
    2da2:	80 91 ab 31 	lds	r24, 0x31AB	; 0x8031ab <egDisplayTiming>
    2da6:	90 91 ac 31 	lds	r25, 0x31AC	; 0x8031ac <egDisplayTiming+0x1>
    2daa:	0e 94 bf 02 	call	0x57e	; 0x57e <xEventGroupWaitBits>
    2dae:	11 c0       	rjmp	.+34     	; 0x2dd2 <delayUS+0xda>
    2db0:	e0 e0       	ldi	r30, 0x00	; 0
    2db2:	fb e0       	ldi	r31, 0x0B	; 11
    2db4:	81 e0       	ldi	r24, 0x01	; 1
    2db6:	86 83       	std	Z+6, r24	; 0x06
    2db8:	10 a2       	std	Z+32, r1	; 0x20
    2dba:	11 a2       	std	Z+33, r1	; 0x21
    2dbc:	60 e0       	ldi	r22, 0x00	; 0
    2dbe:	80 e0       	ldi	r24, 0x00	; 0
    2dc0:	9b e0       	ldi	r25, 0x0B	; 11
    2dc2:	0e 94 94 02 	call	0x528	; 0x528 <TC0_ConfigWGM>
    2dc6:	c1 2c       	mov	r12, r1
    2dc8:	d1 2c       	mov	r13, r1
    2dca:	76 01       	movw	r14, r12
    2dcc:	68 94       	set
    2dce:	c1 f8       	bld	r12, 1
    2dd0:	b3 cf       	rjmp	.-154    	; 0x2d38 <delayUS+0x40>
    2dd2:	0f 91       	pop	r16
    2dd4:	ff 90       	pop	r15
    2dd6:	ef 90       	pop	r14
    2dd8:	df 90       	pop	r13
    2dda:	cf 90       	pop	r12
    2ddc:	08 95       	ret

00002dde <setPort>:
    2dde:	82 95       	swap	r24
    2de0:	80 7f       	andi	r24, 0xF0	; 240
    2de2:	e0 e0       	ldi	r30, 0x00	; 0
    2de4:	f6 e0       	ldi	r31, 0x06	; 6
    2de6:	94 81       	ldd	r25, Z+4	; 0x04
    2de8:	28 2f       	mov	r18, r24
    2dea:	2f 60       	ori	r18, 0x0F	; 15
    2dec:	92 23       	and	r25, r18
    2dee:	94 83       	std	Z+4, r25	; 0x04
    2df0:	94 81       	ldd	r25, Z+4	; 0x04
    2df2:	89 2b       	or	r24, r25
    2df4:	84 83       	std	Z+4, r24	; 0x04
    2df6:	08 95       	ret

00002df8 <Nybble>:
    2df8:	1f 93       	push	r17
    2dfa:	cf 93       	push	r28
    2dfc:	df 93       	push	r29
    2dfe:	c0 e6       	ldi	r28, 0x60	; 96
    2e00:	d6 e0       	ldi	r29, 0x06	; 6
    2e02:	14 e0       	ldi	r17, 0x04	; 4
    2e04:	1d 83       	std	Y+5, r17	; 0x05
    2e06:	61 e0       	ldi	r22, 0x01	; 1
    2e08:	70 e0       	ldi	r23, 0x00	; 0
    2e0a:	80 e0       	ldi	r24, 0x00	; 0
    2e0c:	90 e0       	ldi	r25, 0x00	; 0
    2e0e:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <delayUS>
    2e12:	1e 83       	std	Y+6, r17	; 0x06
    2e14:	df 91       	pop	r29
    2e16:	cf 91       	pop	r28
    2e18:	1f 91       	pop	r17
    2e1a:	08 95       	ret

00002e1c <command>:
    2e1c:	cf 93       	push	r28
    2e1e:	c8 2f       	mov	r28, r24
    2e20:	82 95       	swap	r24
    2e22:	8f 70       	andi	r24, 0x0F	; 15
    2e24:	0e 94 ef 16 	call	0x2dde	; 0x2dde <setPort>
    2e28:	e0 e6       	ldi	r30, 0x60	; 96
    2e2a:	f6 e0       	ldi	r31, 0x06	; 6
    2e2c:	81 e0       	ldi	r24, 0x01	; 1
    2e2e:	86 83       	std	Z+6, r24	; 0x06
    2e30:	82 e0       	ldi	r24, 0x02	; 2
    2e32:	86 83       	std	Z+6, r24	; 0x06
    2e34:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <Nybble>
    2e38:	8c 2f       	mov	r24, r28
    2e3a:	8f 70       	andi	r24, 0x0F	; 15
    2e3c:	0e 94 ef 16 	call	0x2dde	; 0x2dde <setPort>
    2e40:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <Nybble>
    2e44:	cf 91       	pop	r28
    2e46:	08 95       	ret

00002e48 <write>:
    2e48:	cf 93       	push	r28
    2e4a:	c8 2f       	mov	r28, r24
    2e4c:	82 95       	swap	r24
    2e4e:	8f 70       	andi	r24, 0x0F	; 15
    2e50:	0e 94 ef 16 	call	0x2dde	; 0x2dde <setPort>
    2e54:	e0 e6       	ldi	r30, 0x60	; 96
    2e56:	f6 e0       	ldi	r31, 0x06	; 6
    2e58:	81 e0       	ldi	r24, 0x01	; 1
    2e5a:	85 83       	std	Z+5, r24	; 0x05
    2e5c:	82 e0       	ldi	r24, 0x02	; 2
    2e5e:	86 83       	std	Z+6, r24	; 0x06
    2e60:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <Nybble>
    2e64:	8c 2f       	mov	r24, r28
    2e66:	8f 70       	andi	r24, 0x0F	; 15
    2e68:	0e 94 ef 16 	call	0x2dde	; 0x2dde <setPort>
    2e6c:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <Nybble>
    2e70:	cf 91       	pop	r28
    2e72:	08 95       	ret

00002e74 <vInitDisplay>:
 }
 
 void vInitDisplay() {
    2e74:	ef 92       	push	r14
    2e76:	ff 92       	push	r15
    2e78:	0f 93       	push	r16
	PORTA.DIRSET = PIN4_bm;
    2e7a:	e0 e0       	ldi	r30, 0x00	; 0
    2e7c:	f6 e0       	ldi	r31, 0x06	; 6
    2e7e:	80 e1       	ldi	r24, 0x10	; 16
    2e80:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN5_bm;
    2e82:	80 e2       	ldi	r24, 0x20	; 32
    2e84:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN6_bm;
    2e86:	80 e4       	ldi	r24, 0x40	; 64
    2e88:	81 83       	std	Z+1, r24	; 0x01
	PORTA.DIRSET = PIN7_bm;
    2e8a:	80 e8       	ldi	r24, 0x80	; 128
    2e8c:	81 83       	std	Z+1, r24	; 0x01
	PORTD.DIRSET = PIN0_bm;
    2e8e:	a0 e6       	ldi	r26, 0x60	; 96
    2e90:	b6 e0       	ldi	r27, 0x06	; 6
    2e92:	81 e0       	ldi	r24, 0x01	; 1
    2e94:	11 96       	adiw	r26, 0x01	; 1
    2e96:	8c 93       	st	X, r24
    2e98:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN1_bm;
    2e9a:	82 e0       	ldi	r24, 0x02	; 2
    2e9c:	11 96       	adiw	r26, 0x01	; 1
    2e9e:	8c 93       	st	X, r24
    2ea0:	11 97       	sbiw	r26, 0x01	; 1
	PORTD.DIRSET = PIN2_bm;
    2ea2:	84 e0       	ldi	r24, 0x04	; 4
    2ea4:	11 96       	adiw	r26, 0x01	; 1
    2ea6:	8c 93       	st	X, r24
    2ea8:	11 97       	sbiw	r26, 0x01	; 1
	PORTA.OUT &= 0x0F;
    2eaa:	84 81       	ldd	r24, Z+4	; 0x04
    2eac:	8f 70       	andi	r24, 0x0F	; 15
    2eae:	84 83       	std	Z+4, r24	; 0x04
	PORTD.OUT &= 0xF8;
    2eb0:	14 96       	adiw	r26, 0x04	; 4
    2eb2:	8c 91       	ld	r24, X
    2eb4:	14 97       	sbiw	r26, 0x04	; 4
    2eb6:	88 7f       	andi	r24, 0xF8	; 248
    2eb8:	14 96       	adiw	r26, 0x04	; 4
    2eba:	8c 93       	st	X, r24

	if((displayLineQueue = xQueueCreate(DISPLAY_QUEUE_DEPTH, sizeof(displayLine_t))) == NULL)
    2ebc:	40 e0       	ldi	r20, 0x00	; 0
    2ebe:	66 e1       	ldi	r22, 0x16	; 22
    2ec0:	88 e0       	ldi	r24, 0x08	; 8
    2ec2:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <xQueueGenericCreate>
    2ec6:	80 93 a9 31 	sts	0x31A9, r24	; 0x8031a9 <displayLineQueue>
    2eca:	90 93 aa 31 	sts	0x31AA, r25	; 0x8031aa <displayLineQueue+0x1>
	{
		//error(ERR_QUEUE_CREATE_HANDLE_NULL);
	}
	
	egDisplayTiming = xEventGroupCreate();
    2ece:	0e 94 aa 02 	call	0x554	; 0x554 <xEventGroupCreate>
    2ed2:	80 93 ab 31 	sts	0x31AB, r24	; 0x8031ab <egDisplayTiming>
    2ed6:	90 93 ac 31 	sts	0x31AC, r25	; 0x8031ac <egDisplayTiming+0x1>
	

	xTaskCreate(vDisplayUpdateTask, (const char*) "dispUpdate", configMINIMAL_STACK_SIZE+150, NULL, 1, NULL);	
    2eda:	e1 2c       	mov	r14, r1
    2edc:	f1 2c       	mov	r15, r1
    2ede:	01 e0       	ldi	r16, 0x01	; 1
    2ee0:	20 e0       	ldi	r18, 0x00	; 0
    2ee2:	30 e0       	ldi	r19, 0x00	; 0
    2ee4:	4e e5       	ldi	r20, 0x5E	; 94
    2ee6:	51 e0       	ldi	r21, 0x01	; 1
    2ee8:	63 e9       	ldi	r22, 0x93	; 147
    2eea:	70 e2       	ldi	r23, 0x20	; 32
    2eec:	88 ed       	ldi	r24, 0xD8	; 216
    2eee:	97 e1       	ldi	r25, 0x17	; 23
    2ef0:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <xTaskCreate>
 }
    2ef4:	0f 91       	pop	r16
    2ef6:	ff 90       	pop	r15
    2ef8:	ef 90       	pop	r14
    2efa:	08 95       	ret

00002efc <_displaySetPos>:
 
 void _displaySetPos(int line, int pos) {
	 switch(line) {
    2efc:	81 30       	cpi	r24, 0x01	; 1
    2efe:	91 05       	cpc	r25, r1
    2f00:	79 f0       	breq	.+30     	; 0x2f20 <_displaySetPos+0x24>
    2f02:	1c f4       	brge	.+6      	; 0x2f0a <_displaySetPos+0xe>
    2f04:	89 2b       	or	r24, r25
    2f06:	39 f0       	breq	.+14     	; 0x2f16 <_displaySetPos+0x1a>
    2f08:	19 c0       	rjmp	.+50     	; 0x2f3c <_displaySetPos+0x40>
    2f0a:	82 30       	cpi	r24, 0x02	; 2
    2f0c:	91 05       	cpc	r25, r1
    2f0e:	69 f0       	breq	.+26     	; 0x2f2a <_displaySetPos+0x2e>
    2f10:	03 97       	sbiw	r24, 0x03	; 3
    2f12:	81 f0       	breq	.+32     	; 0x2f34 <_displaySetPos+0x38>
    2f14:	13 c0       	rjmp	.+38     	; 0x2f3c <_displaySetPos+0x40>
		 case 0:
		 command(0x80 + 0x00 + pos);
    2f16:	80 e8       	ldi	r24, 0x80	; 128
    2f18:	86 0f       	add	r24, r22
    2f1a:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <command>
		 break;
    2f1e:	0e c0       	rjmp	.+28     	; 0x2f3c <_displaySetPos+0x40>
		 case 1:
		 command(0x80 + 0x40 + pos);
    2f20:	80 ec       	ldi	r24, 0xC0	; 192
    2f22:	86 0f       	add	r24, r22
    2f24:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <command>
		 break;
    2f28:	09 c0       	rjmp	.+18     	; 0x2f3c <_displaySetPos+0x40>
		 case 2:
		 command(0x80 + 0x14 + pos);
    2f2a:	84 e9       	ldi	r24, 0x94	; 148
    2f2c:	86 0f       	add	r24, r22
    2f2e:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <command>
		 break;
    2f32:	04 c0       	rjmp	.+8      	; 0x2f3c <_displaySetPos+0x40>
		 case 3:
		 command(0x80 + 0x54 + pos);
    2f34:	84 ed       	ldi	r24, 0xD4	; 212
    2f36:	86 0f       	add	r24, r22
    2f38:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <command>
		 break;
	 }
	 delayUS(39);
    2f3c:	67 e2       	ldi	r22, 0x27	; 39
    2f3e:	70 e0       	ldi	r23, 0x00	; 0
    2f40:	80 e0       	ldi	r24, 0x00	; 0
    2f42:	90 e0       	ldi	r25, 0x00	; 0
    2f44:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <delayUS>
    2f48:	08 95       	ret

00002f4a <_displayWriteChar>:
 }

 void _displayWriteChar(char c) {
	 write(c);
    2f4a:	0e 94 24 17 	call	0x2e48	; 0x2e48 <write>
	 delayUS(43);
    2f4e:	6b e2       	ldi	r22, 0x2B	; 43
    2f50:	70 e0       	ldi	r23, 0x00	; 0
    2f52:	80 e0       	ldi	r24, 0x00	; 0
    2f54:	90 e0       	ldi	r25, 0x00	; 0
    2f56:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <delayUS>
    2f5a:	08 95       	ret

00002f5c <_displayWriteString>:
 }
 
 void _displayWriteString(char* s) {
    2f5c:	0f 93       	push	r16
    2f5e:	1f 93       	push	r17
    2f60:	cf 93       	push	r28
    2f62:	df 93       	push	r29
    2f64:	fc 01       	movw	r30, r24
	 for(int i = 0; i < 20; i++) {
		 if(s[i] == '\0') {
    2f66:	80 81       	ld	r24, Z
    2f68:	81 11       	cpse	r24, r1
    2f6a:	0a c0       	rjmp	.+20     	; 0x2f80 <_displayWriteString+0x24>
    2f6c:	11 c0       	rjmp	.+34     	; 0x2f90 <_displayWriteString+0x34>
    2f6e:	89 91       	ld	r24, Y+
    2f70:	88 23       	and	r24, r24
    2f72:	71 f0       	breq	.+28     	; 0x2f90 <_displayWriteString+0x34>
			 break;
		 }
		 _displayWriteChar(s[i]);
    2f74:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_displayWriteChar>
	 write(c);
	 delayUS(43);
 }
 
 void _displayWriteString(char* s) {
	 for(int i = 0; i < 20; i++) {
    2f78:	0c 17       	cp	r16, r28
    2f7a:	1d 07       	cpc	r17, r29
    2f7c:	c1 f7       	brne	.-16     	; 0x2f6e <_displayWriteString+0x12>
    2f7e:	08 c0       	rjmp	.+16     	; 0x2f90 <_displayWriteString+0x34>
    2f80:	8f 01       	movw	r16, r30
		 if(s[i] == '\0') {
			 break;
		 }
		 _displayWriteChar(s[i]);
    2f82:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_displayWriteChar>
    2f86:	e8 01       	movw	r28, r16
    2f88:	21 96       	adiw	r28, 0x01	; 1
    2f8a:	0c 5e       	subi	r16, 0xEC	; 236
    2f8c:	1f 4f       	sbci	r17, 0xFF	; 255
    2f8e:	ef cf       	rjmp	.-34     	; 0x2f6e <_displayWriteString+0x12>
	 }
 }
    2f90:	df 91       	pop	r29
    2f92:	cf 91       	pop	r28
    2f94:	1f 91       	pop	r17
    2f96:	0f 91       	pop	r16
    2f98:	08 95       	ret

00002f9a <_displayWriteStringAtPos>:

 void _displayWriteStringAtPos(int line, int pos, char* s) {
    2f9a:	cf 93       	push	r28
    2f9c:	df 93       	push	r29
    2f9e:	ea 01       	movw	r28, r20
	 _displaySetPos(line, pos);
    2fa0:	0e 94 7e 17 	call	0x2efc	; 0x2efc <_displaySetPos>
	 _displayWriteString(s);
    2fa4:	ce 01       	movw	r24, r28
    2fa6:	0e 94 ae 17 	call	0x2f5c	; 0x2f5c <_displayWriteString>
 }
    2faa:	df 91       	pop	r29
    2fac:	cf 91       	pop	r28
    2fae:	08 95       	ret

00002fb0 <vDisplayUpdateTask>:

 void vDisplayUpdateTask(void *pvParameters) {
    2fb0:	cf 93       	push	r28
    2fb2:	df 93       	push	r29
    2fb4:	cd b7       	in	r28, 0x3d	; 61
    2fb6:	de b7       	in	r29, 0x3e	; 62
    2fb8:	c6 56       	subi	r28, 0x66	; 102
    2fba:	d1 09       	sbc	r29, r1
    2fbc:	cd bf       	out	0x3d, r28	; 61
    2fbe:	de bf       	out	0x3e, r29	; 62
    2fc0:	5e 01       	movw	r10, r28
    2fc2:	41 e5       	ldi	r20, 0x51	; 81
    2fc4:	a4 0e       	add	r10, r20
    2fc6:	b1 1c       	adc	r11, r1
    2fc8:	fe 01       	movw	r30, r28
    2fca:	31 96       	adiw	r30, 0x01	; 1
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
			displayLines[i][j] = 0x20;
    2fcc:	20 e2       	ldi	r18, 0x20	; 32
    2fce:	08 c0       	rjmp	.+16     	; 0x2fe0 <vDisplayUpdateTask+0x30>
    2fd0:	21 93       	st	Z+, r18
 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
		for(int j = 0; j < 20; j ++) {
    2fd2:	e8 17       	cp	r30, r24
    2fd4:	f9 07       	cpc	r31, r25
    2fd6:	e1 f7       	brne	.-8      	; 0x2fd0 <vDisplayUpdateTask+0x20>
    2fd8:	fc 01       	movw	r30, r24

 void vDisplayUpdateTask(void *pvParameters) {
	 int i = 0;
	 int j = 0;
	 char displayLines[4][20];
	 for(int i = 0; i < 4;i++) {
    2fda:	a8 16       	cp	r10, r24
    2fdc:	b9 06       	cpc	r11, r25
    2fde:	19 f0       	breq	.+6      	; 0x2fe6 <vDisplayUpdateTask+0x36>
    2fe0:	cf 01       	movw	r24, r30
    2fe2:	44 96       	adiw	r24, 0x14	; 20
    2fe4:	f5 cf       	rjmp	.-22     	; 0x2fd0 <vDisplayUpdateTask+0x20>
			displayLines[i][j] = 0x20;
		}
	 }
	 displayLine_t newLine;

	 delayUS(40000);
    2fe6:	60 e4       	ldi	r22, 0x40	; 64
    2fe8:	7c e9       	ldi	r23, 0x9C	; 156
    2fea:	80 e0       	ldi	r24, 0x00	; 0
    2fec:	90 e0       	ldi	r25, 0x00	; 0
    2fee:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <delayUS>
	 setPort(0x03);
    2ff2:	83 e0       	ldi	r24, 0x03	; 3
    2ff4:	0e 94 ef 16 	call	0x2dde	; 0x2dde <setPort>
	 delayUS(5000);
    2ff8:	68 e8       	ldi	r22, 0x88	; 136
    2ffa:	73 e1       	ldi	r23, 0x13	; 19
    2ffc:	80 e0       	ldi	r24, 0x00	; 0
    2ffe:	90 e0       	ldi	r25, 0x00	; 0
    3000:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <delayUS>
	 Nybble();
    3004:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <Nybble>
	 delayUS(160);
    3008:	60 ea       	ldi	r22, 0xA0	; 160
    300a:	70 e0       	ldi	r23, 0x00	; 0
    300c:	80 e0       	ldi	r24, 0x00	; 0
    300e:	90 e0       	ldi	r25, 0x00	; 0
    3010:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <delayUS>
	 Nybble();
    3014:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <Nybble>
	 delayUS(160);
    3018:	60 ea       	ldi	r22, 0xA0	; 160
    301a:	70 e0       	ldi	r23, 0x00	; 0
    301c:	80 e0       	ldi	r24, 0x00	; 0
    301e:	90 e0       	ldi	r25, 0x00	; 0
    3020:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <delayUS>
	 Nybble();
    3024:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <Nybble>
	 delayUS(160);
    3028:	60 ea       	ldi	r22, 0xA0	; 160
    302a:	70 e0       	ldi	r23, 0x00	; 0
    302c:	80 e0       	ldi	r24, 0x00	; 0
    302e:	90 e0       	ldi	r25, 0x00	; 0
    3030:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <delayUS>
	 setPort(0x02);
    3034:	82 e0       	ldi	r24, 0x02	; 2
    3036:	0e 94 ef 16 	call	0x2dde	; 0x2dde <setPort>
	 Nybble();
    303a:	0e 94 fc 16 	call	0x2df8	; 0x2df8 <Nybble>
	 command(0x28);
    303e:	88 e2       	ldi	r24, 0x28	; 40
    3040:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <command>
	 command(0x10);
    3044:	80 e1       	ldi	r24, 0x10	; 16
    3046:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <command>
	 command(0x0C); //Cursor and Blinking off
    304a:	8c e0       	ldi	r24, 0x0C	; 12
    304c:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <command>
	 command(0x06);
    3050:	86 e0       	ldi	r24, 0x06	; 6
    3052:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <command>
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    3056:	10 e2       	ldi	r17, 0x20	; 32
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    3058:	6e 01       	movw	r12, r28
    305a:	51 e5       	ldi	r21, 0x51	; 81
    305c:	c5 0e       	add	r12, r21
    305e:	d1 1c       	adc	r13, r1
    3060:	0f 2e       	mov	r0, r31
    3062:	f4 e1       	ldi	r31, 0x14	; 20
    3064:	4f 2e       	mov	r4, r31
    3066:	f0 2d       	mov	r31, r0
    3068:	0f 2e       	mov	r0, r31
    306a:	f6 e1       	ldi	r31, 0x16	; 22
    306c:	8f 2e       	mov	r8, r31
    306e:	91 2c       	mov	r9, r1
    3070:	f0 2d       	mov	r31, r0
    3072:	5c 2c       	mov	r5, r12
    3074:	0d 2d       	mov	r16, r13
	 command(0x10);
	 command(0x0C); //Cursor and Blinking off
	 command(0x06);
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
    3076:	68 ec       	ldi	r22, 0xC8	; 200
    3078:	70 e0       	ldi	r23, 0x00	; 0
    307a:	80 e0       	ldi	r24, 0x00	; 0
    307c:	90 e0       	ldi	r25, 0x00	; 0
    307e:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vTaskDelay>
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
    3082:	40 e0       	ldi	r20, 0x00	; 0
    3084:	50 e0       	ldi	r21, 0x00	; 0
    3086:	ba 01       	movw	r22, r20
    3088:	80 91 ab 31 	lds	r24, 0x31AB	; 0x8031ab <egDisplayTiming>
    308c:	90 91 ac 31 	lds	r25, 0x31AC	; 0x8031ac <egDisplayTiming+0x1>
    3090:	0e 94 84 03 	call	0x708	; 0x708 <xEventGroupClearBits>
    3094:	67 2b       	or	r22, r23
    3096:	68 2b       	or	r22, r24
    3098:	69 2b       	or	r22, r25
    309a:	09 f4       	brne	.+2      	; 0x309e <vDisplayUpdateTask+0xee>
    309c:	49 c0       	rjmp	.+146    	; 0x3130 <vDisplayUpdateTask+0x180>
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    309e:	42 e0       	ldi	r20, 0x02	; 2
    30a0:	50 e0       	ldi	r21, 0x00	; 0
    30a2:	60 e0       	ldi	r22, 0x00	; 0
    30a4:	70 e0       	ldi	r23, 0x00	; 0
    30a6:	80 91 ab 31 	lds	r24, 0x31AB	; 0x8031ab <egDisplayTiming>
    30aa:	90 91 ac 31 	lds	r25, 0x31AC	; 0x8031ac <egDisplayTiming+0x1>
    30ae:	0e 94 84 03 	call	0x708	; 0x708 <xEventGroupClearBits>
    30b2:	fe 01       	movw	r30, r28
    30b4:	31 96       	adiw	r30, 0x01	; 1
    30b6:	08 c0       	rjmp	.+16     	; 0x30c8 <vDisplayUpdateTask+0x118>
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
    30b8:	11 93       	st	Z+, r17
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
				for(j = 0; j < 20; j ++) {
    30ba:	e8 17       	cp	r30, r24
    30bc:	f9 07       	cpc	r31, r25
    30be:	e1 f7       	brne	.-8      	; 0x30b8 <vDisplayUpdateTask+0x108>
    30c0:	fc 01       	movw	r30, r24
	 
	 for(;;) {		 
		 vTaskDelay(DISPLAY_UPDATE_TIME_MS/portTICK_RATE_MS);
		 if(xEventGroupGetBits(egDisplayTiming) && EG_DISPLAY_CLEAR != 0x00) {
			xEventGroupClearBits(egDisplayTiming, EG_DISPLAY_CLEAR);
			for(i = 0; i < 4;i++) {
    30c2:	8a 15       	cp	r24, r10
    30c4:	9b 05       	cpc	r25, r11
    30c6:	a1 f1       	breq	.+104    	; 0x3130 <vDisplayUpdateTask+0x180>
    30c8:	cf 01       	movw	r24, r30
    30ca:	44 96       	adiw	r24, 0x14	; 20
    30cc:	f5 cf       	rjmp	.-22     	; 0x30b8 <vDisplayUpdateTask+0x108>
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
    30ce:	2f ef       	ldi	r18, 0xFF	; 255
    30d0:	3f ef       	ldi	r19, 0xFF	; 255
    30d2:	a9 01       	movw	r20, r18
    30d4:	65 2d       	mov	r22, r5
    30d6:	70 2f       	mov	r23, r16
    30d8:	80 91 a9 31 	lds	r24, 0x31A9	; 0x8031a9 <displayLineQueue>
    30dc:	90 91 aa 31 	lds	r25, 0x31AA	; 0x8031aa <displayLineQueue+0x1>
    30e0:	0e 94 ed 08 	call	0x11da	; 0x11da <xQueueReceive>
    30e4:	88 23       	and	r24, r24
    30e6:	21 f1       	breq	.+72     	; 0x3130 <vDisplayUpdateTask+0x180>
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    30e8:	f6 01       	movw	r30, r12
    30ea:	21 81       	ldd	r18, Z+1	; 0x01
    30ec:	82 2f       	mov	r24, r18
    30ee:	90 e0       	ldi	r25, 0x00	; 0
    30f0:	44 97       	sbiw	r24, 0x14	; 20
    30f2:	f4 f4       	brge	.+60     	; 0x3130 <vDisplayUpdateTask+0x180>
    30f4:	82 81       	ldd	r24, Z+2	; 0x02
    30f6:	88 23       	and	r24, r24
    30f8:	d9 f0       	breq	.+54     	; 0x3130 <vDisplayUpdateTask+0x180>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
    30fa:	90 81       	ld	r25, Z
    30fc:	30 e0       	ldi	r19, 0x00	; 0
    30fe:	d9 01       	movw	r26, r18
    3100:	49 9e       	mul	r4, r25
    3102:	a0 0d       	add	r26, r0
    3104:	b1 1d       	adc	r27, r1
    3106:	11 24       	eor	r1, r1
    3108:	41 e0       	ldi	r20, 0x01	; 1
    310a:	50 e0       	ldi	r21, 0x00	; 0
    310c:	4c 0f       	add	r20, r28
    310e:	5d 1f       	adc	r21, r29
    3110:	a4 0f       	add	r26, r20
    3112:	b5 1f       	adc	r27, r21
    3114:	33 96       	adiw	r30, 0x03	; 3
    3116:	a4 01       	movw	r20, r8
    3118:	42 1b       	sub	r20, r18
    311a:	53 0b       	sbc	r21, r19
    311c:	9a 01       	movw	r18, r20
    311e:	2c 0d       	add	r18, r12
    3120:	3d 1d       	adc	r19, r13
    3122:	8d 93       	st	X+, r24
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
			 if(xQueueReceive(displayLineQueue, &newLine, portMAX_DELAY)) {	
				i=0;			
				while((i+newLine.displayPos < 20) && (newLine.displayBuffer[i] != 0x00)) {				
    3124:	e2 17       	cp	r30, r18
    3126:	f3 07       	cpc	r31, r19
    3128:	19 f0       	breq	.+6      	; 0x3130 <vDisplayUpdateTask+0x180>
    312a:	81 91       	ld	r24, Z+
    312c:	81 11       	cpse	r24, r1
    312e:	f9 cf       	rjmp	.-14     	; 0x3122 <vDisplayUpdateTask+0x172>
				for(j = 0; j < 20; j ++) {
					displayLines[i][j] = 0x20;
				}
			}
		 }
		 while(uxQueueMessagesWaiting(displayLineQueue) > 0) {
    3130:	80 91 a9 31 	lds	r24, 0x31A9	; 0x8031a9 <displayLineQueue>
    3134:	90 91 aa 31 	lds	r25, 0x31AA	; 0x8031aa <displayLineQueue+0x1>
    3138:	0e 94 93 09 	call	0x1326	; 0x1326 <uxQueueMessagesWaiting>
    313c:	81 11       	cpse	r24, r1
    313e:	c7 cf       	rjmp	.-114    	; 0x30ce <vDisplayUpdateTask+0x11e>
    3140:	ce 01       	movw	r24, r28
    3142:	01 96       	adiw	r24, 0x01	; 1
    3144:	7c 01       	movw	r14, r24
    3146:	61 2c       	mov	r6, r1
    3148:	71 2c       	mov	r7, r1
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
			 _displayWriteStringAtPos(i,0,&displayLines[i][0]);
    314a:	a7 01       	movw	r20, r14
    314c:	60 e0       	ldi	r22, 0x00	; 0
    314e:	70 e0       	ldi	r23, 0x00	; 0
    3150:	c3 01       	movw	r24, r6
    3152:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <_displayWriteStringAtPos>
					displayLines[newLine.displayLine][i+newLine.displayPos] = newLine.displayBuffer[i];
					i++;
				}
			 }
		 }
		 for(i = 0; i < 4; i++) {
    3156:	9f ef       	ldi	r25, 0xFF	; 255
    3158:	69 1a       	sub	r6, r25
    315a:	79 0a       	sbc	r7, r25
    315c:	e4 e1       	ldi	r30, 0x14	; 20
    315e:	ee 0e       	add	r14, r30
    3160:	f1 1c       	adc	r15, r1
    3162:	f4 e0       	ldi	r31, 0x04	; 4
    3164:	6f 16       	cp	r6, r31
    3166:	71 04       	cpc	r7, r1
    3168:	81 f7       	brne	.-32     	; 0x314a <vDisplayUpdateTask+0x19a>
    316a:	85 cf       	rjmp	.-246    	; 0x3076 <vDisplayUpdateTask+0xc6>

0000316c <vDisplayClear>:
	 }
 }
 

void vDisplayClear() {
	xEventGroupSetBits(egDisplayTiming, EG_DISPLAY_CLEAR);
    316c:	42 e0       	ldi	r20, 0x02	; 2
    316e:	50 e0       	ldi	r21, 0x00	; 0
    3170:	60 e0       	ldi	r22, 0x00	; 0
    3172:	70 e0       	ldi	r23, 0x00	; 0
    3174:	80 91 ab 31 	lds	r24, 0x31AB	; 0x8031ab <egDisplayTiming>
    3178:	90 91 ac 31 	lds	r25, 0x31AC	; 0x8031ac <egDisplayTiming+0x1>
    317c:	0e 94 a5 03 	call	0x74a	; 0x74a <xEventGroupSetBits>
    3180:	08 95       	ret

00003182 <vDisplayWriteStringAtPos>:
}

void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
    3182:	2f 92       	push	r2
    3184:	3f 92       	push	r3
    3186:	4f 92       	push	r4
    3188:	5f 92       	push	r5
    318a:	6f 92       	push	r6
    318c:	7f 92       	push	r7
    318e:	8f 92       	push	r8
    3190:	9f 92       	push	r9
    3192:	af 92       	push	r10
    3194:	bf 92       	push	r11
    3196:	cf 92       	push	r12
    3198:	df 92       	push	r13
    319a:	ef 92       	push	r14
    319c:	ff 92       	push	r15
    319e:	0f 93       	push	r16
    31a0:	1f 93       	push	r17
    31a2:	cf 93       	push	r28
    31a4:	df 93       	push	r29
    31a6:	cd b7       	in	r28, 0x3d	; 61
    31a8:	de b7       	in	r29, 0x3e	; 62
    31aa:	6d 97       	sbiw	r28, 0x1d	; 29
    31ac:	cd bf       	out	0x3d, r28	; 61
    31ae:	de bf       	out	0x3e, r29	; 62
    31b0:	2b a9       	ldd	r18, Y+51	; 0x33
    31b2:	2b 8f       	std	Y+27, r18	; 0x1b
    31b4:	af a9       	ldd	r26, Y+55	; 0x37
    31b6:	b8 ad       	ldd	r27, Y+56	; 0x38
	va_list arg;	
	va_start(arg, fmt);
    31b8:	7e 01       	movw	r14, r28
    31ba:	39 e3       	ldi	r19, 0x39	; 57
    31bc:	e3 0e       	add	r14, r19
    31be:	f1 1c       	adc	r15, r1
    31c0:	26 e1       	ldi	r18, 0x16	; 22
    31c2:	3d e2       	ldi	r19, 0x2D	; 45
	display_vprintf(line, pos, fmt, arg);
    31c4:	e2 e0       	ldi	r30, 0x02	; 2
    31c6:	fd e2       	ldi	r31, 0x2D	; 45
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
    31c8:	11 92       	st	Z+, r1
	char ch;
	int length = 0;

	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
    31ca:	e2 17       	cp	r30, r18
    31cc:	f3 07       	cpc	r31, r19
    31ce:	e1 f7       	brne	.-8      	; 0x31c8 <vDisplayWriteStringAtPos+0x46>
    31d0:	0f 2e       	mov	r0, r31
    31d2:	fe ee       	ldi	r31, 0xEE	; 238
    31d4:	af 2e       	mov	r10, r31
    31d6:	fc e2       	ldi	r31, 0x2C	; 44
    31d8:	bf 2e       	mov	r11, r31
    31da:	f0 2d       	mov	r31, r0
    31dc:	22 e0       	ldi	r18, 0x02	; 2
    31de:	3d e2       	ldi	r19, 0x2D	; 45
    31e0:	f5 01       	movw	r30, r10
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
    31e2:	11 92       	st	Z+, r1
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    31e4:	e2 17       	cp	r30, r18
    31e6:	f3 07       	cpc	r31, r19
    31e8:	e1 f7       	brne	.-8      	; 0x31e2 <vDisplayWriteStringAtPos+0x60>
    31ea:	81 2c       	mov	r8, r1
    31ec:	91 2c       	mov	r9, r1
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    31ee:	0f 2e       	mov	r0, r31
    31f0:	f2 e0       	ldi	r31, 0x02	; 2
    31f2:	cf 2e       	mov	r12, r31
    31f4:	fd e2       	ldi	r31, 0x2D	; 45
    31f6:	df 2e       	mov	r13, r31
    31f8:	f0 2d       	mov	r31, r0
    31fa:	fc c2       	rjmp	.+1528   	; 0x37f4 <vDisplayWriteStringAtPos+0x672>
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
    31fc:	85 32       	cpi	r24, 0x25	; 37
    31fe:	09 f0       	breq	.+2      	; 0x3202 <vDisplayWriteStringAtPos+0x80>
    3200:	e8 c2       	rjmp	.+1488   	; 0x37d2 <vDisplayWriteStringAtPos+0x650>
			switch (ch = *fmt++) {
    3202:	2d 01       	movw	r4, r26
    3204:	82 e0       	ldi	r24, 0x02	; 2
    3206:	48 0e       	add	r4, r24
    3208:	51 1c       	adc	r5, r1
    320a:	11 96       	adiw	r26, 0x01	; 1
    320c:	8c 91       	ld	r24, X
    320e:	85 36       	cpi	r24, 0x65	; 101
    3210:	09 f4       	brne	.+2      	; 0x3214 <vDisplayWriteStringAtPos+0x92>
    3212:	db c1       	rjmp	.+950    	; 0x35ca <vDisplayWriteStringAtPos+0x448>
    3214:	38 f4       	brcc	.+14     	; 0x3224 <vDisplayWriteStringAtPos+0xa2>
    3216:	83 36       	cpi	r24, 0x63	; 99
    3218:	c1 f0       	breq	.+48     	; 0x324a <vDisplayWriteStringAtPos+0xc8>
    321a:	08 f0       	brcs	.+2      	; 0x321e <vDisplayWriteStringAtPos+0x9c>
    321c:	48 c0       	rjmp	.+144    	; 0x32ae <vDisplayWriteStringAtPos+0x12c>
    321e:	85 32       	cpi	r24, 0x25	; 37
    3220:	51 f0       	breq	.+20     	; 0x3236 <vDisplayWriteStringAtPos+0xb4>
    3222:	e7 c2       	rjmp	.+1486   	; 0x37f2 <vDisplayWriteStringAtPos+0x670>
    3224:	83 37       	cpi	r24, 0x73	; 115
    3226:	f9 f0       	breq	.+62     	; 0x3266 <vDisplayWriteStringAtPos+0xe4>
    3228:	88 37       	cpi	r24, 0x78	; 120
    322a:	09 f4       	brne	.+2      	; 0x322e <vDisplayWriteStringAtPos+0xac>
    322c:	68 c0       	rjmp	.+208    	; 0x32fe <vDisplayWriteStringAtPos+0x17c>
    322e:	86 36       	cpi	r24, 0x66	; 102
    3230:	09 f0       	breq	.+2      	; 0x3234 <vDisplayWriteStringAtPos+0xb2>
    3232:	df c2       	rjmp	.+1470   	; 0x37f2 <vDisplayWriteStringAtPos+0x670>
    3234:	8c c0       	rjmp	.+280    	; 0x334e <vDisplayWriteStringAtPos+0x1cc>
				/* %% - print out a single %    */
				case '%':
				str[length] = '%';
    3236:	f4 01       	movw	r30, r8
    3238:	e2 51       	subi	r30, 0x12	; 18
    323a:	f3 4d       	sbci	r31, 0xD3	; 211
    323c:	95 e2       	ldi	r25, 0x25	; 37
    323e:	90 83       	st	Z, r25
				length++;
    3240:	af ef       	ldi	r26, 0xFF	; 255
    3242:	8a 1a       	sub	r8, r26
    3244:	9a 0a       	sbc	r9, r26
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3246:	d2 01       	movw	r26, r4
    3248:	d5 c2       	rjmp	.+1450   	; 0x37f4 <vDisplayWriteStringAtPos+0x672>
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
				str[length] = char_temp;
    324a:	f4 01       	movw	r30, r8
    324c:	e2 51       	subi	r30, 0x12	; 18
    324e:	f3 4d       	sbci	r31, 0xD3	; 211
    3250:	d7 01       	movw	r26, r14
    3252:	8c 91       	ld	r24, X
    3254:	80 83       	st	Z, r24
				length++;
    3256:	bf ef       	ldi	r27, 0xFF	; 255
    3258:	8b 1a       	sub	r8, r27
    325a:	9b 0a       	sbc	r9, r27
				length++;
				break;

				/* %c: print out a character    */
				case 'c':
				char_temp = va_arg(arg, int);
    325c:	f7 01       	movw	r30, r14
    325e:	32 96       	adiw	r30, 0x02	; 2
    3260:	7f 01       	movw	r14, r30
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    3262:	d2 01       	movw	r26, r4
    3264:	c7 c2       	rjmp	.+1422   	; 0x37f4 <vDisplayWriteStringAtPos+0x672>
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    3266:	a7 01       	movw	r20, r14
    3268:	4e 5f       	subi	r20, 0xFE	; 254
    326a:	5f 4f       	sbci	r21, 0xFF	; 255
    326c:	d7 01       	movw	r26, r14
    326e:	8d 91       	ld	r24, X+
    3270:	9c 91       	ld	r25, X
    3272:	9c 01       	movw	r18, r24
    3274:	b4 01       	movw	r22, r8
    3276:	f4 01       	movw	r30, r8
    3278:	e2 51       	subi	r30, 0x12	; 18
    327a:	f3 4d       	sbci	r31, 0xD3	; 211
				for(int i = 0; i < strlen(string_temp);i++) {
    327c:	00 e0       	ldi	r16, 0x00	; 0
    327e:	10 e0       	ldi	r17, 0x00	; 0
    3280:	06 c0       	rjmp	.+12     	; 0x328e <vDisplayWriteStringAtPos+0x10c>
					str[length+i] = string_temp[i];
    3282:	d9 01       	movw	r26, r18
    3284:	fd 90       	ld	r15, X+
    3286:	9d 01       	movw	r18, r26
    3288:	f1 92       	st	Z+, r15
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
				for(int i = 0; i < strlen(string_temp);i++) {
    328a:	0f 5f       	subi	r16, 0xFF	; 255
    328c:	1f 4f       	sbci	r17, 0xFF	; 255
    328e:	dc 01       	movw	r26, r24
    3290:	0d 90       	ld	r0, X+
    3292:	00 20       	and	r0, r0
    3294:	e9 f7       	brne	.-6      	; 0x3290 <vDisplayWriteStringAtPos+0x10e>
    3296:	11 97       	sbiw	r26, 0x01	; 1
    3298:	a8 1b       	sub	r26, r24
    329a:	b9 0b       	sbc	r27, r25
    329c:	0a 17       	cp	r16, r26
    329e:	1b 07       	cpc	r17, r27
    32a0:	80 f3       	brcs	.-32     	; 0x3282 <vDisplayWriteStringAtPos+0x100>
					str[length+i] = string_temp[i];
				}
				length += strlen(string_temp);
    32a2:	4d 01       	movw	r8, r26
    32a4:	86 0e       	add	r8, r22
    32a6:	97 1e       	adc	r9, r23
				length++;
				break;

				/* %s: print out a string       */
				case 's':
				string_temp = va_arg(arg, char *);
    32a8:	7a 01       	movw	r14, r20
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    32aa:	d2 01       	movw	r26, r4
    32ac:	a3 c2       	rjmp	.+1350   	; 0x37f4 <vDisplayWriteStringAtPos+0x672>
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    32ae:	87 01       	movw	r16, r14
    32b0:	0e 5f       	subi	r16, 0xFE	; 254
    32b2:	1f 4f       	sbci	r17, 0xFF	; 255
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    32b4:	4a e0       	ldi	r20, 0x0A	; 10
    32b6:	b6 01       	movw	r22, r12
    32b8:	f7 01       	movw	r30, r14
    32ba:	80 81       	ld	r24, Z
    32bc:	91 81       	ldd	r25, Z+1	; 0x01
    32be:	0e 94 bc 1f 	call	0x3f78	; 0x3f78 <__itoa_ncheck>
    32c2:	94 01       	movw	r18, r8
    32c4:	d4 01       	movw	r26, r8
    32c6:	a2 51       	subi	r26, 0x12	; 18
    32c8:	b3 4d       	sbci	r27, 0xD3	; 211
    32ca:	42 e0       	ldi	r20, 0x02	; 2
    32cc:	5d e2       	ldi	r21, 0x2D	; 45
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    32ce:	80 e0       	ldi	r24, 0x00	; 0
    32d0:	90 e0       	ldi	r25, 0x00	; 0
    32d2:	05 c0       	rjmp	.+10     	; 0x32de <vDisplayWriteStringAtPos+0x15c>
					str[length+i] = buffer[i];
    32d4:	fa 01       	movw	r30, r20
    32d6:	61 91       	ld	r22, Z+
    32d8:	af 01       	movw	r20, r30
    32da:	6d 93       	st	X+, r22

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 10);
				for(int i = 0; i < strlen(buffer);i++) {
    32dc:	01 96       	adiw	r24, 0x01	; 1
    32de:	f6 01       	movw	r30, r12
    32e0:	01 90       	ld	r0, Z+
    32e2:	00 20       	and	r0, r0
    32e4:	e9 f7       	brne	.-6      	; 0x32e0 <vDisplayWriteStringAtPos+0x15e>
    32e6:	31 97       	sbiw	r30, 0x01	; 1
    32e8:	e2 50       	subi	r30, 0x02	; 2
    32ea:	fd 42       	sbci	r31, 0x2D	; 45
    32ec:	8e 17       	cp	r24, r30
    32ee:	9f 07       	cpc	r25, r31
    32f0:	88 f3       	brcs	.-30     	; 0x32d4 <vDisplayWriteStringAtPos+0x152>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    32f2:	4f 01       	movw	r8, r30
    32f4:	82 0e       	add	r8, r18
    32f6:	93 1e       	adc	r9, r19
				length += strlen(string_temp);
				break;

				/* %d: print out an int         */
				case 'd':
				int_temp = va_arg(arg, int);
    32f8:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    32fa:	d2 01       	movw	r26, r4
    32fc:	7b c2       	rjmp	.+1270   	; 0x37f4 <vDisplayWriteStringAtPos+0x672>
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    32fe:	87 01       	movw	r16, r14
    3300:	0e 5f       	subi	r16, 0xFE	; 254
    3302:	1f 4f       	sbci	r17, 0xFF	; 255
    3304:	40 e1       	ldi	r20, 0x10	; 16
    3306:	b6 01       	movw	r22, r12
    3308:	d7 01       	movw	r26, r14
    330a:	8d 91       	ld	r24, X+
    330c:	9c 91       	ld	r25, X
    330e:	0e 94 bc 1f 	call	0x3f78	; 0x3f78 <__itoa_ncheck>
    3312:	94 01       	movw	r18, r8
    3314:	f4 01       	movw	r30, r8
    3316:	e2 51       	subi	r30, 0x12	; 18
    3318:	f3 4d       	sbci	r31, 0xD3	; 211
    331a:	42 e0       	ldi	r20, 0x02	; 2
    331c:	5d e2       	ldi	r21, 0x2D	; 45
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    331e:	80 e0       	ldi	r24, 0x00	; 0
    3320:	90 e0       	ldi	r25, 0x00	; 0
    3322:	05 c0       	rjmp	.+10     	; 0x332e <vDisplayWriteStringAtPos+0x1ac>
					str[length+i] = buffer[i];
    3324:	da 01       	movw	r26, r20
    3326:	6d 91       	ld	r22, X+
    3328:	ad 01       	movw	r20, r26
    332a:	61 93       	st	Z+, r22

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
				itoa(int_temp, buffer, 16);
				for(int i = 0; i < strlen(buffer);i++) {
    332c:	01 96       	adiw	r24, 0x01	; 1
    332e:	d6 01       	movw	r26, r12
    3330:	0d 90       	ld	r0, X+
    3332:	00 20       	and	r0, r0
    3334:	e9 f7       	brne	.-6      	; 0x3330 <vDisplayWriteStringAtPos+0x1ae>
    3336:	11 97       	sbiw	r26, 0x01	; 1
    3338:	a2 50       	subi	r26, 0x02	; 2
    333a:	bd 42       	sbci	r27, 0x2D	; 45
    333c:	8a 17       	cp	r24, r26
    333e:	9b 07       	cpc	r25, r27
    3340:	88 f3       	brcs	.-30     	; 0x3324 <vDisplayWriteStringAtPos+0x1a2>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    3342:	4d 01       	movw	r8, r26
    3344:	82 0e       	add	r8, r18
    3346:	93 1e       	adc	r9, r19
				length += strlen(buffer);
				break;

				/* %x: print out an int in hex  */
				case 'x':
				int_temp = va_arg(arg, int);
    3348:	78 01       	movw	r14, r16
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    334a:	d2 01       	movw	r26, r4
    334c:	53 c2       	rjmp	.+1190   	; 0x37f4 <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    334e:	17 01       	movw	r2, r14
    3350:	b4 e0       	ldi	r27, 0x04	; 4
    3352:	2b 0e       	add	r2, r27
    3354:	31 1c       	adc	r3, r1
    3356:	d7 01       	movw	r26, r14
    3358:	8d 91       	ld	r24, X+
    335a:	9d 91       	ld	r25, X+
    335c:	0d 90       	ld	r0, X+
    335e:	bc 91       	ld	r27, X
    3360:	a0 2d       	mov	r26, r0
    3362:	8f 8b       	std	Y+23, r24	; 0x17
    3364:	98 8f       	std	Y+24, r25	; 0x18
    3366:	a9 8f       	std	Y+25, r26	; 0x19
    3368:	ba 8f       	std	Y+26, r27	; 0x1a

    int exponent = 0;
    int places = 0;
    static const int width = 4;

    if (value == 0.0) {
    336a:	20 e0       	ldi	r18, 0x00	; 0
    336c:	30 e0       	ldi	r19, 0x00	; 0
    336e:	a9 01       	movw	r20, r18
    3370:	bc 01       	movw	r22, r24
    3372:	cd 01       	movw	r24, r26
    3374:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <__cmpsf2>
    3378:	81 11       	cpse	r24, r1
    337a:	05 c0       	rjmp	.+10     	; 0x3386 <vDisplayWriteStringAtPos+0x204>
        buffer[0] = '0';
    337c:	20 e3       	ldi	r18, 0x30	; 48
    337e:	f6 01       	movw	r30, r12
    3380:	20 83       	st	Z, r18
        buffer[1] = '\0';
    3382:	11 82       	std	Z+1, r1	; 0x01
    3384:	04 c1       	rjmp	.+520    	; 0x358e <vDisplayWriteStringAtPos+0x40c>
        return;
    }         

    if (value < 0.0) {
    3386:	20 e0       	ldi	r18, 0x00	; 0
    3388:	30 e0       	ldi	r19, 0x00	; 0
    338a:	a9 01       	movw	r20, r18
    338c:	6f 89       	ldd	r22, Y+23	; 0x17
    338e:	78 8d       	ldd	r23, Y+24	; 0x18
    3390:	89 8d       	ldd	r24, Y+25	; 0x19
    3392:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3394:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <__cmpsf2>
    3398:	88 23       	and	r24, r24
    339a:	9c f4       	brge	.+38     	; 0x33c2 <vDisplayWriteStringAtPos+0x240>
        *buffer++ = '-';
    339c:	ed e2       	ldi	r30, 0x2D	; 45
    339e:	d6 01       	movw	r26, r12
    33a0:	ec 93       	st	X, r30
        value = -value;
    33a2:	8f 89       	ldd	r24, Y+23	; 0x17
    33a4:	98 8d       	ldd	r25, Y+24	; 0x18
    33a6:	a9 8d       	ldd	r26, Y+25	; 0x19
    33a8:	ba 8d       	ldd	r27, Y+26	; 0x1a
    33aa:	b0 58       	subi	r27, 0x80	; 128
    33ac:	8f 8b       	std	Y+23, r24	; 0x17
    33ae:	98 8f       	std	Y+24, r25	; 0x18
    33b0:	a9 8f       	std	Y+25, r26	; 0x19
    33b2:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
        *buffer++ = '-';
    33b4:	0f 2e       	mov	r0, r31
    33b6:	f3 e0       	ldi	r31, 0x03	; 3
    33b8:	6f 2e       	mov	r6, r31
    33ba:	fd e2       	ldi	r31, 0x2D	; 45
    33bc:	7f 2e       	mov	r7, r31
    33be:	f0 2d       	mov	r31, r0
    33c0:	01 c0       	rjmp	.+2      	; 0x33c4 <vDisplayWriteStringAtPos+0x242>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }         

    if (value < 0.0) {
    33c2:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    33c4:	20 e0       	ldi	r18, 0x00	; 0
    33c6:	30 e0       	ldi	r19, 0x00	; 0
    33c8:	40 e8       	ldi	r20, 0x80	; 128
    33ca:	5f e3       	ldi	r21, 0x3F	; 63
    33cc:	6f 89       	ldd	r22, Y+23	; 0x17
    33ce:	78 8d       	ldd	r23, Y+24	; 0x18
    33d0:	89 8d       	ldd	r24, Y+25	; 0x19
    33d2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33d4:	0e 94 0a 1f 	call	0x3e14	; 0x3e14 <__gesf2>
    33d8:	88 23       	and	r24, r24
    33da:	0c f4       	brge	.+2      	; 0x33de <vDisplayWriteStringAtPos+0x25c>
    33dc:	44 c2       	rjmp	.+1160   	; 0x3866 <vDisplayWriteStringAtPos+0x6e4>
    33de:	00 e0       	ldi	r16, 0x00	; 0
    33e0:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    33e2:	20 e0       	ldi	r18, 0x00	; 0
    33e4:	30 e0       	ldi	r19, 0x00	; 0
    33e6:	40 e2       	ldi	r20, 0x20	; 32
    33e8:	51 e4       	ldi	r21, 0x41	; 65
    33ea:	6f 89       	ldd	r22, Y+23	; 0x17
    33ec:	78 8d       	ldd	r23, Y+24	; 0x18
    33ee:	89 8d       	ldd	r24, Y+25	; 0x19
    33f0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    33f2:	0e 94 b0 1d 	call	0x3b60	; 0x3b60 <__divsf3>
    33f6:	6f 8b       	std	Y+23, r22	; 0x17
    33f8:	78 8f       	std	Y+24, r23	; 0x18
    33fa:	89 8f       	std	Y+25, r24	; 0x19
    33fc:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    33fe:	0f 5f       	subi	r16, 0xFF	; 255
    3400:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3402:	20 e0       	ldi	r18, 0x00	; 0
    3404:	30 e0       	ldi	r19, 0x00	; 0
    3406:	40 e8       	ldi	r20, 0x80	; 128
    3408:	5f e3       	ldi	r21, 0x3F	; 63
    340a:	0e 94 0a 1f 	call	0x3e14	; 0x3e14 <__gesf2>
    340e:	88 23       	and	r24, r24
    3410:	44 f7       	brge	.-48     	; 0x33e2 <vDisplayWriteStringAtPos+0x260>
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3412:	2d ec       	ldi	r18, 0xCD	; 205
    3414:	3c ec       	ldi	r19, 0xCC	; 204
    3416:	4c ec       	ldi	r20, 0xCC	; 204
    3418:	5d e3       	ldi	r21, 0x3D	; 61
    341a:	6f 89       	ldd	r22, Y+23	; 0x17
    341c:	78 8d       	ldd	r23, Y+24	; 0x18
    341e:	89 8d       	ldd	r24, Y+25	; 0x19
    3420:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3422:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <__cmpsf2>
    3426:	88 23       	and	r24, r24
    3428:	1c f0       	brlt	.+6      	; 0x3430 <vDisplayWriteStringAtPos+0x2ae>
    342a:	1a c0       	rjmp	.+52     	; 0x3460 <vDisplayWriteStringAtPos+0x2de>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    342c:	00 e0       	ldi	r16, 0x00	; 0
    342e:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
        value *= 10.0;
    3430:	20 e0       	ldi	r18, 0x00	; 0
    3432:	30 e0       	ldi	r19, 0x00	; 0
    3434:	40 e2       	ldi	r20, 0x20	; 32
    3436:	51 e4       	ldi	r21, 0x41	; 65
    3438:	6f 89       	ldd	r22, Y+23	; 0x17
    343a:	78 8d       	ldd	r23, Y+24	; 0x18
    343c:	89 8d       	ldd	r24, Y+25	; 0x19
    343e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3440:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <__mulsf3>
    3444:	6f 8b       	std	Y+23, r22	; 0x17
    3446:	78 8f       	std	Y+24, r23	; 0x18
    3448:	89 8f       	std	Y+25, r24	; 0x19
    344a:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    344c:	01 50       	subi	r16, 0x01	; 1
    344e:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3450:	2d ec       	ldi	r18, 0xCD	; 205
    3452:	3c ec       	ldi	r19, 0xCC	; 204
    3454:	4c ec       	ldi	r20, 0xCC	; 204
    3456:	5d e3       	ldi	r21, 0x3D	; 61
    3458:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <__cmpsf2>
    345c:	88 23       	and	r24, r24
    345e:	44 f3       	brlt	.-48     	; 0x3430 <vDisplayWriteStringAtPos+0x2ae>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    3460:	10 16       	cp	r1, r16
    3462:	11 06       	cpc	r1, r17
    3464:	ac f5       	brge	.+106    	; 0x34d0 <vDisplayWriteStringAtPos+0x34e>
    3466:	73 01       	movw	r14, r6
    3468:	d3 01       	movw	r26, r6
    346a:	a0 0f       	add	r26, r16
    346c:	b1 1f       	adc	r27, r17
    346e:	ac 8f       	std	Y+28, r26	; 0x1c
    3470:	bd 8f       	std	Y+29, r27	; 0x1d
    3472:	3d 01       	movw	r6, r26
    3474:	6f 89       	ldd	r22, Y+23	; 0x17
    3476:	78 8d       	ldd	r23, Y+24	; 0x18
    3478:	89 8d       	ldd	r24, Y+25	; 0x19
    347a:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10;
    347c:	20 e0       	ldi	r18, 0x00	; 0
    347e:	30 e0       	ldi	r19, 0x00	; 0
    3480:	40 e2       	ldi	r20, 0x20	; 32
    3482:	51 e4       	ldi	r21, 0x41	; 65
    3484:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <__mulsf3>
    3488:	6f 8b       	std	Y+23, r22	; 0x17
    348a:	78 8f       	std	Y+24, r23	; 0x18
    348c:	89 8f       	std	Y+25, r24	; 0x19
    348e:	9a 8f       	std	Y+26, r25	; 0x1a
    3490:	0e 94 22 1e 	call	0x3c44	; 0x3c44 <__fixsfsi>
        *buffer++ = digit + '0';
    3494:	20 e3       	ldi	r18, 0x30	; 48
    3496:	26 0f       	add	r18, r22
    3498:	f7 01       	movw	r30, r14
    349a:	21 93       	st	Z+, r18
    349c:	7f 01       	movw	r14, r30
        value = value * 10 - digit;
    349e:	07 2e       	mov	r0, r23
    34a0:	00 0c       	add	r0, r0
    34a2:	88 0b       	sbc	r24, r24
    34a4:	99 0b       	sbc	r25, r25
    34a6:	0e 94 5a 1e 	call	0x3cb4	; 0x3cb4 <__floatsisf>
    34aa:	9b 01       	movw	r18, r22
    34ac:	ac 01       	movw	r20, r24
    34ae:	6f 89       	ldd	r22, Y+23	; 0x17
    34b0:	78 8d       	ldd	r23, Y+24	; 0x18
    34b2:	89 8d       	ldd	r24, Y+25	; 0x19
    34b4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    34b6:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <__subsf3>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    34ba:	e6 14       	cp	r14, r6
    34bc:	f7 04       	cpc	r15, r7
    34be:	f1 f6       	brne	.-68     	; 0x347c <vDisplayWriteStringAtPos+0x2fa>
    34c0:	6f 8b       	std	Y+23, r22	; 0x17
    34c2:	78 8f       	std	Y+24, r23	; 0x18
    34c4:	89 8f       	std	Y+25, r24	; 0x19
    34c6:	9a 8f       	std	Y+26, r25	; 0x1a
        value = value * 10 - digit;
        ++places;
        --exponent;
    }

    if (places == 0)
    34c8:	01 15       	cp	r16, r1
    34ca:	11 05       	cpc	r17, r1
    34cc:	89 f4       	brne	.+34     	; 0x34f0 <vDisplayWriteStringAtPos+0x36e>
    34ce:	db c1       	rjmp	.+950    	; 0x3886 <vDisplayWriteStringAtPos+0x704>
        value = -value;
    }

    exponent = normalize(&value);

    while (exponent > 0) {
    34d0:	c8 01       	movw	r24, r16
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    34d2:	e0 e3       	ldi	r30, 0x30	; 48
    34d4:	d3 01       	movw	r26, r6
    34d6:	ec 93       	st	X, r30

    *buffer++ = '.';
    34d8:	73 01       	movw	r14, r6
    34da:	f2 e0       	ldi	r31, 0x02	; 2
    34dc:	ef 0e       	add	r14, r31
    34de:	f1 1c       	adc	r15, r1
    34e0:	2e e2       	ldi	r18, 0x2E	; 46
    34e2:	11 96       	adiw	r26, 0x01	; 1
    34e4:	2c 93       	st	X, r18

    while (exponent < 0 && places < width) {
    34e6:	99 23       	and	r25, r25
    34e8:	6c f0       	brlt	.+26     	; 0x3504 <vDisplayWriteStringAtPos+0x382>
    34ea:	00 e0       	ldi	r16, 0x00	; 0
    34ec:	10 e0       	ldi	r17, 0x00	; 0
    34ee:	1f c0       	rjmp	.+62     	; 0x352e <vDisplayWriteStringAtPos+0x3ac>
    }

    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';
    34f0:	ec 8c       	ldd	r14, Y+28	; 0x1c
    34f2:	fd 8c       	ldd	r15, Y+29	; 0x1d
    34f4:	3f ef       	ldi	r19, 0xFF	; 255
    34f6:	e3 1a       	sub	r14, r19
    34f8:	f3 0a       	sbc	r15, r19
    34fa:	ee e2       	ldi	r30, 0x2E	; 46
    34fc:	ac 8d       	ldd	r26, Y+28	; 0x1c
    34fe:	bd 8d       	ldd	r27, Y+29	; 0x1d
    3500:	ec 93       	st	X, r30
    3502:	12 c0       	rjmp	.+36     	; 0x3528 <vDisplayWriteStringAtPos+0x3a6>

    while (exponent < 0 && places < width) {
    3504:	00 e0       	ldi	r16, 0x00	; 0
    3506:	10 e0       	ldi	r17, 0x00	; 0
        *buffer++ = '0';
    3508:	ff ef       	ldi	r31, 0xFF	; 255
    350a:	ef 1a       	sub	r14, r31
    350c:	ff 0a       	sbc	r15, r31
    350e:	f7 01       	movw	r30, r14
    3510:	31 97       	sbiw	r30, 0x01	; 1
    3512:	20 e3       	ldi	r18, 0x30	; 48
    3514:	20 83       	st	Z, r18
        --exponent;
    3516:	01 97       	sbiw	r24, 0x01	; 1
        ++places;
    3518:	0f 5f       	subi	r16, 0xFF	; 255
    351a:	1f 4f       	sbci	r17, 0xFF	; 255
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    351c:	99 23       	and	r25, r25
    351e:	24 f4       	brge	.+8      	; 0x3528 <vDisplayWriteStringAtPos+0x3a6>
    3520:	04 30       	cpi	r16, 0x04	; 4
    3522:	11 05       	cpc	r17, r1
    3524:	8c f3       	brlt	.-30     	; 0x3508 <vDisplayWriteStringAtPos+0x386>
    3526:	31 c0       	rjmp	.+98     	; 0x358a <vDisplayWriteStringAtPos+0x408>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    3528:	04 30       	cpi	r16, 0x04	; 4
    352a:	11 05       	cpc	r17, r1
    352c:	74 f5       	brge	.+92     	; 0x358a <vDisplayWriteStringAtPos+0x408>
    352e:	37 01       	movw	r6, r14
    3530:	84 e0       	ldi	r24, 0x04	; 4
    3532:	90 e0       	ldi	r25, 0x00	; 0
    3534:	80 1b       	sub	r24, r16
    3536:	91 0b       	sbc	r25, r17
    3538:	e8 0e       	add	r14, r24
    353a:	f9 1e       	adc	r15, r25
    353c:	87 01       	movw	r16, r14
    353e:	6f 89       	ldd	r22, Y+23	; 0x17
    3540:	78 8d       	ldd	r23, Y+24	; 0x18
    3542:	89 8d       	ldd	r24, Y+25	; 0x19
    3544:	9a 8d       	ldd	r25, Y+26	; 0x1a
        int digit = value * 10.0;
    3546:	20 e0       	ldi	r18, 0x00	; 0
    3548:	30 e0       	ldi	r19, 0x00	; 0
    354a:	40 e2       	ldi	r20, 0x20	; 32
    354c:	51 e4       	ldi	r21, 0x41	; 65
    354e:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <__mulsf3>
    3552:	6f 8b       	std	Y+23, r22	; 0x17
    3554:	78 8f       	std	Y+24, r23	; 0x18
    3556:	89 8f       	std	Y+25, r24	; 0x19
    3558:	9a 8f       	std	Y+26, r25	; 0x1a
    355a:	0e 94 22 1e 	call	0x3c44	; 0x3c44 <__fixsfsi>
        *buffer++ = digit + '0';
    355e:	20 e3       	ldi	r18, 0x30	; 48
    3560:	26 0f       	add	r18, r22
    3562:	d3 01       	movw	r26, r6
    3564:	2d 93       	st	X+, r18
    3566:	3d 01       	movw	r6, r26
        value = value * 10.0 - digit;
    3568:	07 2e       	mov	r0, r23
    356a:	00 0c       	add	r0, r0
    356c:	88 0b       	sbc	r24, r24
    356e:	99 0b       	sbc	r25, r25
    3570:	0e 94 5a 1e 	call	0x3cb4	; 0x3cb4 <__floatsisf>
    3574:	9b 01       	movw	r18, r22
    3576:	ac 01       	movw	r20, r24
    3578:	6f 89       	ldd	r22, Y+23	; 0x17
    357a:	78 8d       	ldd	r23, Y+24	; 0x18
    357c:	89 8d       	ldd	r24, Y+25	; 0x19
    357e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3580:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <__subsf3>
        *buffer++ = '0';
        --exponent;
        ++places;
    }

    while (places < width) {
    3584:	60 16       	cp	r6, r16
    3586:	71 06       	cpc	r7, r17
    3588:	f1 f6       	brne	.-68     	; 0x3546 <vDisplayWriteStringAtPos+0x3c4>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
        ++places;
    }
    *buffer = '\0';
    358a:	f7 01       	movw	r30, r14
    358c:	10 82       	st	Z, r1
    358e:	94 01       	movw	r18, r8
    3590:	f4 01       	movw	r30, r8
    3592:	e2 51       	subi	r30, 0x12	; 18
    3594:	f3 4d       	sbci	r31, 0xD3	; 211
    if (places == 0)
        *buffer++ = '0';

    *buffer++ = '.';

    while (exponent < 0 && places < width) {
    3596:	42 e0       	ldi	r20, 0x02	; 2
    3598:	5d e2       	ldi	r21, 0x2D	; 45
    359a:	80 e0       	ldi	r24, 0x00	; 0
    359c:	90 e0       	ldi	r25, 0x00	; 0
    359e:	05 c0       	rjmp	.+10     	; 0x35aa <vDisplayWriteStringAtPos+0x428>

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    35a0:	da 01       	movw	r26, r20
    35a2:	6d 91       	ld	r22, X+
    35a4:	ad 01       	movw	r20, r26
    35a6:	61 93       	st	Z+, r22
				break;

				case 'f':
				double_temp = va_arg(arg, double);
				ftoa_fixed(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    35a8:	01 96       	adiw	r24, 0x01	; 1
    35aa:	d6 01       	movw	r26, r12
    35ac:	0d 90       	ld	r0, X+
    35ae:	00 20       	and	r0, r0
    35b0:	e9 f7       	brne	.-6      	; 0x35ac <vDisplayWriteStringAtPos+0x42a>
    35b2:	11 97       	sbiw	r26, 0x01	; 1
    35b4:	a2 50       	subi	r26, 0x02	; 2
    35b6:	bd 42       	sbci	r27, 0x2D	; 45
    35b8:	8a 17       	cp	r24, r26
    35ba:	9b 07       	cpc	r25, r27
    35bc:	88 f3       	brcs	.-30     	; 0x35a0 <vDisplayWriteStringAtPos+0x41e>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    35be:	4d 01       	movw	r8, r26
    35c0:	82 0e       	add	r8, r18
    35c2:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'f':
				double_temp = va_arg(arg, double);
    35c4:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    35c6:	d2 01       	movw	r26, r4
    35c8:	15 c1       	rjmp	.+554    	; 0x37f4 <vDisplayWriteStringAtPos+0x672>
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    35ca:	17 01       	movw	r2, r14
    35cc:	b4 e0       	ldi	r27, 0x04	; 4
    35ce:	2b 0e       	add	r2, r27
    35d0:	31 1c       	adc	r3, r1
    35d2:	d7 01       	movw	r26, r14
    35d4:	8d 91       	ld	r24, X+
    35d6:	9d 91       	ld	r25, X+
    35d8:	0d 90       	ld	r0, X+
    35da:	bc 91       	ld	r27, X
    35dc:	a0 2d       	mov	r26, r0
    35de:	8f 8b       	std	Y+23, r24	; 0x17
    35e0:	98 8f       	std	Y+24, r25	; 0x18
    35e2:	a9 8f       	std	Y+25, r26	; 0x19
    35e4:	ba 8f       	std	Y+26, r27	; 0x1a

void ftoa_sci(char *buffer, double value) {
    int exponent = 0;    
    static const int width = 4;

    if (value == 0.0) {
    35e6:	20 e0       	ldi	r18, 0x00	; 0
    35e8:	30 e0       	ldi	r19, 0x00	; 0
    35ea:	a9 01       	movw	r20, r18
    35ec:	bc 01       	movw	r22, r24
    35ee:	cd 01       	movw	r24, r26
    35f0:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <__cmpsf2>
    35f4:	81 11       	cpse	r24, r1
    35f6:	05 c0       	rjmp	.+10     	; 0x3602 <vDisplayWriteStringAtPos+0x480>
        buffer[0] = '0';
    35f8:	20 e3       	ldi	r18, 0x30	; 48
    35fa:	f6 01       	movw	r30, r12
    35fc:	20 83       	st	Z, r18
        buffer[1] = '\0';
    35fe:	11 82       	std	Z+1, r1	; 0x01
    3600:	ca c0       	rjmp	.+404    	; 0x3796 <vDisplayWriteStringAtPos+0x614>
        return;
    }

    if (value < 0.0) {
    3602:	20 e0       	ldi	r18, 0x00	; 0
    3604:	30 e0       	ldi	r19, 0x00	; 0
    3606:	a9 01       	movw	r20, r18
    3608:	6f 89       	ldd	r22, Y+23	; 0x17
    360a:	78 8d       	ldd	r23, Y+24	; 0x18
    360c:	89 8d       	ldd	r24, Y+25	; 0x19
    360e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3610:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <__cmpsf2>
    3614:	88 23       	and	r24, r24
    3616:	9c f4       	brge	.+38     	; 0x363e <vDisplayWriteStringAtPos+0x4bc>
        *buffer++ = '-';
    3618:	ed e2       	ldi	r30, 0x2D	; 45
    361a:	d6 01       	movw	r26, r12
    361c:	ec 93       	st	X, r30
        value = -value;
    361e:	8f 89       	ldd	r24, Y+23	; 0x17
    3620:	98 8d       	ldd	r25, Y+24	; 0x18
    3622:	a9 8d       	ldd	r26, Y+25	; 0x19
    3624:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3626:	b0 58       	subi	r27, 0x80	; 128
    3628:	8f 8b       	std	Y+23, r24	; 0x17
    362a:	98 8f       	std	Y+24, r25	; 0x18
    362c:	a9 8f       	std	Y+25, r26	; 0x19
    362e:	ba 8f       	std	Y+26, r27	; 0x1a
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
        *buffer++ = '-';
    3630:	0f 2e       	mov	r0, r31
    3632:	f3 e0       	ldi	r31, 0x03	; 3
    3634:	6f 2e       	mov	r6, r31
    3636:	fd e2       	ldi	r31, 0x2D	; 45
    3638:	7f 2e       	mov	r7, r31
    363a:	f0 2d       	mov	r31, r0
    363c:	01 c0       	rjmp	.+2      	; 0x3640 <vDisplayWriteStringAtPos+0x4be>
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0.0) {
    363e:	36 01       	movw	r6, r12

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    3640:	20 e0       	ldi	r18, 0x00	; 0
    3642:	30 e0       	ldi	r19, 0x00	; 0
    3644:	40 e8       	ldi	r20, 0x80	; 128
    3646:	5f e3       	ldi	r21, 0x3F	; 63
    3648:	6f 89       	ldd	r22, Y+23	; 0x17
    364a:	78 8d       	ldd	r23, Y+24	; 0x18
    364c:	89 8d       	ldd	r24, Y+25	; 0x19
    364e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3650:	0e 94 0a 1f 	call	0x3e14	; 0x3e14 <__gesf2>
    3654:	88 23       	and	r24, r24
    3656:	dc f0       	brlt	.+54     	; 0x368e <vDisplayWriteStringAtPos+0x50c>
    3658:	00 e0       	ldi	r16, 0x00	; 0
    365a:	10 e0       	ldi	r17, 0x00	; 0
        value /= 10.0;
    365c:	20 e0       	ldi	r18, 0x00	; 0
    365e:	30 e0       	ldi	r19, 0x00	; 0
    3660:	40 e2       	ldi	r20, 0x20	; 32
    3662:	51 e4       	ldi	r21, 0x41	; 65
    3664:	6f 89       	ldd	r22, Y+23	; 0x17
    3666:	78 8d       	ldd	r23, Y+24	; 0x18
    3668:	89 8d       	ldd	r24, Y+25	; 0x19
    366a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    366c:	0e 94 b0 1d 	call	0x3b60	; 0x3b60 <__divsf3>
    3670:	6f 8b       	std	Y+23, r22	; 0x17
    3672:	78 8f       	std	Y+24, r23	; 0x18
    3674:	89 8f       	std	Y+25, r24	; 0x19
    3676:	9a 8f       	std	Y+26, r25	; 0x1a
        ++exponent;
    3678:	0f 5f       	subi	r16, 0xFF	; 255
    367a:	1f 4f       	sbci	r17, 0xFF	; 255

static int normalize(double *val) {
    int exponent = 0;
    double value = *val;

    while (value >= 1.0) {
    367c:	20 e0       	ldi	r18, 0x00	; 0
    367e:	30 e0       	ldi	r19, 0x00	; 0
    3680:	40 e8       	ldi	r20, 0x80	; 128
    3682:	5f e3       	ldi	r21, 0x3F	; 63
    3684:	0e 94 0a 1f 	call	0x3e14	; 0x3e14 <__gesf2>
    3688:	88 23       	and	r24, r24
    368a:	44 f7       	brge	.-48     	; 0x365c <vDisplayWriteStringAtPos+0x4da>
    368c:	02 c0       	rjmp	.+4      	; 0x3692 <vDisplayWriteStringAtPos+0x510>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    368e:	00 e0       	ldi	r16, 0x00	; 0
    3690:	10 e0       	ldi	r17, 0x00	; 0
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3692:	2d ec       	ldi	r18, 0xCD	; 205
    3694:	3c ec       	ldi	r19, 0xCC	; 204
    3696:	4c ec       	ldi	r20, 0xCC	; 204
    3698:	5d e3       	ldi	r21, 0x3D	; 61
    369a:	6f 89       	ldd	r22, Y+23	; 0x17
    369c:	78 8d       	ldd	r23, Y+24	; 0x18
    369e:	89 8d       	ldd	r24, Y+25	; 0x19
    36a0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    36a2:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <__cmpsf2>
    36a6:	88 23       	and	r24, r24
    36a8:	c4 f4       	brge	.+48     	; 0x36da <vDisplayWriteStringAtPos+0x558>
        value *= 10.0;
    36aa:	20 e0       	ldi	r18, 0x00	; 0
    36ac:	30 e0       	ldi	r19, 0x00	; 0
    36ae:	40 e2       	ldi	r20, 0x20	; 32
    36b0:	51 e4       	ldi	r21, 0x41	; 65
    36b2:	6f 89       	ldd	r22, Y+23	; 0x17
    36b4:	78 8d       	ldd	r23, Y+24	; 0x18
    36b6:	89 8d       	ldd	r24, Y+25	; 0x19
    36b8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    36ba:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <__mulsf3>
    36be:	6f 8b       	std	Y+23, r22	; 0x17
    36c0:	78 8f       	std	Y+24, r23	; 0x18
    36c2:	89 8f       	std	Y+25, r24	; 0x19
    36c4:	9a 8f       	std	Y+26, r25	; 0x1a
        --exponent;
    36c6:	01 50       	subi	r16, 0x01	; 1
    36c8:	11 09       	sbc	r17, r1
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    36ca:	2d ec       	ldi	r18, 0xCD	; 205
    36cc:	3c ec       	ldi	r19, 0xCC	; 204
    36ce:	4c ec       	ldi	r20, 0xCC	; 204
    36d0:	5d e3       	ldi	r21, 0x3D	; 61
    36d2:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <__cmpsf2>
    36d6:	88 23       	and	r24, r24
    36d8:	44 f3       	brlt	.-48     	; 0x36aa <vDisplayWriteStringAtPos+0x528>
        value = -value;
    }

    exponent = normalize(&value);

    int digit = value * 10.0;
    36da:	20 e0       	ldi	r18, 0x00	; 0
    36dc:	30 e0       	ldi	r19, 0x00	; 0
    36de:	40 e2       	ldi	r20, 0x20	; 32
    36e0:	51 e4       	ldi	r21, 0x41	; 65
    36e2:	6f 89       	ldd	r22, Y+23	; 0x17
    36e4:	78 8d       	ldd	r23, Y+24	; 0x18
    36e6:	89 8d       	ldd	r24, Y+25	; 0x19
    36e8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    36ea:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <__mulsf3>
    36ee:	6f 8b       	std	Y+23, r22	; 0x17
    36f0:	78 8f       	std	Y+24, r23	; 0x18
    36f2:	89 8f       	std	Y+25, r24	; 0x19
    36f4:	9a 8f       	std	Y+26, r25	; 0x1a
    36f6:	0e 94 22 1e 	call	0x3c44	; 0x3c44 <__fixsfsi>
    *buffer++ = digit + '0';
    36fa:	20 e3       	ldi	r18, 0x30	; 48
    36fc:	26 0f       	add	r18, r22
    36fe:	d3 01       	movw	r26, r6
    3700:	2c 93       	st	X, r18
    value = value * 10.0 - digit;
    3702:	07 2e       	mov	r0, r23
    3704:	00 0c       	add	r0, r0
    3706:	88 0b       	sbc	r24, r24
    3708:	99 0b       	sbc	r25, r25
    370a:	0e 94 5a 1e 	call	0x3cb4	; 0x3cb4 <__floatsisf>
    370e:	9b 01       	movw	r18, r22
    3710:	ac 01       	movw	r20, r24
    3712:	6f 89       	ldd	r22, Y+23	; 0x17
    3714:	78 8d       	ldd	r23, Y+24	; 0x18
    3716:	89 8d       	ldd	r24, Y+25	; 0x19
    3718:	9a 8d       	ldd	r25, Y+26	; 0x1a
    371a:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <__subsf3>
    --exponent;
    371e:	f8 01       	movw	r30, r16
    3720:	31 97       	sbiw	r30, 0x01	; 1
    3722:	ec 8f       	std	Y+28, r30	; 0x1c
    3724:	fd 8f       	std	Y+29, r31	; 0x1d

    *buffer++ = '.';
    3726:	ee e2       	ldi	r30, 0x2E	; 46
    3728:	d3 01       	movw	r26, r6
    372a:	11 96       	adiw	r26, 0x01	; 1
    372c:	ec 93       	st	X, r30
    372e:	83 01       	movw	r16, r6
    3730:	0e 5f       	subi	r16, 0xFE	; 254
    3732:	1f 4f       	sbci	r17, 0xFF	; 255
    3734:	73 01       	movw	r14, r6
    3736:	f6 e0       	ldi	r31, 0x06	; 6
    3738:	ef 0e       	add	r14, r31
    373a:	f1 1c       	adc	r15, r1

    for (int i = 0; i < width; i++) {
        int digit = value * 10.0;
    373c:	20 e0       	ldi	r18, 0x00	; 0
    373e:	30 e0       	ldi	r19, 0x00	; 0
    3740:	40 e2       	ldi	r20, 0x20	; 32
    3742:	51 e4       	ldi	r21, 0x41	; 65
    3744:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <__mulsf3>
    3748:	6f 8b       	std	Y+23, r22	; 0x17
    374a:	78 8f       	std	Y+24, r23	; 0x18
    374c:	89 8f       	std	Y+25, r24	; 0x19
    374e:	9a 8f       	std	Y+26, r25	; 0x1a
    3750:	0e 94 22 1e 	call	0x3c44	; 0x3c44 <__fixsfsi>
        *buffer++ = digit + '0';
    3754:	20 e3       	ldi	r18, 0x30	; 48
    3756:	26 0f       	add	r18, r22
    3758:	d8 01       	movw	r26, r16
    375a:	2d 93       	st	X+, r18
    375c:	8d 01       	movw	r16, r26
        value = value * 10.0 - digit;
    375e:	07 2e       	mov	r0, r23
    3760:	00 0c       	add	r0, r0
    3762:	88 0b       	sbc	r24, r24
    3764:	99 0b       	sbc	r25, r25
    3766:	0e 94 5a 1e 	call	0x3cb4	; 0x3cb4 <__floatsisf>
    376a:	9b 01       	movw	r18, r22
    376c:	ac 01       	movw	r20, r24
    376e:	6f 89       	ldd	r22, Y+23	; 0x17
    3770:	78 8d       	ldd	r23, Y+24	; 0x18
    3772:	89 8d       	ldd	r24, Y+25	; 0x19
    3774:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3776:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <__subsf3>
    value = value * 10.0 - digit;
    --exponent;

    *buffer++ = '.';

    for (int i = 0; i < width; i++) {
    377a:	0e 15       	cp	r16, r14
    377c:	1f 05       	cpc	r17, r15
    377e:	f1 f6       	brne	.-68     	; 0x373c <vDisplayWriteStringAtPos+0x5ba>
        int digit = value * 10.0;
        *buffer++ = digit + '0';
        value = value * 10.0 - digit;
    }

    *buffer++ = 'e';
    3780:	25 e6       	ldi	r18, 0x65	; 101
    3782:	f3 01       	movw	r30, r6
    3784:	26 83       	std	Z+6, r18	; 0x06
    3786:	b3 01       	movw	r22, r6
    3788:	69 5f       	subi	r22, 0xF9	; 249
    378a:	7f 4f       	sbci	r23, 0xFF	; 255
    378c:	4a e0       	ldi	r20, 0x0A	; 10
    378e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3790:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3792:	0e 94 bc 1f 	call	0x3f78	; 0x3f78 <__itoa_ncheck>
    3796:	94 01       	movw	r18, r8
    3798:	f4 01       	movw	r30, r8
    379a:	e2 51       	subi	r30, 0x12	; 18
    379c:	f3 4d       	sbci	r31, 0xD3	; 211
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    379e:	42 e0       	ldi	r20, 0x02	; 2
    37a0:	5d e2       	ldi	r21, 0x2D	; 45
    37a2:	80 e0       	ldi	r24, 0x00	; 0
    37a4:	90 e0       	ldi	r25, 0x00	; 0
    37a6:	05 c0       	rjmp	.+10     	; 0x37b2 <vDisplayWriteStringAtPos+0x630>

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
					str[length+i] = buffer[i];
    37a8:	da 01       	movw	r26, r20
    37aa:	6d 91       	ld	r22, X+
    37ac:	ad 01       	movw	r20, r26
    37ae:	61 93       	st	Z+, r22
				break;

				case 'e':
				double_temp = va_arg(arg, double);
				ftoa_sci(buffer, double_temp);
				for(int i = 0; i < strlen(buffer);i++) {
    37b0:	01 96       	adiw	r24, 0x01	; 1
    37b2:	d6 01       	movw	r26, r12
    37b4:	0d 90       	ld	r0, X+
    37b6:	00 20       	and	r0, r0
    37b8:	e9 f7       	brne	.-6      	; 0x37b4 <vDisplayWriteStringAtPos+0x632>
    37ba:	11 97       	sbiw	r26, 0x01	; 1
    37bc:	a2 50       	subi	r26, 0x02	; 2
    37be:	bd 42       	sbci	r27, 0x2D	; 45
    37c0:	8a 17       	cp	r24, r26
    37c2:	9b 07       	cpc	r25, r27
    37c4:	88 f3       	brcs	.-30     	; 0x37a8 <vDisplayWriteStringAtPos+0x626>
					str[length+i] = buffer[i];
				}
				length += strlen(buffer);
    37c6:	4d 01       	movw	r8, r26
    37c8:	82 0e       	add	r8, r18
    37ca:	93 1e       	adc	r9, r19
				}
				length += strlen(buffer);
				break;

				case 'e':
				double_temp = va_arg(arg, double);
    37cc:	71 01       	movw	r14, r2
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    37ce:	d2 01       	movw	r26, r4
    37d0:	11 c0       	rjmp	.+34     	; 0x37f4 <vDisplayWriteStringAtPos+0x672>
				break;
			}
		}
		else {
			str[length] = ch;
			if(str[length] == '\n') {
    37d2:	8a 30       	cpi	r24, 0x0A	; 10
    37d4:	29 f0       	breq	.+10     	; 0x37e0 <vDisplayWriteStringAtPos+0x65e>
				length += strlen(buffer);
				break;
			}
		}
		else {
			str[length] = ch;
    37d6:	f4 01       	movw	r30, r8
    37d8:	e2 51       	subi	r30, 0x12	; 18
    37da:	f3 4d       	sbci	r31, 0xD3	; 211
    37dc:	80 83       	st	Z, r24
    37de:	04 c0       	rjmp	.+8      	; 0x37e8 <vDisplayWriteStringAtPos+0x666>
			if(str[length] == '\n') {
				str[length] = '\0';				
    37e0:	f4 01       	movw	r30, r8
    37e2:	e2 51       	subi	r30, 0x12	; 18
    37e4:	f3 4d       	sbci	r31, 0xD3	; 211
    37e6:	10 82       	st	Z, r1
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    37e8:	11 96       	adiw	r26, 0x01	; 1
		else {
			str[length] = ch;
			if(str[length] == '\n') {
				str[length] = '\0';				
			}
			length++;
    37ea:	ef ef       	ldi	r30, 0xFF	; 255
    37ec:	8e 1a       	sub	r8, r30
    37ee:	9e 0a       	sbc	r9, r30
    37f0:	01 c0       	rjmp	.+2      	; 0x37f4 <vDisplayWriteStringAtPos+0x672>
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
		if ( '%' == ch ) {
			switch (ch = *fmt++) {
    37f2:	d2 01       	movw	r26, r4
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
		str[i] = 0x00;
	}
	while ((ch = *fmt++)!=false) {
    37f4:	8c 91       	ld	r24, X
    37f6:	81 11       	cpse	r24, r1
    37f8:	01 cd       	rjmp	.-1534   	; 0x31fc <vDisplayWriteStringAtPos+0x7a>
				str[length] = '\0';				
			}
			length++;
		}
	}
	if(length + pos >= 20) {
    37fa:	8d a9       	ldd	r24, Y+53	; 0x35
    37fc:	9e a9       	ldd	r25, Y+54	; 0x36
    37fe:	88 0d       	add	r24, r8
    3800:	99 1d       	adc	r25, r9
    3802:	44 97       	sbiw	r24, 0x14	; 20
    3804:	3c f0       	brlt	.+14     	; 0x3814 <vDisplayWriteStringAtPos+0x692>
		length = 20-pos;
    3806:	84 e1       	ldi	r24, 0x14	; 20
    3808:	90 e0       	ldi	r25, 0x00	; 0
    380a:	4c 01       	movw	r8, r24
    380c:	2d a9       	ldd	r18, Y+53	; 0x35
    380e:	3e a9       	ldd	r19, Y+54	; 0x36
    3810:	82 1a       	sub	r8, r18
    3812:	93 0a       	sbc	r9, r19
    3814:	fe 01       	movw	r30, r28
    3816:	33 96       	adiw	r30, 0x03	; 3
    3818:	ce 01       	movw	r24, r28
    381a:	47 96       	adiw	r24, 0x17	; 23
	static char buffer[20];
	static char str[20];
	for(int i = 0; i < 20; i++) {
		buffer[i] = 0x00;
	}
	for(int i = 0; i < 20; i++) {
    381c:	df 01       	movw	r26, r30
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
    381e:	1d 92       	st	X+, r1
	}
	if(length + pos >= 20) {
		length = 20-pos;
	}
	displayLine_t newLine;
	for(int i = 0; i < 20; i++) {
    3820:	a8 17       	cp	r26, r24
    3822:	b9 07       	cpc	r27, r25
    3824:	e1 f7       	brne	.-8      	; 0x381e <vDisplayWriteStringAtPos+0x69c>
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
    3826:	3b 8d       	ldd	r19, Y+27	; 0x1b
    3828:	39 83       	std	Y+1, r19	; 0x01
	newLine.displayPos = pos;
    382a:	8d a9       	ldd	r24, Y+53	; 0x35
    382c:	8a 83       	std	Y+2, r24	; 0x02
	for(int i = 0; i < length;i++) {
    382e:	18 14       	cp	r1, r8
    3830:	19 04       	cpc	r1, r9
    3832:	5c f4       	brge	.+22     	; 0x384a <vDisplayWriteStringAtPos+0x6c8>
    3834:	ce 01       	movw	r24, r28
    3836:	88 0d       	add	r24, r8
    3838:	99 1d       	adc	r25, r9
    383a:	03 96       	adiw	r24, 0x03	; 3
		newLine.displayBuffer[i] = str[i];
    383c:	d5 01       	movw	r26, r10
    383e:	2d 91       	ld	r18, X+
    3840:	5d 01       	movw	r10, r26
    3842:	21 93       	st	Z+, r18
	for(int i = 0; i < 20; i++) {
		newLine.displayBuffer[i] = 0x00;
	}
	newLine.displayLine = line;
	newLine.displayPos = pos;
	for(int i = 0; i < length;i++) {
    3844:	8e 17       	cp	r24, r30
    3846:	9f 07       	cpc	r25, r31
    3848:	c9 f7       	brne	.-14     	; 0x383c <vDisplayWriteStringAtPos+0x6ba>
		newLine.displayBuffer[i] = str[i];
	}	
	xQueueSend(displayLineQueue, (void *) &newLine, portMAX_DELAY);
    384a:	00 e0       	ldi	r16, 0x00	; 0
    384c:	2f ef       	ldi	r18, 0xFF	; 255
    384e:	3f ef       	ldi	r19, 0xFF	; 255
    3850:	a9 01       	movw	r20, r18
    3852:	be 01       	movw	r22, r28
    3854:	6f 5f       	subi	r22, 0xFF	; 255
    3856:	7f 4f       	sbci	r23, 0xFF	; 255
    3858:	80 91 a9 31 	lds	r24, 0x31A9	; 0x8031a9 <displayLineQueue>
    385c:	90 91 aa 31 	lds	r25, 0x31AA	; 0x8031aa <displayLineQueue+0x1>
    3860:	0e 94 02 08 	call	0x1004	; 0x1004 <xQueueGenericSend>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    3864:	1b c0       	rjmp	.+54     	; 0x389c <vDisplayWriteStringAtPos+0x71a>
    while (value >= 1.0) {
        value /= 10.0;
        ++exponent;
    }

    while (value < 0.1) {
    3866:	2d ec       	ldi	r18, 0xCD	; 205
    3868:	3c ec       	ldi	r19, 0xCC	; 204
    386a:	4c ec       	ldi	r20, 0xCC	; 204
    386c:	5d e3       	ldi	r21, 0x3D	; 61
    386e:	6f 89       	ldd	r22, Y+23	; 0x17
    3870:	78 8d       	ldd	r23, Y+24	; 0x18
    3872:	89 8d       	ldd	r24, Y+25	; 0x19
    3874:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3876:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <__cmpsf2>
    387a:	88 23       	and	r24, r24
    387c:	0c f4       	brge	.+2      	; 0x3880 <vDisplayWriteStringAtPos+0x6fe>
    387e:	d6 cd       	rjmp	.-1108   	; 0x342c <vDisplayWriteStringAtPos+0x2aa>
	
	return length;
}

static int normalize(double *val) {
    int exponent = 0;
    3880:	80 e0       	ldi	r24, 0x00	; 0
    3882:	90 e0       	ldi	r25, 0x00	; 0
    3884:	26 ce       	rjmp	.-948    	; 0x34d2 <vDisplayWriteStringAtPos+0x350>
        ++places;
        --exponent;
    }

    if (places == 0)
        *buffer++ = '0';
    3886:	20 e3       	ldi	r18, 0x30	; 48
    3888:	ec 8d       	ldd	r30, Y+28	; 0x1c
    388a:	fd 8d       	ldd	r31, Y+29	; 0x1d
    388c:	20 83       	st	Z, r18

    *buffer++ = '.';
    388e:	7f 01       	movw	r14, r30
    3890:	32 e0       	ldi	r19, 0x02	; 2
    3892:	e3 0e       	add	r14, r19
    3894:	f1 1c       	adc	r15, r1
    3896:	8e e2       	ldi	r24, 0x2E	; 46
    3898:	81 83       	std	Z+1, r24	; 0x01
    389a:	46 ce       	rjmp	.-884    	; 0x3528 <vDisplayWriteStringAtPos+0x3a6>
void vDisplayWriteStringAtPos(int line, int pos, char const *fmt, ...) {
	va_list arg;	
	va_start(arg, fmt);
	display_vprintf(line, pos, fmt, arg);
	va_end(arg);	
}
    389c:	6d 96       	adiw	r28, 0x1d	; 29
    389e:	cd bf       	out	0x3d, r28	; 61
    38a0:	de bf       	out	0x3e, r29	; 62
    38a2:	df 91       	pop	r29
    38a4:	cf 91       	pop	r28
    38a6:	1f 91       	pop	r17
    38a8:	0f 91       	pop	r16
    38aa:	ff 90       	pop	r15
    38ac:	ef 90       	pop	r14
    38ae:	df 90       	pop	r13
    38b0:	cf 90       	pop	r12
    38b2:	bf 90       	pop	r11
    38b4:	af 90       	pop	r10
    38b6:	9f 90       	pop	r9
    38b8:	8f 90       	pop	r8
    38ba:	7f 90       	pop	r7
    38bc:	6f 90       	pop	r6
    38be:	5f 90       	pop	r5
    38c0:	4f 90       	pop	r4
    38c2:	3f 90       	pop	r3
    38c4:	2f 90       	pop	r2
    38c6:	08 95       	ret

000038c8 <vTask_DMAHandler>:


void vTask_DMAHandler(void *pvParameters) 
{
	//Do things and Stuff with DMA!
	xDMAProcessEventGroup = xEventGroupCreate();
    38c8:	0e 94 aa 02 	call	0x554	; 0x554 <xEventGroupCreate>
    38cc:	80 93 18 2d 	sts	0x2D18, r24	; 0x802d18 <xDMAProcessEventGroup>
    38d0:	90 93 19 2d 	sts	0x2D19, r25	; 0x802d19 <xDMAProcessEventGroup+0x1>
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,count_after_peak = 0;
	PORTF.DIRSET = PIN1_bm; /*LED1*/
    38d4:	e0 ea       	ldi	r30, 0xA0	; 160
    38d6:	f6 e0       	ldi	r31, 0x06	; 6
    38d8:	82 e0       	ldi	r24, 0x02	; 2
    38da:	81 83       	std	Z+1, r24	; 0x01
	PORTF.DIRSET = PIN2_bm; /*LED2*/
    38dc:	94 e0       	ldi	r25, 0x04	; 4
    38de:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN0_bm;
    38e0:	e0 e8       	ldi	r30, 0x80	; 128
    38e2:	f6 e0       	ldi	r31, 0x06	; 6
    38e4:	91 e0       	ldi	r25, 0x01	; 1
    38e6:	91 83       	std	Z+1, r25	; 0x01
	PORTE.DIRSET = PIN1_bm;
    38e8:	81 83       	std	Z+1, r24	; 0x01
{
	//Do things and Stuff with DMA!
	xDMAProcessEventGroup = xEventGroupCreate();
	EventBits_t uxBits;
	BaseType_t xResult;
	int i,n,count_after_peak = 0;
    38ea:	81 2c       	mov	r8, r1
    38ec:	91 2c       	mov	r9, r1
				}
			}
			count_buffer_a++;
			
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x02));
    38ee:	0f 2e       	mov	r0, r31
    38f0:	f0 ea       	ldi	r31, 0xA0	; 160
    38f2:	af 2e       	mov	r10, r31
    38f4:	f6 e0       	ldi	r31, 0x06	; 6
    38f6:	bf 2e       	mov	r11, r31
    38f8:	f0 2d       	mov	r31, r0
	PORTE.DIRSET = PIN0_bm;
	PORTE.DIRSET = PIN1_bm;
	
	while(1)
	{
		uxBits = xEventGroupWaitBits(
    38fa:	cc 24       	eor	r12, r12
    38fc:	ca 94       	dec	r12
    38fe:	dc 2c       	mov	r13, r12
    3900:	76 01       	movw	r14, r12
    3902:	00 e0       	ldi	r16, 0x00	; 0
    3904:	21 e0       	ldi	r18, 0x01	; 1
    3906:	43 e0       	ldi	r20, 0x03	; 3
    3908:	50 e0       	ldi	r21, 0x00	; 0
    390a:	60 e0       	ldi	r22, 0x00	; 0
    390c:	70 e0       	ldi	r23, 0x00	; 0
    390e:	80 91 18 2d 	lds	r24, 0x2D18	; 0x802d18 <xDMAProcessEventGroup>
    3912:	90 91 19 2d 	lds	r25, 0x2D19	; 0x802d19 <xDMAProcessEventGroup+0x1>
    3916:	0e 94 bf 02 	call	0x57e	; 0x57e <xEventGroupWaitBits>
		pdTRUE,        /* Bits should be cleared before returning. */
		pdFALSE,       /* Don't wait for both bits, either bit will do. */
		portMAX_DELAY );/* Wait a maximum for either bit to be set. */
			
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
    391a:	60 fd       	sbrc	r22, 0
    391c:	05 c0       	rjmp	.+10     	; 0x3928 <vTask_DMAHandler+0x60>
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			for (i=0;i<buffer_length;i++)
    391e:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    3922:	81 11       	cpse	r24, r1
    3924:	41 c0       	rjmp	.+130    	; 0x39a8 <vTask_DMAHandler+0xe0>
    3926:	71 c0       	rjmp	.+226    	; 0x3a0a <vTask_DMAHandler+0x142>
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
		{
			//Do stuff with BufferA
			//buffer_a ....
			for (i=0;i<buffer_length;i++)//Detect signal 
    3928:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    392c:	88 23       	and	r24, r24
    392e:	79 f1       	breq	.+94     	; 0x398e <vTask_DMAHandler+0xc6>
    3930:	c0 e0       	ldi	r28, 0x00	; 0
    3932:	d0 e0       	ldi	r29, 0x00	; 0
			{
				if (buffer_a[i] >= 20)
    3934:	fe 01       	movw	r30, r28
    3936:	e0 5b       	subi	r30, 0xB0	; 176
    3938:	f0 4d       	sbci	r31, 0xD0	; 208
    393a:	80 81       	ld	r24, Z
    393c:	84 31       	cpi	r24, 0x14	; 20
    393e:	70 f0       	brcs	.+28     	; 0x395c <vTask_DMAHandler+0x94>
				{
					xResult = xEventGroupSetBits(
    3940:	42 e0       	ldi	r20, 0x02	; 2
    3942:	50 e0       	ldi	r21, 0x00	; 0
    3944:	60 e0       	ldi	r22, 0x00	; 0
    3946:	70 e0       	ldi	r23, 0x00	; 0
    3948:	80 91 14 2e 	lds	r24, 0x2E14	; 0x802e14 <xSignalProcessEventGroup>
    394c:	90 91 15 2e 	lds	r25, 0x2E15	; 0x802e15 <xSignalProcessEventGroup+0x1>
    3950:	0e 94 a5 03 	call	0x74a	; 0x74a <xEventGroupSetBits>
    3954:	16 2f       	mov	r17, r22
								);
					if( xResult & Process_Signal_BufferB )		//test if Eventgroup bit is set
					{
						//count_array_a++;
					}
					count_after_peak = 0;
    3956:	81 2c       	mov	r8, r1
    3958:	91 2c       	mov	r9, r1
    395a:	12 c0       	rjmp	.+36     	; 0x3980 <vTask_DMAHandler+0xb8>
				}
				
				else											// if value is under threshold, it shall stop calculating the signal
				{
					count_after_peak++;							// wait 100 counts to make sure that signal has stopped
    395c:	8f ef       	ldi	r24, 0xFF	; 255
    395e:	88 1a       	sub	r8, r24
    3960:	98 0a       	sbc	r9, r24
					if (count_after_peak >=100)					// no signal stop calculating -> set event bits to 0
    3962:	e4 e6       	ldi	r30, 0x64	; 100
    3964:	8e 16       	cp	r8, r30
    3966:	91 04       	cpc	r9, r1
    3968:	5c f0       	brlt	.+22     	; 0x3980 <vTask_DMAHandler+0xb8>
					{											// no signal stop calculating -> set event bits to 0
						xResult = xEventGroupClearBits(			// clear event bits
    396a:	43 e0       	ldi	r20, 0x03	; 3
    396c:	50 e0       	ldi	r21, 0x00	; 0
    396e:	60 e0       	ldi	r22, 0x00	; 0
    3970:	70 e0       	ldi	r23, 0x00	; 0
    3972:	80 91 14 2e 	lds	r24, 0x2E14	; 0x802e14 <xSignalProcessEventGroup>
    3976:	90 91 15 2e 	lds	r25, 0x2E15	; 0x802e15 <xSignalProcessEventGroup+0x1>
    397a:	0e 94 84 03 	call	0x708	; 0x708 <xEventGroupClearBits>
    397e:	16 2f       	mov	r17, r22
		//Check Event bits
		if(uxBits & DMA_EVT_GRP_BufferA)
		{
			//Do stuff with BufferA
			//buffer_a ....
			for (i=0;i<buffer_length;i++)//Detect signal 
    3980:	21 96       	adiw	r28, 0x01	; 1
    3982:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    3986:	90 e0       	ldi	r25, 0x00	; 0
    3988:	c8 17       	cp	r28, r24
    398a:	d9 07       	cpc	r29, r25
    398c:	9c f2       	brlt	.-90     	; 0x3934 <vTask_DMAHandler+0x6c>
											Process_Signal_BufferA|Process_Signal_BufferB
											);												
					}
				}
			}
			count_buffer_a++;
    398e:	80 91 17 2d 	lds	r24, 0x2D17	; 0x802d17 <count_buffer_a>
    3992:	8f 5f       	subi	r24, 0xFF	; 255
    3994:	80 93 17 2d 	sts	0x2D17, r24	; 0x802d17 <count_buffer_a>
			
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x02));
    3998:	f5 01       	movw	r30, r10
    399a:	84 81       	ldd	r24, Z+4	; 0x04
    399c:	8d 7f       	andi	r24, 0xFD	; 253
    399e:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x04;	
    39a0:	84 81       	ldd	r24, Z+4	; 0x04
    39a2:	84 60       	ori	r24, 0x04	; 4
    39a4:	84 83       	std	Z+4, r24	; 0x04
    39a6:	3d c0       	rjmp	.+122    	; 0x3a22 <vTask_DMAHandler+0x15a>
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			for (i=0;i<buffer_length;i++)
    39a8:	c0 e0       	ldi	r28, 0x00	; 0
    39aa:	d0 e0       	ldi	r29, 0x00	; 0
			{				
				if (buffer_b[i] >= 20)
    39ac:	fe 01       	movw	r30, r28
    39ae:	e0 5f       	subi	r30, 0xF0	; 240
    39b0:	f0 4d       	sbci	r31, 0xD0	; 208
    39b2:	80 81       	ld	r24, Z
    39b4:	84 31       	cpi	r24, 0x14	; 20
    39b6:	58 f0       	brcs	.+22     	; 0x39ce <vTask_DMAHandler+0x106>
				{
				xResult = xEventGroupSetBits(
    39b8:	41 e0       	ldi	r20, 0x01	; 1
    39ba:	50 e0       	ldi	r21, 0x00	; 0
    39bc:	60 e0       	ldi	r22, 0x00	; 0
    39be:	70 e0       	ldi	r23, 0x00	; 0
    39c0:	80 91 14 2e 	lds	r24, 0x2E14	; 0x802e14 <xSignalProcessEventGroup>
    39c4:	90 91 15 2e 	lds	r25, 0x2E15	; 0x802e15 <xSignalProcessEventGroup+0x1>
    39c8:	0e 94 a5 03 	call	0x74a	; 0x74a <xEventGroupSetBits>
    39cc:	16 2f       	mov	r17, r22
									xSignalProcessEventGroup,   /* The event group being updated. */
									Process_Signal_BufferA		/* The bits being set. */
									);	
				}
				if(xResult & Process_Signal_BufferA)			//test if Eventgroup bit is set
    39ce:	10 ff       	sbrs	r17, 0
    39d0:	03 c0       	rjmp	.+6      	; 0x39d8 <vTask_DMAHandler+0x110>
				{
					{
						//count_array_b++;
					}
					count_buffer_a = 0;
    39d2:	10 92 17 2d 	sts	0x2D17, r1	; 0x802d17 <count_buffer_a>
    39d6:	12 c0       	rjmp	.+36     	; 0x39fc <vTask_DMAHandler+0x134>
				}
				else											// if value is under threshold, it shall stop calculating the signal
				{
					count_after_peak++;					
    39d8:	ff ef       	ldi	r31, 0xFF	; 255
    39da:	8f 1a       	sub	r8, r31
    39dc:	9f 0a       	sbc	r9, r31
					if (count_after_peak >=100)					// wait 100 counts to make sure that signal has stopped
    39de:	84 e6       	ldi	r24, 0x64	; 100
    39e0:	88 16       	cp	r8, r24
    39e2:	91 04       	cpc	r9, r1
    39e4:	5c f0       	brlt	.+22     	; 0x39fc <vTask_DMAHandler+0x134>
					{									
						xResult = xEventGroupClearBits(			// clear event bits
    39e6:	43 e0       	ldi	r20, 0x03	; 3
    39e8:	50 e0       	ldi	r21, 0x00	; 0
    39ea:	60 e0       	ldi	r22, 0x00	; 0
    39ec:	70 e0       	ldi	r23, 0x00	; 0
    39ee:	80 91 14 2e 	lds	r24, 0x2E14	; 0x802e14 <xSignalProcessEventGroup>
    39f2:	90 91 15 2e 	lds	r25, 0x2E15	; 0x802e15 <xSignalProcessEventGroup+0x1>
    39f6:	0e 94 84 03 	call	0x708	; 0x708 <xEventGroupClearBits>
    39fa:	16 2f       	mov	r17, r22
		
		else //When it was not DMA_EVT_GRP_BufferA, then it was probably B. Since we only use two bits!
		{						
			//Do stuff with BufferB
			//buffer_b ....
			for (i=0;i<buffer_length;i++)
    39fc:	21 96       	adiw	r28, 0x01	; 1
    39fe:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    3a02:	90 e0       	ldi	r25, 0x00	; 0
    3a04:	c8 17       	cp	r28, r24
    3a06:	d9 07       	cpc	r29, r25
    3a08:	8c f2       	brlt	.-94     	; 0x39ac <vTask_DMAHandler+0xe4>
												Process_Signal_BufferA|Process_Signal_BufferB
												);										// no signal stop calculating -> set event bits to 0
						}
				}
			}
			count_buffer_b++;
    3a0a:	80 91 16 2d 	lds	r24, 0x2D16	; 0x802d16 <count_buffer_b>
    3a0e:	8f 5f       	subi	r24, 0xFF	; 255
    3a10:	80 93 16 2d 	sts	0x2D16, r24	; 0x802d16 <count_buffer_b>
			//Debug Output
			PORTF.OUT = (PORTF.OUT & (0xFF - 0x04));
    3a14:	f5 01       	movw	r30, r10
    3a16:	84 81       	ldd	r24, Z+4	; 0x04
    3a18:	8b 7f       	andi	r24, 0xFB	; 251
    3a1a:	84 83       	std	Z+4, r24	; 0x04
			PORTF.OUT |= 0x02;
    3a1c:	84 81       	ldd	r24, Z+4	; 0x04
    3a1e:	82 60       	ori	r24, 0x02	; 2
    3a20:	84 83       	std	Z+4, r24	; 0x04
		}
	vTaskDelay(100 / portTICK_RATE_MS);
    3a22:	64 e6       	ldi	r22, 0x64	; 100
    3a24:	70 e0       	ldi	r23, 0x00	; 0
    3a26:	80 e0       	ldi	r24, 0x00	; 0
    3a28:	90 e0       	ldi	r25, 0x00	; 0
    3a2a:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <vTaskDelay>
	}
    3a2e:	65 cf       	rjmp	.-310    	; 0x38fa <vTask_DMAHandler+0x32>

00003a30 <getResetReason>:
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
	 // software reset ?
	 if( RST.STATUS & RST_SRF_bm )
    3a30:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3a34:	85 ff       	sbrs	r24, 5
    3a36:	05 c0       	rjmp	.+10     	; 0x3a42 <getResetReason+0x12>
	 {
		 // reset this bit
		 RST.STATUS = RST_SRF_bm;
    3a38:	80 e2       	ldi	r24, 0x20	; 32
    3a3a:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_SOFTWARERESET;
    3a3e:	81 e0       	ldi	r24, 0x01	; 1
    3a40:	08 95       	ret
	 }
	 // power on reset ?
	 else if( RST.STATUS & RST_PORF_bm)
    3a42:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3a46:	80 ff       	sbrs	r24, 0
    3a48:	05 c0       	rjmp	.+10     	; 0x3a54 <getResetReason+0x24>
	 {
		 // reset this bit
		 RST.STATUS = RST_PORF_bm;
    3a4a:	81 e0       	ldi	r24, 0x01	; 1
    3a4c:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_POWERONRESET;
    3a50:	82 e0       	ldi	r24, 0x02	; 2
    3a52:	08 95       	ret
	 }
	 // debugger reset ?
	 else if( RST.STATUS & RST_PDIRF_bm)
    3a54:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3a58:	84 ff       	sbrs	r24, 4
    3a5a:	05 c0       	rjmp	.+10     	; 0x3a66 <getResetReason+0x36>
	 {
		 // reset this bit
		 RST.STATUS = RST_PDIRF_bm;
    3a5c:	80 e1       	ldi	r24, 0x10	; 16
    3a5e:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_DEBUGGERRESET;
    3a62:	83 e0       	ldi	r24, 0x03	; 3
    3a64:	08 95       	ret
	 }
	 // external reset ?
	 else if( RST.STATUS & RST_EXTRF_bm)
    3a66:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    3a6a:	81 ff       	sbrs	r24, 1
    3a6c:	05 c0       	rjmp	.+10     	; 0x3a78 <getResetReason+0x48>
	 {
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
    3a6e:	82 e0       	ldi	r24, 0x02	; 2
    3a70:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
		 returnValue = RESETREASON_EXTERNALRESET;
    3a74:	84 e0       	ldi	r24, 0x04	; 4
    3a76:	08 95       	ret
 */ 
 #include "avr_compiler.h"
 #include "utils.h"

 resetReason_t getResetReason(void) {
	 resetReason_t returnValue = RESETREASON_POWERONRESET;
    3a78:	82 e0       	ldi	r24, 0x02	; 2
		 // reset this bit
		 RST.STATUS = RST_EXTRF_bm;
		 returnValue = RESETREASON_EXTERNALRESET;
	 }
	 return returnValue;
    3a7a:	08 95       	ret

00003a7c <__subsf3>:
    3a7c:	50 58       	subi	r21, 0x80	; 128

00003a7e <__addsf3>:
    3a7e:	bb 27       	eor	r27, r27
    3a80:	aa 27       	eor	r26, r26
    3a82:	0e 94 56 1d 	call	0x3aac	; 0x3aac <__addsf3x>
    3a86:	0c 94 d0 1e 	jmp	0x3da0	; 0x3da0 <__fp_round>
    3a8a:	0e 94 c2 1e 	call	0x3d84	; 0x3d84 <__fp_pscA>
    3a8e:	38 f0       	brcs	.+14     	; 0x3a9e <__addsf3+0x20>
    3a90:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <__fp_pscB>
    3a94:	20 f0       	brcs	.+8      	; 0x3a9e <__addsf3+0x20>
    3a96:	39 f4       	brne	.+14     	; 0x3aa6 <__addsf3+0x28>
    3a98:	9f 3f       	cpi	r25, 0xFF	; 255
    3a9a:	19 f4       	brne	.+6      	; 0x3aa2 <__addsf3+0x24>
    3a9c:	26 f4       	brtc	.+8      	; 0x3aa6 <__addsf3+0x28>
    3a9e:	0c 94 bf 1e 	jmp	0x3d7e	; 0x3d7e <__fp_nan>
    3aa2:	0e f4       	brtc	.+2      	; 0x3aa6 <__addsf3+0x28>
    3aa4:	e0 95       	com	r30
    3aa6:	e7 fb       	bst	r30, 7
    3aa8:	0c 94 b9 1e 	jmp	0x3d72	; 0x3d72 <__fp_inf>

00003aac <__addsf3x>:
    3aac:	e9 2f       	mov	r30, r25
    3aae:	0e 94 e1 1e 	call	0x3dc2	; 0x3dc2 <__fp_split3>
    3ab2:	58 f3       	brcs	.-42     	; 0x3a8a <__addsf3+0xc>
    3ab4:	ba 17       	cp	r27, r26
    3ab6:	62 07       	cpc	r22, r18
    3ab8:	73 07       	cpc	r23, r19
    3aba:	84 07       	cpc	r24, r20
    3abc:	95 07       	cpc	r25, r21
    3abe:	20 f0       	brcs	.+8      	; 0x3ac8 <__addsf3x+0x1c>
    3ac0:	79 f4       	brne	.+30     	; 0x3ae0 <__addsf3x+0x34>
    3ac2:	a6 f5       	brtc	.+104    	; 0x3b2c <__addsf3x+0x80>
    3ac4:	0c 94 03 1f 	jmp	0x3e06	; 0x3e06 <__fp_zero>
    3ac8:	0e f4       	brtc	.+2      	; 0x3acc <__addsf3x+0x20>
    3aca:	e0 95       	com	r30
    3acc:	0b 2e       	mov	r0, r27
    3ace:	ba 2f       	mov	r27, r26
    3ad0:	a0 2d       	mov	r26, r0
    3ad2:	0b 01       	movw	r0, r22
    3ad4:	b9 01       	movw	r22, r18
    3ad6:	90 01       	movw	r18, r0
    3ad8:	0c 01       	movw	r0, r24
    3ada:	ca 01       	movw	r24, r20
    3adc:	a0 01       	movw	r20, r0
    3ade:	11 24       	eor	r1, r1
    3ae0:	ff 27       	eor	r31, r31
    3ae2:	59 1b       	sub	r21, r25
    3ae4:	99 f0       	breq	.+38     	; 0x3b0c <__addsf3x+0x60>
    3ae6:	59 3f       	cpi	r21, 0xF9	; 249
    3ae8:	50 f4       	brcc	.+20     	; 0x3afe <__addsf3x+0x52>
    3aea:	50 3e       	cpi	r21, 0xE0	; 224
    3aec:	68 f1       	brcs	.+90     	; 0x3b48 <__addsf3x+0x9c>
    3aee:	1a 16       	cp	r1, r26
    3af0:	f0 40       	sbci	r31, 0x00	; 0
    3af2:	a2 2f       	mov	r26, r18
    3af4:	23 2f       	mov	r18, r19
    3af6:	34 2f       	mov	r19, r20
    3af8:	44 27       	eor	r20, r20
    3afa:	58 5f       	subi	r21, 0xF8	; 248
    3afc:	f3 cf       	rjmp	.-26     	; 0x3ae4 <__addsf3x+0x38>
    3afe:	46 95       	lsr	r20
    3b00:	37 95       	ror	r19
    3b02:	27 95       	ror	r18
    3b04:	a7 95       	ror	r26
    3b06:	f0 40       	sbci	r31, 0x00	; 0
    3b08:	53 95       	inc	r21
    3b0a:	c9 f7       	brne	.-14     	; 0x3afe <__addsf3x+0x52>
    3b0c:	7e f4       	brtc	.+30     	; 0x3b2c <__addsf3x+0x80>
    3b0e:	1f 16       	cp	r1, r31
    3b10:	ba 0b       	sbc	r27, r26
    3b12:	62 0b       	sbc	r22, r18
    3b14:	73 0b       	sbc	r23, r19
    3b16:	84 0b       	sbc	r24, r20
    3b18:	ba f0       	brmi	.+46     	; 0x3b48 <__addsf3x+0x9c>
    3b1a:	91 50       	subi	r25, 0x01	; 1
    3b1c:	a1 f0       	breq	.+40     	; 0x3b46 <__addsf3x+0x9a>
    3b1e:	ff 0f       	add	r31, r31
    3b20:	bb 1f       	adc	r27, r27
    3b22:	66 1f       	adc	r22, r22
    3b24:	77 1f       	adc	r23, r23
    3b26:	88 1f       	adc	r24, r24
    3b28:	c2 f7       	brpl	.-16     	; 0x3b1a <__addsf3x+0x6e>
    3b2a:	0e c0       	rjmp	.+28     	; 0x3b48 <__addsf3x+0x9c>
    3b2c:	ba 0f       	add	r27, r26
    3b2e:	62 1f       	adc	r22, r18
    3b30:	73 1f       	adc	r23, r19
    3b32:	84 1f       	adc	r24, r20
    3b34:	48 f4       	brcc	.+18     	; 0x3b48 <__addsf3x+0x9c>
    3b36:	87 95       	ror	r24
    3b38:	77 95       	ror	r23
    3b3a:	67 95       	ror	r22
    3b3c:	b7 95       	ror	r27
    3b3e:	f7 95       	ror	r31
    3b40:	9e 3f       	cpi	r25, 0xFE	; 254
    3b42:	08 f0       	brcs	.+2      	; 0x3b46 <__addsf3x+0x9a>
    3b44:	b0 cf       	rjmp	.-160    	; 0x3aa6 <__addsf3+0x28>
    3b46:	93 95       	inc	r25
    3b48:	88 0f       	add	r24, r24
    3b4a:	08 f0       	brcs	.+2      	; 0x3b4e <__addsf3x+0xa2>
    3b4c:	99 27       	eor	r25, r25
    3b4e:	ee 0f       	add	r30, r30
    3b50:	97 95       	ror	r25
    3b52:	87 95       	ror	r24
    3b54:	08 95       	ret

00003b56 <__cmpsf2>:
    3b56:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <__fp_cmp>
    3b5a:	08 f4       	brcc	.+2      	; 0x3b5e <__cmpsf2+0x8>
    3b5c:	81 e0       	ldi	r24, 0x01	; 1
    3b5e:	08 95       	ret

00003b60 <__divsf3>:
    3b60:	0e 94 c4 1d 	call	0x3b88	; 0x3b88 <__divsf3x>
    3b64:	0c 94 d0 1e 	jmp	0x3da0	; 0x3da0 <__fp_round>
    3b68:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <__fp_pscB>
    3b6c:	58 f0       	brcs	.+22     	; 0x3b84 <__divsf3+0x24>
    3b6e:	0e 94 c2 1e 	call	0x3d84	; 0x3d84 <__fp_pscA>
    3b72:	40 f0       	brcs	.+16     	; 0x3b84 <__divsf3+0x24>
    3b74:	29 f4       	brne	.+10     	; 0x3b80 <__divsf3+0x20>
    3b76:	5f 3f       	cpi	r21, 0xFF	; 255
    3b78:	29 f0       	breq	.+10     	; 0x3b84 <__divsf3+0x24>
    3b7a:	0c 94 b9 1e 	jmp	0x3d72	; 0x3d72 <__fp_inf>
    3b7e:	51 11       	cpse	r21, r1
    3b80:	0c 94 04 1f 	jmp	0x3e08	; 0x3e08 <__fp_szero>
    3b84:	0c 94 bf 1e 	jmp	0x3d7e	; 0x3d7e <__fp_nan>

00003b88 <__divsf3x>:
    3b88:	0e 94 e1 1e 	call	0x3dc2	; 0x3dc2 <__fp_split3>
    3b8c:	68 f3       	brcs	.-38     	; 0x3b68 <__divsf3+0x8>

00003b8e <__divsf3_pse>:
    3b8e:	99 23       	and	r25, r25
    3b90:	b1 f3       	breq	.-20     	; 0x3b7e <__divsf3+0x1e>
    3b92:	55 23       	and	r21, r21
    3b94:	91 f3       	breq	.-28     	; 0x3b7a <__divsf3+0x1a>
    3b96:	95 1b       	sub	r25, r21
    3b98:	55 0b       	sbc	r21, r21
    3b9a:	bb 27       	eor	r27, r27
    3b9c:	aa 27       	eor	r26, r26
    3b9e:	62 17       	cp	r22, r18
    3ba0:	73 07       	cpc	r23, r19
    3ba2:	84 07       	cpc	r24, r20
    3ba4:	38 f0       	brcs	.+14     	; 0x3bb4 <__divsf3_pse+0x26>
    3ba6:	9f 5f       	subi	r25, 0xFF	; 255
    3ba8:	5f 4f       	sbci	r21, 0xFF	; 255
    3baa:	22 0f       	add	r18, r18
    3bac:	33 1f       	adc	r19, r19
    3bae:	44 1f       	adc	r20, r20
    3bb0:	aa 1f       	adc	r26, r26
    3bb2:	a9 f3       	breq	.-22     	; 0x3b9e <__divsf3_pse+0x10>
    3bb4:	35 d0       	rcall	.+106    	; 0x3c20 <__divsf3_pse+0x92>
    3bb6:	0e 2e       	mov	r0, r30
    3bb8:	3a f0       	brmi	.+14     	; 0x3bc8 <__divsf3_pse+0x3a>
    3bba:	e0 e8       	ldi	r30, 0x80	; 128
    3bbc:	32 d0       	rcall	.+100    	; 0x3c22 <__divsf3_pse+0x94>
    3bbe:	91 50       	subi	r25, 0x01	; 1
    3bc0:	50 40       	sbci	r21, 0x00	; 0
    3bc2:	e6 95       	lsr	r30
    3bc4:	00 1c       	adc	r0, r0
    3bc6:	ca f7       	brpl	.-14     	; 0x3bba <__divsf3_pse+0x2c>
    3bc8:	2b d0       	rcall	.+86     	; 0x3c20 <__divsf3_pse+0x92>
    3bca:	fe 2f       	mov	r31, r30
    3bcc:	29 d0       	rcall	.+82     	; 0x3c20 <__divsf3_pse+0x92>
    3bce:	66 0f       	add	r22, r22
    3bd0:	77 1f       	adc	r23, r23
    3bd2:	88 1f       	adc	r24, r24
    3bd4:	bb 1f       	adc	r27, r27
    3bd6:	26 17       	cp	r18, r22
    3bd8:	37 07       	cpc	r19, r23
    3bda:	48 07       	cpc	r20, r24
    3bdc:	ab 07       	cpc	r26, r27
    3bde:	b0 e8       	ldi	r27, 0x80	; 128
    3be0:	09 f0       	breq	.+2      	; 0x3be4 <__divsf3_pse+0x56>
    3be2:	bb 0b       	sbc	r27, r27
    3be4:	80 2d       	mov	r24, r0
    3be6:	bf 01       	movw	r22, r30
    3be8:	ff 27       	eor	r31, r31
    3bea:	93 58       	subi	r25, 0x83	; 131
    3bec:	5f 4f       	sbci	r21, 0xFF	; 255
    3bee:	3a f0       	brmi	.+14     	; 0x3bfe <__divsf3_pse+0x70>
    3bf0:	9e 3f       	cpi	r25, 0xFE	; 254
    3bf2:	51 05       	cpc	r21, r1
    3bf4:	78 f0       	brcs	.+30     	; 0x3c14 <__divsf3_pse+0x86>
    3bf6:	0c 94 b9 1e 	jmp	0x3d72	; 0x3d72 <__fp_inf>
    3bfa:	0c 94 04 1f 	jmp	0x3e08	; 0x3e08 <__fp_szero>
    3bfe:	5f 3f       	cpi	r21, 0xFF	; 255
    3c00:	e4 f3       	brlt	.-8      	; 0x3bfa <__divsf3_pse+0x6c>
    3c02:	98 3e       	cpi	r25, 0xE8	; 232
    3c04:	d4 f3       	brlt	.-12     	; 0x3bfa <__divsf3_pse+0x6c>
    3c06:	86 95       	lsr	r24
    3c08:	77 95       	ror	r23
    3c0a:	67 95       	ror	r22
    3c0c:	b7 95       	ror	r27
    3c0e:	f7 95       	ror	r31
    3c10:	9f 5f       	subi	r25, 0xFF	; 255
    3c12:	c9 f7       	brne	.-14     	; 0x3c06 <__divsf3_pse+0x78>
    3c14:	88 0f       	add	r24, r24
    3c16:	91 1d       	adc	r25, r1
    3c18:	96 95       	lsr	r25
    3c1a:	87 95       	ror	r24
    3c1c:	97 f9       	bld	r25, 7
    3c1e:	08 95       	ret
    3c20:	e1 e0       	ldi	r30, 0x01	; 1
    3c22:	66 0f       	add	r22, r22
    3c24:	77 1f       	adc	r23, r23
    3c26:	88 1f       	adc	r24, r24
    3c28:	bb 1f       	adc	r27, r27
    3c2a:	62 17       	cp	r22, r18
    3c2c:	73 07       	cpc	r23, r19
    3c2e:	84 07       	cpc	r24, r20
    3c30:	ba 07       	cpc	r27, r26
    3c32:	20 f0       	brcs	.+8      	; 0x3c3c <__divsf3_pse+0xae>
    3c34:	62 1b       	sub	r22, r18
    3c36:	73 0b       	sbc	r23, r19
    3c38:	84 0b       	sbc	r24, r20
    3c3a:	ba 0b       	sbc	r27, r26
    3c3c:	ee 1f       	adc	r30, r30
    3c3e:	88 f7       	brcc	.-30     	; 0x3c22 <__divsf3_pse+0x94>
    3c40:	e0 95       	com	r30
    3c42:	08 95       	ret

00003c44 <__fixsfsi>:
    3c44:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3c48:	68 94       	set
    3c4a:	b1 11       	cpse	r27, r1
    3c4c:	0c 94 04 1f 	jmp	0x3e08	; 0x3e08 <__fp_szero>
    3c50:	08 95       	ret

00003c52 <__fixunssfsi>:
    3c52:	0e 94 e9 1e 	call	0x3dd2	; 0x3dd2 <__fp_splitA>
    3c56:	88 f0       	brcs	.+34     	; 0x3c7a <__fixunssfsi+0x28>
    3c58:	9f 57       	subi	r25, 0x7F	; 127
    3c5a:	98 f0       	brcs	.+38     	; 0x3c82 <__fixunssfsi+0x30>
    3c5c:	b9 2f       	mov	r27, r25
    3c5e:	99 27       	eor	r25, r25
    3c60:	b7 51       	subi	r27, 0x17	; 23
    3c62:	b0 f0       	brcs	.+44     	; 0x3c90 <__fixunssfsi+0x3e>
    3c64:	e1 f0       	breq	.+56     	; 0x3c9e <__fixunssfsi+0x4c>
    3c66:	66 0f       	add	r22, r22
    3c68:	77 1f       	adc	r23, r23
    3c6a:	88 1f       	adc	r24, r24
    3c6c:	99 1f       	adc	r25, r25
    3c6e:	1a f0       	brmi	.+6      	; 0x3c76 <__fixunssfsi+0x24>
    3c70:	ba 95       	dec	r27
    3c72:	c9 f7       	brne	.-14     	; 0x3c66 <__fixunssfsi+0x14>
    3c74:	14 c0       	rjmp	.+40     	; 0x3c9e <__fixunssfsi+0x4c>
    3c76:	b1 30       	cpi	r27, 0x01	; 1
    3c78:	91 f0       	breq	.+36     	; 0x3c9e <__fixunssfsi+0x4c>
    3c7a:	0e 94 03 1f 	call	0x3e06	; 0x3e06 <__fp_zero>
    3c7e:	b1 e0       	ldi	r27, 0x01	; 1
    3c80:	08 95       	ret
    3c82:	0c 94 03 1f 	jmp	0x3e06	; 0x3e06 <__fp_zero>
    3c86:	67 2f       	mov	r22, r23
    3c88:	78 2f       	mov	r23, r24
    3c8a:	88 27       	eor	r24, r24
    3c8c:	b8 5f       	subi	r27, 0xF8	; 248
    3c8e:	39 f0       	breq	.+14     	; 0x3c9e <__fixunssfsi+0x4c>
    3c90:	b9 3f       	cpi	r27, 0xF9	; 249
    3c92:	cc f3       	brlt	.-14     	; 0x3c86 <__fixunssfsi+0x34>
    3c94:	86 95       	lsr	r24
    3c96:	77 95       	ror	r23
    3c98:	67 95       	ror	r22
    3c9a:	b3 95       	inc	r27
    3c9c:	d9 f7       	brne	.-10     	; 0x3c94 <__fixunssfsi+0x42>
    3c9e:	3e f4       	brtc	.+14     	; 0x3cae <__fixunssfsi+0x5c>
    3ca0:	90 95       	com	r25
    3ca2:	80 95       	com	r24
    3ca4:	70 95       	com	r23
    3ca6:	61 95       	neg	r22
    3ca8:	7f 4f       	sbci	r23, 0xFF	; 255
    3caa:	8f 4f       	sbci	r24, 0xFF	; 255
    3cac:	9f 4f       	sbci	r25, 0xFF	; 255
    3cae:	08 95       	ret

00003cb0 <__floatunsisf>:
    3cb0:	e8 94       	clt
    3cb2:	09 c0       	rjmp	.+18     	; 0x3cc6 <__floatsisf+0x12>

00003cb4 <__floatsisf>:
    3cb4:	97 fb       	bst	r25, 7
    3cb6:	3e f4       	brtc	.+14     	; 0x3cc6 <__floatsisf+0x12>
    3cb8:	90 95       	com	r25
    3cba:	80 95       	com	r24
    3cbc:	70 95       	com	r23
    3cbe:	61 95       	neg	r22
    3cc0:	7f 4f       	sbci	r23, 0xFF	; 255
    3cc2:	8f 4f       	sbci	r24, 0xFF	; 255
    3cc4:	9f 4f       	sbci	r25, 0xFF	; 255
    3cc6:	99 23       	and	r25, r25
    3cc8:	a9 f0       	breq	.+42     	; 0x3cf4 <__floatsisf+0x40>
    3cca:	f9 2f       	mov	r31, r25
    3ccc:	96 e9       	ldi	r25, 0x96	; 150
    3cce:	bb 27       	eor	r27, r27
    3cd0:	93 95       	inc	r25
    3cd2:	f6 95       	lsr	r31
    3cd4:	87 95       	ror	r24
    3cd6:	77 95       	ror	r23
    3cd8:	67 95       	ror	r22
    3cda:	b7 95       	ror	r27
    3cdc:	f1 11       	cpse	r31, r1
    3cde:	f8 cf       	rjmp	.-16     	; 0x3cd0 <__floatsisf+0x1c>
    3ce0:	fa f4       	brpl	.+62     	; 0x3d20 <__floatsisf+0x6c>
    3ce2:	bb 0f       	add	r27, r27
    3ce4:	11 f4       	brne	.+4      	; 0x3cea <__floatsisf+0x36>
    3ce6:	60 ff       	sbrs	r22, 0
    3ce8:	1b c0       	rjmp	.+54     	; 0x3d20 <__floatsisf+0x6c>
    3cea:	6f 5f       	subi	r22, 0xFF	; 255
    3cec:	7f 4f       	sbci	r23, 0xFF	; 255
    3cee:	8f 4f       	sbci	r24, 0xFF	; 255
    3cf0:	9f 4f       	sbci	r25, 0xFF	; 255
    3cf2:	16 c0       	rjmp	.+44     	; 0x3d20 <__floatsisf+0x6c>
    3cf4:	88 23       	and	r24, r24
    3cf6:	11 f0       	breq	.+4      	; 0x3cfc <__floatsisf+0x48>
    3cf8:	96 e9       	ldi	r25, 0x96	; 150
    3cfa:	11 c0       	rjmp	.+34     	; 0x3d1e <__floatsisf+0x6a>
    3cfc:	77 23       	and	r23, r23
    3cfe:	21 f0       	breq	.+8      	; 0x3d08 <__floatsisf+0x54>
    3d00:	9e e8       	ldi	r25, 0x8E	; 142
    3d02:	87 2f       	mov	r24, r23
    3d04:	76 2f       	mov	r23, r22
    3d06:	05 c0       	rjmp	.+10     	; 0x3d12 <__floatsisf+0x5e>
    3d08:	66 23       	and	r22, r22
    3d0a:	71 f0       	breq	.+28     	; 0x3d28 <__floatsisf+0x74>
    3d0c:	96 e8       	ldi	r25, 0x86	; 134
    3d0e:	86 2f       	mov	r24, r22
    3d10:	70 e0       	ldi	r23, 0x00	; 0
    3d12:	60 e0       	ldi	r22, 0x00	; 0
    3d14:	2a f0       	brmi	.+10     	; 0x3d20 <__floatsisf+0x6c>
    3d16:	9a 95       	dec	r25
    3d18:	66 0f       	add	r22, r22
    3d1a:	77 1f       	adc	r23, r23
    3d1c:	88 1f       	adc	r24, r24
    3d1e:	da f7       	brpl	.-10     	; 0x3d16 <__floatsisf+0x62>
    3d20:	88 0f       	add	r24, r24
    3d22:	96 95       	lsr	r25
    3d24:	87 95       	ror	r24
    3d26:	97 f9       	bld	r25, 7
    3d28:	08 95       	ret

00003d2a <__fp_cmp>:
    3d2a:	99 0f       	add	r25, r25
    3d2c:	00 08       	sbc	r0, r0
    3d2e:	55 0f       	add	r21, r21
    3d30:	aa 0b       	sbc	r26, r26
    3d32:	e0 e8       	ldi	r30, 0x80	; 128
    3d34:	fe ef       	ldi	r31, 0xFE	; 254
    3d36:	16 16       	cp	r1, r22
    3d38:	17 06       	cpc	r1, r23
    3d3a:	e8 07       	cpc	r30, r24
    3d3c:	f9 07       	cpc	r31, r25
    3d3e:	c0 f0       	brcs	.+48     	; 0x3d70 <__fp_cmp+0x46>
    3d40:	12 16       	cp	r1, r18
    3d42:	13 06       	cpc	r1, r19
    3d44:	e4 07       	cpc	r30, r20
    3d46:	f5 07       	cpc	r31, r21
    3d48:	98 f0       	brcs	.+38     	; 0x3d70 <__fp_cmp+0x46>
    3d4a:	62 1b       	sub	r22, r18
    3d4c:	73 0b       	sbc	r23, r19
    3d4e:	84 0b       	sbc	r24, r20
    3d50:	95 0b       	sbc	r25, r21
    3d52:	39 f4       	brne	.+14     	; 0x3d62 <__fp_cmp+0x38>
    3d54:	0a 26       	eor	r0, r26
    3d56:	61 f0       	breq	.+24     	; 0x3d70 <__fp_cmp+0x46>
    3d58:	23 2b       	or	r18, r19
    3d5a:	24 2b       	or	r18, r20
    3d5c:	25 2b       	or	r18, r21
    3d5e:	21 f4       	brne	.+8      	; 0x3d68 <__fp_cmp+0x3e>
    3d60:	08 95       	ret
    3d62:	0a 26       	eor	r0, r26
    3d64:	09 f4       	brne	.+2      	; 0x3d68 <__fp_cmp+0x3e>
    3d66:	a1 40       	sbci	r26, 0x01	; 1
    3d68:	a6 95       	lsr	r26
    3d6a:	8f ef       	ldi	r24, 0xFF	; 255
    3d6c:	81 1d       	adc	r24, r1
    3d6e:	81 1d       	adc	r24, r1
    3d70:	08 95       	ret

00003d72 <__fp_inf>:
    3d72:	97 f9       	bld	r25, 7
    3d74:	9f 67       	ori	r25, 0x7F	; 127
    3d76:	80 e8       	ldi	r24, 0x80	; 128
    3d78:	70 e0       	ldi	r23, 0x00	; 0
    3d7a:	60 e0       	ldi	r22, 0x00	; 0
    3d7c:	08 95       	ret

00003d7e <__fp_nan>:
    3d7e:	9f ef       	ldi	r25, 0xFF	; 255
    3d80:	80 ec       	ldi	r24, 0xC0	; 192
    3d82:	08 95       	ret

00003d84 <__fp_pscA>:
    3d84:	00 24       	eor	r0, r0
    3d86:	0a 94       	dec	r0
    3d88:	16 16       	cp	r1, r22
    3d8a:	17 06       	cpc	r1, r23
    3d8c:	18 06       	cpc	r1, r24
    3d8e:	09 06       	cpc	r0, r25
    3d90:	08 95       	ret

00003d92 <__fp_pscB>:
    3d92:	00 24       	eor	r0, r0
    3d94:	0a 94       	dec	r0
    3d96:	12 16       	cp	r1, r18
    3d98:	13 06       	cpc	r1, r19
    3d9a:	14 06       	cpc	r1, r20
    3d9c:	05 06       	cpc	r0, r21
    3d9e:	08 95       	ret

00003da0 <__fp_round>:
    3da0:	09 2e       	mov	r0, r25
    3da2:	03 94       	inc	r0
    3da4:	00 0c       	add	r0, r0
    3da6:	11 f4       	brne	.+4      	; 0x3dac <__fp_round+0xc>
    3da8:	88 23       	and	r24, r24
    3daa:	52 f0       	brmi	.+20     	; 0x3dc0 <__fp_round+0x20>
    3dac:	bb 0f       	add	r27, r27
    3dae:	40 f4       	brcc	.+16     	; 0x3dc0 <__fp_round+0x20>
    3db0:	bf 2b       	or	r27, r31
    3db2:	11 f4       	brne	.+4      	; 0x3db8 <__fp_round+0x18>
    3db4:	60 ff       	sbrs	r22, 0
    3db6:	04 c0       	rjmp	.+8      	; 0x3dc0 <__fp_round+0x20>
    3db8:	6f 5f       	subi	r22, 0xFF	; 255
    3dba:	7f 4f       	sbci	r23, 0xFF	; 255
    3dbc:	8f 4f       	sbci	r24, 0xFF	; 255
    3dbe:	9f 4f       	sbci	r25, 0xFF	; 255
    3dc0:	08 95       	ret

00003dc2 <__fp_split3>:
    3dc2:	57 fd       	sbrc	r21, 7
    3dc4:	90 58       	subi	r25, 0x80	; 128
    3dc6:	44 0f       	add	r20, r20
    3dc8:	55 1f       	adc	r21, r21
    3dca:	59 f0       	breq	.+22     	; 0x3de2 <__fp_splitA+0x10>
    3dcc:	5f 3f       	cpi	r21, 0xFF	; 255
    3dce:	71 f0       	breq	.+28     	; 0x3dec <__fp_splitA+0x1a>
    3dd0:	47 95       	ror	r20

00003dd2 <__fp_splitA>:
    3dd2:	88 0f       	add	r24, r24
    3dd4:	97 fb       	bst	r25, 7
    3dd6:	99 1f       	adc	r25, r25
    3dd8:	61 f0       	breq	.+24     	; 0x3df2 <__fp_splitA+0x20>
    3dda:	9f 3f       	cpi	r25, 0xFF	; 255
    3ddc:	79 f0       	breq	.+30     	; 0x3dfc <__fp_splitA+0x2a>
    3dde:	87 95       	ror	r24
    3de0:	08 95       	ret
    3de2:	12 16       	cp	r1, r18
    3de4:	13 06       	cpc	r1, r19
    3de6:	14 06       	cpc	r1, r20
    3de8:	55 1f       	adc	r21, r21
    3dea:	f2 cf       	rjmp	.-28     	; 0x3dd0 <__fp_split3+0xe>
    3dec:	46 95       	lsr	r20
    3dee:	f1 df       	rcall	.-30     	; 0x3dd2 <__fp_splitA>
    3df0:	08 c0       	rjmp	.+16     	; 0x3e02 <__fp_splitA+0x30>
    3df2:	16 16       	cp	r1, r22
    3df4:	17 06       	cpc	r1, r23
    3df6:	18 06       	cpc	r1, r24
    3df8:	99 1f       	adc	r25, r25
    3dfa:	f1 cf       	rjmp	.-30     	; 0x3dde <__fp_splitA+0xc>
    3dfc:	86 95       	lsr	r24
    3dfe:	71 05       	cpc	r23, r1
    3e00:	61 05       	cpc	r22, r1
    3e02:	08 94       	sec
    3e04:	08 95       	ret

00003e06 <__fp_zero>:
    3e06:	e8 94       	clt

00003e08 <__fp_szero>:
    3e08:	bb 27       	eor	r27, r27
    3e0a:	66 27       	eor	r22, r22
    3e0c:	77 27       	eor	r23, r23
    3e0e:	cb 01       	movw	r24, r22
    3e10:	97 f9       	bld	r25, 7
    3e12:	08 95       	ret

00003e14 <__gesf2>:
    3e14:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <__fp_cmp>
    3e18:	08 f4       	brcc	.+2      	; 0x3e1c <__gesf2+0x8>
    3e1a:	8f ef       	ldi	r24, 0xFF	; 255
    3e1c:	08 95       	ret

00003e1e <__mulsf3>:
    3e1e:	0e 94 22 1f 	call	0x3e44	; 0x3e44 <__mulsf3x>
    3e22:	0c 94 d0 1e 	jmp	0x3da0	; 0x3da0 <__fp_round>
    3e26:	0e 94 c2 1e 	call	0x3d84	; 0x3d84 <__fp_pscA>
    3e2a:	38 f0       	brcs	.+14     	; 0x3e3a <__mulsf3+0x1c>
    3e2c:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <__fp_pscB>
    3e30:	20 f0       	brcs	.+8      	; 0x3e3a <__mulsf3+0x1c>
    3e32:	95 23       	and	r25, r21
    3e34:	11 f0       	breq	.+4      	; 0x3e3a <__mulsf3+0x1c>
    3e36:	0c 94 b9 1e 	jmp	0x3d72	; 0x3d72 <__fp_inf>
    3e3a:	0c 94 bf 1e 	jmp	0x3d7e	; 0x3d7e <__fp_nan>
    3e3e:	11 24       	eor	r1, r1
    3e40:	0c 94 04 1f 	jmp	0x3e08	; 0x3e08 <__fp_szero>

00003e44 <__mulsf3x>:
    3e44:	0e 94 e1 1e 	call	0x3dc2	; 0x3dc2 <__fp_split3>
    3e48:	70 f3       	brcs	.-36     	; 0x3e26 <__mulsf3+0x8>

00003e4a <__mulsf3_pse>:
    3e4a:	95 9f       	mul	r25, r21
    3e4c:	c1 f3       	breq	.-16     	; 0x3e3e <__mulsf3+0x20>
    3e4e:	95 0f       	add	r25, r21
    3e50:	50 e0       	ldi	r21, 0x00	; 0
    3e52:	55 1f       	adc	r21, r21
    3e54:	62 9f       	mul	r22, r18
    3e56:	f0 01       	movw	r30, r0
    3e58:	72 9f       	mul	r23, r18
    3e5a:	bb 27       	eor	r27, r27
    3e5c:	f0 0d       	add	r31, r0
    3e5e:	b1 1d       	adc	r27, r1
    3e60:	63 9f       	mul	r22, r19
    3e62:	aa 27       	eor	r26, r26
    3e64:	f0 0d       	add	r31, r0
    3e66:	b1 1d       	adc	r27, r1
    3e68:	aa 1f       	adc	r26, r26
    3e6a:	64 9f       	mul	r22, r20
    3e6c:	66 27       	eor	r22, r22
    3e6e:	b0 0d       	add	r27, r0
    3e70:	a1 1d       	adc	r26, r1
    3e72:	66 1f       	adc	r22, r22
    3e74:	82 9f       	mul	r24, r18
    3e76:	22 27       	eor	r18, r18
    3e78:	b0 0d       	add	r27, r0
    3e7a:	a1 1d       	adc	r26, r1
    3e7c:	62 1f       	adc	r22, r18
    3e7e:	73 9f       	mul	r23, r19
    3e80:	b0 0d       	add	r27, r0
    3e82:	a1 1d       	adc	r26, r1
    3e84:	62 1f       	adc	r22, r18
    3e86:	83 9f       	mul	r24, r19
    3e88:	a0 0d       	add	r26, r0
    3e8a:	61 1d       	adc	r22, r1
    3e8c:	22 1f       	adc	r18, r18
    3e8e:	74 9f       	mul	r23, r20
    3e90:	33 27       	eor	r19, r19
    3e92:	a0 0d       	add	r26, r0
    3e94:	61 1d       	adc	r22, r1
    3e96:	23 1f       	adc	r18, r19
    3e98:	84 9f       	mul	r24, r20
    3e9a:	60 0d       	add	r22, r0
    3e9c:	21 1d       	adc	r18, r1
    3e9e:	82 2f       	mov	r24, r18
    3ea0:	76 2f       	mov	r23, r22
    3ea2:	6a 2f       	mov	r22, r26
    3ea4:	11 24       	eor	r1, r1
    3ea6:	9f 57       	subi	r25, 0x7F	; 127
    3ea8:	50 40       	sbci	r21, 0x00	; 0
    3eaa:	9a f0       	brmi	.+38     	; 0x3ed2 <__mulsf3_pse+0x88>
    3eac:	f1 f0       	breq	.+60     	; 0x3eea <__mulsf3_pse+0xa0>
    3eae:	88 23       	and	r24, r24
    3eb0:	4a f0       	brmi	.+18     	; 0x3ec4 <__mulsf3_pse+0x7a>
    3eb2:	ee 0f       	add	r30, r30
    3eb4:	ff 1f       	adc	r31, r31
    3eb6:	bb 1f       	adc	r27, r27
    3eb8:	66 1f       	adc	r22, r22
    3eba:	77 1f       	adc	r23, r23
    3ebc:	88 1f       	adc	r24, r24
    3ebe:	91 50       	subi	r25, 0x01	; 1
    3ec0:	50 40       	sbci	r21, 0x00	; 0
    3ec2:	a9 f7       	brne	.-22     	; 0x3eae <__mulsf3_pse+0x64>
    3ec4:	9e 3f       	cpi	r25, 0xFE	; 254
    3ec6:	51 05       	cpc	r21, r1
    3ec8:	80 f0       	brcs	.+32     	; 0x3eea <__mulsf3_pse+0xa0>
    3eca:	0c 94 b9 1e 	jmp	0x3d72	; 0x3d72 <__fp_inf>
    3ece:	0c 94 04 1f 	jmp	0x3e08	; 0x3e08 <__fp_szero>
    3ed2:	5f 3f       	cpi	r21, 0xFF	; 255
    3ed4:	e4 f3       	brlt	.-8      	; 0x3ece <__mulsf3_pse+0x84>
    3ed6:	98 3e       	cpi	r25, 0xE8	; 232
    3ed8:	d4 f3       	brlt	.-12     	; 0x3ece <__mulsf3_pse+0x84>
    3eda:	86 95       	lsr	r24
    3edc:	77 95       	ror	r23
    3ede:	67 95       	ror	r22
    3ee0:	b7 95       	ror	r27
    3ee2:	f7 95       	ror	r31
    3ee4:	e7 95       	ror	r30
    3ee6:	9f 5f       	subi	r25, 0xFF	; 255
    3ee8:	c1 f7       	brne	.-16     	; 0x3eda <__mulsf3_pse+0x90>
    3eea:	fe 2b       	or	r31, r30
    3eec:	88 0f       	add	r24, r24
    3eee:	91 1d       	adc	r25, r1
    3ef0:	96 95       	lsr	r25
    3ef2:	87 95       	ror	r24
    3ef4:	97 f9       	bld	r25, 7
    3ef6:	08 95       	ret

00003ef8 <__divmodhi4>:
    3ef8:	97 fb       	bst	r25, 7
    3efa:	07 2e       	mov	r0, r23
    3efc:	16 f4       	brtc	.+4      	; 0x3f02 <__divmodhi4+0xa>
    3efe:	00 94       	com	r0
    3f00:	07 d0       	rcall	.+14     	; 0x3f10 <__divmodhi4_neg1>
    3f02:	77 fd       	sbrc	r23, 7
    3f04:	09 d0       	rcall	.+18     	; 0x3f18 <__divmodhi4_neg2>
    3f06:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <__udivmodhi4>
    3f0a:	07 fc       	sbrc	r0, 7
    3f0c:	05 d0       	rcall	.+10     	; 0x3f18 <__divmodhi4_neg2>
    3f0e:	3e f4       	brtc	.+14     	; 0x3f1e <__divmodhi4_exit>

00003f10 <__divmodhi4_neg1>:
    3f10:	90 95       	com	r25
    3f12:	81 95       	neg	r24
    3f14:	9f 4f       	sbci	r25, 0xFF	; 255
    3f16:	08 95       	ret

00003f18 <__divmodhi4_neg2>:
    3f18:	70 95       	com	r23
    3f1a:	61 95       	neg	r22
    3f1c:	7f 4f       	sbci	r23, 0xFF	; 255

00003f1e <__divmodhi4_exit>:
    3f1e:	08 95       	ret

00003f20 <__tablejump2__>:
    3f20:	ee 0f       	add	r30, r30
    3f22:	ff 1f       	adc	r31, r31
    3f24:	88 1f       	adc	r24, r24
    3f26:	8b bf       	out	0x3b, r24	; 59
    3f28:	07 90       	elpm	r0, Z+
    3f2a:	f6 91       	elpm	r31, Z
    3f2c:	e0 2d       	mov	r30, r0
    3f2e:	19 94       	eijmp

00003f30 <__udivmodhi4>:
    3f30:	aa 1b       	sub	r26, r26
    3f32:	bb 1b       	sub	r27, r27
    3f34:	51 e1       	ldi	r21, 0x11	; 17
    3f36:	07 c0       	rjmp	.+14     	; 0x3f46 <__udivmodhi4_ep>

00003f38 <__udivmodhi4_loop>:
    3f38:	aa 1f       	adc	r26, r26
    3f3a:	bb 1f       	adc	r27, r27
    3f3c:	a6 17       	cp	r26, r22
    3f3e:	b7 07       	cpc	r27, r23
    3f40:	10 f0       	brcs	.+4      	; 0x3f46 <__udivmodhi4_ep>
    3f42:	a6 1b       	sub	r26, r22
    3f44:	b7 0b       	sbc	r27, r23

00003f46 <__udivmodhi4_ep>:
    3f46:	88 1f       	adc	r24, r24
    3f48:	99 1f       	adc	r25, r25
    3f4a:	5a 95       	dec	r21
    3f4c:	a9 f7       	brne	.-22     	; 0x3f38 <__udivmodhi4_loop>
    3f4e:	80 95       	com	r24
    3f50:	90 95       	com	r25
    3f52:	bc 01       	movw	r22, r24
    3f54:	cd 01       	movw	r24, r26
    3f56:	08 95       	ret

00003f58 <memcpy>:
    3f58:	fb 01       	movw	r30, r22
    3f5a:	dc 01       	movw	r26, r24
    3f5c:	02 c0       	rjmp	.+4      	; 0x3f62 <memcpy+0xa>
    3f5e:	01 90       	ld	r0, Z+
    3f60:	0d 92       	st	X+, r0
    3f62:	41 50       	subi	r20, 0x01	; 1
    3f64:	50 40       	sbci	r21, 0x00	; 0
    3f66:	d8 f7       	brcc	.-10     	; 0x3f5e <memcpy+0x6>
    3f68:	08 95       	ret

00003f6a <memset>:
    3f6a:	dc 01       	movw	r26, r24
    3f6c:	01 c0       	rjmp	.+2      	; 0x3f70 <memset+0x6>
    3f6e:	6d 93       	st	X+, r22
    3f70:	41 50       	subi	r20, 0x01	; 1
    3f72:	50 40       	sbci	r21, 0x00	; 0
    3f74:	e0 f7       	brcc	.-8      	; 0x3f6e <memset+0x4>
    3f76:	08 95       	ret

00003f78 <__itoa_ncheck>:
    3f78:	bb 27       	eor	r27, r27
    3f7a:	4a 30       	cpi	r20, 0x0A	; 10
    3f7c:	31 f4       	brne	.+12     	; 0x3f8a <__itoa_ncheck+0x12>
    3f7e:	99 23       	and	r25, r25
    3f80:	22 f4       	brpl	.+8      	; 0x3f8a <__itoa_ncheck+0x12>
    3f82:	bd e2       	ldi	r27, 0x2D	; 45
    3f84:	90 95       	com	r25
    3f86:	81 95       	neg	r24
    3f88:	9f 4f       	sbci	r25, 0xFF	; 255
    3f8a:	0c 94 c8 1f 	jmp	0x3f90	; 0x3f90 <__utoa_common>

00003f8e <__utoa_ncheck>:
    3f8e:	bb 27       	eor	r27, r27

00003f90 <__utoa_common>:
    3f90:	fb 01       	movw	r30, r22
    3f92:	55 27       	eor	r21, r21
    3f94:	aa 27       	eor	r26, r26
    3f96:	88 0f       	add	r24, r24
    3f98:	99 1f       	adc	r25, r25
    3f9a:	aa 1f       	adc	r26, r26
    3f9c:	a4 17       	cp	r26, r20
    3f9e:	10 f0       	brcs	.+4      	; 0x3fa4 <__utoa_common+0x14>
    3fa0:	a4 1b       	sub	r26, r20
    3fa2:	83 95       	inc	r24
    3fa4:	50 51       	subi	r21, 0x10	; 16
    3fa6:	b9 f7       	brne	.-18     	; 0x3f96 <__utoa_common+0x6>
    3fa8:	a0 5d       	subi	r26, 0xD0	; 208
    3faa:	aa 33       	cpi	r26, 0x3A	; 58
    3fac:	08 f0       	brcs	.+2      	; 0x3fb0 <__utoa_common+0x20>
    3fae:	a9 5d       	subi	r26, 0xD9	; 217
    3fb0:	a1 93       	st	Z+, r26
    3fb2:	00 97       	sbiw	r24, 0x00	; 0
    3fb4:	79 f7       	brne	.-34     	; 0x3f94 <__utoa_common+0x4>
    3fb6:	b1 11       	cpse	r27, r1
    3fb8:	b1 93       	st	Z+, r27
    3fba:	11 92       	st	Z+, r1
    3fbc:	cb 01       	movw	r24, r22
    3fbe:	0c 94 e1 1f 	jmp	0x3fc2	; 0x3fc2 <strrev>

00003fc2 <strrev>:
    3fc2:	dc 01       	movw	r26, r24
    3fc4:	fc 01       	movw	r30, r24
    3fc6:	67 2f       	mov	r22, r23
    3fc8:	71 91       	ld	r23, Z+
    3fca:	77 23       	and	r23, r23
    3fcc:	e1 f7       	brne	.-8      	; 0x3fc6 <strrev+0x4>
    3fce:	32 97       	sbiw	r30, 0x02	; 2
    3fd0:	04 c0       	rjmp	.+8      	; 0x3fda <strrev+0x18>
    3fd2:	7c 91       	ld	r23, X
    3fd4:	6d 93       	st	X+, r22
    3fd6:	70 83       	st	Z, r23
    3fd8:	62 91       	ld	r22, -Z
    3fda:	ae 17       	cp	r26, r30
    3fdc:	bf 07       	cpc	r27, r31
    3fde:	c8 f3       	brcs	.-14     	; 0x3fd2 <strrev+0x10>
    3fe0:	08 95       	ret

00003fe2 <_exit>:
    3fe2:	f8 94       	cli

00003fe4 <__stop_program>:
    3fe4:	ff cf       	rjmp	.-2      	; 0x3fe4 <__stop_program>
